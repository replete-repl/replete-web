// Compiled by ClojureScript 1.10.520 {}
goog.provide('replete.io_impl');
goog.require('cljs.core');
replete.io_impl.busy_sleep = (function replete$io_impl$busy_sleep(wake_up_time){
var now = (new Date()).getTime();
while(true){
if((!((now > wake_up_time)))){
var G__1109 = (new Date()).getTime();
now = G__1109;
continue;
} else {
return null;
}
break;
}
});
replete.io_impl.sleep = (function replete$io_impl$sleep(m,n){
var now = (new Date()).getTime();
return replete.io_impl.busy_sleep.call(null,(now + m));
});
replete.io_impl.dependencies = cljs.core.PersistentHashMap.fromArrays(["cljs/tools/reader/impl/errors.cljs","cljs/core.cljs","cljs/analyzer.cljc","cljs/spec/alpha.cljs","cljs/spec/gen/alpha.cljc","cljs/reader.cljs","cljs/repl.cljs","clojure/test/check.cljc","cljs/pprint.cljs","clojure/data.clj","cljs/js.clj","clojure/zip.clj","cljs/analyzer/macros.clj","clojure/string.clj","clojure/test/check/random.clj","cljs/tools/reader/reader_types.clj","cljs/nodejs.cljs","clojure/set.cljs","cljs/pprint.cljc","cljs/env.cljc","clojure/test/check/random.cljs","clojure/test/check/generators.cljc","clojure/data.cljs","cljs/env/macros.clj","clojure/core/reducers.cljs","cljs/tools/reader/reader_types.cljs","cljs/analyzer/api.cljc","cljs/spec/test/alpha.cljc","cljs/core.js","cljs/spec/test/alpha.cljs","cljs/core$macros.cljc","clojure/zip.cljs","cljs/tools/reader/impl/utils.cljs","clojure/test/check/properties.cljc","clojure/reflect.clj","cljs/test.cljs","cljs/spec/gen/alpha.cljs","cljs/core.cljc","clojure/test/check/clojure_test.cljc","cljs/tools/reader/impl/inspect.cljs","cljs/tools/reader/impl/commons.cljs","clojure/walk.clj","cljs/repl.cljc","clojure/string.cljs","cljs/tagged_literals.cljc","cljs/test.cljc","clojure/core/reducers.clj","cljs/core.cljs.cache.json","cljs/js.cljs","clojure/set.clj","clojure/walk.cljs","cljs/tools/reader.cljs","clojure/reflect.cljs","cljs/reader.clj","cljs/spec/alpha.cljc"],[new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader/impl/errors.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader.impl.errors",new cljs.core.Keyword(null,"source","source",-433931539),";;   Copyright (c) Russ Olsen, Nicola Mometto, Rich Hickey & contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.errors\n  (:require [cljs.tools.reader.reader-types :as types]\n            [clojure.string :as s]\n            [cljs.tools.reader.impl.inspect :as i]))\n\n(defn- ex-details\n  [rdr ex-type]\n  (let [details {:type :reader-exception\n                 :ex-kind ex-type}]\n    (if (types/indexing-reader? rdr)\n      (assoc\n       details\n       :file (types/get-file-name rdr)\n       :line (types/get-line-number rdr)\n       :col (types/get-column-number rdr))\n      details)))\n\n(defn- throw-ex\n  \"Throw an ex-info error.\"\n  [rdr ex-type & msg]\n  (let [details (ex-details rdr ex-type)\n        file (:file details)\n        line (:line details)\n        col (:col details)\n        msg1 (if file (str file \" \"))\n        msg2 (if line (str \"[line \" line \", col \" col \"]\"))\n        msg3 (if (or msg1 msg2) \" \")\n        full-msg (apply str msg1 msg2 msg3 msg)]\n    (throw (ex-info full-msg details))))\n\n(defn reader-error\n  \"Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n  [rdr & msgs]\n  (throw-ex rdr :reader-error (apply str msgs)))\n\n(defn illegal-arg-error\n  \"Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n  [rdr & msgs]\n  (throw-ex rdr :illegal-argument (apply str msgs)))\n\n(defn eof-error\n  \"Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided\"\n  [rdr & msgs]\n  (throw-ex rdr :eof (apply str msgs)))\n\n(defn throw-eof-delimited\n  ([rdr kind column line] (throw-eof-delimited rdr kind line column nil))\n  ([rdr kind line column n]\n   (eof-error\n    rdr\n    \"Unexpected EOF while reading \"\n    (if n\n      (str \"item \" n \" of \"))\n    (name kind)\n    (if line\n      (str \", starting at line \" line \" and column \" column))\n    \".\")))\n\n(defn throw-odd-map [rdr line col elements]\n  (reader-error\n   rdr\n   \"The map literal starting with \"\n   (i/inspect (first elements))\n   (if line (str \" on line \" line \" column \" col))\n   \" contains \"\n   (count elements)\n   \" form(s). Map literals must contain an even number of forms.\"))\n\n(defn throw-invalid-number [rdr token]\n  (reader-error\n   rdr\n   \"Invalid number: \"\n   token\n   \".\"))\n\n(defn throw-invalid-unicode-literal [rdr token]\n  (throw\n   (illegal-arg-error\n    rdr\n    \"Invalid unicode literal: \\\\\"\n    token\n    \".\")))\n\n(defn throw-invalid-unicode-escape [rdr ch]\n  (reader-error\n   rdr\n   \"Invalid unicode escape: \\\\u\"\n   ch\n   \".\"))\n\n(defn throw-invalid [rdr kind token]\n  (reader-error rdr \"Invalid \" (name kind) \": \" token \".\"))\n\n(defn throw-eof-at-start [rdr kind]\n  (eof-error rdr \"Unexpected EOF while reading start of \" (name kind) \".\"))\n\n(defn throw-bad-char [rdr kind ch]\n  (reader-error rdr \"Invalid character: \" ch \" found while reading \" (name kind) \".\"))\n\n(defn throw-eof-at-dispatch [rdr]\n  (eof-error rdr \"Unexpected EOF while reading dispatch character.\"))\n\n(defn throw-bad-dispatch [rdr ch]\n  (reader-error rdr \"No dispatch macro for \" ch \".\"))\n\n(defn throw-unmatch-delimiter [rdr ch]\n  (reader-error rdr \"Unmatched delimiter \" ch \".\"))\n\n(defn throw-eof-reading [rdr kind & start]\n  (let [init (case kind :regex \"#\\\"\" :string \\\")]\n    (eof-error rdr \"Unexpected EOF reading \" (name kind) \" starting \" (apply str init start) \".\")))\n\n(defn throw-no-dispatch [rdr ch]\n  (throw-bad-dispatch rdr ch))\n\n(defn throw-invalid-unicode-char[rdr token]\n  (reader-error\n   rdr\n   \"Invalid unicode character \\\\\"\n   token\n   \".\"))\n\n(defn throw-invalid-unicode-digit-in-token[rdr ch token]\n  (illegal-arg-error\n   rdr\n   \"Invalid digit \"\n   ch\n   \" in unicode character \\\\\"\n   token\n   \".\"))\n\n(defn throw-invalid-unicode-digit[rdr ch]\n  (illegal-arg-error\n   rdr\n   \"Invalid digit \"\n   ch\n   \" in unicode character.\"))\n\n(defn throw-invalid-unicode-len[rdr actual expected]\n  (illegal-arg-error\n   rdr\n   \"Invalid unicode literal. Unicode literals should be \"\n   expected\n   \"characters long.  \"\n   \"value suppled is \"\n   actual\n   \"characters long.\"))\n\n(defn throw-invalid-character-literal[rdr token]\n  (reader-error rdr \"Invalid character literal \\\\u\" token \".\"))\n\n(defn throw-invalid-octal-len[rdr token]\n  (reader-error\n   rdr\n   \"Invalid octal escape sequence in a character literal:\"\n   token\n   \". Octal escape sequences must be 3 or fewer digits.\"))\n\n(defn throw-bad-octal-number [rdr]\n  (reader-error rdr \"Octal escape sequence must be in range [0, 377].\"))\n\n(defn throw-unsupported-character[rdr token]\n  (reader-error\n   rdr\n   \"Unsupported character: \"\n   token\n   \".\"))\n\n(defn throw-eof-in-character [rdr]\n  (eof-error\n   rdr\n   \"Unexpected EOF while reading character.\"))\n\n(defn throw-bad-escape-char [rdr ch]\n  (reader-error rdr \"Unsupported escape character: \\\\\" ch \".\"))\n\n(defn throw-single-colon [rdr]\n  (reader-error rdr \"A single colon is not a valid keyword.\"))\n\n(defn throw-bad-metadata [rdr x]\n  (reader-error\n   rdr\n   \"Metadata cannot be \"\n   (i/inspect x)\n   \". Metadata must be a Symbol, Keyword, String or Map.\"))\n\n(defn throw-bad-metadata-target [rdr target]\n  (reader-error\n   rdr\n   \"Metadata can not be applied to \"\n   (i/inspect target)\n   \". \"\n   \"Metadata can only be applied to IMetas.\"))\n\n(defn throw-feature-not-keyword [rdr feature]\n  (reader-error\n   rdr\n   \"Feature cannot be \"\n   (i/inspect feature)\n   \" Features must be keywords.\"))\n\n(defn throw-ns-map-no-map [rdr ns-name]\n  (reader-error rdr \"Namespaced map with namespace \" ns-name \" does not specify a map.\"))\n\n(defn throw-bad-ns [rdr ns-name]\n  (reader-error rdr \"Invalid value used as namespace in namespaced map: \" ns-name \".\"))\n\n(defn throw-bad-reader-tag [rdr tag]\n  (reader-error\n   rdr\n   \"Invalid reader tag: \"\n   (i/inspect tag)\n   \". Reader tags must be symbols.\"))\n\n(defn throw-unknown-reader-tag [rdr tag]\n  (reader-error\n   rdr\n   \"No reader function for tag \"\n   (i/inspect tag)\n   \".\"))\n\n(defn- duplicate-keys-error [msg coll]\n  (letfn [(duplicates [seq]\n            (for [[id freq] (frequencies seq)\n                  :when (> freq 1)]\n              id))]\n    (let [dups (duplicates coll)]\n      (apply str msg\n             (when (> (count dups) 1) \"s\")\n             \": \" (interpose \", \" dups)))))\n\n(defn throw-dup-keys [rdr kind ks]\n  (reader-error\n   rdr\n   (duplicate-keys-error\n    (str (s/capitalize (name kind)) \" literal contains duplicate key\")\n    ks)))\n\n(defn throw-eof-error [rdr line]\n  (if line\n    (eof-error rdr \"EOF while reading, starting at line \" line \".\")\n    (eof-error rdr \"EOF while reading.\")))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/core.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.core",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.core\n  (:require goog.math.Long\n            goog.math.Integer\n            [goog.string :as gstring]\n            [goog.object :as gobject]\n            [goog.array :as garray]\n            [goog.Uri])\n  (:import [goog.string StringBuffer]))\n\n;; next line is auto-generated by the build-script - Do not edit!\n(def *clojurescript-version* \"1.10.520\")\n\n;; Setting of these Vars is in ClojureScript code is associated with intrinsics\n;; that affect compilation state, but otherwise turn into no-ops in the emitted\n;; JavaScript.\n\n;; The scope of *unchecked-if* is controlled by balanced pairs of set! calls.\n(def *unchecked-if* false)\n;; The scope of *unchecked-arrays* is file-scope: In JVM ClojureScript its side-\n;; effect is to set same-named analyzer dynamic Var, which is unset via binding\n;; scopes. In self-hosted it is cleared via cljs.js/post-file-side-effects.\n(def *unchecked-arrays* false)\n;; The scope of *warn-on-infer* is file-scope: Its side effect is to set the\n;; cljs.analyzer/*cljs-warnings* dynamic Var, which is unset via binding scopes.\n(def *warn-on-infer* false)\n\n(set! *unchecked-arrays* true)\n\n(defonce PROTOCOL_SENTINEL #js {})\n\n(def MODULE_URIS nil) ;; set by compiler\n(def MODULE_INFOS nil) ;; set by compiler\n\n(goog-define\n  ^{:dynamic true\n    :doc \"Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \\\"nodejs\\\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.\"}\n  *target* \"default\")\n\n(def\n  ^{:dynamic true\n    :doc \"Var bound to the current namespace. Only used for bootstrapping.\"\n    :jsdoc [\"@type {*}\"]}\n  *ns* nil)\n\n(def\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *out* nil)\n\n(def\n  ^{:dynamic true}\n  *assert* true)\n\n(defonce\n  ^{:doc \"Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-fn* nil)\n\n(defn ^{:doc \"Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise.\" :dynamic true}\n  *exec-tap-fn*\n  [f]\n  (and\n   (exists? js/setTimeout)\n   (js/setTimeout f 0)\n   true))\n\n(defonce\n  ^{:doc \"Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-err-fn* nil)\n\n(defn set-print-fn!\n  \"Set *print-fn* to f.\"\n  [f] (set! *print-fn* f))\n\n(defn set-print-err-fn!\n  \"Set *print-err-fn* to f.\"\n  [f] (set! *print-err-fn* f))\n\n(def\n  ^{:dynamic true\n    :doc \"When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.\"}\n  *flush-on-newline* true)\n\n(def\n  ^{:dynamic true\n    :doc \"When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.\"}\n  *print-newline* true)\n\n(def\n  ^{:dynamic true\n    :doc \"When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true\"}\n  *print-readably* true)\n\n(def\n  ^{:dynamic true\n    :doc \"If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.\"}\n  *print-meta* false)\n\n(def\n  ^{:dynamic true\n    :doc \"When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.\"}\n  *print-dup* false)\n\n(def\n  ^{:dynamic true\n    :doc \"*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true.\"}\n  *print-namespace-maps* false)\n\n(def\n  ^{:dynamic true\n    :doc \"*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.\"\n    :jsdoc [\"@type {null|number}\"]}\n  *print-length* nil)\n\n(def\n  ^{:dynamic true\n    :doc \"*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.\"\n    :jsdoc [\"@type {null|number}\"]}\n  *print-level* nil)\n\n(def\n  ^{:dynamic true\n    :doc \"*print-fns-bodies* controls whether functions print their source or\n    only their names.\"}\n  *print-fn-bodies* false)\n\n(defonce\n  ^{:dynamic true\n    :jsdoc [\"@type {*}\"]}\n  *loaded-libs* nil)\n\n(defn- pr-opts []\n  {:flush-on-newline *flush-on-newline*\n   :readably *print-readably*\n   :meta *print-meta*\n   :dup *print-dup*\n   :print-length *print-length*})\n\n(declare into-array)\n\n(defn enable-console-print!\n  \"Set *print-fn* to console.log\"\n  []\n  (set! *print-newline* false)\n  (set-print-fn!\n    (fn []\n      (let [xs (js-arguments)]\n        (.apply (.-log js/console) js/console (garray/clone xs)))))\n  (set-print-err-fn!\n    (fn []\n      (let [xs (js-arguments)]\n        (.apply (.-error js/console) js/console (garray/clone xs)))))\n  nil)\n\n(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)\n\n(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)\n\n(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)\n\n(def\n  ^{:doc \"bound in a repl thread to the most recent exception caught by the repl\"}\n  *e)\n\n(defn truth_\n  \"Internal - do not use!\"\n  [x]\n  (cljs.core/truth_ x))\n\n(def not-native nil)\n\n(declare instance? Keyword)\n\n(defn ^boolean identical?\n  \"Tests if 2 arguments are the same object\"\n  [x y]\n  (cljs.core/identical? x y))\n\n(defn ^boolean nil?\n  \"Returns true if x is nil, false otherwise.\"\n  [x]\n  (coercive-= x nil))\n\n(defn ^boolean array?\n  \"Returns true if x is a JavaScript array.\"\n  [x]\n  (if (identical? *target* \"nodejs\")\n    (.isArray js/Array x)\n    (instance? js/Array x)))\n\n(defn ^boolean number?\n  \"Returns true if x is a JavaScript number.\"\n  [x]\n  (cljs.core/number? x))\n\n(defn not\n  \"Returns true if x is logical false, false otherwise.\"\n  [x]\n  (cond\n    (nil? x) true\n    (false? x) true\n    :else false))\n\n(defn ^boolean some?\n  \"Returns true if x is not nil, false otherwise.\"\n  [x] (not (nil? x)))\n\n(defn object?\n  \"Returns true if x's constructor is Object\"\n  [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))\n\n(defn ^boolean string?\n  \"Returns true if x is a JavaScript string.\"\n  [x]\n  (goog/isString x))\n\n(defn char?\n  \"Returns true if x is a JavaScript string of length one.\"\n  [x]\n  (and (string? x) (== 1 (.-length x))))\n\n(defn any?\n  \"Returns true if given any argument.\"\n  [x] true)\n\n(set! *unchecked-if* true)\n(defn native-satisfies?\n  \"Internal - do not use!\"\n  [p x]\n  (let [x (if (nil? x) nil x)]\n    (cond\n     (unchecked-get p (goog/typeOf x)) true\n     (unchecked-get p \"_\") true\n     :else false)))\n(set! *unchecked-if* false)\n\n(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))\n\n(def\n  ^{:doc \"When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)\n\n(def\n  ^{:doc \"A sequence of the supplied command line arguments, or nil if\n  none were supplied\"}\n  *command-line-args* nil)\n\n(defn type\n  \"Return x's constructor.\"\n  [x]\n  (when-not (nil? x)\n    (.-constructor x)))\n\n(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))\n\n(defn type->str [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))\n\n;; INTERNAL - do not use, only for Node.js\n(defn load-file [file]\n  (when-not js/COMPILED\n    (cljs.core/load-file* file)))\n\n(if (and (exists? js/Symbol)\n         (identical? (goog/typeOf js/Symbol) \"function\"))\n  (def ITER_SYMBOL (.-iterator js/Symbol))\n  (def ITER_SYMBOL \"@@iterator\"))\n\n(def ^{:jsdoc [\"@enum {string}\"]}\n  CHAR_MAP\n  #js {\"-\"    \"_\"\n       \":\"    \"_COLON_\"\n       \"+\"    \"_PLUS_\"\n       \">\"    \"_GT_\"\n       \"<\"    \"_LT_\"\n       \"=\"    \"_EQ_\"\n       \"~\"    \"_TILDE_\"\n       \"!\"    \"_BANG_\"\n       \"@\"    \"_CIRCA_\"\n       \"#\"    \"_SHARP_\"\n       \"'\"    \"_SINGLEQUOTE_\"\n       \"\\\\\\\"\" \"_DOUBLEQUOTE_\"\n       \"%\"    \"_PERCENT_\"\n       \"^\"    \"_CARET_\"\n       \"&\"    \"_AMPERSAND_\"\n       \"*\"    \"_STAR_\"\n       \"|\"    \"_BAR_\"\n       \"{\"    \"_LBRACE_\"\n       \"}\"    \"_RBRACE_\"\n       \"[\"    \"_LBRACK_\"\n       \"]\"    \"_RBRACK_\"\n       \"/\"    \"_SLASH_\"\n       \"\\\\\\\\\" \"_BSLASH_\"\n       \"?\"    \"_QMARK_\"})\n\n(def ^{:jsdoc [\"@enum {string}\"]}\n  DEMUNGE_MAP\n  #js {\"_\"             \"-\"\n       \"_COLON_\"       \":\"\n       \"_PLUS_\"        \"+\"\n       \"_GT_\"          \">\"\n       \"_LT_\"          \"<\"\n       \"_EQ_\"          \"=\"\n       \"_TILDE_\"       \"~\"\n       \"_BANG_\"        \"!\"\n       \"_CIRCA_\"       \"@\"\n       \"_SHARP_\"       \"#\"\n       \"_SINGLEQUOTE_\" \"'\"\n       \"_DOUBLEQUOTE_\" \"\\\\\\\"\"\n       \"_PERCENT_\"     \"%\"\n       \"_CARET_\"       \"^\"\n       \"_AMPERSAND_\"   \"&\"\n       \"_STAR_\"        \"*\"\n       \"_BAR_\"         \"|\"\n       \"_LBRACE_\"      \"{\"\n       \"_RBRACE_\"      \"}\"\n       \"_LBRACK_\"      \"[\"\n       \"_RBRACK_\"      \"]\"\n       \"_SLASH_\"       \"/\"\n       \"_BSLASH_\"      \"\\\\\\\\\"\n       \"_QMARK_\"       \"?\"})\n\n(def DEMUNGE_PATTERN nil)\n\n(defn system-time\n  \"Returns highest resolution time offered by host in milliseconds.\"\n  []\n  (cond\n    (and (exists? js/performance)\n         (not (nil? (. js/performance -now))))\n    (.now js/performance)\n\n    (and (exists? js/process)\n         (not (nil? (. js/process -hrtime))))\n    (let [t (.hrtime js/process)]\n      (/ (+ (* (aget t 0) 1e9) (aget t 1)) 1e6))\n\n    :else (.getTime (js/Date.))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; arrays ;;;;;;;;;;;;;;;;\n\n(declare apply)\n\n(defn ^array make-array\n  \"Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.\"\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size))\n  ([type size & more-sizes]\n    (let [dims more-sizes\n          dimarray (make-array size)]\n      (dotimes [i (alength dimarray)]\n        (aset dimarray i (apply make-array nil dims)))\n      dimarray)))\n\n(defn aclone\n  \"Returns a javascript array, cloned from the passed in array\"\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))\n\n(defn ^array array\n  \"Creates a new javascript array.\n@param {...*} var_args\" ;;array is a special case, don't emulate this doc string\n  [var-args]            ;; [& items]\n  (let [a (js/Array. (alength (cljs.core/js-arguments)))]\n    (loop [i 0]\n      (if (< i (alength a))\n        (do\n          (aset a i (aget (cljs.core/js-arguments) i))\n          (recur (inc i)))\n        a))))\n\n(defn- maybe-warn\n  [e]\n  (when *print-err-fn*\n    (*print-err-fn* e)))\n\n(defn- checked-aget\n  ([array idx]\n   (when-assert\n     (try\n       (assert (or (array? array) (goog/isArrayLike array)))\n       (assert (number? idx))\n       (assert (not (neg? idx)))\n       (assert (< idx (alength array)))\n       (catch :default e\n         (maybe-warn e))))\n   (unchecked-get array idx))\n  ([array idx & idxs]\n   (apply checked-aget (checked-aget array idx) idxs)))\n\n(defn- checked-aset\n  ([array idx val]\n   (when-assert\n     (try\n       (assert (or (array? array) (goog/isArrayLike array)))\n       (assert (number? idx))\n       (assert (not (neg? idx)))\n       (assert (< idx (alength array)))\n       (catch :default e\n         (maybe-warn e))))\n   (unchecked-set array idx val))\n  ([array idx idx2 & idxv]\n   (apply checked-aset (checked-aget array idx) idx2 idxv)))\n\n(defn- checked-aget'\n  ([array idx]\n   {:pre [(or (array? array) (goog/isArrayLike array))\n          (number? idx) (not (neg? idx)) (< idx (alength array))]}\n   (unchecked-get array idx))\n  ([array idx & idxs]\n   (apply checked-aget' (checked-aget' array idx) idxs)))\n\n(defn- checked-aset'\n  ([array idx val]\n   {:pre [(or (array? array) (goog/isArrayLike array))\n          (number? idx) (not (neg? idx)) (< idx (alength array))]}\n   (unchecked-set array idx val))\n  ([array idx idx2 & idxv]\n   (apply checked-aset' (checked-aget' array idx) idx2 idxv)))\n\n(defn aget\n  \"Returns the value at the index/indices. Works on JavaScript arrays.\"\n  ([array idx]\n     (cljs.core/aget array idx))\n  ([array idx & idxs]\n     (apply aget (aget array idx) idxs)))\n\n(defn aset\n  \"Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.\"\n  ([array idx val]\n    (cljs.core/aset array idx val))\n  ([array idx idx2 & idxv]\n    (apply aset (aget array idx) idx2 idxv)))\n\n(defn ^number alength\n  \"Returns the length of the array. Works on arrays of all types.\"\n  [array]\n  (cljs.core/alength array))\n\n(declare reduce)\n\n(defn ^array into-array\n  \"Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.\"\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))\n\n(defn js-invoke\n  \"Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.\"\n  [obj s & args]\n  (.apply (unchecked-get obj s) obj (into-array args)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;; core protocols ;;;;;;;;;;;;;\n\n(defprotocol Fn\n  \"Marker protocol\")\n\n(defprotocol IFn\n  \"Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2\"\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q r]\n    [this a b c d e f g h i j k l m n o p q r s]\n    [this a b c d e f g h i j k l m n o p q r s t]\n    [this a b c d e f g h i j k l m n o p q r s t rest]))\n\n(defprotocol ICloneable\n  \"Protocol for cloning a value.\"\n  (^clj -clone [value]\n    \"Creates a clone of value.\"))\n\n(defprotocol ICounted\n  \"Protocol for adding the ability to count a collection in constant time.\"\n  (^number -count [coll]\n    \"Calculates the count of coll in constant time. Used by cljs.core/count.\"))\n\n(defprotocol IEmptyableCollection\n  \"Protocol for creating an empty collection.\"\n  (-empty [coll]\n    \"Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.\"))\n\n(defprotocol ICollection\n  \"Protocol for adding to a collection.\"\n  (^clj -conj [coll o]\n    \"Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)\"))\n\n#_(defprotocol IOrdinal\n    (-index [coll]))\n\n(defprotocol IIndexed\n  \"Protocol for collections to provide indexed-based access to their items.\"\n  (-nth [coll n] [coll n not-found]\n    \"Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.\"))\n\n(defprotocol ASeq\n  \"Marker protocol indicating an array sequence.\")\n\n(defprotocol ISeq\n  \"Protocol for collections to provide access to their items as sequences.\"\n  (-first [coll]\n    \"Returns the first item in the collection coll. Used by cljs.core/first.\")\n  (^clj -rest [coll]\n    \"Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()\"))\n\n(defprotocol INext\n  \"Protocol for accessing the next items of a collection.\"\n  (^clj-or-nil -next [coll]\n    \"Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil\"))\n\n(defprotocol ILookup\n  \"Protocol for looking up a value in a data structure.\"\n  (-lookup [o k] [o k not-found]\n    \"Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.\"))\n\n(defprotocol IAssociative\n  \"Protocol for adding associativity to collections.\"\n  (^boolean -contains-key? [coll k]\n    \"Returns true if k is a key in coll.\")\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]\n    \"Returns a new collection of coll with a mapping from key k to\n     value v added to it.\"))\n\n(defprotocol IFind\n  \"Protocol for implementing entry finding in collections.\"\n  (-find [coll k] \"Returns the map entry for key, or nil if key not present.\"))\n\n(defprotocol IMap\n  \"Protocol for adding mapping functionality to collections.\"\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]\n    \"Returns a new collection of coll without the mapping for key k.\"))\n\n(defprotocol IMapEntry\n  \"Protocol for examining a map entry.\"\n  (-key [coll]\n    \"Returns the key of the map entry.\")\n  (-val [coll]\n    \"Returns the value of the map entry.\"))\n\n(defprotocol ISet\n  \"Protocol for adding set functionality to a collection.\"\n  (^clj -disjoin [coll v]\n    \"Returns a new collection of coll that does not contain v.\"))\n\n(defprotocol IStack\n  \"Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.\"\n  (-peek [coll]\n    \"Returns the item from the top of the stack. Is used by cljs.core/peek.\")\n  (^clj -pop [coll]\n    \"Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.\"))\n\n(defprotocol IVector\n  \"Protocol for adding vector functionality to collections.\"\n  (^clj -assoc-n [coll n val]\n    \"Returns a new vector with value val added at position n.\"))\n\n(defprotocol IDeref\n  \"Protocol for adding dereference functionality to a reference.\"\n  (-deref [o]\n    \"Returns the value of the reference o.\"))\n\n(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))\n\n(defprotocol IMeta\n  \"Protocol for accessing the metadata of an object.\"\n  (^clj-or-nil -meta [o]\n    \"Returns the metadata of object o.\"))\n\n(defprotocol IWithMeta\n  \"Protocol for adding metadata to an object.\"\n  (^clj -with-meta [o meta]\n    \"Returns a new object with value of o and metadata meta added to it.\"))\n\n(defprotocol IReduce\n  \"Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.\"\n  (-reduce [coll f] [coll f start]\n    \"f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.\"))\n\n(defprotocol IKVReduce\n  \"Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.\"\n  (-kv-reduce [coll f init]\n    \"Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.\"))\n\n(defprotocol IEquiv\n  \"Protocol for adding value comparison functionality to a type.\"\n  (^boolean -equiv [o other]\n    \"Returns true if o and other are equal, false otherwise.\"))\n\n(defprotocol IHash\n  \"Protocol for adding hashing functionality to a type.\"\n  (-hash [o]\n    \"Returns the hash code of o.\"))\n\n(defprotocol ISeqable\n  \"Protocol for adding the ability to a type to be transformed into a sequence.\"\n  (^clj-or-nil -seq [o]\n    \"Returns a seq of o, or nil if o is empty.\"))\n\n(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")\n\n(defprotocol IList\n  \"Marker interface indicating a persistent list\")\n\n(defprotocol IRecord\n  \"Marker interface indicating a record object\")\n\n(defprotocol IReversible\n  \"Protocol for reversing a seq.\"\n  (^clj -rseq [coll]\n    \"Returns a seq of the items in coll in reversed order.\"))\n\n(defprotocol ISorted\n  \"Protocol for a collection which can represent their items\n  in a sorted manner. \"\n  (^clj -sorted-seq [coll ascending?]\n    \"Returns a sorted seq from coll in either ascending or descending order.\")\n  (^clj -sorted-seq-from [coll k ascending?]\n    \"Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)\")\n  (-entry-key [coll entry]\n    \"Returns the key for entry.\")\n  (-comparator [coll]\n    \"Returns the comparator for coll.\"))\n\n(defprotocol IWriter\n  \"Protocol for writing. Currently only implemented by StringBufferWriter.\"\n  (-write [writer s]\n    \"Writes s with writer and returns the result.\")\n  (-flush [writer]\n    \"Flush writer.\"))\n\n(defprotocol IPrintWithWriter\n  \"The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.\"\n  (-pr-writer [o writer opts]))\n\n(defprotocol IPending\n  \"Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.\"\n  (^boolean -realized? [x]\n    \"Returns true if a value for x has been produced, false otherwise.\"))\n\n(defprotocol IWatchable\n  \"Protocol for types that can be watched. Currently only implemented by Atom.\"\n  (-notify-watches [this oldval newval]\n    \"Calls all watchers with this, oldval and newval.\")\n  (-add-watch [this key f]\n    \"Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.\")\n  (-remove-watch [this key]\n    \"Removes watcher that corresponds to key from this.\"))\n\n(defprotocol IEditableCollection\n  \"Protocol for collections which can transformed to transients.\"\n  (^clj -as-transient [coll]\n    \"Returns a new, transient version of the collection, in constant time.\"))\n\n(defprotocol ITransientCollection\n  \"Protocol for adding basic functionality to transient collections.\"\n  (^clj -conj! [tcoll val]\n    \"Adds value val to tcoll and returns tcoll.\")\n  (^clj -persistent! [tcoll]\n    \"Creates a persistent data structure from tcoll and returns it.\"))\n\n(defprotocol ITransientAssociative\n  \"Protocol for adding associativity to transient collections.\"\n  (^clj -assoc! [tcoll key val]\n    \"Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.\"))\n\n(defprotocol ITransientMap\n  \"Protocol for adding mapping functionality to transient collections.\"\n  (^clj -dissoc! [tcoll key]\n    \"Returns a new transient collection of tcoll without the mapping for key.\"))\n\n(defprotocol ITransientVector\n  \"Protocol for adding vector functionality to transient collections.\"\n  (^clj -assoc-n! [tcoll n val]\n    \"Returns tcoll with value val added at position n.\")\n  (^clj -pop! [tcoll]\n    \"Returns tcoll with the last item removed from it.\"))\n\n(defprotocol ITransientSet\n  \"Protocol for adding set functionality to a transient collection.\"\n  (^clj -disjoin! [tcoll v]\n    \"Returns tcoll without v.\"))\n\n(defprotocol IComparable\n  \"Protocol for values that can be compared.\"\n  (^number -compare [x y]\n    \"Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.\"))\n\n(defprotocol IChunk\n  \"Protocol for accessing the items of a chunk.\"\n  (-drop-first [coll]\n    \"Return a new chunk of coll with the first item removed.\"))\n\n(defprotocol IChunkedSeq\n  \"Protocol for accessing a collection as sequential chunks.\"\n  (-chunked-first [coll]\n    \"Returns the first chunk in coll.\")\n  (-chunked-rest [coll]\n    \"Return a new collection of coll with the first chunk removed.\"))\n\n(defprotocol IChunkedNext\n  \"Protocol for accessing the chunks of a collection.\"\n  (-chunked-next [coll]\n    \"Returns a new collection of coll without the first chunk.\"))\n\n(defprotocol INamed\n  \"Protocol for adding a name.\"\n  (^string -name [x]\n    \"Returns the name String of x.\")\n  ( ^{:tag #{string clj-nil}}-namespace [x]\n    \"Returns the namespace String of x.\"))\n\n(defprotocol IAtom\n  \"Marker protocol indicating an atom.\")\n\n(defprotocol IReset\n  \"Protocol for adding resetting functionality.\"\n  (-reset! [o new-value]\n    \"Sets the value of o to new-value.\"))\n\n(defprotocol ISwap\n  \"Protocol for adding swapping functionality.\"\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]\n    \"Swaps the value of o to be (apply f current-value-of-atom args).\"))\n\n(defprotocol IVolatile\n  \"Protocol for adding volatile functionality.\"\n  (-vreset! [o new-value]\n    \"Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.\"))\n\n(defprotocol IIterable\n  \"Protocol for iterating over a collection.\"\n  (-iterator [coll]\n    \"Returns an iterator for coll.\"))\n\n;; Printing support\n\n(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))\n\n(defn pr-str*\n  \"Support so that collections can implement toString without\n   loading all the printing machinery.\"\n  [^not-native obj]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))\n\n;;;;;;;;;;;;;;;;;;; Murmur3 ;;;;;;;;;;;;;;;\n\n;;http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/Integer.java\n(defn ^number int-rotate-left [x n]\n  (bit-or\n    (bit-shift-left x n)\n    (unsigned-bit-shift-right x (- n))))\n\n;; http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n(if (and (exists? Math/imul)\n         (not (zero? (Math/imul 0xffffffff 5))))\n  (defn ^number imul [a b] (Math/imul a b))\n  (defn ^number imul [a b]\n    (let [ah (bit-and (unsigned-bit-shift-right a 16) 0xffff)\n          al (bit-and a 0xffff)\n          bh (bit-and (unsigned-bit-shift-right b 16) 0xffff)\n          bl (bit-and b 0xffff)]\n      (bit-or\n        (+ (* al bl)\n           (unsigned-bit-shift-right\n             (bit-shift-left (+ (* ah bl) (* al bh)) 16) 0)) 0))))\n\n;; http://smhasher.googlecode.com/svn/trunk/MurmurHash3.cpp\n(def m3-seed 0)\n(def m3-C1 (int 0xcc9e2d51))\n(def m3-C2 (int 0x1b873593))\n\n(defn ^number m3-mix-K1 [k1]\n  (-> (int k1) (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))\n\n(defn ^number m3-mix-H1 [h1 k1]\n  (int (-> (int h1) (bit-xor (int k1)) (int-rotate-left 13) (imul 5) (+ (int 0xe6546b64)))))\n\n(defn ^number m3-fmix [h1 len]\n  (as-> (int h1) h1\n    (bit-xor h1 len)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))\n    (imul h1 (int 0x85ebca6b))\n    (bit-xor h1 (unsigned-bit-shift-right h1 13))\n    (imul h1 (int 0xc2b2ae35))\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))))\n\n(defn ^number m3-hash-int [in]\n  (if (zero? in)\n    in\n    (let [k1 (m3-mix-K1 in)\n          h1 (m3-mix-H1 m3-seed k1)]\n      (m3-fmix h1 4))))\n\n(defn ^number m3-hash-unencoded-chars [in]\n  (let [h1 (loop [i 1 h1 m3-seed]\n             (if (< i (.-length in))\n               (recur (+ i 2)\n                 (m3-mix-H1 h1\n                   (m3-mix-K1\n                     (bit-or (.charCodeAt in (dec i))\n                       (bit-shift-left (.charCodeAt in i) 16)))))\n               h1))\n        h1 (if (== (bit-and (.-length in) 1) 1)\n             (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (.-length in)))))\n             h1)]\n    (m3-fmix h1 (imul 2 (.-length in)))))\n\n;;;;;;;;;;;;;;;;;;; symbols ;;;;;;;;;;;;;;;\n\n(declare list Symbol = compare)\n\n;; Simple caching of string hashcode\n(def string-hash-cache (js-obj))\n(def string-hash-cache-count 0)\n\n;;http://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java\n(defn hash-string* [s]\n  (if-not (nil? s)\n    (let [len (.-length s)]\n      (if (pos? len)\n        (loop [i 0 hash 0]\n          (if (< i len)\n            (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n            hash))\n        0))\n    0))\n\n(defn add-to-string-hash-cache [k]\n  (let [h (hash-string* k)]\n    (gobject/set string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))\n\n(defn hash-string [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (if (nil? k)\n    0\n    (let [h (unchecked-get string-hash-cache k)]\n      (if (number? h)\n        h\n        (add-to-string-hash-cache k)))))\n\n(defn hash\n  \"Returns the hash code of its argument. Note this is the hash code\n   consistent with =.\"\n  [o]\n  (cond\n    (implements? IHash o)\n    (bit-xor (-hash o) 0)\n\n    (number? o)\n    (if (js/isFinite o)\n      (js-mod (Math/floor o) 2147483647)\n      (case o\n        ##Inf\n        2146435072\n        ##-Inf\n        -1048576\n        2146959360))\n\n    ;; note: mirrors Clojure's behavior on the JVM, where the hashCode is\n    ;; 1231 for true and 1237 for false\n    ;; http://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html#hashCode%28%29\n    (true? o) 1231\n\n    (false? o) 1237\n\n    (string? o)\n    (m3-hash-int (hash-string o))\n\n    (instance? js/Date o)\n    (bit-xor (.valueOf o) 0)\n\n    (nil? o) 0\n\n    :else\n    (bit-xor (-hash o) 0)))\n\n(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed\n    (+ hash 0x9e3779b9\n      (bit-shift-left seed 6)\n      (bit-shift-right seed 2))))\n\n(defn ^boolean instance?\n  \"Evaluates x and tests if it is an instance of the type\n  c. Returns true or false\"\n  [c x]\n  (cljs.core/instance? c x))\n\n(defn ^boolean symbol?\n  \"Return true if x is a Symbol\"\n  [x]\n  (instance? Symbol x))\n\n(defn- hash-symbol [sym]\n  (hash-combine\n    (m3-hash-unencoded-chars (.-name sym))\n    (hash-string (.-ns sym))))\n\n(defn- compare-symbols [a b]\n  (cond\n   (identical? (.-str a) (.-str b)) 0\n   (and (not (.-ns a)) (.-ns b)) -1\n   (.-ns a) (if-not (.-ns b)\n              1\n              (let [nsc (garray/defaultCompare (.-ns a) (.-ns b))]\n                (if (== 0 nsc)\n                  (garray/defaultCompare (.-name a) (.-name b))\n                  nsc)))\n   :default (garray/defaultCompare (.-name a) (.-name b))))\n\n(declare get)\n\n(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  (equiv [this other] (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n\n  IFn\n  (-invoke [sym coll]\n    (get coll sym))\n  (-invoke [sym coll not-found]\n    (get coll sym not-found))\n\n  IMeta\n  (-meta [_] _meta)\n\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))\n\n(defn var?\n  \"Returns true if v is of type cljs.core.Var\"\n  [v]\n  (instance? cljs.core.Var v))\n\n(defn symbol\n  \"Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.\"\n  ([name]\n   (cond (symbol? name) name\n         (string? name) (let [idx (.indexOf name \"/\")]\n                          (if (< idx 1)\n                            (symbol nil name)\n                            (symbol (.substring name 0 idx)\n                                    (.substring name (inc idx) (. name -length)))))\n         (var? name) (.-sym name)\n         (keyword? name) (recur (.-fqn name))\n         :else (throw (new js/Error \"no conversion to symbol\"))))\n  ([ns name]\n   (let [sym-str (if-not (nil? ns)\n                   (str ns \"/\" name)\n                   name)]\n     (Symbol. ns name sym-str nil nil))))\n\n(deftype Var [val sym _meta]\n  Object\n  (isMacro [_]\n    (. (val) -cljs$lang$macro))\n  (toString [_]\n    (str \"#'\" sym))\n  IDeref\n  (-deref [_] (val))\n  IMeta\n  (-meta [_] _meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (Var. val sym new-meta))\n  IEquiv\n  (-equiv [this other]\n    (if (instance? Var other)\n      (= (.-sym this) (.-sym other))\n      false))\n  IHash\n  (-hash [_]\n    (hash-symbol sym))\n  Fn\n  IFn\n  (-invoke [_]\n    ((val)))\n  (-invoke [_ a]\n    ((val) a))\n  (-invoke [_ a b]\n    ((val) a b))\n  (-invoke [_ a b c]\n    ((val) a b c))\n  (-invoke [_ a b c d]\n    ((val) a b c d))\n  (-invoke [_ a b c d e]\n    ((val) a b c d e))\n  (-invoke [_ a b c d e f]\n    ((val) a b c d e f))\n  (-invoke [_ a b c d e f g]\n    ((val) a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    ((val) a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    ((val) a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    ((val) a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    ((val) a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    ((val) a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    ((val) a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    ((val) a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    ((val) a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    ((val) a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    ((val) a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    ((val) a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    ((val) a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    ((val) a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply (val) a b c d e f g h i j k l m n o p q r s t rest)))\n\n;;;;;;;;;;;;;;;;;;; fundamentals ;;;;;;;;;;;;;;;\n\n(declare array-seq prim-seq IndexedSeq)\n\n(defn iterable?\n  \"Return true if x implements IIterable protocol.\"\n  [x]\n  (satisfies? IIterable x))\n\n(defn clone\n  \"Clone the supplied value which must implement ICloneable.\"\n  [value]\n  (-clone value))\n\n(defn cloneable?\n  \"Return true if x implements ICloneable protocol.\"\n  [value]\n  (satisfies? ICloneable value))\n\n(defn ^seq seq\n  \"Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.\"\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0 nil))\n\n      (string? coll)\n      (when-not (zero? (.-length coll))\n        (IndexedSeq. coll 0 nil))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll \" is not ISeqable\"))))))\n\n(defn first\n  \"Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.\"\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))\n\n(defn ^seq rest\n  \"Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.\"\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))\n\n(defn ^seq next\n  \"Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil\"\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next coll)\n      (seq (rest coll)))))\n\n(defn ^boolean =\n  \"Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.\"\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))\n\n;; EXPERIMENTAL: subject to change\n(deftype ES6Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))\n\n(defn es6-iterator\n  \"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"\n  [coll]\n  (ES6Iterator. (seq coll)))\n\n(declare es6-iterator-seq)\n\n(deftype ES6IteratorSeq [value iter ^:mutable _rest]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] value)\n  (-rest [_]\n    (when (nil? _rest)\n      (set! _rest (es6-iterator-seq iter)))\n    _rest))\n\n(defn es6-iterator-seq\n  \"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"\n  [iter]\n  (let [v (.next iter)]\n    (if (.-done v)\n      ()\n      (ES6IteratorSeq. (.-value v) iter nil))))\n\n;;;;;;;;;;;;;;;;;;; Murmur3 Helpers ;;;;;;;;;;;;;;;;\n\n(defn ^number mix-collection-hash\n  \"Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n  [hash-basis count]\n  (let [h1 m3-seed\n        k1 (m3-mix-K1 hash-basis)\n        h1 (m3-mix-H1 h1 k1)]\n    (m3-fmix h1 count)))\n\n(defn ^number hash-ordered-coll\n  \"Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n  [coll]\n  (loop [n 0 hash-code 1 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n        (next coll))\n      (mix-collection-hash hash-code n))))\n\n(def ^:private empty-ordered-hash\n  (mix-collection-hash 1 0))\n\n(defn ^number hash-unordered-coll\n  \"Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.\"\n  [coll]\n  (loop [n 0 hash-code 0 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ hash-code (hash (first coll))) 0) (next coll))\n      (mix-collection-hash hash-code n))))\n\n(def ^:private empty-unordered-hash\n  (mix-collection-hash 0 0))\n\n;;;;;;;;;;;;;;;;;;; protocols on primitives ;;;;;;;;\n(declare hash-map list equiv-sequential)\n\n(extend-type nil\n  ICounted\n  (-count [_] 0))\n\n;; TODO: we should remove this and handle date equality checking\n;; by some other means, probably by adding a new primitive type\n;; case to the hash table lookup - David\n\n(extend-type js/Date\n  IEquiv\n  (-equiv [o other]\n    (and (instance? js/Date other)\n         (== (.valueOf o) (.valueOf other))))\n\n  IComparable\n  (-compare [this other]\n    (if (instance? js/Date other)\n      (garray/defaultCompare (.valueOf this) (.valueOf other))\n      (throw (js/Error. (str \"Cannot compare \" this \" to \" other))))))\n\n(defprotocol Inst\n  (inst-ms* [inst]))\n\n(extend-protocol Inst\n  js/Date\n  (inst-ms* [inst] (.getTime inst)))\n\n(defn inst-ms\n  \"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"\n  [inst]\n  (inst-ms* inst))\n\n(defn inst?\n  \"Return true if x satisfies Inst\"\n  [x]\n  (satisfies? Inst x))\n\n(extend-type number\n  IEquiv\n  (-equiv [x o] (identical? x o)))\n\n(declare with-meta)\n\n(extend-type function\n  Fn\n  IMeta\n  (-meta [_] nil))\n\n(extend-type default\n  IHash\n  (-hash [o]\n    (goog/getUid o)))\n\n;;this is primitive because & emits call to array-seq\n(defn inc\n  \"Returns a number one greater than num.\"\n  [x] (cljs.core/+ x 1))\n\n(declare deref)\n\n(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))\n\n(defn reduced\n  \"Wraps x in a way such that a reduce will terminate with the value x\"\n  [x]\n  (Reduced. x))\n\n(defn reduced?\n  \"Returns true if x is the result of a call to reduced\"\n  [r]\n  (instance? Reduced r))\n\n(defn ensure-reduced\n  \"If x is already reduced?, returns it, else returns (reduced x)\"\n  [x]\n  (if (reduced? x) x (reduced x)))\n\n(defn unreduced\n  \"If x is reduced?, returns (deref x), else returns x\"\n  [x]\n  (if (reduced? x) (deref x) x))\n\n;; generic to all refs\n;; (but currently hard-coded to atom!)\n(defn deref\n  \"Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.\"\n  [o]\n  (-deref o))\n\n(defn- ci-reduce\n  \"Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization\"\n  ([cicoll f]\n     (let [cnt (-count cicoll)]\n       (if (zero? cnt)\n         (f)\n         (loop [val (-nth cicoll 0), n 1]\n           (if (< n cnt)\n             (let [nval (f val (-nth cicoll n))]\n               (if (reduced? nval)\n                 @nval\n                 (recur nval (inc n))))\n             val)))))\n  ([cicoll f val]\n     (let [cnt (-count cicoll)]\n       (loop [val val, n 0]\n         (if (< n cnt)\n           (let [nval (f val (-nth cicoll n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val))))\n  ([cicoll f val idx]\n     (let [cnt (-count cicoll)]\n       (loop [val val, n idx]\n         (if (< n cnt)\n           (let [nval (f val (-nth cicoll n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val)))))\n\n(defn- array-reduce\n  ([arr f]\n     (let [cnt (alength arr)]\n       (if (zero? (alength arr))\n         (f)\n         (loop [val (aget arr 0), n 1]\n           (if (< n cnt)\n             (let [nval (f val (aget arr n))]\n               (if (reduced? nval)\n                 @nval\n                 (recur nval (inc n))))\n             val)))))\n  ([arr f val]\n     (let [cnt (alength arr)]\n       (loop [val val, n 0]\n         (if (< n cnt)\n           (let [nval (f val (aget arr n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val))))\n  ([arr f val idx]\n     (let [cnt (alength arr)]\n       (loop [val val, n idx]\n         (if (< n cnt)\n           (let [nval (f val (aget arr n))]\n             (if (reduced? nval)\n               @nval\n               (recur nval (inc n))))\n           val)))))\n\n(declare hash-coll cons drop count nth RSeq List)\n\n(defn counted?\n  \"Returns true if coll implements count in constant time\"\n  [x] (satisfies? ICounted x))\n\n(defn indexed?\n  \"Returns true if coll implements nth in constant time\"\n  [x] (satisfies? IIndexed x))\n\n(defn- -indexOf\n  ([coll x]\n   (-indexOf coll x 0))\n  ([coll x start]\n   (let [len (count coll)]\n     (if (>= start len)\n       -1\n       (loop [idx (cond\n                    (pos? start) start\n                    (neg? start) (max 0 (+ start len))\n                    :else start)]\n         (if (< idx len)\n           (if (= (nth coll idx) x)\n             idx\n             (recur (inc idx)))\n           -1))))))\n\n(defn- -lastIndexOf\n  ([coll x]\n   (-lastIndexOf coll x (count coll)))\n  ([coll x start]\n   (let [len (count coll)]\n    (if (zero? len)\n      -1\n      (loop [idx (cond\n                   (pos? start) (min (dec len) start)\n                   (neg? start) (+ len start)\n                   :else start)]\n        (if (>= idx 0)\n          (if (= (nth coll idx) x)\n            idx\n            (recur (dec idx)))\n          -1))))))\n\n(deftype IndexedSeqIterator [arr ^:mutable i]\n  Object\n  (hasNext [_]\n    (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret)))\n\n(deftype IndexedSeq [arr i meta]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i meta))\n\n  ISeqable\n  (-seq [this]\n    (when (< i (alength arr))\n      this))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (IndexedSeq. arr i new-meta)))\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i) nil)\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i) nil)\n               nil))\n\n  ICounted\n  (-count [_]\n    (max 0 (- (alength arr) i)))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (if (and (<= 0 i) (< i (alength arr)))\n        (aget arr i)\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (and (<= 0 i) (< i (alength arr)))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IIterable\n  (-iterator [coll]\n    (IndexedSeqIterator. arr i))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))\n\n(es6-iterable IndexedSeq)\n\n(defn prim-seq\n  \"Create seq from a primitive JavaScript Array-like.\"\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i nil))))\n\n(defn array-seq\n  \"Create a seq from a JavaScript array.\"\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))\n\n(declare with-meta seq-reduce)\n\n(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (RSeq. ci i new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n  \n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))\n\n(es6-iterable RSeq)\n\n(defn second\n  \"Same as (first (next x))\"\n  [coll]\n  (first (next coll)))\n\n(defn ffirst\n  \"Same as (first (first x))\"\n  [coll]\n  (first (first coll)))\n\n(defn nfirst\n  \"Same as (next (first x))\"\n  [coll]\n  (next (first coll)))\n\n(defn fnext\n  \"Same as (first (next x))\"\n  [coll]\n  (first (next coll)))\n\n(defn nnext\n  \"Same as (next (next x))\"\n  [coll]\n  (next (next coll)))\n\n(defn last\n  \"Return the last item in coll, in linear time\"\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))\n\n(extend-type default\n  IEquiv\n  (-equiv [x o] (identical? x o)))\n\n(defn conj\n  \"conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.\"\n  ([] [])\n  ([coll] coll)\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))\n\n(defn empty\n  \"Returns an empty collection of the same category as coll, or nil\"\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? IEmptyableCollection coll)\n      (-empty coll)\n\n      (satisfies? IEmptyableCollection coll)\n      (-empty coll)\n\n      :else nil)))\n\n(defn- accumulating-seq-count [coll]\n  (loop [s (seq coll) acc 0]\n    (if (counted? s) ; assumes nil is counted, which it currently is\n      (+ acc (-count s))\n      (recur (next s) (inc acc)))))\n\n(defn count\n  \"Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps\"\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count coll)\n\n      (array? coll)\n      (alength coll)\n    \n      (string? coll)\n      ^number (.-length coll)\n\n      (implements? ISeqable coll)\n      (accumulating-seq-count coll)\n\n      :else (-count coll))\n    0))\n\n(defn- linear-traversal-nth\n  ([coll n]\n     (cond\n       (nil? coll)     (throw (js/Error. \"Index out of bounds\"))\n       (zero? n)       (if (seq coll)\n                         (first coll)\n                         (throw (js/Error. \"Index out of bounds\")))\n       (indexed? coll) (-nth coll n)\n       (seq coll)      (recur (next coll) (dec n))\n       :else           (throw (js/Error. \"Index out of bounds\"))))\n  ([coll n not-found]\n     (cond\n       (nil? coll)     not-found\n       (zero? n)       (if (seq coll)\n                         (first coll)\n                         not-found)\n       (indexed? coll) (-nth coll n not-found)\n       (seq coll)      (recur (next coll) (dec n) not-found)\n       :else           not-found)))\n\n(defn nth\n  \"Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.\"\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"Index argument to nth must be a number\"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth coll n)\n\n      (array? coll)\n      (if (and (< -1 n (.-length coll)))\n        (aget coll (int n))\n        (throw (js/Error. \"Index out of bounds\")))\n\n      (string? coll)\n      (if (and (< -1 n (.-length coll)))\n        (.charAt coll (int n))\n        (throw (js/Error. \"Index out of bounds\")))\n\n      (or (implements? ISeq coll)\n          (implements? ISequential coll))\n      (if (neg? n)\n        (throw (js/Error. \"Index out of bounds\"))\n        (linear-traversal-nth coll n))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"Index argument to nth must be a number.\"))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth coll n not-found)\n\n      (array? coll)\n      (if (and (< -1 n (.-length coll)))\n        (aget coll (int n))\n        not-found)\n\n      (string? coll)\n      (if (and (< -1 n (.-length coll)))\n        (.charAt coll (int n))\n        not-found)\n\n      (or (implements? ISeq coll)\n          (implements? ISequential coll))\n      (if (neg? n)\n        not-found\n        (linear-traversal-nth coll n not-found))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n not-found)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll))))))))\n\n(defn nthrest\n  \"Returns the nth rest of coll, coll when n is 0.\"\n  [coll n]\n    (loop [n n xs coll]\n      (if-let [xs (and (pos? n) (seq xs))]\n        (recur (dec n) (rest xs))\n        xs)))\n\n(defn get\n  \"Returns the value mapped to key, not-found or nil if key not present.\"\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup o k)\n\n        (array? o)\n        (when (and (some? k) (< k (.-length o)))\n          (aget o (int k)))\n\n        (string? o)\n        (when (and (some? k) (< k (.-length o)))\n          (.charAt o (int k)))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n\n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup o k not-found)\n\n        (array? o)\n        (if (and (some? k) (< -1 k (.-length o)))\n          (aget o (int k))\n          not-found)\n\n        (string? o)\n        (if (and (some? k) (< -1 k (.-length o)))\n          (.charAt o (int k))\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))\n\n(declare PersistentHashMap PersistentArrayMap MapEntry)\n\n(defn assoc\n  \"assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.\"\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (array-map k v)))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))\n\n(defn dissoc\n  \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).\"\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))\n\n(defn fn?\n  \"Return true if f is a JavaScript function or satisfies the Fn protocol.\"\n  [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))\n\n(deftype MetaFn [afn meta]\n  IMeta\n  (-meta [_] meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (MetaFn. afn new-meta))\n  Fn\n  IFn\n  (-invoke [_]\n    (afn))\n  (-invoke [_ a]\n    (afn a))\n  (-invoke [_ a b]\n    (afn a b))\n  (-invoke [_ a b c]\n    (afn a b c))\n  (-invoke [_ a b c d]\n    (afn a b c d))\n  (-invoke [_ a b c d e]\n    (afn a b c d e))\n  (-invoke [_ a b c d e f]\n    (afn a b c d e f))\n  (-invoke [_ a b c d e f g]\n    (afn a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    (afn a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    (afn a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    (afn a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    (afn a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    (afn a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    (afn a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    (afn a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    (afn a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    (afn a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    (afn a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    (afn a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    (afn a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    (afn a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply afn a b c d e f g h i j k l m n o p q r s t rest)))\n\n(defn with-meta\n  \"Returns an object of the same type and value as obj, with\n  map m as its metadata.\"\n  [o meta]\n  (if ^boolean (goog/isFunction o)\n    (MetaFn. o meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))\n\n(defn meta\n  \"Returns the metadata of obj, returns nil if there is no metadata.\"\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))\n\n(defn peek\n  \"For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.\"\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))\n\n(defn pop\n  \"For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.\"\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))\n\n(defn disj\n  \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).\"\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))\n\n(defn empty?\n  \"Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n  [coll] (or (nil? coll)\n             (not (seq coll))))\n\n(defn coll?\n  \"Returns true if x satisfies ICollection\"\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))\n\n(defn set?\n  \"Returns true if x satisfies ISet\"\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))\n\n(defn associative?\n \"Returns true if coll implements IAssociative\"\n  [x] (satisfies? IAssociative x))\n\n(defn ifind?\n \"Returns true if coll implements IFind\"\n  [x] (satisfies? IFind x))\n\n(defn sequential?\n  \"Returns true if coll satisfies ISequential\"\n  [x] (satisfies? ISequential x))\n\n(defn sorted?\n  \"Returns true if coll satisfies ISorted\"\n  [x] (satisfies? ISorted x))\n\n(defn reduceable?\n  \"Returns true if coll satisfies IReduce\"\n  [x] (satisfies? IReduce x))\n\n(defn map?\n  \"Return true if x satisfies IMap\"\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))\n\n(defn record?\n  \"Return true if x satisfies IRecord\"\n  [x]\n  (satisfies? IRecord x))\n\n(defn vector?\n  \"Return true if x satisfies IVector\"\n  [x] (satisfies? IVector x))\n\n(declare ChunkedCons ChunkedSeq)\n\n(defn chunked-seq?\n  \"Return true if x is satisfies IChunkedSeq.\"\n  [x] (implements? IChunkedSeq x))\n\n;;;;;;;;;;;;;;;;;;;; js primitives ;;;;;;;;;;;;\n(defn js-obj\n  \"Create JavaSript object from an even number arguments representing\n  interleaved keys and values.\"\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))\n\n(defn js-keys\n  \"Return the JavaScript keys for an object.\"\n  [obj]\n  (gobject/getKeys obj))\n\n(defn js-delete\n  \"Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise.\"\n  [obj key]\n  (cljs.core/js-delete obj key))\n\n(defn- array-copy\n  ([from i to j len]\n    (loop [i i j j len len]\n       (if (zero? len)\n         to\n         (do (aset to j (aget from i))\n             (recur (inc i) (inc j) (dec len)))))))\n\n(defn- array-copy-downward\n  ([from i to j len]\n     (loop [i (+ i (dec len)) j (+ j (dec len)) len len]\n       (if (zero? len)\n         to\n         (do (aset to j (aget from i))\n             (recur (dec i) (dec j) (dec len)))))))\n\n;;;;;;;;;;;;;;;; preds ;;;;;;;;;;;;;;;;;;\n\n(def ^:private lookup-sentinel (js-obj))\n\n(defn ^boolean false?\n  \"Returns true if x is the value false, false otherwise.\"\n  [x] (cljs.core/false? x))\n\n(defn ^boolean true?\n  \"Returns true if x is the value true, false otherwise.\"\n  [x] (cljs.core/true? x))\n\n(defn boolean?\n  \"Return true if x is a Boolean\"\n  [x] (or (cljs.core/true? x) (cljs.core/false? x)))\n\n(defn ^boolean undefined?\n  \"Returns true if x identical to the JavaScript undefined value.\"\n  [x]\n  (cljs.core/undefined? x))\n\n(defn seq?\n  \"Return true if s satisfies ISeq\"\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))\n\n(defn seqable?\n  \"Return true if the seq function is supported for s\"\n  [s]\n  (or\n   (nil? s)\n   (satisfies? ISeqable s)\n   (array? s)\n   (string? s)))\n\n(defn boolean\n  \"Coerce to boolean\"\n  [x]\n  (cond\n    (nil? x) false\n    (false? x) false\n    :else true))\n\n(defn ifn?\n  \"Returns true if f returns true for fn? or satisfies IFn.\"\n  [f]\n  (or (fn? f) (satisfies? IFn f)))\n\n(defn integer?\n  \"Returns true if n is a JavaScript number with no decimal part.\"\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))\n\n(defn int?\n  \"Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.\"\n  [x]\n  (or (integer? x)\n      (instance? goog.math.Integer x)\n      (instance? goog.math.Long x)))\n\n(defn pos-int?\n  \"Return true if x satisfies int? and is positive.\"\n  [x]\n  (cond\n    (integer? x) (pos? x)\n\n    (instance? goog.math.Integer x)\n    (and (not (.isNegative x))\n         (not (.isZero x)))\n\n    (instance? goog.math.Long x)\n    (and (not (.isNegative x))\n         (not (.isZero x)))\n\n    :else false))\n\n(defn ^boolean neg-int?\n  \"Return true if x satisfies int? and is negative.\"\n  [x]\n  (cond\n    (integer? x) (neg? x)\n\n    (instance? goog.math.Integer x)\n    (.isNegative x)\n\n    (instance? goog.math.Long x)\n    (.isNegative x)\n\n    :else false))\n\n(defn nat-int?\n  \"Return true if x satisfies int? and is a natural integer value.\"\n  [x]\n  (cond\n    (integer? x)\n    (not (neg? x))\n\n    (instance? goog.math.Integer x)\n    (not (.isNegative x))\n\n    (instance? goog.math.Long x)\n    (not (.isNegative x))\n\n    :else false))\n\n(defn float?\n  \"Returns true for JavaScript numbers, false otherwise.\"\n  [x]\n  (number? x))\n\n(defn double?\n  \"Returns true for JavaScript numbers, false otherwise.\"\n  [x]\n  (number? x))\n\n(defn infinite?\n  \"Returns true for Infinity and -Infinity values.\"\n  [x]\n  (or (identical? x js/Number.POSITIVE_INFINITY)\n      (identical? x js/Number.NEGATIVE_INFINITY)))\n\n(defn contains?\n  \"Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.\"\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))\n\n(defn find\n  \"Returns the map entry for key, or nil if key not present.\"\n  [coll k]\n  (if (ifind? coll)\n    (-find coll k)\n    (when (and (not (nil? coll))\n            (associative? coll)\n            (contains? coll k))\n      (MapEntry. k (get coll k) nil))))\n\n(defn ^boolean distinct?\n  \"Returns true if no two of the arguments are =\"\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Seq fns ;;;;;;;;;;;;;;;;\n\n(defn ^number compare\n  \"Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.\"\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (number? x) (if (number? y)\n                 (garray/defaultCompare x y)\n                 (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))\n\n   (satisfies? IComparable x)\n   (-compare x y)\n\n   :else\n   (if (and (or (string? x) (array? x) (true? x) (false? x))\n            (identical? (type x) (type y)))\n     (garray/defaultCompare x y)\n     (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n\n(defn ^:private compare-indexed\n  \"Compare indexed collection.\"\n  ([xs ys]\n     (let [xl (count xs)\n           yl (count ys)]\n       (cond\n        (< xl yl) -1\n        (> xl yl) 1\n        (== xl 0) 0\n        :else (compare-indexed xs ys xl 0))))\n  ([xs ys len n]\n     (let [d (compare (nth xs n) (nth ys n))]\n       (if (and (zero? d) (< (+ n 1) len))\n         (recur xs ys len (inc n))\n         d))))\n\n(defn ^:private fn->comparator\n  \"Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.\"\n  [f]\n  (if (= f compare)\n    compare\n    (fn [x y]\n      (let [r (f x y)]\n        (if (number? r)\n          r\n          (if r\n            -1\n            (if (f y x) 1 0)))))))\n\n(declare to-array)\n\n(defn sort\n  \"Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.\"\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))\n\n(defn sort-by\n  \"Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.\"\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))\n\n; simple reduce based on seqs, used as default\n(defn- seq-reduce\n  ([f coll]\n    (if-let [s (seq coll)]\n      (reduce f (first s) (next s))\n      (f)))\n  ([f val coll]\n    (loop [val val, coll (seq coll)]\n      (if coll\n        (let [nval (f val (first coll))]\n          (if (reduced? nval)\n            @nval\n            (recur nval (next coll))))\n        val))))\n\n(declare vec)\n\n(defn shuffle\n  \"Return a random permutation of coll\"\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))\n\n(defn- iter-reduce\n  ([coll f]\n   (let [iter (-iterator coll)]\n     (if (.hasNext iter)\n       (let [init (.next iter)]\n         (loop [acc init]\n           (if ^boolean (.hasNext iter)\n             (let [nacc (f acc (.next iter))]\n               (if (reduced? nacc)\n                 @nacc\n                 (recur nacc)))\n             acc)))\n       (f))))\n  ([coll f init]\n   (let [iter (-iterator coll)]\n     (loop [acc init]\n       (if ^boolean (.hasNext iter)\n         (let [nacc (f acc (.next iter))]\n           (if (reduced? nacc)\n             @nacc\n             (recur nacc)))\n         acc)))))\n\n(defn reduce\n  \"f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.\"\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       (iterable? coll)\n       (iter-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n\n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       (iterable? coll)\n       (iter-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))\n\n(defn reduce-kv\n  \"Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.\"\n  ([f init coll]\n    (if-not (nil? coll)\n      (-kv-reduce coll f init)\n      init)))\n\n(defn identity\n  \"Returns its argument.\"\n  [x] x)\n\n(defn completing\n  \"Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.\"\n  ([f] (completing f identity))\n  ([f cf]\n    (fn\n      ([] (f))\n      ([x] (cf x))\n      ([x y] (f x y)))))\n\n(defn transduce\n  \"reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.\"\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (reduce f init coll)]\n       (f ret))))\n\n;;; Math - variadic forms will not work until the following implemented:\n;;; first, next, reduce\n\n(defn ^number +\n  \"Returns the sum of nums. (+) returns 0.\"\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))\n\n(defn ^number -\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.\"\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))\n\n(defn ^number *\n  \"Returns the product of nums. (*) returns 1.\"\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))\n\n(declare divide)\n\n(defn ^number /\n  \"If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.\"\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))\n\n(defn ^boolean <\n  \"Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.\"\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))\n\n(defn ^boolean <=\n  \"Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.\"\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))\n\n(defn ^boolean >\n  \"Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.\"\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))\n\n(defn ^boolean >=\n  \"Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.\"\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))\n\n(defn dec\n  \"Returns a number one less than num.\"\n  [x] (- x 1))\n\n(defn ^number max\n  \"Returns the greatest of the nums.\"\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))\n\n(defn ^number min\n  \"Returns the least of the nums.\"\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))\n\n(defn ^number byte [x] x)\n\n(defn char\n  \"Coerce to char\"\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))\n\n(defn ^number short [x] x)\n(defn ^number float [x] x)\n(defn ^number double [x] x)\n\n(defn ^number unchecked-byte [x] x)\n(defn ^number unchecked-char [x] x)\n(defn ^number unchecked-short [x] x)\n(defn ^number unchecked-float [x] x)\n(defn ^number unchecked-double [x] x)\n\n(defn ^number unchecked-add\n  \"Returns the sum of nums. (+) returns 0.\"\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))\n\n(defn ^number unchecked-add-int\n  \"Returns the sum of nums. (+) returns 0.\"\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))\n\n(defn unchecked-dec\n  \"Returns a number one less than x, an int.\"\n  [x]\n  (cljs.core/unchecked-dec x))\n\n(defn unchecked-dec-int\n  \"Returns a number one less than x, an int.\"\n  [x]\n  (cljs.core/unchecked-dec-int x))\n\n(defn ^number unchecked-divide-int\n  \"If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.\"\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))\n\n(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))\n\n(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))\n\n(defn ^number unchecked-multiply\n  \"Returns the product of nums. (*) returns 1.\"\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))\n\n(defn ^number unchecked-multiply-int\n  \"Returns the product of nums. (*) returns 1.\"\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))\n\n(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))\n\n(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))\n\n(declare mod)\n\n(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))\n\n(defn ^number unchecked-subtract\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.\"\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))\n\n(defn ^number unchecked-subtract-int\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.\"\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-subtract-int (cljs.core/unchecked-subtract-int x y) more)))\n\n(defn- ^number fix [q]\n  (if (>= q 0)\n    (Math/floor q)\n    (Math/ceil q)))\n\n(defn int\n  \"Coerce to int by stripping decimal places.\"\n  [x]\n  (bit-or x 0))\n\n(defn unchecked-int\n  \"Coerce to int by stripping decimal places.\"\n  [x]\n  (fix x))\n\n(defn long\n  \"Coerce to long by stripping decimal places. Identical to `int'.\"\n  [x]\n  (fix x))\n\n(defn unchecked-long\n  \"Coerce to long by stripping decimal places. Identical to `int'.\"\n  [x]\n  (fix x))\n\n(defn booleans [x] x)\n(defn bytes [x] x)\n(defn chars [x] x)\n(defn shorts [x] x)\n(defn ints [x] x)\n(defn floats [x] x)\n(defn doubles [x] x)\n(defn longs [x] x)\n\n(defn js-mod\n  \"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"\n  [n d]\n  (cljs.core/js-mod n d))\n\n(defn mod\n  \"Modulus of num and div. Truncates toward negative infinity.\"\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))\n\n(defn quot\n  \"quot[ient] of dividing numerator by denominator.\"\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))\n\n(defn rem\n  \"remainder of dividing numerator by denominator.\"\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))\n\n(defn bit-xor\n  \"Bitwise exclusive or\"\n  ([x y] (cljs.core/bit-xor x y))\n  ([x y & more]\n     (reduce bit-xor (cljs.core/bit-xor x y) more)))\n\n(defn bit-and\n  \"Bitwise and\"\n  ([x y] (cljs.core/bit-and x y))\n  ([x y & more]\n     (reduce bit-and (cljs.core/bit-and x y) more)))\n\n(defn bit-or\n  \"Bitwise or\"\n  ([x y] (cljs.core/bit-or x y))\n  ([x y & more]\n     (reduce bit-or (cljs.core/bit-or x y) more)))\n\n(defn bit-and-not\n  \"Bitwise and with complement\"\n  ([x y] (cljs.core/bit-and-not x y))\n  ([x y & more]\n     (reduce bit-and-not (cljs.core/bit-and-not x y) more)))\n\n(defn bit-clear\n  \"Clear bit at index n\"\n  [x n]\n  (cljs.core/bit-clear x n))\n\n(defn bit-flip\n  \"Flip bit at index n\"\n  [x n]\n  (cljs.core/bit-flip x n))\n\n(defn bit-not\n  \"Bitwise complement\"\n  [x] (cljs.core/bit-not x))\n\n(defn bit-set\n  \"Set bit at index n\"\n  [x n]\n  (cljs.core/bit-set x n))\n\n(defn ^boolean bit-test\n  \"Test bit at index n\"\n  [x n]\n  (cljs.core/bit-test x n))\n\n(defn bit-shift-left\n  \"Bitwise shift left\"\n  [x n] (cljs.core/bit-shift-left x n))\n\n(defn bit-shift-right\n  \"Bitwise shift right\"\n  [x n] (cljs.core/bit-shift-right x n))\n\n(defn bit-shift-right-zero-fill\n  \"DEPRECATED: Bitwise shift right with zero fill\"\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))\n\n(defn unsigned-bit-shift-right\n  \"Bitwise shift right with zero fill\"\n  [x n] (cljs.core/unsigned-bit-shift-right x n))\n\n(defn bit-count\n  \"Counts the number of bits set in n\"\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))\n\n(defn ^boolean ==\n  \"Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.\"\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))\n\n(defn ^boolean pos?\n  \"Returns true if num is greater than zero, else false\"\n  [x] (cljs.core/pos? x))\n\n(defn ^boolean zero?\n  \"Returns true if num is zero, else false\"\n  [x]\n  (cljs.core/zero? x))\n\n(defn ^boolean neg?\n  \"Returns true if num is less than zero, else false\"\n  [x] (cljs.core/neg? x))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; protocols for host types ;;;;;;\n\n(defn nthnext\n  \"Returns the nth next of coll, (seq coll) when n is 0.\"\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;; basics ;;;;;;;;;;;;;;;;;;\n\n(defn str\n  \"With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.\"\n  ([] \"\")\n  ([x] (if (nil? x)\n         \"\"\n         (.join #js [x] \"\")))\n  ([x & ys]\n    (loop [sb (StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))\n\n(defn subs\n  \"Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.\"\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))\n\n(declare map name)\n\n(defn- equiv-sequential\n  \"Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.\"\n  [x y]\n  (boolean\n    (when (sequential? y)\n      (if (and (counted? x) (counted? y)\n               (not (== (count x) (count y))))\n        false\n        (loop [xs (seq x) ys (seq y)]\n          (cond (nil? xs) (nil? ys)\n            (nil? ys) false\n            (= (first xs) (first ys)) (recur (next xs) (next ys))\n            :else false))))))\n\n(defn- hash-coll [coll]\n  (if (seq coll)\n    (loop [res (hash (first coll)) s (next coll)]\n      (if (nil? s)\n        res\n        (recur (hash-combine res (hash (first s))) (next s))))\n    0))\n\n(declare key val)\n\n(defn- hash-imap [m]\n  ;; a la clojure.lang.APersistentMap\n  (loop [h 0 s (seq m)]\n    (if s\n      (let [e (first s)]\n        (recur (js-mod (+ h (bit-xor (hash (key e)) (hash (val e))))\n                    4503599627370496)\n               (next s)))\n      h)))\n\n(defn- hash-iset [s]\n  ;; a la clojure.lang.APersistentSet\n  (loop [h 0 s (seq s)]\n    (if s\n      (let [e (first s)]\n        (recur (js-mod (+ h (hash e)) 4503599627370496)\n               (next s)))\n      h)))\n\n(declare name chunk-first chunk-rest)\n\n(defn- extend-object!\n  \"Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.\"\n  [obj fn-map]\n  (doseq [[key-name f] fn-map]\n    (let [str-name (name key-name)]\n      (gobject/set obj str-name f)))\n  obj)\n\n;;;;;;;;;;;;;;;; cons ;;;;;;;;;;;;;;;;\n(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x count))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (List. new-meta first rest count __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(defn list?\n  \"Returns true if x implements IList\"\n  [x]\n  (satisfies? IList x))\n\n(es6-iterable List)\n\n(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (EmptyList. new-meta)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (or (list? other)\n            (sequential? other))\n      (nil? (seq other))\n      false))\n\n  IHash\n  (-hash [coll] empty-ordered-hash)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(set! (.-EMPTY List) (EmptyList. nil))\n\n(es6-iterable EmptyList)\n\n(defn reversible?\n  \"Returns true if coll satisfies? IReversible.\"\n  [coll]\n  (satisfies? IReversible coll))\n\n(defn ^seq rseq\n  \"Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n  [rev]\n  (-rseq rev))\n\n(defn reverse\n  \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n  [coll]\n  (if (reversible? coll)\n    (or (rseq coll) ())\n    (reduce conj () coll)))\n\n(defn list\n  \"Creates a new list containing the items.\"\n  [& xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))\n\n(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Cons. new-meta first rest __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll nil))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n  \n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable Cons)\n\n(defn cons\n  \"Returns a new seq where x is the first element and coll is the rest.\"\n  [x coll]\n  (cond\n    (nil? coll)             (List. nil x nil 1 nil)\n    (implements? ISeq coll) (Cons. nil x coll nil)\n    :default                (Cons. nil x (seq coll) nil)))\n\n(defn hash-keyword [k]\n  (int (+ (hash-symbol k) 0x9e3779b9)))\n\n(defn- compare-keywords [a b]\n  (cond\n   (identical? (.-fqn a) (.-fqn b)) 0\n   (and (not (.-ns a)) (.-ns b)) -1\n   (.-ns a) (if-not (.-ns b)\n              1\n              (let [nsc (garray/defaultCompare (.-ns a) (.-ns b))]\n                (if (== 0 nsc)\n                  (garray/defaultCompare (.-name a) (.-name b))\n                  nsc)))\n   :default (garray/defaultCompare (.-name a) (.-name b))))\n\n(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str \":\" fqn))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-keyword _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str \":\" fqn))))\n\n(defn keyword?\n  \"Return true if x is a Keyword\"\n  [x]\n  (instance? Keyword x))\n\n(defn keyword-identical?\n  \"Efficient test to determine that two keywords are identical.\"\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x) (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))\n\n(defn symbol-identical?\n  \"Efficient test to determine that two symbols are identical.\"\n  [x y]\n  (if (identical? x y)\n    true\n    (if (and (symbol? x) (symbol? y))\n      (identical? (.-str x) (.-str y))\n      false)))\n\n(defn namespace\n  \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n  [x]\n  (if (implements? INamed x)\n    (-namespace x)\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))\n\n(defn ident?\n  \"Return true if x is a symbol or keyword\"\n  [x] (or (keyword? x) (symbol? x)))\n\n(defn simple-ident?\n  \"Return true if x is a symbol or keyword without a namespace\"\n  [x] (and (ident? x) (nil? (namespace x))))\n\n(defn qualified-ident?\n  \"Return true if x is a symbol or keyword with a namespace\"\n  [x] (boolean (and (ident? x) (namespace x) true)))\n\n(defn simple-symbol?\n  \"Return true if x is a symbol without a namespace\"\n  [x] (and (symbol? x) (nil? (namespace x))))\n\n(defn qualified-symbol?\n  \"Return true if x is a symbol with a namespace\"\n  [x] (boolean (and (symbol? x) (namespace x) true)))\n\n(defn simple-keyword?\n  \"Return true if x is a keyword without a namespace\"\n  [x] (and (keyword? x) (nil? (namespace x))))\n\n(defn qualified-keyword?\n  \"Return true if x is a keyword with a namespace\"\n  [x] (boolean (and (keyword? x) (namespace x) true)))\n\n(defn keyword\n  \"Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.\"\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (string? name) (let [parts (.split name \"/\")]\n                             (if (== (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name]\n   (let [ns   (cond\n                (keyword? ns) (cljs.core/name ns)\n                (symbol? ns)  (cljs.core/name ns)\n                :else ns)\n         name (cond\n                (keyword? name) (cljs.core/name name)\n                (symbol? name) (cljs.core/name name)\n                :else name)]\n     (Keyword. ns name (str (when ns (str ns \"/\")) name) nil))))\n\n\n(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IPending\n  (-realized? [coll]\n    (not fn))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (LazySeq. new-meta #(-seq coll) nil __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n            (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable LazySeq)\n\n(declare ArrayChunk)\n\n(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))\n\n(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))\n\n(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))\n\n(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))\n\n(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ChunkedCons. chunk more new-meta __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more nil nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more nil nil)\n      (when-not (nil? more)\n        (-seq more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash)))\n\n(es6-iterable ChunkedCons)\n\n(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))\n\n(defn chunk-append [b x]\n  (.add b x))\n\n(defn chunk [b]\n  (.chunk b))\n\n(defn chunk-first [s]\n  (-chunked-first s))\n\n(defn chunk-rest [s]\n  (-chunked-rest s))\n\n(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))\n\n;;;;;;;;;;;;;;;;\n\n(defn to-array\n  \"Returns an array containing the contents of coll.\"\n  [coll]\n  (let [ary (array)]\n    (loop [s (seq coll)]\n      (if-not (nil? s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))\n\n(defn to-array-2d\n  \"Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.\"\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when-not (nil? xs)\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))\n\n(defn int-array\n  \"Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.\"\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn long-array\n  \"Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.\"\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn double-array\n  \"Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.\"\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn object-array\n  \"Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.\"\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))\n\n(defn bounded-count\n  \"If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq\"\n  {:added \"1.9\"}\n  [n coll]\n  (if (counted? coll)\n    (count coll)\n    (loop [i 0 s (seq coll)]\n      (if (and (not (nil? s)) (< i n))\n        (recur (inc i) (next s))\n        i))))\n\n(defn spread\n  [arglist]\n  (when-not (nil? arglist)\n    (let [n (next arglist)]\n      (if (nil? n)\n        (seq (first arglist))\n        (cons (first arglist)\n              (spread n))))))\n\n(defn concat\n  \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))\n\n(defn list*\n  \"Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.\"\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))\n\n\n;;; Transients\n\n(defn transient\n  \"Returns a new, transient version of the collection, in constant time.\"\n  [coll]\n  (-as-transient coll))\n\n(defn persistent!\n  \"Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.\"\n  [tcoll]\n  (-persistent! tcoll))\n\n(defn conj!\n  \"Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.\"\n  ([] (transient []))\n  ([tcoll] tcoll)\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))\n\n(defn assoc!\n  \"When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.\"\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val & kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))\n\n(defn dissoc!\n  \"Returns a transient map that doesn't contain a mapping for key(s).\"\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key & ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))\n\n(defn pop!\n  \"Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll\"\n  [tcoll]\n  (-pop! tcoll))\n\n(defn disj!\n  \"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).\"\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))\n\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; apply ;;;;;;;;;;;;;;;;\n\n;; see core.clj\n(gen-apply-to)\n\n(set! *unchecked-if* true)\n\n(defn- ^seq next*\n  \"Internal. DO NOT USE! Next without the nil? check.\"\n  [coll]\n  (if (implements? INext coll)\n    (-next ^not-native coll)\n    (seq (rest coll))))\n\n(defn- apply-to-simple\n  \"Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!\"\n  ([f ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$0 f)\n       (.cljs$core$IFn$_invoke$arity$0 f)\n       (.call f f))\n     (apply-to-simple f (-first args) (next* args))))\n  ([f a0 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$1 f)\n       (.cljs$core$IFn$_invoke$arity$1 f a0)\n       (.call f f a0))\n     (apply-to-simple f a0 (-first args) (next* args))))\n  ([f a0 a1 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$2 f)\n       (.cljs$core$IFn$_invoke$arity$2 f a0 a1)\n       (.call f f a0 a1))\n     (apply-to-simple f a0 a1 (-first args) (next* args))))\n  ([f a0 a1 a2 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$3 f)\n       (.cljs$core$IFn$_invoke$arity$3 f a0 a1 a2)\n       (.call f f a0 a1 a2))\n     (apply-to-simple f a0 a1 a2 (-first args) (next* args))))\n  ([f a0 a1 a2 a3 ^seq args]\n   (if (nil? args)\n     (if (.-cljs$core$IFn$_invoke$arity$4 f)\n       (.cljs$core$IFn$_invoke$arity$4 f a0 a1 a2 a3)\n       (.call f f a0 a1 a2 a3))\n     (gen-apply-to-simple f 4 args))))\n\n(defn apply\n  \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n  ([f args]\n   (if (.-cljs$lang$applyTo f)\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (bounded-count (inc fixed-arity) args)]\n       (if (<= bc fixed-arity)\n         (apply-to f bc args)\n         (.cljs$lang$applyTo f args)))\n     (apply-to-simple f (seq args))))\n  ([f x args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (inc (bounded-count fixed-arity args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x (seq args))))\n  ([f x y args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 2 (bounded-count (dec fixed-arity) args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x y (seq args))))\n  ([f x y z args]\n   (if (.-cljs$lang$applyTo f)\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 3 (bounded-count (- fixed-arity 2) args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f x y z (seq args))))\n  ([f a b c d & args]\n   (if (.-cljs$lang$applyTo f)\n     (let [spread-args (spread args)\n           arglist (cons a (cons b (cons c (cons d spread-args))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)\n           bc (+ 4 (bounded-count (- fixed-arity 3) spread-args))]\n       (if (<= bc fixed-arity)\n         (apply-to f bc arglist)\n         (.cljs$lang$applyTo f arglist)))\n     (apply-to-simple f a b c d (spread args)))))\n\n(set! *unchecked-if* false)\n\n(defn vary-meta\n \"Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.\"\n  ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d & args]\n   (with-meta obj (apply f (meta obj) a b c d args))))\n\n(defn ^boolean not=\n  \"Same as (not (= obj1 obj2))\"\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))\n\n(defn not-empty\n  \"If coll is empty, returns nil, else coll\"\n  [coll] (when (seq coll) coll))\n\n(defn nil-iter []\n  (reify\n    Object\n    (hasNext [_] false)\n    (next [_] (js/Error. \"No such element\"))\n    (remove [_] (js/Error. \"Unsupported operation\"))))\n\n(deftype StringIter [s ^:mutable i]\n  Object\n  (hasNext [_] (< i (.-length s)))\n  (next [_]\n    (let [ret (.charAt s i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(defn string-iter [x]\n  (StringIter. x 0))\n\n(deftype ArrayIter [arr ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(defn array-iter [x]\n  (ArrayIter. x 0))\n\n(def INIT #js {})\n(def START #js {})\n\n(deftype SeqIter [^:mutable _seq ^:mutable _next]\n  Object\n  (hasNext [_]\n    (if (identical? _seq INIT)\n      (do\n        (set! _seq START)\n        (set! _next (seq _next)))\n      (if (identical? _seq _next)\n        (set! _next (next _seq))))\n    (not (nil? _next)))\n  (next [this]\n    (if-not ^boolean (.hasNext this)\n      (throw (js/Error. \"No such element\"))\n      (do\n        (set! _seq _next)\n        (first _next))))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(defn seq-iter [coll]\n  (SeqIter. INIT coll))\n\n(defn iter [coll]\n  (cond\n    (iterable? coll) (-iterator coll)\n    (nil? coll) (nil-iter)\n    (string? coll) (string-iter coll)\n    (array? coll) (array-iter coll)\n    (seqable? coll) (seq-iter coll)\n    :else (throw (js/Error. (str \"Cannot create iterator from \" coll)))))\n\n(deftype Many [vals]\n  Object\n  (add [this o]\n    (.push vals o)\n    this)\n  (remove [this]\n    (.shift vals))\n  (isEmpty [this]\n    (zero? (.-length vals)))\n  (toString [this]\n    (str \"Many: \" vals)))\n\n(def ^:private NONE #js {})\n\n(deftype Single [^:mutable val]\n  Object\n  (add [this o]\n    (if (identical? val NONE)\n      (do\n        (set! val o)\n        this)\n      (Many. #js [val o])))\n  (remove [this]\n    (if (identical? val NONE)\n      (throw (js/Error. (str \"Removing object from empty buffer\")))\n      (let [ret val]\n        (set! val NONE)\n        ret)))\n  (isEmpty [this]\n    (identical? val NONE))\n  (toString [this]\n    (str \"Single: \" val)))\n\n(deftype Empty []\n  Object\n  (add [this o]\n    (Single. o))\n  (remove [this]\n    (throw (js/Error. (str \"Removing object from empty buffer\"))))\n  (isEmpty [this]\n    true)\n  (toString [this]\n    \"Empty\"))\n\n(def ^:private EMPTY (Empty.))\n\n(deftype MultiIterator [iters]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not ^boolean (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (let [nexts (array)]\n      (dotimes [i (alength iters)]\n        (aset nexts i (.next (aget iters i))))\n      (prim-seq nexts 0))))\n\n(defn- chunkIteratorSeq [iter]\n  (lazy-seq\n    (when ^boolean (.hasNext iter)\n      (let [arr (array)]\n        (loop [n 0]\n          (if (and (.hasNext iter) (< n 32))\n            (do\n              (aset arr n (.next iter))\n              (recur (inc n)))\n            (chunk-cons (array-chunk arr 0 n) (chunkIteratorSeq iter))))))))\n\n(deftype TransformerIterator [^:mutable buffer ^:mutable _next ^:mutable completed ^:mutable xf sourceIter multi]\n  Object\n  (step [this]\n    (if-not (identical? _next NONE)\n      true\n      (loop []\n        (if (identical? _next NONE)\n          (if ^boolean (.isEmpty buffer)\n            (if ^boolean completed\n              false\n              (if ^boolean (.hasNext sourceIter)\n                (let [iter (if ^boolean multi\n                             (apply xf (cons nil (.next sourceIter)))\n                             (xf nil (.next sourceIter)))]\n                  (when (reduced? iter)\n                    (xf nil)\n                    (set! completed true))\n                  (recur))\n                (do\n                  (xf nil)\n                  (set! completed true)\n                  (recur))))\n            (do\n              (set! _next (.remove buffer))\n              (recur)))\n          true))))\n  (hasNext [this]\n    (.step this))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (let [ret _next]\n        (set! _next NONE)\n        ret)\n      (throw (js/Error. \"No such element\"))))\n  (remove [_]\n    (js/Error. \"Unsupported operation\")))\n\n(es6-iterable TransformerIterator)\n\n(defn transformer-iterator\n  [xform sourceIter multi]\n  (let [iterator (TransformerIterator. EMPTY NONE false nil sourceIter multi)]\n    (set! (.-xf iterator)\n      (xform (fn\n               ([] nil)\n               ([acc] acc)\n               ([acc o]\n                (set! (.-buffer iterator) (.add (.-buffer iterator) o))\n                acc))))\n    iterator))\n\n(set! (.-create TransformerIterator)\n  (fn [xform source]\n    (transformer-iterator xform source false)))\n\n(set! (.-createMulti TransformerIterator)\n  (fn [xform sources]\n    (transformer-iterator xform (MultiIterator. (to-array sources)) true)))\n\n(defn sequence\n  \"Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments\"\n  ([coll]\n     (if (seq? coll)\n       coll\n       (or (seq coll) ())))\n  ([xform coll]\n   (or (chunkIteratorSeq\n         (.create TransformerIterator xform (iter coll)))\n       ()))\n  ([xform coll & colls]\n   (or (chunkIteratorSeq\n         (.createMulti TransformerIterator xform (map iter (cons coll colls))))\n       ())))\n\n(defn every?\n  \"Returns true if (pred x) is logical true for every x in coll, else\n  false.\"\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))\n\n(defn not-every?\n  \"Returns false if (pred x) is logical true for every x in\n  coll, else true.\"\n  [pred coll] (not (every? pred coll)))\n\n(defn some\n  \"Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)\"\n  [pred coll]\n  (when-let [s (seq coll)]\n    (or (pred (first s)) (recur pred (next s)))))\n\n(defn not-any?\n  \"Returns false if (pred x) is logical true for any x in coll,\n  else true.\"\n  [pred coll] (not (some pred coll)))\n\n(defn even?\n  \"Returns true if n is even, throws an exception if n is not an integer\"\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))\n\n(defn odd?\n  \"Returns true if n is odd, throws an exception if n is not an integer\"\n  [n] (not (even? n)))\n\n(defn complement\n  \"Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.\"\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))\n\n(defn constantly\n  \"Returns a function that takes any number of arguments and returns x.\"\n  [x] (fn [& args] x))\n\n(defn comp\n  \"Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.\"\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))\n\n(defn partial\n  \"Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.\"\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z & args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z & args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))\n\n(defn fnil\n  \"Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.\"\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))\n\n(declare volatile!)\n\n(defn map-indexed\n  \"Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.\"\n  ([f]\n    (fn [rf]\n      (let [i (volatile! -1)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n    (letfn [(mapi [idx coll]\n              (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (chunk-append b (f (+ idx i) (-nth c i))))\n                      (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                    (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n      (mapi 0 coll))))\n\n(defn keep\n  \"Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.\"\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))\n\n;; =============================================================================\n;; Atom\n\n(deftype Atom [state meta validator watches]\n  Object\n  (equiv [this other]\n    (-equiv this other))\n\n  IAtom\n\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f))\n    this)\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))\n\n(defn atom\n  \"Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.\"\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))\n\n(declare pr-str)\n\n(defn reset!\n  \"Sets the value of atom to newval without regard for the\n  current value. Returns new-value.\"\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (when-not (validate new-value)\n          (throw (js/Error. \"Validator rejected reference state\"))))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))\n\n(defn reset-vals!\n  \"Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.\"\n  {:added \"1.9\"}\n  [a new-value]\n  (let [validate (.-validator a)]\n    (when-not (nil? validate)\n      (when-not (validate new-value)\n        (throw (js/Error. \"Validator rejected reference state\"))))\n    (let [old-value (.-state a)]\n      (set! (.-state a) new-value)\n      (when-not (nil? (.-watches a))\n        (-notify-watches a old-value new-value))\n      [old-value new-value])))\n\n(defn swap!\n  \"Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.\"\n  ([a f]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a)))\n     (-swap! a f)))\n  ([a f x]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a) x))\n     (-swap! a f x)))\n  ([a f x y]\n   (if (instance? Atom a)\n     (reset! a (f (.-state a) x y))\n     (-swap! a f x y)))\n  ([a f x y & more]\n   (if (instance? Atom a)\n     (reset! a (apply f (.-state a) x y more))\n     (-swap! a f x y more))))\n\n(defn swap-vals!\n  \"Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.\"\n  {:added \"1.9\"}\n  ([a f]\n   (reset-vals! a (f (.-state a))))\n  ([a f x]\n   (reset-vals! a (f (.-state a) x)))\n  ([a f x y]\n   (reset-vals! a (f (.-state a) x y)))\n  ([a f x y & more]\n   (reset-vals! a (apply f (.-state a) x y more))))\n\n(defn compare-and-set!\n  \"Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.\"\n  [^not-native a oldval newval]\n  (if (= (-deref a) oldval)\n    (do (reset! a newval) true)\n    false))\n\n(defn set-validator!\n  \"Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.\"\n  [iref val]\n  (when (and (some? val)\n             (not (val (-deref iref))))\n    (throw (js/Error. \"Validator rejected reference state\")))\n  (set! (.-validator iref) val))\n\n(defn get-validator\n  \"Gets the validator-fn for a var/ref/agent/atom.\"\n  [iref]\n  (.-validator iref))\n\n(deftype Volatile [^:mutable state]\n  IVolatile\n  (-vreset! [_ new-state]\n    (set! state new-state))\n\n  IDeref\n  (-deref [_] state))\n\n(defn volatile!\n  \"Creates and returns a Volatile with an initial value of val.\"\n  [val]\n  (Volatile. val))\n\n(defn volatile?\n  \"Returns true if x is a volatile.\"\n  [x] (instance? Volatile x))\n\n(defn vreset!\n  \"Sets the value of volatile to newval without regard for the\n   current value. Returns newval.\"\n  [vol newval]  (-vreset! vol newval))\n\n(defn keep-indexed\n  \"Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.\"\n  ([f]\n   (fn [rf]\n     (let [ia (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! ia inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))\n\n(defn every-pred\n  \"Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.\"\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))\n\n(defn some-fn\n  \"Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.\"\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))\n\n(defn map\n  \"Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.\"\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input & inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))\n\n(defn take\n  \"Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.\"\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na\n                    nn (vswap! na dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when (pos? n)\n         (when-let [s (seq coll)]\n           (cons (first s) (take (dec n) (rest s))))))))\n\n(defn drop\n  \"Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.\"\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na]\n                (vswap! na dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (let [step (fn [n coll]\n                  (let [s (seq coll)]\n                    (if (and (pos? n) s)\n                      (recur (dec n) (rest s))\n                      s)))]\n       (lazy-seq (step n coll)))))\n\n(defn drop-last\n  \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))\n\n(defn take-last\n  \"Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))\n\n(defn drop-while\n  \"Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.\"\n  ([pred]\n     (fn [rf]\n       (let [da (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @da]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! da nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))\n\n(deftype Cycle [meta all prev ^:mutable current ^:mutable _next]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (currentval [coll]\n    (when-not ^seq current\n      (if-let [c (next prev)]\n        (set! current c)\n        (set! current all)))\n    current)\n\n  IPending\n  (-realized? [coll]\n    (some? current))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Cycle. new-meta all prev current _next)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (first (.currentval coll)))\n  (-rest [coll]\n    (when (nil? _next)\n      (set! _next (Cycle. nil all (.currentval coll) nil nil)))\n    _next)\n\n  INext\n  (-next [coll]\n    (-rest coll))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll f]\n    (loop [s (.currentval coll) ret (first s)]\n      (let [s   (or (next s) all)\n            ret (f ret (first s))]\n        (if (reduced? ret)\n          @ret\n          (recur s ret)))))\n  (-reduce [coll f start]\n    (loop [s (.currentval coll) ret start]\n      (let [ret (f ret (first s))]\n        (if (reduced? ret)\n          @ret\n          (recur (or (next s) all) ret))))))\n\n(defn cycle\n  \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n  [coll] (if-let [vals (seq coll)]\n           (Cycle. nil vals nil vals nil)\n           (.-EMPTY List)))\n\n(defn split-at\n  \"Returns a vector of [(take n coll) (drop n coll)]\"\n  [n coll]\n  [(take n coll) (drop n coll)])\n\n(deftype Repeat [meta count val ^:mutable next ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x count))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IPending\n  (-realized? [coll] false)\n  \n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Repeat. new-meta count val next nil)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    val)\n  (-rest [coll]\n    (if (nil? next)\n      (if (> count 1)\n        (do\n          (set! next (Repeat. nil (dec count) val nil nil))\n          next)\n        (if (== -1 count)\n          coll\n          ()))\n      next))\n\n  INext\n  (-next [coll]\n    (if (nil? next)\n      (if (> count 1)\n        (do\n          (set! next (Repeat. nil (dec count) val nil nil))\n          next)\n        (if (== -1 count)\n          coll\n          nil))\n      next))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n  \n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IReduce\n  (-reduce [coll f]\n    (if (== count -1)\n      (loop [ret (f val val)]\n        (if (reduced? ret)\n          @ret\n          (recur (f ret val))))\n      (loop [i 1 ret val]\n        (if (< i count)\n          (let [ret (f ret val)]\n            (if (reduced? ret)\n              @ret\n              (recur (inc i) ret)))\n          ret))))\n  (-reduce [coll f start]\n    (if (== count -1)\n      (loop [ret (f start val)]\n        (if (reduced? ret)\n          @ret\n          (recur (f ret val))))\n      (loop [i 0 ret start]\n        (if (< i count)\n          (let [ret (f ret val)]\n            (if (reduced? ret)\n              @ret\n              (recur (inc i) ret)))\n          ret)))))\n\n(defn repeat\n  \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n  ([x] (Repeat. nil -1 x nil nil))\n  ([n x] (if (pos? n)\n           (Repeat. nil n x nil nil)\n           (.-EMPTY List))))\n\n(defn replicate\n  \"DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.\"\n  [n x] (take n (repeat x)))\n\n(defn repeatedly\n  \"Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it\"\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))\n\n(def ^:private UNREALIZED-SEED #js {})\n\n(deftype Iterate [meta f prev-seed ^:mutable seed ^:mutable next]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IPending\n  (-realized? [coll]\n    (not (identical? seed UNREALIZED-SEED)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (Iterate. new-meta f prev-seed seed next)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (when (identical? UNREALIZED-SEED seed)\n      (set! seed (f prev-seed)))\n    seed)\n  (-rest [coll]\n    (when (nil? next)\n      (set! next (Iterate. nil f (-first coll) UNREALIZED-SEED nil)))\n    next)\n\n  INext\n  (-next [coll]\n    (-rest coll))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeqable\n  (-seq [coll] coll)\n\n  IReduce\n  (-reduce [coll rf]\n    (let [first (-first coll)\n          v     (f first)]\n      (loop [ret (rf first v) v v]\n        (if (reduced? ret)\n          @ret\n          (let [v (f v)]\n            (recur (rf ret v) v))))))\n  (-reduce [coll rf start]\n    (let [v (-first coll)]\n      (loop [ret (rf start v) v v]\n        (if (reduced? ret)\n          @ret\n          (let [v (f v)]\n            (recur (rf ret v) v)))))))\n\n(defn iterate\n  \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n  {:added \"1.0\"}\n  [f x] (Iterate. nil f nil x nil))\n\n(defn interleave\n  \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n  ([] ())\n  ([c1] (lazy-seq c1))\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))\n\n(defn interpose\n  \"Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.\"\n  ([sep]\n    (fn [rf]\n      (let [started (volatile! false)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if @started\n              (let [sepr (rf result sep)]\n                (if (reduced? sepr)\n                  sepr\n                  (rf sepr input)))\n              (do\n                (vreset! started true)\n                (rf result input))))))))\n  ([sep coll] (drop 1 (interleave (repeat sep) coll))))\n\n\n\n(defn- flatten1\n  \"Take a collection of collections, and return a lazy seq\n  of items from the inner collection\"\n  [colls]\n  (let [cat (fn cat [coll colls]\n              (lazy-seq\n                (if-let [coll (seq coll)]\n                  (cons (first coll) (cat (rest coll) colls))\n                  (when (seq colls)\n                    (cat (first colls) (rest colls))))))]\n    (cat nil colls)))\n\n(declare cat)\n\n(defn mapcat\n  \"Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided\"\n  {:added \"1.0\"\n   :static true}\n  ([f] (comp (map f) cat))\n  ([f & colls]\n     (apply concat (apply map f colls))))\n\n(defn filter\n  \"Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.\"\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))\n\n(defn remove\n  \"Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.\"\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))\n\n(defn tree-seq\n  \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.\"\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))\n\n(defn flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.\"\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))\n\n(defn into\n  \"Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.\"\n  ([] [])\n  ([to] to)\n  ([to from]\n     (if-not (nil? to)\n       (if (implements? IEditableCollection to)\n         (-with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))\n         (reduce -conj to from))\n       (reduce conj () from)))\n  ([to xform from]\n     (if (implements? IEditableCollection to)\n       (-with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))\n       (transduce xform conj to from))))\n\n(defn mapv\n  \"Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.\"\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))\n\n(defn filterv\n  \"Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\"\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))\n\n(defn partition\n  \"Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.\"\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))\n\n(defn get-in\n  \"Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.\"\n  {:added \"1.2\"\n   :static true}\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if-not (nil? ks)\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))\n\n(defn assoc-in\n  \"Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.\"\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))\n\n(defn update-in\n  \"'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.\"\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))\n\n(defn update\n  \"'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.\"\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))\n\n;;; PersistentVector\n\n(deftype VectorNode [edit arr])\n\n(defn- pv-fresh-node [edit]\n  (VectorNode. edit (make-array 32)))\n\n(defn- pv-aget [node idx]\n  (aget (.-arr node) idx))\n\n(defn- pv-aset [node idx val]\n  (aset (.-arr node) idx val))\n\n(defn- pv-clone-node [node]\n  (VectorNode. (.-edit node) (aclone (.-arr node))))\n\n(defn- tail-off [pv]\n  (let [cnt (.-cnt pv)]\n    (if (< cnt 32)\n      0\n      (bit-shift-left (bit-shift-right-zero-fill (dec cnt) 5) 5))))\n\n(defn- new-path [edit level node]\n  (loop [ll level\n         ret node]\n    (if (zero? ll)\n      ret\n      (let [embed ret\n            r (pv-fresh-node edit)\n            _ (pv-aset r 0 embed)]\n        (recur (- ll 5) r)))))\n\n(defn- push-tail [pv level parent tailnode]\n  (let [ret (pv-clone-node parent)\n        subidx (bit-and (bit-shift-right-zero-fill (dec (.-cnt pv)) level) 0x01f)]\n    (if (== 5 level)\n      (do\n        (pv-aset ret subidx tailnode)\n        ret)\n      (let [child (pv-aget parent subidx)]\n        (if-not (nil? child)\n          (let [node-to-insert (push-tail pv (- level 5) child tailnode)]\n            (pv-aset ret subidx node-to-insert)\n            ret)\n          (let [node-to-insert (new-path nil (- level 5) tailnode)]\n            (pv-aset ret subidx node-to-insert)\n            ret))))))\n\n(defn- vector-index-out-of-bounds [i cnt]\n  (throw (js/Error. (str \"No item \" i \" in vector of length \" cnt))))\n\n(defn- first-array-for-longvec [pv]\n  ;; invariants: (count pv) > 32.\n  (loop [node (.-root pv)\n         level (.-shift pv)]\n    (if (pos? level)\n      (recur (pv-aget node 0) (- level 5))\n      (.-arr node))))\n\n(defn- unchecked-array-for [pv i]\n  ;; invariant: i is a valid index of pv (use array-for if unknown).\n  (if (>= i (tail-off pv))\n      (.-tail pv)\n      (loop [node (.-root pv)\n             level (.-shift pv)]\n        (if (pos? level)\n          (recur (pv-aget node (bit-and (bit-shift-right-zero-fill i level) 0x01f))\n                 (- level 5))\n          (.-arr node)))))\n\n(defn- array-for [pv i]\n  (if (and (<= 0 i) (< i (.-cnt pv)))\n    (unchecked-array-for pv i)\n    (vector-index-out-of-bounds i (.-cnt pv))))\n\n(defn- do-assoc [pv level node i val]\n  (let [ret (pv-clone-node node)]\n    (if (zero? level)\n      (do\n        (pv-aset ret (bit-and i 0x01f) val)\n        ret)\n      (let [subidx (bit-and (bit-shift-right-zero-fill i level) 0x01f)]\n        (pv-aset ret subidx (do-assoc pv (- level 5) (pv-aget node subidx) i val))\n        ret))))\n\n(defn- pop-tail [pv level node]\n  (let [subidx (bit-and (bit-shift-right-zero-fill (- (.-cnt pv) 2) level) 0x01f)]\n    (cond\n     (> level 5) (let [new-child (pop-tail pv (- level 5) (pv-aget node subidx))]\n                   (if (and (nil? new-child) (zero? subidx))\n                     nil\n                     (let [ret (pv-clone-node node)]\n                       (pv-aset ret subidx new-child)\n                       ret)))\n     (zero? subidx) nil\n     :else (let [ret (pv-clone-node node)]\n             (pv-aset ret subidx nil)\n             ret))))\n\n(deftype RangedIterator [^:mutable i ^:mutable base ^:mutable arr v start end]\n  Object\n  (hasNext [this]\n    (< i end))\n  (next [this]\n    (when (== (- i base) 32)\n      (set! arr (unchecked-array-for v i))\n      (set! base (+ base 32)))\n    (let [ret (aget arr (bit-and i 0x01f))]\n      (set! i (inc i))\n      ret)))\n\n(defn ranged-iterator [v start end]\n  (let [i start]\n    (RangedIterator. i (- i (js-mod i 32))\n      (when (< start (count v))\n        (unchecked-array-for v i))\n      v start end)))\n\n(defn- pv-reduce\n  ([pv f start end]\n   (if (< start end)\n     (pv-reduce pv f (nth pv start) (inc start) end)\n     (f)))\n  ([pv f init start end]\n   (loop [acc init i start arr (unchecked-array-for pv start)]\n     (if (< i end)\n       (let [j (bit-and i 0x01f)\n             arr (if (zero? j) (unchecked-array-for pv i) arr)\n             nacc (f acc (aget arr j))]\n         (if (reduced? nacc)\n           @nacc\n           (recur nacc (inc i) arr)))\n       acc))))\n\n(declare tv-editable-root tv-editable-tail TransientVector deref\n         pr-sequential-writer pr-writer chunked-seq)\n\n(defprotocol APersistentVector\n  \"Marker protocol\")\n\n(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentVector. new-meta cnt shift root tail __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta (.-EMPTY PersistentVector) meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) (.-EMPTY-NODE PersistentVector) nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (instance? PersistentVector other)\n      (if (== cnt (count other))\n        (let [me-iter  (-iterator coll)\n              you-iter (-iterator other)]\n          (loop []\n            (if ^boolean (.hasNext me-iter)\n              (let [x (.next me-iter)\n                    y (.next you-iter)]\n                (if (= x y)\n                  (recur)\n                  false))\n              true)))\n        false)\n      (equiv-sequential coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (<= cnt 32) (IndexedSeq. tail 0 nil)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. \"Vector's key for assoc must be a number.\"))))\n  (-contains-key? [coll k]\n    (if (integer? k)\n      (and (<= 0 k) (< k cnt))\n      false))\n\n  IFind\n  (-find [coll n]\n    (when (and (<= 0 n) (< n cnt))\n      (MapEntry. n (aget (unchecked-array-for coll n) (bit-and n 0x01f)) nil)))\n\n  APersistentVector\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (<= 0 n) (< n cnt))\n       (if (<= (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (== n cnt) (-conj coll val)\n       :else (throw (js/Error. (str \"Index \" n \" out of bounds  [0,\" cnt \"]\")))))\n\n  IReduce\n  (-reduce [v f]\n    (pv-reduce v f 0 cnt))\n  (-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (+ j i) (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (when (pos? cnt)\n      (RSeq. coll (dec cnt) nil)))\n\n  IIterable\n  (-iterator [this]\n    (ranged-iterator this 0 cnt)))\n\n(set! (.-EMPTY-NODE PersistentVector) (VectorNode. nil (make-array 32)))\n\n(set! (.-EMPTY PersistentVector)\n  (PersistentVector. nil 0 5 (.-EMPTY-NODE PersistentVector) (array) empty-ordered-hash))\n\n(set! (.-fromArray PersistentVector)\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (< l 32)\n        (PersistentVector. nil l 5 (.-EMPTY-NODE PersistentVector) xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 (.-EMPTY-NODE PersistentVector) node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (< i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))\n\n(es6-iterable PersistentVector)\n\n(declare map-entry?)\n\n(defn vec\n  \"Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.\"\n  [coll]\n  (cond\n    (map-entry? coll)\n    [(key coll) (val coll)]\n\n    (vector? coll)\n    (with-meta coll nil)\n\n    (array? coll)\n    (.fromArray PersistentVector coll true)\n\n    :else\n    (-persistent!\n      (reduce -conj!\n        (-as-transient (.-EMPTY PersistentVector))\n        coll))))\n\n(defn vector\n  \"Creates a new vector containing the args.\"\n  [& args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (.fromArray PersistentVector (.-arr args) true)\n    (vec args)))\n\n(declare subvec)\n\n(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (chunked-seq vec node i off new-meta)))\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    ())\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (pv-reduce vec f (+ i off) (count vec)))\n\n  (-reduce [coll f start]\n    (pv-reduce vec f start (+ i off) (count vec))))\n\n(es6-iterable ChunkedSeq)\n\n(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))\n\n(declare build-subvec)\n\n(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (build-subvec new-meta v start end __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (== start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (<= end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (<= end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. \"Subvec's key for assoc must be a number.\"))))\n\n  IFind\n  (-find [coll n]\n    (when-not (neg? n)\n      (let [idx (+ start n)]\n        (when (< idx end)\n          (MapEntry. n (-lookup v idx) nil)))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (if (or (neg? n) (<= (inc end) v-pos))\n        (throw (js/Error. (str \"Index \" n \" out of bounds [0,\" (-count coll) \"]\")))\n        (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil))))\n\n  IReduce\n  (-reduce [coll f]\n    (if (implements? APersistentVector v)\n      (pv-reduce v f start end)\n      (ci-reduce coll f)))\n  (-reduce [coll f init]\n    (if (implements? APersistentVector v)\n      (pv-reduce v f init start end)\n      (ci-reduce coll f init)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (loop [i start j 0 init init]\n      (if (< i end)\n        (let [init (f init j (-nth v i))]\n          (if (reduced? init)\n            @init\n            (recur (inc i) (inc j) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IIterable\n  (-iterator [coll]\n    (if (implements? APersistentVector v)\n      (ranged-iterator v start end)\n      (seq-iter coll))))\n\n(es6-iterable Subvec)\n\n(defn- build-subvec [meta v start end __hash]\n  (if (instance? Subvec v)\n    (recur meta (.-v v) (+ (.-start v) start) (+ (.-start v) end) __hash)\n    (do\n      (when-not (vector? v)\n        (throw (js/Error. \"v must satisfy IVector\")))\n      (let [c (count v)]\n        (when (or (neg? start)\n                  (neg? end)\n                  (> start c)\n                  (> end c))\n          (throw (js/Error. \"Index out of bounds\"))))\n      (Subvec. meta v start end __hash))))\n\n(defn subvec\n  \"Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.\"\n  ([v start]\n   (subvec v start (count v)))\n  ([v start end]\n   (assert (and (not (nil? start)) (not (nil? end))))\n   (build-subvec nil v (int start) (int end) nil)))\n\n(defn- tv-ensure-editable [edit node]\n  (if (identical? edit (.-edit node))\n    node\n    (VectorNode. edit (aclone (.-arr node)))))\n\n(defn- tv-editable-root [node]\n  (VectorNode. (js-obj) (aclone (.-arr node))))\n\n(defn- tv-editable-tail [tl]\n  (let [ret (make-array 32)]\n    (array-copy tl 0 ret 0 (alength tl))\n    ret))\n\n(defn- tv-push-tail [tv level parent tail-node]\n  (let [ret    (tv-ensure-editable (.. tv -root -edit) parent)\n        subidx (bit-and (bit-shift-right-zero-fill (dec (.-cnt tv)) level) 0x01f)]\n    (pv-aset ret subidx\n             (if (== level 5)\n               tail-node\n               (let [child (pv-aget ret subidx)]\n                 (if-not (nil? child)\n                   (tv-push-tail tv (- level 5) child tail-node)\n                   (new-path (.. tv -root -edit) (- level 5) tail-node)))))\n    ret))\n\n(defn- tv-pop-tail [tv level node]\n  (let [node   (tv-ensure-editable (.. tv -root -edit) node)\n        subidx (bit-and (bit-shift-right-zero-fill (- (.-cnt tv) 2) level) 0x01f)]\n    (cond\n      (> level 5) (let [new-child (tv-pop-tail\n                                   tv (- level 5) (pv-aget node subidx))]\n                    (if (and (nil? new-child) (zero? subidx))\n                      nil\n                      (do (pv-aset node subidx new-child)\n                          node)))\n      (zero? subidx) nil\n      :else (do (pv-aset node subidx nil)\n                node))))\n\n(defn- unchecked-editable-array-for [tv i]\n  ;; invariant: i is a valid index of tv.\n  (if (>= i (tail-off tv))\n    (.-tail tv)\n    (let [root (.-root tv)]\n      (loop [node  root\n             level (.-shift tv)]\n        (if (pos? level)\n          (recur (tv-ensure-editable\n                   (.-edit root)\n                   (pv-aget node\n                            (bit-and (bit-shift-right-zero-fill i level)\n                                     0x01f)))\n                 (- level 5))\n          (.-arr node))))))\n\n(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. \"TransientVector's key for assoc! must be a number.\"))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))\n\n;;; PersistentQueue ;;;\n\n(deftype PersistentQueueIter [^:mutable fseq riter]\n  Object\n  (hasNext [_]\n    (or (and (some? fseq) (seq fseq)) (and (some? riter) (.hasNext riter))))\n  (next [_]\n    (cond\n      (some? fseq)\n      (let [ret (first fseq)]\n        (set! fseq (next fseq))\n        ret)\n      (and (some? riter) ^boolean (.hasNext riter))\n      (.next riter)\n      :else (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentQueueSeq. new-meta front rear __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  INext\n  (-next [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (when (some? rear)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))\n\n(es6-iterable PersistentQueueSeq)\n\n(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IIterable\n  (-iterator [coll]\n    (PersistentQueueIter. front (-iterator rear)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentQueue. new-meta count front rear __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentQueue) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))\n\n(set! (.-EMPTY PersistentQueue) (PersistentQueue. nil 0 nil [] empty-ordered-hash))\n\n(es6-iterable PersistentQueue)\n\n(deftype NeverEquiv []\n  Object\n  (equiv [this other]\n    (-equiv this other))\n  IEquiv\n  (-equiv [o other] false))\n\n(def ^:private never-equiv (NeverEquiv.))\n\n(defn equiv-map\n  \"Test map equivalence. Returns true if x equals y, otherwise returns false.\"\n  [x y]\n  (boolean\n    (when (and (map? y) (not (record? y)))\n      ; assume all maps are counted\n      (when (== (count x) (count y))\n        (if (satisfies? IKVReduce x)\n          (reduce-kv\n            (fn [_ k v]\n              (if (= (get y k never-equiv) v)\n                true\n                (reduced false)))\n            true x)\n          (every?\n            (fn [xkv]\n              (= (get y (first xkv) never-equiv) (second xkv)))\n            x))))))\n\n\n(defn- scan-array [incr k array]\n  (let [len (alength array)]\n    (loop [i 0]\n      (when (< i len)\n        (if (identical? k (aget array i))\n          i\n          (recur (+ i incr)))))))\n\n; The keys field is an array of all keys of this map, in no particular\n; order. Any string, keyword, or symbol key is used as a property name\n; to store the value in strobj.  If a key is assoc'ed when that same\n; key already exists in strobj, the old value is overwritten. If a\n; non-string key is assoc'ed, return a HashMap object instead.\n\n(defn- obj-map-compare-keys [a b]\n  (let [a (hash a)\n        b (hash b)]\n    (cond\n     (< a b) -1\n     (> a b) 1\n     :else 0)))\n\n(defn- obj-map->hash-map [m k v]\n  (let [ks  (.-keys m)\n        len (alength ks)\n        so  (.-strobj m)\n        mm  (meta m)]\n    (loop [i   0\n           out (transient (.-EMPTY PersistentHashMap))]\n      (if (< i len)\n        (let [k (aget ks i)]\n          (recur (inc i) (assoc! out k (gobject/get so k))))\n        (-with-meta (persistent! (assoc! out k v)) mm)))))\n\n;;; ObjMap - DEPRECATED\n\n(defn- obj-clone [obj ks]\n  (let [new-obj (js-obj)\n        l (alength ks)]\n    (loop [i 0]\n      (when (< i l)\n        (let [k (aget ks i)]\n          (gobject/set new-obj k (gobject/get obj k))\n          (recur (inc i)))))\n    new-obj))\n\n(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ObjMap. new-meta keys strobj update-count __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY ObjMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (unchecked-get strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (unchecked-get strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (> update-count (.-HASHMAP_THRESHOLD ObjMap))\n                (>= (alength keys) (.-HASHMAP_THRESHOLD ObjMap)))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (gobject/set new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (gobject/set new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IFind\n  (-find [coll k]\n    (when (and ^boolean (goog/isString k)\n            (not (nil? (scan-array 1 k keys))))\n      (MapEntry. k (unchecked-get strobj k) nil)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (unchecked-get strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))\n\n(set! (.-EMPTY ObjMap) (ObjMap. nil (array) (js-obj) 0 empty-unordered-hash))\n\n(set! (.-HASHMAP_THRESHOLD ObjMap) 8)\n\n(set! (.-fromObject ObjMap) (fn [ks obj] (ObjMap. nil ks obj 0 nil)))\n\n;; Record Iterator\n(deftype RecordIter [^:mutable i record base-count fields ext-map-iter]\n  Object\n  (hasNext [_]\n    (or (< i base-count) (.hasNext ext-map-iter)))\n  (next [_]\n    (if (< i base-count)\n      (let [k (nth fields i)]\n        (set! i (inc i))\n        (MapEntry. k (-lookup record k) nil))\n      (.next ext-map-iter)))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n;; EXPERIMENTAL: subject to change\n(deftype ES6EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))\n\n(defn es6-entries-iterator [coll]\n  (ES6EntriesIterator. (seq coll)))\n\n;; EXPERIMENTAL: subject to change\n(deftype ES6SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))\n\n(defn es6-set-entries-iterator [coll]\n  (ES6SetEntriesIterator. (seq coll)))\n\n;;; PersistentArrayMap\n\n(defn- array-index-of-nil? [arr]\n  (let [len (alength arr)]\n    (loop [i 0]\n      (cond\n        (<= len i) -1\n        (nil? (aget arr i)) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-keyword? [arr k]\n  (let [len  (alength arr)\n        kstr (.-fqn k)]\n    (loop [i 0]\n      (cond\n        (<= len i) -1\n        (and (keyword? (aget arr i))\n             (identical? kstr (.-fqn (aget arr i)))) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-symbol? [arr k]\n  (let [len  (alength arr)\n        kstr (.-str k)]\n    (loop [i 0]\n      (cond\n        (<= len i) -1\n        (and (symbol? (aget arr i))\n             (identical? kstr (.-str (aget arr i)))) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-identical? [arr k]\n  (let [len (alength arr)]\n    (loop [i 0]\n      (cond\n        (<= len i) -1\n        (identical? k (aget arr i)) i\n        :else (recur (+ i 2))))))\n\n(defn- array-index-of-equiv? [arr k]\n  (let [len (alength arr)]\n    (loop [i 0]\n      (cond\n        (<= len i) -1\n        (= k (aget arr i)) i\n        :else (recur (+ i 2))))))\n\n(defn array-index-of [arr k]\n  (cond\n    (keyword? k) (array-index-of-keyword? arr k)\n\n    (or ^boolean (goog/isString k) (number? k))\n    (array-index-of-identical? arr k)\n\n    (symbol? k) (array-index-of-symbol? arr k)\n\n    (nil? k)\n    (array-index-of-nil? arr)\n\n    :else (array-index-of-equiv? arr k)))\n\n(defn- array-map-index-of [m k]\n  (array-index-of (.-arr m) k))\n\n(defn- array-extend-kv [arr k v]\n  (let [l (alength arr)\n        narr (make-array (+ l 2))]\n    (loop [i 0]\n      (when (< i l)\n        (aset narr i (aget arr i))\n        (recur (inc i))))\n    (aset narr l k)\n    (aset narr (inc l) v)\n    narr))\n\n(defn- array-map-extend-kv [m k v]\n  (array-extend-kv (.-arr m) k v))\n\n(declare TransientArrayMap)\n\n(deftype MapEntry [key val ^:mutable __hash]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    (throw (js/Error. \"Index out of bounds\"))))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (== k 0) (== k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))\n\n(defn map-entry?\n  \"Returns true if x satisfies IMapEntry\"\n  [x]\n  (implements? IMapEntry x))\n\n(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (PersistentArrayMapSeq. arr i new-meta)))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (MapEntry. (aget arr i) (aget arr (inc i)) nil))\n\n  (-rest [coll]\n    (if (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) nil)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) nil)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable PersistentArrayMapSeq)\n\n(defn persistent-array-map-seq [arr i _meta]\n  (when (<= i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))\n\n(declare keys vals)\n\n(deftype PersistentArrayMapIterator [arr ^:mutable i cnt]\n  Object\n  (hasNext [_]\n    (< i cnt))\n  (next [_]\n    (let [ret (MapEntry. (aget arr i) (aget arr (inc i)) nil)]\n      (set! i (+ i 2))\n      ret)))\n\n(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentArrayMap. new-meta cnt arr __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentArrayMap) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (if (and (map? other) (not (record? other)))\n      (let [alen (alength arr)\n            ^not-native other other]\n        (if (== cnt (-count other))\n          (loop [i 0]\n            (if (< i alen)\n              (let [v (-lookup other (aget arr i) lookup-sentinel)]\n                (if-not (identical? v lookup-sentinel)\n                  (if (= (aget arr (inc i)) v)\n                    (recur (+ i 2))\n                    false)\n                  false))\n              true))\n          false))\n      false))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  IIterable\n  (-iterator [this]\n    (PersistentArrayMapIterator. arr 0 (* cnt 2)))\n\n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt (.-HASHMAP-THRESHOLD PersistentArrayMap))\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into (.-EMPTY PersistentHashMap) coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IFind\n  (-find [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (when-not (== idx -1)\n        (MapEntry. (aget arr idx) (aget arr (inc idx)) nil))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n  \n  IReduce\n  (-reduce [coll f]\n    (iter-reduce coll f))\n  (-reduce [coll f start]\n    (iter-reduce coll f start))\n  \n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))\n\n(set! (.-EMPTY PersistentArrayMap) (PersistentArrayMap. nil 0 (array) empty-unordered-hash))\n\n(set! (.-HASHMAP-THRESHOLD PersistentArrayMap) 8)\n\n(set! (.-fromArray PersistentArrayMap)\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (as-> (if no-clone arr (aclone arr)) arr\n      (if no-check\n        arr\n        (let [ret (array)]\n          (loop [i 0]\n            (when (< i (alength arr))\n              (let [k (aget arr i)\n                    v (aget arr (inc i))\n                    idx (array-index-of ret k)]\n                (when (== idx -1)\n                  (.push ret k)\n                  (.push ret v)))\n              (recur (+ i 2))))\n          ret))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))\n\n(set! (.-createWithCheck PersistentArrayMap)\n  (fn [arr]\n    (let [ret (array)]\n      (loop [i 0]\n        (when (< i (alength arr))\n          (let [k (aget arr i)\n                v (aget arr (inc i))\n                idx (array-index-of ret k)]\n            (if (== idx -1)\n              (doto ret (.push k) (.push v))\n              (throw (js/Error. (str \"Duplicate key: \" k)))))\n          (recur (+ i 2))))\n      (let [cnt (/ (alength arr) 2)]\n        (PersistentArrayMap. nil cnt arr nil)))))\n\n(set! (.-createAsIfByAssoc PersistentArrayMap)\n  (fn [arr]\n    (let [ret (array)]\n      (loop [i 0]\n        (when (< i (alength arr))\n          (let [k (aget arr i)\n                v (aget arr (inc i))\n                idx (array-index-of ret k)]\n            (if (== idx -1)\n              (doto ret (.push k) (.push v))\n              (aset ret (inc idx) v)))\n          (recur (+ i 2))))\n      (PersistentArrayMap. nil (/ (alength ret) 2) ret nil))))\n\n(es6-iterable PersistentArrayMap)\n\n(declare array->transient-hash-map)\n\n(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (cond\n        (map-entry? o)\n        (-assoc! tcoll (key o) (val o))\n\n        (vector? o)\n        (-assoc! tcoll (o 0) (o 1))\n\n        :else\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n  \n  IFn\n  (-invoke [tcoll key]\n    (-lookup tcoll key nil))\n  (-invoke [tcoll key not-found]\n    (-lookup tcoll key not-found)))\n\n(declare TransientHashMap)\n\n(defn- array->transient-hash-map [len arr]\n  (loop [out (transient (.-EMPTY PersistentHashMap))\n         i   0]\n    (if (< i len)\n      (recur (assoc! out (aget arr i) (aget arr (inc i))) (+ i 2))\n      out)))\n\n;;; PersistentHashMap\n\n(deftype Box [^:mutable val])\n\n(declare create-inode-seq create-array-node-seq reset! create-node atom deref)\n\n(defn key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (= key other)))\n\n(defn- mask [hash shift]\n  (bit-and (bit-shift-right-zero-fill hash shift) 0x01f))\n\n(defn- clone-and-set\n  ([arr i a]\n     (doto (aclone arr)\n       (aset i a)))\n  ([arr i a j b]\n     (doto (aclone arr)\n       (aset i a)\n       (aset j b))))\n\n(defn- remove-pair [arr i]\n  (let [new-arr (make-array (- (alength arr) 2))]\n    (array-copy arr 0 new-arr 0 (* 2 i))\n    (array-copy arr (* 2 (inc i)) new-arr (* 2 i) (- (alength new-arr) (* 2 i)))\n    new-arr))\n\n(defn- bitmap-indexed-node-index [bitmap bit]\n  (bit-count (bit-and bitmap (dec bit))))\n\n(defn- bitpos [hash shift]\n  (bit-shift-left 1 (mask hash shift)))\n\n(defn- edit-and-set\n  ([inode edit i a]\n     (let [editable (.ensure-editable inode edit)]\n       (aset (.-arr editable) i a)\n       editable))\n  ([inode edit i a j b]\n     (let [editable (.ensure-editable inode edit)]\n       (aset (.-arr editable) i a)\n       (aset (.-arr editable) j b)\n       editable)))\n\n(defn- inode-kv-reduce [arr f init]\n  (let [len (alength arr)]\n    (loop [i 0 init init]\n      (if (< i len)\n        (let [init (let [k (aget arr i)]\n                     (if-not (nil? k)\n                       (f init k (aget arr (inc i)))\n                       (let [node (aget arr (inc i))]\n                         (if-not (nil? node)\n                           (.kv-reduce node f init)\n                           init))))]\n          (if (reduced? init)\n            init\n            (recur (+ i 2) init)))\n        init))))\n\n(declare ArrayNode)\n\n (deftype NodeIterator [arr ^:mutable i ^:mutable next-entry ^:mutable next-iter]\n  Object\n  (advance [this]\n    (let [len (alength arr)]\n      (loop []\n        (if (< i len)\n          (let [key (aget arr i)\n                node-or-val (aget arr (inc i))\n                ^boolean found\n                (cond (some? key)\n                      (set! next-entry (MapEntry. key node-or-val nil))\n                      (some? node-or-val)\n                      (let [new-iter (-iterator node-or-val)]\n                        (if ^boolean (.hasNext new-iter)\n                          (set! next-iter new-iter)\n                          false))\n                      :else false)]\n            (set! i (+ i 2))\n            (if found true (recur)))\n          false))))\n  (hasNext [this]\n    (or (some? next-entry) (some? next-iter) (.advance this)))\n  (next [this]\n    (cond\n      (some? next-entry)\n      (let [ret next-entry]\n        (set! next-entry nil)\n        ret)\n      (some? next-iter)\n      (let [ret (.next next-iter)]\n        (when-not ^boolean (.hasNext next-iter)\n          (set! next-iter nil))\n        ret)\n      ^boolean (.advance this)\n      (.next this)\n      :else (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc (.-EMPTY BitmapIndexedNode)\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          (MapEntry. key-or-nil val-or-node nil)\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! (.-EMPTY BitmapIndexedNode)\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (set! (.-val removed-leaf?) true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))\n\n(set! (.-EMPTY BitmapIndexedNode) (BitmapIndexedNode. nil 0 (make-array 0)))\n\n(defn- pack-array-node [array-node edit idx]\n  (let [arr     (.-arr array-node)\n        len     (alength arr)\n        new-arr (make-array (* 2 (dec (.-cnt array-node))))]\n    (loop [i 0 j 1 bitmap 0]\n      (if (< i len)\n        (if (and (not (== i idx))\n                 (not (nil? (aget arr i))))\n          (do (aset new-arr j (aget arr i))\n              (recur (inc i) (+ j 2) (bit-or bitmap (bit-shift-left 1 i))))\n          (recur (inc i) j bitmap))\n        (BitmapIndexedNode. edit bitmap new-arr)))))\n\n(deftype ArrayNodeIterator [arr ^:mutable i ^:mutable next-iter]\n  Object\n  (hasNext [this]\n    (let [len (alength arr)]\n      (loop []\n        (if-not (and  (some? next-iter) ^boolean (.hasNext next-iter))\n          (if (< i len)\n            (let [node (aget arr i)]\n              (set! i (inc i))\n              (when (some? node)\n                (set! next-iter (-iterator node)))\n              (recur))\n            false)\n          true))))\n  (next [this]\n    (if ^boolean (.hasNext this)\n      (.next next-iter)\n      (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init))))\n\n IIterable\n (-iterator [coll]\n    (ArrayNodeIterator. arr 0 nil)))\n\n(defn- hash-collision-node-find-index [arr cnt key]\n  (let [lim (* 2 cnt)]\n    (loop [i 0]\n      (if (< i lim)\n        (if (key-test key (aget arr i))\n          i\n          (recur (+ i 2)))\n        -1))))\n\n(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr (inc idx)) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (MapEntry. (aget arr idx) (aget arr (inc idx)) nil)\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (set! (.-val removed-leaf?) true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init))\n\n  IIterable\n  (-iterator [coll]\n    (NodeIterator. arr 0 nil nil)))\n\n(defn- create-node\n  ([shift key1 val1 key2hash key2 val2]\n     (let [key1hash (hash key1)]\n       (if (== key1hash key2hash)\n         (HashCollisionNode. nil key1hash 2 (array key1 val1 key2 val2))\n         (let [added-leaf? (Box. false)]\n           (-> (.-EMPTY BitmapIndexedNode)\n               (.inode-assoc shift key1hash key1 val1 added-leaf?)\n               (.inode-assoc shift key2hash key2 val2 added-leaf?))))))\n  ([edit shift key1 val1 key2hash key2 val2]\n     (let [key1hash (hash key1)]\n       (if (== key1hash key2hash)\n         (HashCollisionNode. nil key1hash 2 (array key1 val1 key2 val2))\n         (let [added-leaf? (Box. false)]\n           (-> (.-EMPTY BitmapIndexedNode)\n               (.inode-assoc! edit shift key1hash key1 val1 added-leaf?)\n               (.inode-assoc! edit shift key2hash key2 val2 added-leaf?)))))))\n\n(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (NodeSeq. new-meta nodes i s __hash)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      (MapEntry. (aget nodes i) (aget nodes (inc i)) nil)\n      (first s)))\n\n  (-rest [coll]\n    (let [ret (if (nil? s)\n                (create-inode-seq nodes (+ i 2) nil)\n                (create-inode-seq nodes i (next s)))]\n      (if-not (nil? ret) ret ())))\n\n  INext\n  (-next [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable NodeSeq)\n\n(defn- create-inode-seq\n  ([nodes]\n     (create-inode-seq nodes 0 nil))\n  ([nodes i s]\n     (if (nil? s)\n       (let [len (alength nodes)]\n         (loop [j i]\n           (if (< j len)\n             (if-not (nil? (aget nodes j))\n               (NodeSeq. nil nodes j nil nil)\n               (if-let [node (aget nodes (inc j))]\n                 (if-let [node-seq (.inode-seq node)]\n                   (NodeSeq. nil nodes (+ j 2) node-seq nil)\n                   (recur (+ j 2)))\n                 (recur (+ j 2)))))))\n       (NodeSeq. nil nodes i s nil))))\n\n(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (ArrayNodeSeq. new-meta nodes i s __hash)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll]\n    (let [ret (create-array-node-seq nodes i (next s))]\n      (if-not (nil? ret) ret ())))\n\n  INext\n  (-next [coll]\n    (create-array-node-seq nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable ArrayNodeSeq)\n\n(defn- create-array-node-seq\n  ([nodes] (create-array-node-seq nodes 0 nil))\n  ([nodes i s]\n     (if (nil? s)\n       (let [len (alength nodes)]\n         (loop [j i]\n           (if (< j len)\n             (if-let [nj (aget nodes j)]\n               (if-let [ns (.inode-seq nj)]\n                 (ArrayNodeSeq. nil nodes (inc j) ns nil)\n                 (recur (inc j)))\n               (recur (inc j))))))\n       (ArrayNodeSeq. nil nodes i s nil))))\n\n(deftype HashMapIter [nil-val root-iter ^:mutable seen]\n  Object\n  (hasNext [_]\n    (or (not ^boolean seen) ^boolean (.hasNext root-iter)))\n  (next [_]\n    (if-not ^boolean seen\n      (do\n        (set! seen true)\n        (MapEntry. nil nil-val nil))\n      (.next root-iter)))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IIterable\n  (-iterator [coll]\n    (let [root-iter (if ^boolean root (-iterator root) (nil-iter))]\n      (if has-nil?\n        (HashMapIter. nil-val root-iter false)\n        root-iter)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentHashMap. new-meta cnt root has-nil? nil-val __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons (MapEntry. nil nil-val nil) s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              (.-EMPTY BitmapIndexedNode)\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IFind\n  (-find [coll k]\n    (cond\n      (nil? k) (when has-nil? (MapEntry. nil nil-val nil))\n      (nil? root) nil\n      :else (.inode-find root 0 (hash k) k nil)))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (unreduced (.kv-reduce root f init))\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))\n\n(set! (.-EMPTY PersistentHashMap) (PersistentHashMap. nil 0 nil false nil empty-unordered-hash))\n\n(set! (.-fromArray PersistentHashMap)\n  (fn [arr ^boolean no-clone]\n    (let [arr (if no-clone arr (aclone arr))\n          len (alength arr)]\n      (loop [i 0 ret (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (+ i 2)\n            (-assoc! ret (aget arr i) (aget arr (inc i))))\n          (-persistent! ret))))))\n\n(set! (.-fromArrays PersistentHashMap)\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (inc i) (-assoc! out (aget ks i) (aget vs i)))\n          (persistent! out))))))\n\n(set! (.-createWithCheck PersistentHashMap)\n  (fn [arr]\n    (let [len (alength arr)\n          ret (transient (.-EMPTY PersistentHashMap))]\n      (loop [i 0]\n        (when (< i len)\n          (-assoc! ret (aget arr i) (aget arr (inc i)))\n          (if (not= (-count ret) (inc (/ i 2)))\n            (throw (js/Error. (str \"Duplicate key: \" (aget arr i))))\n            (recur (+ i 2)))))\n      (-persistent! ret))))\n\n(es6-iterable PersistentHashMap)\n\n(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (cond\n        (map-entry? o)\n        (.assoc! tcoll (key o) (val o))\n\n        (vector? o)\n        (.assoc! tcoll (o 0) (o 1))\n\n        :else\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                (.-EMPTY BitmapIndexedNode)\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if ^boolean (.-val removed-leaf?)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key))\n\n  IFn\n  (-invoke [tcoll key]\n    (-lookup tcoll key))\n  (-invoke [tcoll key not-found]\n    (-lookup tcoll key not-found)))\n\n;;; PersistentTreeMap\n\n(defn- tree-map-seq-push [node stack ^boolean ascending?]\n  (loop [t node stack stack]\n    (if-not (nil? t)\n      (recur (if ascending? (.-left t) (.-right t))\n             (conj stack t))\n      stack)))\n\n(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n  INext\n  (-next [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (when-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil))))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeMapSeq. new-meta stack ascending? cnt __hash)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable PersistentTreeMapSeq)\n\n(defn- create-tree-map-seq [tree ascending? cnt]\n  (PersistentTreeMapSeq. nil (tree-map-seq-push tree nil ascending?) ascending? cnt nil))\n\n(declare RedNode BlackNode)\n\n(defn- balance-left [key val ins right]\n  (if (instance? RedNode ins)\n    (cond\n      (instance? RedNode (.-left ins))\n      (RedNode. (.-key ins) (.-val ins)\n              (.blacken (.-left ins))\n              (BlackNode. key val (.-right ins) right nil)\n              nil)\n\n      (instance? RedNode (.-right ins))\n      (RedNode. (.. ins -right -key) (.. ins -right -val)\n                (BlackNode. (.-key ins) (.-val ins)\n                            (.-left ins)\n                            (.. ins -right -left)\n                            nil)\n                (BlackNode. key val\n                            (.. ins -right -right)\n                            right\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. key val ins right nil))\n    (BlackNode. key val ins right nil)))\n\n(defn- balance-right [key val left ins]\n  (if (instance? RedNode ins)\n    (cond\n      (instance? RedNode (.-right ins))\n      (RedNode. (.-key ins) (.-val ins)\n                (BlackNode. key val left (.-left ins) nil)\n                (.blacken (.-right ins))\n                nil)\n\n      (instance? RedNode (.-left ins))\n      (RedNode. (.. ins -left -key) (.. ins -left -val)\n                (BlackNode. key val left (.. ins -left -left) nil)\n                (BlackNode. (.-key ins) (.-val ins)\n                            (.. ins -left -right)\n                            (.-right ins)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. key val left ins nil))\n    (BlackNode. key val left ins nil)))\n\n(defn- balance-left-del [key val del right]\n  (cond\n    (instance? RedNode del)\n    (RedNode. key val (.blacken del) right nil)\n\n    (instance? BlackNode right)\n    (balance-right key val del (.redden right))\n\n    (and (instance? RedNode right) (instance? BlackNode (.-left right)))\n    (RedNode. (.. right -left -key) (.. right -left -val)\n              (BlackNode. key val del (.. right -left -left) nil)\n              (balance-right (.-key right) (.-val right)\n                             (.. right -left -right)\n                             (.redden (.-right right)))\n              nil)\n\n    :else\n    (throw (js/Error. \"red-black tree invariant violation\"))))\n\n(defn- balance-right-del [key val left del]\n  (cond\n    (instance? RedNode del)\n    (RedNode. key val left (.blacken del) nil)\n\n    (instance? BlackNode left)\n    (balance-left key val (.redden left) del)\n\n    (and (instance? RedNode left) (instance? BlackNode (.-right left)))\n    (RedNode. (.. left -right -key) (.. left -right -val)\n              (balance-left (.-key left) (.-val left)\n                            (.redden (.-left left))\n                            (.. left -right -left))\n              (BlackNode. key val (.. left -right -right) del nil)\n              nil)\n\n    :else\n    (throw (js/Error. \"red-black tree invariant violation\"))))\n\n(defn- tree-map-kv-reduce [node f init]\n  (let [init (if-not (nil? (.-left node))\n               (tree-map-kv-reduce (.-left node) f init)\n               init)]\n    (if (reduced? init)\n      init\n      (let [init (f init (.-key node) (.-val node))]\n        (if (reduced? init)\n          init\n          (if-not (nil? (.-right node))\n            (tree-map-kv-reduce (.-right node) f init)\n            init))))))\n\n(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (-with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    (throw (js/Error. \"Index out of bounds\"))))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (== k 0) (== k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))\n\n(es6-iterable BlackNode)\n\n(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (-with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] nil)\n\n  ISequential\n  ISeqable\n  (-seq [node] (IndexedSeq. #js [key val] 0 nil))\n\n  IReversible\n  (-rseq [node] (IndexedSeq. #js [val key] 0 nil))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    (throw (js/Error. \"Index out of bounds\"))))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n  (-contains-key? [node k]\n    (or (== k 0) (== k 1)))\n\n  IFind\n  (-find [node k]\n    (case k\n      0 (MapEntry. 0 key nil)\n      1 (MapEntry. 1 val nil)\n      nil))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-nth node k))\n\n  (-invoke [node k not-found]\n    (-nth node k not-found)))\n\n(es6-iterable RedNode)\n\n(defn- tree-map-add [comp tree k v found]\n  (if (nil? tree)\n    (RedNode. k v nil nil nil)\n    (let [c (comp k (.-key tree))]\n      (cond\n        (zero? c)\n        (do (aset found 0 tree)\n            nil)\n\n        (neg? c)\n        (let [ins (tree-map-add comp (.-left tree) k v found)]\n          (if-not (nil? ins)\n            (.add-left tree ins)))\n\n        :else\n        (let [ins (tree-map-add comp (.-right tree) k v found)]\n          (if-not (nil? ins)\n            (.add-right tree ins)))))))\n\n(defn- tree-map-append [left right]\n  (cond\n    (nil? left)\n    right\n\n    (nil? right)\n    left\n\n    (instance? RedNode left)\n    (if (instance? RedNode right)\n      (let [app (tree-map-append (.-right left) (.-left right))]\n        (if (instance? RedNode app)\n          (RedNode. (.-key app) (.-val app)\n                    (RedNode. (.-key left) (.-val left)\n                              (.-left left)\n                              (.-left app)\n                              nil)\n                    (RedNode. (.-key right) (.-val right)\n                              (.-right app)\n                              (.-right right)\n                              nil)\n                    nil)\n          (RedNode. (.-key left) (.-val left)\n                    (.-left left)\n                    (RedNode. (.-key right) (.-val right) app (.-right right) nil)\n                    nil)))\n      (RedNode. (.-key left) (.-val left)\n                (.-left left)\n                (tree-map-append (.-right left) right)\n                nil))\n\n    (instance? RedNode right)\n    (RedNode. (.-key right) (.-val right)\n              (tree-map-append left (.-left right))\n              (.-right right)\n              nil)\n\n    :else\n    (let [app (tree-map-append (.-right left) (.-left right))]\n      (if (instance? RedNode app)\n        (RedNode. (.-key app) (.-val app)\n                  (BlackNode. (.-key left) (.-val left)\n                              (.-left left)\n                              (.-left app)\n                              nil)\n                  (BlackNode. (.-key right) (.-val right)\n                              (.-right app)\n                              (.-right right)\n                              nil)\n                  nil)\n        (balance-left-del (.-key left) (.-val left)\n                          (.-left left)\n                          (BlackNode. (.-key right) (.-val right)\n                                      app\n                                      (.-right right)\n                                      nil))))))\n\n(defn- tree-map-remove [comp tree k found]\n  (if-not (nil? tree)\n    (let [c (comp k (.-key tree))]\n      (cond\n        (zero? c)\n        (do (aset found 0 tree)\n            (tree-map-append (.-left tree) (.-right tree)))\n\n        (neg? c)\n        (let [del (tree-map-remove comp (.-left tree) k found)]\n          (if (or (not (nil? del)) (not (nil? (aget found 0))))\n            (if (instance? BlackNode (.-left tree))\n              (balance-left-del (.-key tree) (.-val tree) del (.-right tree))\n              (RedNode. (.-key tree) (.-val tree) del (.-right tree) nil))))\n\n        :else\n        (let [del (tree-map-remove comp (.-right tree) k found)]\n          (if (or (not (nil? del)) (not (nil? (aget found 0))))\n            (if (instance? BlackNode (.-right tree))\n              (balance-right-del (.-key tree) (.-val tree) (.-left tree) del)\n              (RedNode. (.-key tree) (.-val tree) (.-left tree) del nil))))))))\n\n(defn- tree-map-replace [comp tree k v]\n  (let [tk (.-key tree)\n        c  (comp k tk)]\n    (cond (zero? c) (.replace tree tk v (.-left tree) (.-right tree))\n          (neg? c)  (.replace tree tk (.-val tree) (tree-map-replace comp (.-left tree) k v) (.-right tree))\n          :else     (.replace tree tk (.-val tree) (.-left tree) (tree-map-replace comp (.-right tree) k v)))))\n\n(declare key)\n\n(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k not-found]\n    (-lookup coll k not-found))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeMap. comp tree cnt new-meta __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeMap. comp nil 0 meta 0))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (unreduced (tree-map-kv-reduce tree f init))\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IFind\n  (-find [coll k]\n    (.entry-at coll k))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))\n\n(set! (.-EMPTY PersistentTreeMap) (PersistentTreeMap. compare nil 0 nil empty-unordered-hash))\n\n(es6-iterable PersistentTreeMap)\n\n(defn hash-map\n  \"keyval => key val\n  Returns a new hash map with supplied mappings.\"\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient (.-EMPTY PersistentHashMap))]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))\n\n(defn array-map\n  \"keyval => key val\n  Returns a new array map with supplied mappings.\"\n  [& keyvals]\n  (let [arr (if (and (instance? IndexedSeq keyvals) (zero? (.-i keyvals)))\n              (.-arr keyvals)\n              (into-array keyvals))]\n    (.createAsIfByAssoc PersistentArrayMap arr)))\n\n(defn obj-map\n  \"keyval => key val\n  Returns a new object map with supplied mappings.\"\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (gobject/set obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (.fromObject ObjMap ks obj)))))\n\n(defn sorted-map\n  \"keyval => key val\n  Returns a new sorted map with supplied mappings.\"\n  ([& keyvals]\n     (loop [in (seq keyvals) out (.-EMPTY PersistentTreeMap)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))\n\n(defn sorted-map-by\n  \"keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.\"\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))\n\n(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (KeySeq. mseq new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq nil)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq nil))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable KeySeq)\n\n(defn keys\n  \"Returns a sequence of the map's keys, in the same order as (seq map).\"\n  [map]\n  (when-let [mseq (seq map)]\n    (KeySeq. mseq nil)))\n\n(defn key\n  \"Returns the key of the map entry.\"\n  [map-entry]\n  (-key map-entry))\n\n(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta _meta)\n      coll\n      (ValSeq. mseq new-meta)))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq nil)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq nil))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))\n\n(es6-iterable ValSeq)\n\n(defn vals\n  \"Returns a sequence of the map's values, in the same order as (seq map).\"\n  [map]\n  (when-let [mseq (seq map)]\n    (ValSeq. mseq nil)))\n\n(defn val\n  \"Returns the value in the map entry.\"\n  [map-entry]\n  (-val map-entry))\n\n(defn merge\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.\"\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))\n\n(defn merge-with\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).\"\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))\n\n(defn select-keys\n  \"Returns a map containing only those entries in map whose key is in keys\"\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        (-with-meta ret (meta map)))))\n\n;;; PersistentHashSet\n\n(declare TransientHashSet)\n\n(deftype HashSetIter [iter]\n  Object\n  (hasNext [_]\n    (.hasNext iter))\n  (next [_]\n    (if ^boolean (.hasNext iter)\n      (.-key (.next iter))\n      (throw (js/Error. \"No such element\"))))\n  (remove [_] (js/Error. \"Unsupported operation\")))\n\n(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IIterable\n  (-iterator [coll]\n    (HashSetIter. (-iterator hash-map)))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentHashSet. new-meta hash-map __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashSet) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     ^boolean\n     (try\n       (reduce-kv\n         #(or (contains? other %2) (reduced false))\n         true hash-map)\n       (catch js/Error ex\n         false))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if-let [entry (-find hash-map v)]\n      (key entry)\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))\n\n(set! (.-EMPTY PersistentHashSet)\n  (PersistentHashSet. nil (.-EMPTY PersistentArrayMap) empty-unordered-hash))\n\n(set! (.-fromArray PersistentHashSet)\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (<= len (.-HASHMAP-THRESHOLD PersistentArrayMap))\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient (.-EMPTY PersistentHashSet))]\n         (if (< i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))\n\n(set! (.-createWithCheck PersistentHashSet)\n      (fn [items]\n        (let [len (alength items)\n              t (-as-transient (.-EMPTY PersistentHashSet))]\n          (dotimes [i len]\n            (-conj! t (aget items i))\n            (when-not (= (count t) (inc i))\n              (throw (js/Error. (str \"Duplicate key: \" (aget items i))))))\n          (-persistent! t))))\n\n(set! (.-createAsIfByAssoc PersistentHashSet)\n      (fn [items]\n        (let [len (alength items)\n              t (-as-transient (.-EMPTY PersistentHashSet))]\n          (dotimes [i len] (-conj! t (aget items i)))\n          (-persistent! t))))\n\n(es6-iterable PersistentHashSet)\n\n(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))\n\n(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (if (identical? new-meta meta)\n      coll\n      (PersistentTreeSet. new-meta tree-map __hash)))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeSet. meta (-empty tree-map) 0))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     ^boolean\n     (try\n       (reduce-kv\n         #(or (contains? other %2) (reduced false))\n         true tree-map)\n       (catch js/Error ex\n         false))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))\n\n(set! (.-EMPTY PersistentTreeSet)\n  (PersistentTreeSet. nil (.-EMPTY PersistentTreeMap) empty-unordered-hash))\n\n(es6-iterable PersistentTreeSet)\n\n(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))\n\n(defn set\n  \"Returns a set of the distinct elements of coll.\"\n  [coll]\n  (if (set? coll)\n    (with-meta coll nil)\n    (let [in (seq coll)]\n      (cond\n        (nil? in) #{}\n\n        (and (instance? IndexedSeq in) (zero? (.-i in)))\n        (.createAsIfByAssoc PersistentHashSet (.-arr in))\n\n        :else\n        (loop [^not-native in  in\n               ^not-native out (-as-transient #{})]\n          (if-not (nil? in)\n            (recur (next in) (-conj! out (-first in)))\n            (persistent! out)))))))\n\n(defn hash-set\n  \"Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.\"\n  ([] #{})\n  ([& keys] (set keys)))\n\n(defn sorted-set\n  \"Returns a new sorted set with supplied keys.\"\n  ([& keys]\n   (reduce -conj (.-EMPTY PersistentTreeSet) keys)))\n\n(defn sorted-set-by\n  \"Returns a new sorted set with supplied keys, using the supplied comparator.\"\n  ([comparator & keys]\n   (reduce -conj\n           (PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))\n\n(defn replace\n  \"Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.\"\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (let [n (count coll)]\n         (reduce (fn [v i]\n                   (if-let [e (find smap (nth v i))]\n                     (assoc v i (second e))\n                     v))\n           coll (take n (iterate inc 0))))\n       (map #(if-let [e (find smap %)] (second e) %) coll))))\n\n(defn distinct\n  \"Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.\"\n  ([]\n    (fn [rf]\n      (let [seen (volatile! #{})]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if (contains? @seen input)\n              result\n              (do (vswap! seen conj input)\n                  (rf result input))))))))\n  ([coll]\n    (let [step (fn step [xs seen]\n                 (lazy-seq\n                   ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f)\n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{}))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn butlast\n  \"Return a seq of all but the last item in coll, in linear time\"\n  [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))\n\n(defn name\n  \"Returns the name String of a string, symbol or keyword.\"\n  [x]\n  (if (implements? INamed x)\n    (-name x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str \"Doesn't support name: \" x))))))\n\n(defn zipmap\n  \"Returns a map with the keys mapped to the corresponding vals.\"\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))\n\n(defn max-key\n  \"Returns the x for which (k x), a number, is greatest.\n  \n  If there are multiple such xs, the last one is returned.\"\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))\n\n(defn min-key\n  \"Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.\"\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))\n\n(deftype ArrayList [^:mutable arr]\n  Object\n  (add [_ x] (.push arr x))\n  (size [_] (alength arr))\n  (clear [_] (set! arr (array)))\n  (isEmpty [_] (zero? (alength arr)))\n  (toArray [_] arr))\n\n(defn array-list []\n  (ArrayList. (array)))\n\n(defn partition-all\n  \"Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.\"\n  ([n]\n   (fn [rf]\n     (let [a (array-list)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (== n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))\n\n(defn take-while\n  \"Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.\"\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (when (pred (first s))\n           (cons (first s) (take-while pred (rest s))))))))\n\n(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))\n\n(defn subseq\n  \"sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true\"\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))\n\n(defn rsubseq\n  \"sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true\"\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))\n\n(deftype RangeChunk [start step count]\n  ICounted\n  (-count [coll] count)\n\n  ISeq\n  (-first [coll] start)\n\n  IIndexed\n  (-nth [coll i]\n    (+ start (* i step)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i count))\n      (+ start (* i step))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (<= count 1)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (RangeChunk. (+ start step) step (dec count)))))\n\n(deftype RangeIterator [^:mutable i end step]\n  Object\n  (hasNext [_]\n    (if (pos? step)\n      (< i end)\n      (> i end)))\n  (next [_]\n    (let [ret i]\n      (set! i (+ i step))\n      ret)))\n\n(deftype Range [meta start end step ^:mutable chunk ^:mutable chunk-next ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n  (forceChunk [coll]\n    (when (nil? chunk)\n      (let [count (-count coll)]\n        (if (> count 32)\n          (do\n            (set! chunk-next (Range. nil (+ start (* step 32)) end step nil nil nil))\n            (set! chunk (RangeChunk. start step 32)))\n          (set! chunk (RangeChunk. start step count))))))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step chunk chunk-next __hash))\n\n  IWithMeta\n  (-with-meta [rng new-meta]\n    (if (identical? new-meta meta)\n      rng\n      (Range. new-meta start end step chunk chunk-next __hash)))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng] rng)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (let [s (-next rng)]\n      (if (nil? s)\n        ()\n        s)))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. nil (+ start step) end step nil nil nil))\n      (when (> (+ start step) end)\n        (Range. nil (+ start step) end step nil nil nil))))\n\n  IChunkedSeq\n  (-chunked-first [rng]\n    (.forceChunk rng)\n    chunk)\n  (-chunked-rest [rng]\n    (.forceChunk rng)\n    (if (nil? chunk-next)\n      ()\n      chunk-next))\n\n  IChunkedNext\n  (-chunked-next [rng]\n    (seq (-chunked-rest rng)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (.-EMPTY List))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (Math/ceil (/ (- end start) step)))\n\n  IIndexed\n  (-nth [rng n]\n    (if (and (<= 0 n) (< n (-count rng)))\n      (+ start (* n step))\n      (if (and (<= 0 n) (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (and (<= 0 n) (< n (-count rng)))\n      (+ start (* n step))\n      (if (and (<= 0 n) (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (< i end) (> i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))\n\n(es6-iterable Range)\n\n(defn range\n  \"Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.\"\n  ([] (range 0 (.-MAX_VALUE js/Number) 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step]\n   (cond\n     (pos? step)\n     (if (<= end start)\n       ()\n       (Range. nil start end step nil nil nil))\n\n     (neg? step)\n     (if (>= end start)\n       ()\n       (Range. nil start end step nil nil nil))\n\n     :else\n     (if (== end start)\n       ()\n       (repeat start)))))\n\n(defn take-nth\n  \"Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.\"\n  ([n]\n   {:pre [(number? n)]}\n     (fn [rf]\n       (let [ia (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! ia inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n   {:pre [(number? n)]}\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (cons (first s) (take-nth n (drop n s)))))))\n\n(defn split-with\n  \"Returns a vector of [(take-while pred coll) (drop-while pred coll)]\"\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])\n\n(defn partition-by\n  \"Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.\"\n  ([f]\n     (fn [rf]\n       (let [a (array-list)\n             pa (volatile! ::none)]\n         (fn\n           ([] (rf))\n           ([result]\n              (let [result (if (.isEmpty a)\n                             result\n                             (let [v (vec (.toArray a))]\n                               ;;clear first!\n                               (.clear a)\n                               (unreduced (rf result v))))]\n                (rf result)))\n           ([result input]\n              (let [pval @pa\n                    val (f input)]\n                (vreset! pa val)\n                (if (or (keyword-identical? pval ::none)\n                        (= val pval))\n                  (do\n                    (.add a input)\n                    result)\n                  (let [v (vec (.toArray a))]\n                    (.clear a)\n                    (let [ret (rf result v)]\n                      (when-not (reduced? ret)\n                        (.add a input))\n                      ret)))))))))\n  ([f coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [fst (first s)\n               fv (f fst)\n               run (cons fst (take-while #(= fv (f %)) (next s)))]\n           (cons run (partition-by f (lazy-seq (drop (count run) s)))))))))\n\n(defn frequencies\n  \"Returns a map from distinct items in coll to the number of times\n  they appear.\"\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))\n\n(defn reductions\n  \"Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.\"\n  ([f coll]\n   (lazy-seq\n     (if-let [s (seq coll)]\n       (reductions f (first s) (rest s))\n       (list (f)))))\n  ([f init coll]\n   (if (reduced? init)\n     (list @init)\n     (cons init\n       (lazy-seq\n         (when-let [s (seq coll)]\n           (reductions f (f init (first s)) (rest s))))))))\n\n(defn juxt\n  \"Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]\"\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))\n\n(defn dorun\n  \"When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.\"\n  ([coll]\n   (when-let [s (seq coll)]\n     (recur (next s))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))\n\n(defn doall\n  \"When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.\"\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))\n\n;;;;;;;;;;;;;;;;;;;;;;;;; Regular Expressions ;;;;;;;;;;\n\n(defn regexp?\n  \"Returns true if x is a JavaScript RegExp instance.\"\n  [x]\n  (instance? js/RegExp x))\n\n(defn re-matches\n  \"Returns the result of (re-find re s) if re fully matches s.\"\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when (= (first matches) s)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-matches must match against a string.\"))))\n\n\n(defn re-find\n  \"Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.\"\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when-not (nil? matches)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-find must match against a string.\"))))\n\n(defn- re-seq* [re s]\n  (when-some [matches (.exec re s)]\n    (let [match-str (aget matches 0)\n          match-vals (if (== (.-length matches) 1)\n                       match-str\n                       (vec matches))]\n      (cons match-vals\n            (lazy-seq\n             (let [post-idx (+ (.-index matches)\n                               (max 1 (.-length match-str)))]\n               (when (<= post-idx (.-length s))\n                 (re-seq* re (subs s post-idx)))))))))\n\n(defn re-seq\n  \"Returns a lazy sequence of successive matches of re in s.\"\n  [re s]\n  (if (string? s)\n    (re-seq* re s)\n    (throw (js/TypeError. \"re-seq must match against a string.\"))))\n\n(defn re-pattern\n  \"Returns an instance of RegExp which has compiled the provided string.\"\n  [s]\n  (if (instance? js/RegExp s)\n    s\n    (let [[prefix flags] (re-find #\"^\\(\\?([idmsux]*)\\)\" s)\n          pattern (subs s (count prefix))]\n      (js/RegExp. pattern (or flags \"\")))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Printing ;;;;;;;;;;;;;;;;\n\n(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer \"#\")\n      (do\n        (-write writer begin)\n        (if (zero? (:print-length opts))\n          (when (seq coll)\n            (-write writer (or (:more-marker opts) \"...\")))\n          (do\n            (when (seq coll)\n              (print-one (first coll) writer opts))\n            (loop [coll (next coll) n (dec (:print-length opts))]\n              (if (and coll (or (nil? n) (not (zero? n))))\n                (do\n                  (-write writer sep)\n                  (print-one (first coll) writer opts)\n                  (recur (next coll) (dec n)))\n                (when (and (seq coll) (zero? n))\n                  (-write writer sep)\n                  (-write writer (or (:more-marker opts) \"...\")))))))\n        (-write writer end)))))\n\n(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))\n\n(defn string-print [x]\n  (when (nil? *print-fn*)\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\")))\n  (*print-fn* x)\n  nil)\n\n(defn flush [] ;stub\n  nil)\n\n(def ^:private char-escapes\n  (js-obj\n    \"\\\"\" \"\\\\\\\"\"\n    \"\\\\\" \"\\\\\\\\\"\n    \"\\b\" \"\\\\b\"\n    \"\\f\" \"\\\\f\"\n    \"\\n\" \"\\\\n\"\n    \"\\r\" \"\\\\r\"\n    \"\\t\" \"\\\\t\"))\n\n(defn ^:private quote-string\n  [s]\n  (str \\\"\n       (.replace s (js/RegExp \"[\\\\\\\\\\\"\\b\\f\\n\\r\\t]\" \"g\")\n         (fn [match] (unchecked-get char-escapes match)))\n       \\\"))\n\n(declare print-map)\n\n(defn print-meta? [opts obj]\n  (and (boolean (get opts :meta))\n       (implements? IMeta obj)\n       (not (nil? (meta obj)))))\n\n(defn- pr-writer-impl\n  [obj writer opts]\n  (cond\n    (nil? obj) (-write writer \"nil\")\n    :else\n    (do\n      (when (print-meta? opts obj)\n        (-write writer \"^\")\n        (pr-writer (meta obj) writer opts)\n        (-write writer \" \"))\n      (cond\n        ;; handle CLJS ctors\n        ^boolean (.-cljs$lang$type obj)\n        (.cljs$lang$ctorPrWriter obj obj writer opts)\n\n        ; Use the new, more efficient, IPrintWithWriter interface when possible.\n        (satisfies? IPrintWithWriter obj)\n        (-pr-writer obj writer opts)\n\n        (or (true? obj) (false? obj))\n        (-write writer (str obj))\n\n        (number? obj)\n        (-write writer\n          (cond\n            ^boolean (js/isNaN obj) \"##NaN\"\n            (identical? obj js/Number.POSITIVE_INFINITY) \"##Inf\"\n            (identical? obj js/Number.NEGATIVE_INFINITY) \"##-Inf\"\n            :else (str obj)))\n\n        (object? obj)\n        (do\n          (-write writer \"#js \")\n          (print-map\n            (map (fn [k]\n                   (MapEntry. (cond-> k (some? (re-matches #\"[A-Za-z_\\*\\+\\?!\\-'][\\w\\*\\+\\?!\\-']*\" k)) keyword) (unchecked-get obj k) nil))\n              (js-keys obj))\n            pr-writer writer opts))\n\n        (array? obj)\n        (pr-sequential-writer writer pr-writer \"#js [\" \" \" \"]\" opts obj)\n\n        ^boolean (goog/isString obj)\n        (if (:readably opts)\n          (-write writer (quote-string obj))\n          (-write writer obj))\n\n        ^boolean (goog/isFunction obj)\n        (let [name (.-name obj)\n              name (if (or (nil? name) (gstring/isEmpty name))\n                     \"Function\"\n                     name)]\n          (write-all writer \"#object[\" name\n            (if *print-fn-bodies*\n              (str \" \\\"\" (str obj) \"\\\"\")\n              \"\")\n            \"]\"))\n\n        (instance? js/Date obj)\n        (let [normalize (fn [n len]\n                          (loop [ns (str n)]\n                            (if (< (count ns) len)\n                              (recur (str \"0\" ns))\n                              ns)))]\n          (write-all writer\n            \"#inst \\\"\"\n            (str (.getUTCFullYear obj))             \"-\"\n            (normalize (inc (.getUTCMonth obj)) 2)  \"-\"\n            (normalize (.getUTCDate obj) 2)         \"T\"\n            (normalize (.getUTCHours obj) 2)        \":\"\n            (normalize (.getUTCMinutes obj) 2)      \":\"\n            (normalize (.getUTCSeconds obj) 2)      \".\"\n            (normalize (.getUTCMilliseconds obj) 3) \"-\"\n            \"00:00\\\"\"))\n\n        (regexp? obj) (write-all writer \"#\\\"\" (.-source obj) \"\\\"\")\n\n        :else\n        (if (some-> obj .-constructor .-cljs$lang$ctorStr)\n          (write-all writer\n            \"#object[\" (.replace (.. obj -constructor -cljs$lang$ctorStr)\n                         (js/RegExp. \"/\" \"g\") \".\") \"]\")\n          (let [name (some-> obj .-constructor .-name)\n                name (if (or (nil? name) (gstring/isEmpty name))\n                       \"Object\"\n                       name)]\n            (if (nil? (. obj -constructor))\n              (write-all writer \"#object[\" name \"]\")\n              (write-all writer \"#object[\" name \" \" (str obj) \"]\"))))))))\n\n(defn- pr-writer\n  \"Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.\"\n  [obj writer opts]\n  (if-let [alt-impl (:alt-impl opts)]\n    (alt-impl obj writer (assoc opts :fallback-impl pr-writer-impl))\n    (pr-writer-impl obj writer opts)))\n\n(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))\n\n(defn- pr-sb-with-opts [objs opts]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (pr-seq-writer objs writer opts)\n    (-flush writer)\n    sb))\n\n(defn pr-str-with-opts\n  \"Prints a sequence of objects to a string, observing all the\n  options given in opts\"\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))\n\n(defn prn-str-with-opts\n  \"Same as pr-str-with-opts followed by (newline)\"\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))\n\n(defn- pr-with-opts\n  \"Prints a sequence of objects using string-print, observing all\n  the options given in opts\"\n  [objs opts]\n  (string-print (pr-str-with-opts objs opts)))\n\n(defn newline\n  \"Prints a newline using *print-fn*\"\n  ([] (newline nil))\n  ([opts]\n   (string-print \"\\n\")\n   (when (get opts :flush-on-newline)\n     (flush))))\n\n(defn pr-str\n  \"pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.\"\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))\n\n(defn prn-str\n  \"Same as pr-str followed by (newline)\"\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))\n\n(defn pr\n  \"Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader\"\n  [& objs]\n  (pr-with-opts objs (pr-opts)))\n\n(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))\n\n(defn print-str\n  \"print to a string, returning it\"\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))\n\n(defn println\n  \"Same as print followed by (newline)\"\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))\n\n(defn println-str\n  \"println to a string, returning it\"\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))\n\n(defn prn\n  \"Same as pr followed by (newline).\"\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))\n\n(defn- strip-ns\n  [named]\n  (if (symbol? named)\n    (symbol nil (name named))\n    (keyword nil (name named))))\n\n(defn- lift-ns\n  \"Returns [lifted-ns lifted-map] or nil if m can't be lifted.\"\n  [m]\n  (when *print-namespace-maps*\n    (loop [ns nil\n           [[k v :as entry] & entries] (seq m)\n           lm (empty m)]\n      (if entry\n        (when (or (keyword? k) (symbol? k))\n          (if ns\n            (when (= ns (namespace k))\n              (recur ns entries (assoc lm (strip-ns k) v)))\n            (when-let [new-ns (namespace k)]\n              (recur new-ns entries (assoc lm (strip-ns k) v)))))\n        [ns lm]))))\n\n(defn print-prefix-map [prefix m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    (str prefix \"{\") \", \" \"}\"\n    opts (seq m)))\n\n(defn print-map [m print-one writer opts]\n  (let [[ns lift-map] (when (map? m)\n                        (lift-ns m))]\n    (if ns\n      (print-prefix-map (str \"#:\" ns) lift-map print-one writer opts)\n      (print-prefix-map nil m print-one writer opts))))\n\n(extend-protocol IPrintWithWriter\n  LazySeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  TransformerIterator\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  IndexedSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  RSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  PersistentQueue\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"#queue [\" \" \" \"]\" opts (seq coll)))\n\n  PersistentQueueSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  PersistentTreeMapSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  NodeSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  ArrayNodeSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  List\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  Cons\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  EmptyList\n  (-pr-writer [coll writer opts] (-write writer \"()\"))\n\n  PersistentVector\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts coll))\n\n  ChunkedCons\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  ChunkedSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  Subvec\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts coll))\n\n  BlackNode\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts coll))\n\n  RedNode\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts coll))\n\n  MapEntry\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"[\" \" \" \"]\" opts coll))\n\n  ObjMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  KeySeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  ValSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  PersistentArrayMapSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  PersistentArrayMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  PersistentHashMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  PersistentTreeMap\n  (-pr-writer [coll writer opts]\n    (print-map coll pr-writer writer opts))\n\n  PersistentHashSet\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"#{\" \" \" \"}\" opts coll))\n\n  PersistentTreeSet\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"#{\" \" \" \"}\" opts coll))\n\n  Range\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  Cycle\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  Repeat\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  Iterate\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  ES6IteratorSeq\n  (-pr-writer [coll writer opts] (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll))\n\n  Atom\n  (-pr-writer [a writer opts]\n    (-write writer \"#object[cljs.core.Atom \")\n    (pr-writer {:val (.-state a)} writer opts)\n    (-write writer \"]\"))\n\n  Volatile\n  (-pr-writer [a writer opts]\n    (-write writer \"#object[cljs.core.Volatile \")\n    (pr-writer {:val (.-state a)} writer opts)\n    (-write writer \"]\"))\n\n  Var\n  (-pr-writer [a writer opts]\n    (-write writer \"#'\")\n    (pr-writer (.-sym a) writer opts)))\n\n;; IComparable\n(extend-protocol IComparable\n  Symbol\n  (-compare [x y]\n    (if (symbol? y)\n      (compare-symbols x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y)))))\n\n  Keyword\n  (-compare [x y]\n    (if (keyword? y)\n      (compare-keywords x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y)))))\n\n  Subvec\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y)))))\n  \n  PersistentVector\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y)))))\n\n  MapEntry\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y)))))\n\n  BlackNode\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y)))))\n\n  RedNode\n  (-compare [x y]\n    (if (vector? y)\n      (compare-indexed x y)\n      (throw (js/Error. (str \"Cannot compare \" x \" to \" y))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Reference Types ;;;;;;;;;;;;;;;;\n\n(defn alter-meta!\n  \"Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects\"\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))\n\n(defn reset-meta!\n  \"Atomically resets the metadata for an atom\"\n  [iref m]\n  (set! (.-meta iref) m))\n\n(defn add-watch\n  \"Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1\"\n  [iref key f]\n  (-add-watch iref key f)\n  iref)\n\n(defn remove-watch\n  \"Removes a watch (set by add-watch) from a reference\"\n  [iref key]\n  (-remove-watch iref key)\n  iref)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; gensym ;;;;;;;;;;;;;;;;\n;; Internal - do not use!\n(def\n  ^{:jsdoc [\"@type {*}\"]}\n  gensym_counter nil)\n\n(defn gensym\n  \"Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.\"\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Delay ;;;;;;;;;;;;;;;;;;;;\n\n(deftype Delay [^:mutable f ^:mutable value]\n  IDeref\n  (-deref [_]\n    (when f\n      (set! value (f))\n      (set! f nil))\n    value)\n\n  IPending\n  (-realized? [x]\n    (not f))\n\n  IPrintWithWriter\n  (-pr-writer [x writer opts]\n    (-write writer \"#object[cljs.core.Delay \")\n    (pr-writer {:status (if (nil? f) :ready :pending), :val value} writer opts)\n    (-write writer \"]\")))\n\n(defn delay?\n  \"returns true if x is a Delay created with delay\"\n  [x] (instance? Delay x))\n\n(defn force\n  \"If x is a Delay, returns the (possibly cached) value of its expression, else returns x\"\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))\n\n(defn ^boolean realized?\n  \"Returns true if a value has been produced for a delay or lazy sequence.\"\n  [x]\n  (-realized? x))\n\n(defn- preserving-reduced\n  [rf]\n  #(let [ret (rf %1 %2)]\n     (if (reduced? ret)\n       (reduced ret)\n       ret)))\n\n(defn cat\n  \"A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.\"\n  {:added \"1.7\"}\n  [rf]\n  (let [rf1 (preserving-reduced rf)]\n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rf1 result input)))))\n\n(defn halt-when\n  \"Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.\"\n  {:added \"1.9\"}\n  ([pred] (halt-when pred nil))\n  ([pred retf]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result]\n            (if (and (map? result) (contains? result ::halt))\n              (::halt result)\n              (rf result)))\n         ([result input]\n            (if (pred input)\n              (reduced {::halt (if retf (retf (rf result) input) input)})\n              (rf result input)))))))\n\n(defn dedupe\n  \"Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.\"\n  ([]\n   (fn [rf]\n     (let [pa (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pa]\n              (vreset! pa input)\n              (if (= prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))\n\n(declare rand)\n\n(defn random-sample\n  \"Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.\"\n  ([prob]\n     (filter (fn [_] (< (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (< (rand) prob)) coll)))\n\n(deftype Eduction [xform coll]\n  Object\n  (indexOf [coll x]\n    (-indexOf coll x 0))\n  (indexOf [coll x start]\n    (-indexOf coll x start))\n  (lastIndexOf [coll x]\n    (-lastIndexOf coll x (count coll)))\n  (lastIndexOf [coll x start]\n    (-lastIndexOf coll x start))\n\n  ISequential\n\n  IIterable\n  (-iterator [_]\n    (.create TransformerIterator xform (iter coll)))\n\n  ISeqable\n  (-seq [_] (seq (sequence xform coll)))\n\n  IReduce\n  (-reduce [_ f] (transduce xform (completing f) coll))\n  (-reduce [_ f init] (transduce xform (completing f) init coll))\n\n  IPrintWithWriter\n  (-pr-writer [coll writer opts]\n    (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))\n\n(es6-iterable Eduction)\n\n(defn eduction\n  \"Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.\"\n  {:arglists '([xform* coll])}\n  [& xforms]\n  (Eduction. (apply comp (butlast xforms)) (last xforms)))\n\n(defn run!\n  \"Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil\"\n  [proc coll]\n  (reduce #(proc %2) nil coll)\n  nil)\n\n(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))\n\n(declare clj->js)\n\n(defn key->js\n  ([k] (key->js k clj->js))\n  ([k primitive-fn]\n   (cond\n     (satisfies? IEncodeJS k) (-clj->js k)\n     (or (string? k)\n         (number? k)\n         (keyword? k)\n         (symbol? k)) (primitive-fn k)\n     :default (pr-str k))))\n\n(defn clj->js\n  \"Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`.\"\n  [x & {:keys [keyword-fn]\n        :or   {keyword-fn name}\n        :as options}]\n  (letfn [(keyfn [k] (key->js k thisfn))\n          (thisfn [x] (cond\n                        (nil? x) nil\n                        (satisfies? IEncodeJS x) (-clj->js x)\n                        (keyword? x) (keyword-fn x)\n                        (symbol? x) (str x)\n                        (map? x) (let [m (js-obj)]\n                                   (doseq [[k v] x]\n                                     (gobject/set m (keyfn k) (thisfn v)))\n                                   m)\n                        (coll? x) (let [arr (array)]\n                                    (doseq [x (map thisfn x)]\n                                      (.push arr x))\n                                    arr)\n                        :else x))]\n    (thisfn x)))\n\n\n(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))\n\n(defn js->clj\n  \"Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.\"\n  ([x] (js->clj x :keywordize-keys false))\n  ([x & opts]\n    (let [{:keys [keywordize-keys]} opts\n          keyfn (if keywordize-keys keyword str)\n          f (fn thisfn [x]\n              (cond\n                (satisfies? IEncodeClojure x)\n                (-js->clj x (apply array-map opts))\n\n                (seq? x)\n                (doall (map thisfn x))\n\n                (map-entry? x)\n                (MapEntry. (thisfn (key x)) (thisfn (val x)) nil)\n\n                (coll? x)\n                (into (empty x) (map thisfn) x)\n\n                (array? x)\n                (persistent!\n                 (reduce #(conj! %1 (thisfn %2))\n                         (transient []) x))\n\n                (identical? (type x) js/Object)\n                (persistent!\n                 (reduce (fn [r k] (assoc! r (keyfn k) (thisfn (gobject/get x k))))\n                         (transient {}) (js-keys x)))\n                :else x))]\n      (f x))))\n\n(defn memoize\n  \"Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.\"\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (let [v (get @mem args lookup-sentinel)]\n        (if (identical? v lookup-sentinel)\n          (let [ret (apply f args)]\n            (swap! mem assoc args ret)\n            ret)\n          v)))))\n\n(defn trampoline\n  \"trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.\"\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))\n\n(defn rand\n  \"Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).\"\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))\n\n(defn rand-int\n  \"Returns a random integer between 0 (inclusive) and n (exclusive).\"\n  [n] (Math/floor (* (Math/random) n)))\n\n(defn rand-nth\n  \"Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.\"\n  [coll]\n  (nth coll (rand-int (count coll))))\n\n(defn group-by\n  \"Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.\"\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))\n\n(defn make-hierarchy\n  \"Creates a hierarchy object for use with derive, isa? etc.\"\n  [] {:parents {} :descendants {} :ancestors {}})\n\n(def\n  ^{:private true\n    :jsdoc [\"@type {*}\"]}\n  -global-hierarchy nil)\n\n(defn- get-global-hierarchy []\n  (when (nil? -global-hierarchy)\n    (set! -global-hierarchy (atom (make-hierarchy))))\n  -global-hierarchy)\n\n(defn- swap-global-hierarchy! [f & args]\n  (apply swap! (get-global-hierarchy) f args))\n\n(defn ^boolean isa?\n  \"Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy\"\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))\n\n(defn parents\n  \"Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy\"\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))\n\n(defn ancestors\n  \"Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy\"\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))\n\n(defn descendants\n  \"Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.\"\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))\n\n(defn derive\n  \"Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.\"\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))\n\n(defn underive\n  \"Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.\"\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))\n\n(defn- reset-cache\n  [method-cache method-table cached-hierarchy hierarchy]\n  (swap! method-cache (fn [_] (deref method-table)))\n  (swap! cached-hierarchy (fn [_] (deref hierarchy))))\n\n(defn- prefers*\n  [x y prefer-table]\n  (let [xprefs (@prefer-table x)]\n    (or\n     (when (and xprefs (xprefs y))\n       true)\n     (loop [ps (parents y)]\n       (when (pos? (count ps))\n         (when (prefers* x (first ps) prefer-table)\n           true)\n         (recur (rest ps))))\n     (loop [ps (parents x)]\n       (when (pos? (count ps))\n         (when (prefers* (first ps) y prefer-table)\n           true)\n         (recur (rest ps))))\n     false)))\n\n(defn- dominates\n  [x y prefer-table hierarchy]\n  (or (prefers* x y prefer-table) (isa? hierarchy x y)))\n\n(defn- find-and-cache-best-method\n  [name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]\n  (let [best-entry (reduce (fn [be [k _ :as e]]\n                             (if (isa? @hierarchy dispatch-val k)\n                               (let [be2 (if (or (nil? be) (dominates k (first be) prefer-table @hierarchy))\n                                           e\n                                           be)]\n                                 (when-not (dominates (first be2) k prefer-table @hierarchy)\n                                   (throw (js/Error.\n                                            (str \"Multiple methods in multimethod '\" name\n                                              \"' match dispatch value: \" dispatch-val \" -> \" k\n                                              \" and \" (first be2) \", and neither is preferred\"))))\n                                 be2)\n                               be))\n                     nil @method-table)\n        best-entry (if-let [entry (and (nil? best-entry) (@method-table default-dispatch-val))]\n                     [default-dispatch-val entry]\n                     best-entry)]\n    (when best-entry\n      (if (= @cached-hierarchy @hierarchy)\n        (do\n          (swap! method-cache assoc dispatch-val (second best-entry))\n          (second best-entry))\n        (do\n          (reset-cache method-cache method-table cached-hierarchy hierarchy)\n          (find-and-cache-best-method name dispatch-val hierarchy method-table prefer-table\n            method-cache cached-hierarchy default-dispatch-val))))))\n\n(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-default-dispatch-val [mf])\n  (-dispatch-fn [mf]))\n\n(defn- throw-no-method-error [name dispatch-val]\n  (throw (js/Error. (str \"No method in multimethod '\" name \"' for dispatch value: \" dispatch-val))))\n\n(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n  (-invoke [mf]\n    (let [dispatch-val (dispatch-fn)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn)))\n  (-invoke [mf a]\n    (let [dispatch-val (dispatch-fn a)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a)))\n  (-invoke [mf a b]\n    (let [dispatch-val (dispatch-fn a b)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b)))\n  (-invoke [mf a b c]\n    (let [dispatch-val (dispatch-fn a b c)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c)))\n  (-invoke [mf a b c d]\n    (let [dispatch-val (dispatch-fn a b c d)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d)))\n  (-invoke [mf a b c d e]\n    (let [dispatch-val (dispatch-fn a b c d e)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e)))\n  (-invoke [mf a b c d e f]\n    (let [dispatch-val (dispatch-fn a b c d e f)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f)))\n  (-invoke [mf a b c d e f g]\n    (let [dispatch-val (dispatch-fn a b c d e f g)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g)))\n  (-invoke [mf a b c d e f g h]\n    (let [dispatch-val (dispatch-fn a b c d e f g h)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h)))\n  (-invoke [mf a b c d e f g h i]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i)))\n  (-invoke [mf a b c d e f g h i j]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j)))\n  (-invoke [mf a b c d e f g h i j k]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k)))\n  (-invoke [mf a b c d e f g h i j k l]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l)))\n  (-invoke [mf a b c d e f g h i j k l m]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m)))\n  (-invoke [mf a b c d e f g h i j k l m n]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n)))\n  (-invoke [mf a b c d e f g h i j k l m n o]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o)))\n  (-invoke [mf a b c d e f g h i j k l m n o p]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s t)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s t)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t rest]\n    (let [dispatch-val (apply dispatch-fn a b c d e f g h i j k l m n o p q r s t rest)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (apply target-fn a b c d e f g h i j k l m n o p q r s t rest)))\n\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (find-and-cache-best-method name dispatch-val hierarchy method-table\n        prefer-table method-cache cached-hierarchy default-dispatch-val)))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n  (-default-dispatch-val [mf] default-dispatch-val)\n  (-dispatch-fn [mf] dispatch-fn)\n\n  INamed\n  (-name [this] (-name name))\n  (-namespace [this] (-namespace name))\n\n  IHash\n  (-hash [this] (goog/getUid this)))\n\n(defn remove-all-methods\n  \"Removes all of the methods of multimethod.\"\n [multifn]\n (-reset multifn))\n\n(defn remove-method\n  \"Removes the method of multimethod associated with dispatch-value.\"\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))\n\n(defn prefer-method\n  \"Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict\"\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))\n\n(defn methods\n  \"Given a multimethod, returns a map of dispatch values -> dispatch fns\"\n  [multifn] (-methods multifn))\n\n(defn get-method\n  \"Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default\"\n  [multifn dispatch-val] (-get-method multifn dispatch-val))\n\n(defn prefers\n  \"Given a multimethod, returns a map of preferred value -> set of other values\"\n  [multifn] (-prefers multifn))\n\n(defn default-dispatch-val\n  \"Given a multimethod, return it's default-dispatch-val.\"\n  [multifn] (-default-dispatch-val multifn))\n\n(defn dispatch-fn\n  \"Given a multimethod, return it's dispatch-fn.\"\n  [multifn] (-dispatch-fn multifn))\n\n;; UUID\n(defprotocol IUUID \"A marker protocol for UUIDs\")\n\n(deftype UUID [uuid ^:mutable __hash]\n  IUUID\n\n  Object\n  (toString [_] uuid)\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (when (nil? __hash)\n      (set! __hash (hash uuid)))\n    __hash)\n\n  IComparable\n  (-compare [_ other]\n    (garray/defaultCompare uuid (.-uuid other))))\n\n(defn uuid [s]\n  (assert (string? s))\n  (UUID. (.toLowerCase s) nil))\n\n(defn random-uuid []\n  (letfn [(hex [] (.toString (rand-int 16) 16))]\n    (let [rhex (.toString (bit-or 0x8 (bit-and 0x3 (rand-int 16))) 16)]\n      (uuid\n        (str (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex) \"-\"\n             (hex) (hex) (hex) (hex) \"-\"\n             \"4\"   (hex) (hex) (hex) \"-\"\n             rhex  (hex) (hex) (hex) \"-\"\n             (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex)\n             (hex) (hex) (hex) (hex))))))\n\n(defn uuid?\n  [x] (implements? IUUID x))\n\n;;; ExceptionInfo\n\n(defn- pr-writer-ex-info [obj writer opts]\n  (-write writer \"#error {:message \")\n  (pr-writer (.-message obj) writer opts)\n  (when (.-data obj)\n    (-write writer \", :data \")\n    (pr-writer (.-data obj) writer opts))\n  (when (.-cause obj)\n    (-write writer \", :cause \")\n    (pr-writer (.-cause obj) writer opts))\n  (-write writer \"}\"))\n\n(defn ^{:jsdoc [\"@constructor\"]}\n  ExceptionInfo [message data cause]\n  (let [e (js/Error. message)]\n    (this-as this\n      (set! (.-message this) message)\n      (set! (.-data this) data)\n      (set! (.-cause this) cause)\n      (do\n        (set! (.-name this) (.-name e))\n        ;; non-standard\n        (set! (.-description this) (.-description e))\n        (set! (.-number this) (.-number e))\n        (set! (.-fileName this) (.-fileName e))\n        (set! (.-lineNumber this) (.-lineNumber e))\n        (set! (.-columnNumber this) (.-columnNumber e))\n        (set! (.-stack this) (.-stack e)))\n      this)))\n\n(set! (.. ExceptionInfo -prototype -__proto__) js/Error.prototype)\n\n(extend-type ExceptionInfo\n  IPrintWithWriter\n  (-pr-writer [obj writer opts]\n    (pr-writer-ex-info obj writer opts)))\n\n(set! (.. ExceptionInfo -prototype -toString)\n  (fn []\n    (this-as this (pr-str* this))))\n\n(defn ex-info\n  \"Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.\"\n  ([msg data] (ex-info msg data nil))\n  ([msg data cause]\n    (ExceptionInfo. msg data cause)))\n\n(defn ex-data\n  \"Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.\"\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))\n\n(defn ex-message\n  \"Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.\"\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))\n\n(defn ex-cause\n  \"Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.\"\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))\n\n(defn comparator\n  \"Returns an JavaScript compatible comparator based upon pred.\"\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))\n\n(defn ^boolean special-symbol?\n  \"Returns true if x names a special form\"\n  [x]\n  (contains?\n    '#{if def fn* do let* loop* letfn* throw try catch finally\n       recur new set! ns deftype* defrecord* . js* & quote case* var ns*}\n    x))\n\n(defn test\n  \"test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception\"\n  [v]\n  (let [f (.-cljs$lang$test v)]\n    (if f\n      (do (f) :ok)\n      :no-test)))\n\n\n(deftype TaggedLiteral [tag form]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IEquiv\n  (-equiv [this other]\n    (and (instance? TaggedLiteral other)\n         (= tag (.-tag other))\n         (= form (.-form other))))\n\n  IHash\n  (-hash [this]\n    (+ (* 31 (hash tag))\n       (hash form)))\n\n  ILookup\n  (-lookup [this v]\n    (-lookup this v nil))\n  (-lookup [this v not-found]\n    (case v\n      :tag tag\n      :form form\n      not-found))\n\n  IPrintWithWriter\n  (-pr-writer [o writer opts]\n    (-write writer (str \"#\" tag \" \"))\n    (pr-writer form writer opts)))\n\n(defn tagged-literal?\n  \"Return true if the value is the data representation of a tagged literal\"\n  [value]\n  (instance? TaggedLiteral value))\n\n(defn tagged-literal\n  \"Construct a data representation of a tagged literal from a\n  tag symbol and a form.\"\n  [tag form]\n  {:pre [(symbol? tag)]}\n  (TaggedLiteral. tag form))\n\n(def\n  ^{:private true\n    :jsdoc [\"@type {*}\"]}\n  js-reserved-arr\n  #js [\"arguments\" \"abstract\" \"await\" \"boolean\" \"break\" \"byte\" \"case\"\n       \"catch\" \"char\" \"class\" \"const\" \"continue\"\n       \"debugger\" \"default\" \"delete\" \"do\" \"double\"\n       \"else\" \"enum\" \"export\" \"extends\" \"final\"\n       \"finally\" \"float\" \"for\" \"function\" \"goto\" \"if\"\n       \"implements\" \"import\" \"in\" \"instanceof\" \"int\"\n       \"interface\" \"let\" \"long\" \"native\" \"new\"\n       \"package\" \"private\" \"protected\" \"public\"\n       \"return\" \"short\" \"static\" \"super\" \"switch\"\n       \"synchronized\" \"this\" \"throw\" \"throws\"\n       \"transient\" \"try\" \"typeof\" \"var\" \"void\"\n       \"volatile\" \"while\" \"with\" \"yield\" \"methods\"\n       \"null\" \"constructor\"])\n\n(def\n  ^{:jsdoc [\"@type {null|Object}\"]}\n  js-reserved nil)\n\n(defn- js-reserved? [x]\n  (when (nil? js-reserved)\n    (set! js-reserved\n      (reduce #(do (gobject/set %1 %2 true) %1)\n        #js {} js-reserved-arr)))\n  (.hasOwnProperty js-reserved x))\n\n(defn- demunge-pattern []\n  (when-not DEMUNGE_PATTERN\n    (set! DEMUNGE_PATTERN\n      (let [ks (sort (fn [a b] (- (. b -length) (. a -length)))\n                 (js-keys DEMUNGE_MAP))]\n        (loop [ks ks ret \"\"]\n          (if (seq ks)\n            (recur\n              (next ks)\n              (str\n                (cond-> ret\n                  (not (identical? ret \"\")) (str \"|\"))\n                (first ks)))\n            (str ret \"|\\\\$\"))))))\n  DEMUNGE_PATTERN)\n\n(defn- munge-str [name]\n  (let [sb (StringBuffer.)]\n    (loop [i 0]\n      (if (< i (. name -length))\n        (let [c (.charAt name i)\n              sub (gobject/get CHAR_MAP c)]\n          (if-not (nil? sub)\n            (.append sb sub)\n            (.append sb c))\n          (recur (inc i)))))\n    (.toString sb)))\n\n(defn munge [name]\n  (let [name' (munge-str (str name))\n        name' (cond\n                (identical? name' \"..\") \"_DOT__DOT_\"\n                (js-reserved? name') (str name' \"$\")\n                :else name')]\n    (if (symbol? name)\n      (symbol name')\n      name')))\n\n(defn- demunge-str [munged-name]\n  (let [r (js/RegExp. (demunge-pattern) \"g\")\n        munged-name (if (gstring/endsWith munged-name \"$\")\n                      (.substring munged-name 0 (dec (. munged-name -length)))\n                      munged-name)]\n    (loop [ret \"\" last-match-end 0]\n      (if-let [match (.exec r munged-name)]\n        (let [[x] match]\n          (recur\n            (str ret\n              (.substring munged-name last-match-end\n                (- (. r -lastIndex) (. x -length)))\n              (if (identical? x \"$\") \"/\" (gobject/get DEMUNGE_MAP x)))\n            (. r -lastIndex)))\n        (str ret\n          (.substring munged-name last-match-end (.-length munged-name)))))))\n\n(defn demunge [name]\n  ((if (symbol? name) symbol str)\n    (let [name' (str name)]\n      (if (identical? name' \"_DOT__DOT_\")\n        \"..\"\n        (demunge-str name')))))\n\n(defonce ^{:jsdoc [\"@type {*}\"] :private true}\n  tapset nil)\n\n(defn- maybe-init-tapset []\n  (when (nil? tapset)\n    (set! tapset (atom #{}))))\n\n(defn add-tap\n  \"Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap>. Remember f in order to remove-tap\"\n  [f]\n  (maybe-init-tapset)\n  (swap! tapset conj f)\n  nil)\n\n(defn remove-tap\n  \"Remove f from the tap set.\"\n  [f]\n  (maybe-init-tapset)\n  (swap! tapset disj f)\n  nil)\n\n(defn ^boolean tap>\n  \"Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.\"\n  [x]\n  (maybe-init-tapset)\n  (*exec-tap-fn*\n    (fn []\n      (doseq [tap @tapset]\n        (try\n          (tap x)\n          (catch js/Error ex))))))\n\n;; -----------------------------------------------------------------------------\n;; Bootstrap helpers - incompatible with advanced compilation\n\n(defn- ns-lookup\n  \"Bootstrap only.\"\n  [ns-obj k]\n  (fn [] (gobject/get ns-obj k)))\n\n;; Bootstrap only\n(deftype Namespace [obj name]\n  Object\n  (findInternedVar [this sym]\n    (let [k (munge (str sym))]\n      (when ^boolean (gobject/containsKey obj k)\n        (let [var-sym (symbol (str name) (str sym))\n              var-meta {:ns this}]\n          (Var. (ns-lookup obj k) var-sym var-meta)))))\n  (getName [_] name)\n  (toString [_]\n    (str name))\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Namespace other)\n      (= name (.-name other))\n      false))\n  IHash\n  (-hash [_]\n    (hash name)))\n\n(def\n  ^{:doc \"Bootstrap only.\" :jsdoc [\"@type {*}\"]}\n  NS_CACHE nil)\n\n(defn- find-ns-obj*\n  \"Bootstrap only.\"\n  [ctxt xs]\n  (cond\n    (nil? ctxt) nil\n    (nil? xs) ctxt\n    :else (recur (gobject/get ctxt (first xs)) (next xs))))\n\n(defn find-ns-obj\n  \"Bootstrap only.\"\n  [ns]\n  (let [munged-ns (munge (str ns))\n        segs (.split munged-ns \".\")]\n    (case *target*\n      \"nodejs\"  (if ^boolean js/COMPILED\n                  ; Under simple optimizations on nodejs, namespaces will be in module\n                  ; rather than global scope and must be accessed by a direct call to eval.\n                  ; The first segment may refer to an undefined variable, so its evaluation\n                  ; may throw ReferenceError.\n                  (find-ns-obj*\n                    (try\n                      (let [ctxt (js/eval (first segs))]\n                        (when (and ctxt (object? ctxt))\n                          ctxt))\n                      (catch js/ReferenceError e\n                        nil))\n                    (next segs))\n                  (find-ns-obj* goog/global segs))\n      (\"default\" \"webworker\") (find-ns-obj* goog/global segs)\n      (throw (js/Error. (str \"find-ns-obj not supported for target \" *target*))))))\n\n(defn ns-interns*\n  \"Returns a map of the intern mappings for the namespace.\n  Bootstrap only.\"\n  [sym]\n  (let [ns-obj (find-ns-obj sym)\n        ns     (Namespace. ns-obj sym)]\n    (letfn [(step [ret k]\n              (let [var-sym (symbol (demunge k))]\n                (assoc ret\n                  var-sym (Var. #(gobject/get ns-obj k)\n                            (symbol (str sym) (str var-sym)) {:ns ns}))))]\n      (reduce step {} (js-keys ns-obj)))))\n\n(defn create-ns\n  \"Create a new namespace named by the symbol. Bootstrap only.\"\n  ([sym]\n   (create-ns sym (find-ns-obj sym)))\n  ([sym ns-obj]\n   (Namespace. ns-obj sym)))\n\n(defn find-ns\n  \"Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.\"\n  [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n        (when-not (nil? ns-obj)\n          (let [new-ns (create-ns ns ns-obj)]\n            (swap! NS_CACHE assoc ns new-ns)\n            new-ns))))))\n\n(defn find-macros-ns\n  \"Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.\"\n  [ns]\n  (when (nil? NS_CACHE)\n    (set! NS_CACHE (atom {})))\n  (let [ns-str (str ns)\n        ns (if (not ^boolean (gstring/contains ns-str \"$macros\"))\n             (symbol (str ns-str \"$macros\"))\n             ns)\n        the-ns (get @NS_CACHE ns)]\n    (if-not (nil? the-ns)\n      the-ns\n      (let [ns-obj (find-ns-obj ns)]\n       (when-not (nil? ns-obj)\n         (let [new-ns (create-ns ns ns-obj)]\n           (swap! NS_CACHE assoc ns new-ns)\n           new-ns))))))\n\n(defn ns-name\n  \"Returns the name of the namespace, a Namespace object.\n  Bootstrap only.\"\n  [ns-obj]\n  (.-name ns-obj))\n\n(defn uri?\n  \"Returns true x is a goog.Uri instance.\"\n  {:added \"1.9\"}\n  [x]\n  (instance? goog.Uri x))\n\n(defn- maybe-enable-print! []\n  (cond\n    (exists? js/console)\n    (enable-console-print!)\n\n    (or (identical? *target* \"nashorn\")\n        (identical? *target* \"graaljs\"))\n    (let [system (.type js/Java \"java.lang.System\")]\n      (set! *print-newline* false)\n      (set-print-fn!\n        (fn []\n          (let [xs (js-arguments)\n                s  (.join (garray/clone xs) \"\")]\n            (.println (.-out system) s))))\n      (set-print-err-fn!\n        (fn []\n          (let [xs (js-arguments)\n                s  (.join (garray/clone xs) \"\")]\n            (.println (.-error system) s)))))))\n\n(maybe-enable-print!)\n\n(defonce\n  ^{:doc \"Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated.\" :dynamic true}\n  *eval*\n  (fn [_]\n    (throw (js/Error. \"cljs.core/*eval* not bound\"))))\n\n(defn eval\n  \"Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment.\"\n  [form]\n  (*eval* form))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/analyzer.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.analyzer",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.analyzer\n  #?(:clj  (:refer-clojure :exclude [macroexpand-1 ensure])\n     :cljs (:refer-clojure :exclude [macroexpand-1 ns-interns ensure js-reserved]))\n  #?(:cljs (:require-macros\n             [cljs.analyzer.macros\n              :refer [no-warn wrapping-errors with-warning-handlers\n                      disallowing-recur allowing-redef disallowing-ns*]]\n             [cljs.env.macros :refer [ensure]]))\n  #?(:clj (:require [cljs.util :as util :refer [ns->relpath topo-sort]]\n                    [clojure.java.io :as io]\n                    [clojure.string :as string]\n                    [clojure.set :as set]\n                    [cljs.env :as env :refer [ensure]]\n                    [cljs.js-deps :as deps]\n                    [cljs.tagged-literals :as tags]\n                    [clojure.tools.reader :as reader]\n                    [clojure.tools.reader.reader-types :as readers]\n                    [clojure.edn :as edn])\n     :cljs (:require [goog.string :as gstring]\n                     [clojure.string :as string]\n                     [clojure.set :as set]\n                     [cljs.env :as env]\n                     [cljs.tagged-literals :as tags]\n                     [cljs.tools.reader :as reader]\n                     [cljs.tools.reader.reader-types :as readers]\n                     [cljs.reader :as edn]))\n  #?(:clj (:import [java.io File Reader PushbackReader FileOutputStream FileInputStream]\n                   [java.util.regex Pattern]\n                   [java.net URL]\n                   [java.lang Throwable]\n                   [clojure.lang Namespace Var LazySeq ArityException]\n                   [cljs.tagged_literals JSValue])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; User file-local compiler flags\n#?(:clj (def ^:dynamic *unchecked-if* false))\n#?(:clj (def ^:dynamic *unchecked-arrays* false))\n\n;; Compiler dynamic vars\n(def ^:dynamic *cljs-ns* 'cljs.user)\n(def ^:dynamic *cljs-file* nil)\n(def ^:dynamic *checked-arrays* false)\n(def ^:dynamic *check-alias-dupes* true)\n(def ^:dynamic *cljs-static-fns* false)\n(def ^:dynamic *fn-invoke-direct* false)\n(def ^:dynamic *cljs-macros-path* \"/cljs/core\")\n(def ^:dynamic *cljs-macros-is-classpath* true)\n(def ^:dynamic *cljs-dep-set* (with-meta #{} {:dep-path []}))\n(def ^:dynamic *analyze-deps* true)\n(def ^:dynamic *load-tests* true)\n(def ^:dynamic *load-macros* true)\n(def ^:dynamic *reload-macros* false)\n(def ^:dynamic *macro-infer* true)\n(def ^:dynamic *passes* nil)\n(def ^:dynamic *file-defs* nil)\n(def ^:dynamic *private-var-access-nowarn* false)\n\n(def constants-ns-sym\n  \"The namespace of the constants table as a symbol.\"\n  'cljs.core.constants)\n\n(def ^:private identity-counter (atom 0))\n\n(defn- add-identity [m]\n  (assoc m :identity (swap! identity-counter inc)))\n\n#?(:clj\n   (def transit-read-opts\n     (try\n       (require '[cognitect.transit])\n       (when-some [ns (find-ns 'cognitect.transit)]\n         (let [read-handler     @(ns-resolve ns 'read-handler)\n               read-handler-map @(ns-resolve ns 'read-handler-map)]\n           {:handlers\n             (read-handler-map\n               {\"cljs/js\"    (read-handler (fn [v] (JSValue. v)))\n                \"cljs/regex\" (read-handler (fn [v] (Pattern/compile v)))})}))\n       (catch Throwable t\n         nil))))\n\n#?(:clj\n   (def transit-write-opts\n     (try\n       (require '[cognitect.transit])\n       (when-some [ns (find-ns 'cognitect.transit)]\n         (let [write-handler     @(ns-resolve ns 'write-handler)\n               write-handler-map @(ns-resolve ns 'write-handler-map)]\n           {:handlers\n             (write-handler-map\n               {JSValue\n                (write-handler\n                  (fn [_] \"cljs/js\")\n                  (fn [js] (.val ^JSValue js)))\n                Pattern\n                (write-handler\n                  (fn [_] \"cljs/regex\")\n                  (fn [pat] (.pattern ^Pattern pat)))})}))\n       (catch Throwable t\n         nil))))\n\n#?(:clj\n   (def transit\n     (delay\n       (try\n         (require '[cognitect.transit])\n         (when-some [ns (find-ns 'cognitect.transit)]\n           {:writer @(ns-resolve ns 'writer)\n            :reader @(ns-resolve ns 'reader)\n            :write  @(ns-resolve ns 'write)\n            :read   @(ns-resolve ns 'read)})\n         (catch Throwable t\n           nil)))))\n\n;; log compiler activities\n(def ^:dynamic *verbose* false)\n\n(def -cljs-macros-loaded (atom false))\n\n(def ^:dynamic *cljs-warnings*\n  {:preamble-missing true\n   :unprovided true\n   :undeclared-var true\n   :private-var-access true\n   :undeclared-ns true\n   :undeclared-ns-form true\n   :redef true\n   :redef-in-file true\n   :dynamic true\n   :fn-var true\n   :fn-arity true\n   :fn-deprecated true\n   :declared-arglists-mismatch true\n   :protocol-deprecated true\n   :undeclared-protocol-symbol true\n   :invalid-protocol-symbol true\n   :multiple-variadic-overloads true\n   :variadic-max-arity true\n   :overload-arity true\n   :extending-base-js-type true\n   :invoke-ctor true\n   :invalid-arithmetic true\n   :invalid-array-access true\n   :protocol-invalid-method true\n   :protocol-duped-method true\n   :protocol-multiple-impls true\n   :protocol-with-variadic-method true\n   :protocol-impl-with-variadic-method true\n   :protocol-impl-recur-with-target true\n   :single-segment-namespace true\n   :munged-namespace true\n   :ns-var-clash true\n   :non-dynamic-earmuffed-var true\n   :extend-type-invalid-method-shape true\n   :unsupported-js-module-type true\n   :unsupported-preprocess-value true\n   :js-shadowed-by-local true\n   :infer-warning false})\n\n(defn unchecked-arrays? []\n  *unchecked-arrays*)\n\n(defn checked-arrays\n  \"Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*.\"\n  []\n  (when (and (not (-> @env/*compiler* :options :advanced))\n             (not *unchecked-arrays*))\n    *checked-arrays*))\n\n(def js-reserved\n  #{\"arguments\" \"abstract\" \"await\" \"boolean\" \"break\" \"byte\" \"case\"\n    \"catch\" \"char\" \"class\" \"const\" \"continue\"\n    \"debugger\" \"default\" \"delete\" \"do\" \"double\"\n    \"else\" \"enum\" \"export\" \"extends\" \"final\"\n    \"finally\" \"float\" \"for\" \"function\" \"goto\" \"if\"\n    \"implements\" \"import\" \"in\" \"instanceof\" \"int\"\n    \"interface\" \"let\" \"long\" \"native\" \"new\"\n    \"package\" \"private\" \"protected\" \"public\"\n    \"return\" \"short\" \"static\" \"super\" \"switch\"\n    \"synchronized\" \"this\" \"throw\" \"throws\"\n    \"transient\" \"try\" \"typeof\" \"var\" \"void\"\n    \"volatile\" \"while\" \"with\" \"yield\" \"methods\"\n    \"null\" \"constructor\"})\n\n(def es5-allowed\n  #{\"default\"})\n\n#?(:clj (def SENTINEL (Object.))\n   :cljs (def SENTINEL (js-obj)))\n\n(defn gets\n  ([m k0 k1]\n    (let [m (get m k0 SENTINEL)]\n      (when-not (identical? m SENTINEL)\n        (get m k1))))\n  ([m k0 k1 k2]\n   (let [m (get m k0 SENTINEL)]\n     (when-not (identical? m SENTINEL)\n       (let [m (get m k1 SENTINEL)]\n         (when-not (identical? m SENTINEL)\n           (get m k2))))))\n  ([m k0 k1 k2 k3]\n   (let [m (get m k0 SENTINEL)]\n     (when-not (identical? m SENTINEL)\n       (let [m (get m k1 SENTINEL)]\n         (when-not (identical? m SENTINEL)\n           (let [m (get m k2 SENTINEL)]\n             (when-not (identical? m SENTINEL)\n               (get m k3)))))))))\n\n#?(:cljs\n   (def CLJ_NIL_SYM 'clj-nil))\n\n#?(:cljs\n   (def NUMBER_SYM 'number))\n\n#?(:cljs\n   (def STRING_SYM 'string))\n\n(def BOOLEAN_SYM 'boolean)\n\n#?(:cljs\n   (def JS_STAR_SYM 'js*))\n\n#?(:cljs\n   (def DOT_SYM '.))\n\n#?(:cljs\n   (def NEW_SYM 'new))\n\n#?(:cljs\n   (def CLJS_CORE_SYM 'cljs.core))\n\n#?(:cljs\n   (def CLJS_CORE_MACROS_SYM 'cljs.core$macros))\n\n(def IGNORE_SYM 'ignore)\n\n(def ANY_SYM 'any)\n\n#?(:cljs\n   (defn ^boolean cljs-seq? [x]\n     (implements? ISeq x)))\n\n#?(:cljs\n   (defn ^boolean cljs-map? [x]\n     (implements? IMap x)))\n\n#?(:cljs\n   (defn ^boolean cljs-vector? [x]\n     (implements? IVector x)))\n\n#?(:cljs\n   (defn ^boolean cljs-set? [x]\n     (implements? ISet x)))\n\n#?(:cljs\n   (defn munge-path [ss]\n     (munge (str ss))))\n\n#?(:cljs\n   (defn ns->relpath\n     \"Given a namespace as a symbol return the relative path. May optionally\n     provide the file extension, defaults to :cljs.\"\n     ([ns] (ns->relpath ns :cljs))\n     ([ns ext]\n      (str (string/replace (munge-path ns) \\. \\/) \".\" (name ext)))))\n\n#?(:cljs\n   (defn topo-sort\n     ([x get-deps]\n      (topo-sort x 0 (atom (sorted-map)) (memoize get-deps)))\n     ([x depth state memo-get-deps]\n      (let [deps (memo-get-deps x)]\n        (swap! state update-in [depth] (fnil into #{}) deps)\n        (doseq [dep deps]\n          (topo-sort dep (inc depth) state memo-get-deps))\n        (doseq [[<depth _] (subseq @state < depth)]\n          (swap! state update-in [<depth] set/difference deps))\n        (when (= depth 0)\n          (distinct (apply concat (vals @state))))))))\n\n(declare message namespaces)\n\n(defn ast?\n  #?(:cljs {:tag boolean})\n  [x]\n  (and (map? x) (contains? x :op)))\n\n(defmulti error-message (fn [warning-type & _] warning-type))\n\n(defmethod error-message :preamble-missing\n  [warning-type info]\n  (str \"Preamble resource file not found: \" (string/join \" \" (:missing info))))\n\n(defmethod error-message :unprovided\n  [warning-type info]\n  (str \"Required namespace not provided for \" (string/join \" \" (:unprovided info))))\n\n(defmethod error-message :undeclared-var\n  [warning-type info]\n  (str (if (:macro-present? info)\n         \"Can't take value of macro \"\n         \"Use of undeclared Var \")\n    (:prefix info) \"/\" (:suffix info)))\n\n(defmethod error-message :private-var-access\n  [warning-type info]\n  (str \"var: \" (:sym info) \" is not public\"))\n\n(defmethod error-message :undeclared-ns\n  [warning-type {:keys [ns-sym js-provide] :as info}]\n  (str \"No such namespace: \" ns-sym\n       \", could not locate \" (ns->relpath ns-sym :cljs)\n       \", \" (ns->relpath ns-sym :cljc)\n       \", or JavaScript source providing \\\"\" js-provide \"\\\"\"\n    (when (string/includes? (ns->relpath ns-sym) \"_\")\n      \" (Please check that namespaces with dashes use underscores in the ClojureScript file name)\")))\n\n(defmethod error-message :undeclared-macros-ns\n  [warning-type {:keys [ns-sym js-provide] :as info}]\n  (str \"No such macros namespace: \" ns-sym\n       \", could not locate \" (ns->relpath ns-sym :clj)\n       \" or \" (ns->relpath ns-sym :cljc)))\n\n(defmethod error-message :dynamic\n  [warning-type info]\n  (str (:name info) \" not declared ^:dynamic\"))\n\n(defmethod error-message :redef\n  [warning-type info]\n  (str (:sym info) \" already refers to: \" (symbol (str (:ns info)) (str (:sym info)))\n    \" being replaced by: \" (symbol (str (:ns-name info)) (str (:sym info)))))\n\n(defmethod error-message :redef-in-file\n  [warning-type info]\n  (str (:sym info) \" at line \" (:line info) \" is being replaced\"))\n\n(defmethod error-message :fn-var\n  [warning-type info]\n  (str (symbol (str (:ns-name info)) (str (:sym info)))\n    \" no longer fn, references are stale\"))\n\n(defmethod error-message :fn-arity\n  [warning-type info]\n  (str \"Wrong number of args (\" (:argc info) \") passed to \"\n    (or (:ctor info)\n      (:name info))))\n\n(defmethod error-message :fn-deprecated\n  [warning-type info]\n  (str (-> info :fexpr :info :name) \" is deprecated\"))\n\n(defmethod error-message :declared-arglists-mismatch\n  [warning-type info]\n  (str (symbol (str (:ns-name info)) (str (:sym info)))\n    \" declared arglists \" (:declared info)\n    \" mismatch defined arglists \" (:defined info)))\n\n(defmethod error-message :undeclared-ns-form\n  [warning-type info]\n  (str \"Invalid :refer, \" (:type info) \" \" (:lib info) \"/\" (:sym info) \" does not exist\"))\n\n(defmethod error-message :protocol-deprecated\n  [warning-type info]\n  (str \"Protocol \" (:protocol info) \" is deprecated\"))\n\n(defmethod error-message :undeclared-protocol-symbol\n  [warning-type info]\n  (str \"Can't resolve protocol symbol \" (:protocol info)))\n\n(defmethod error-message :invalid-protocol-symbol\n  [warning-type info]\n  (str \"Symbol \" (:protocol info) \" is not a protocol\"))\n\n(defmethod error-message :protocol-invalid-method\n  [warning-type info]\n  (if (:no-such-method info)\n    (str \"Bad method signature in protocol implementation, \"\n      (:protocol info) \" does not declare method called \" (:fname info))\n    (str \"Bad method signature in protocol implementation, \"\n      (:protocol info) \" \" (:fname info) \" does not declare arity \" (:invalid-arity info))))\n\n(defmethod error-message :protocol-duped-method\n  [warning-type info]\n  (str \"Duplicated methods in protocol implementation \" (:protocol info) \" \" (:fname info)))\n\n(defmethod error-message :protocol-multiple-impls\n  [warning-type info]\n  (str \"Protocol \" (:protocol info) \" implemented multiple times\"))\n\n(defmethod error-message :protocol-with-variadic-method\n  [warning-type info]\n  (str \"Protocol \" (:protocol info) \" declares method \"\n       (:name info) \" with variadic signature (&)\"))\n\n(defmethod error-message :protocol-impl-with-variadic-method\n  [warning-type info]\n  (str \"Protocol \" (:protocol info) \" implements method \"\n    (:name info) \" with variadic signature (&)\"))\n\n(defmethod error-message :protocol-impl-recur-with-target\n  [warning-type info]\n  (str \"Ignoring target object \\\"\" (pr-str (:form info)) \"\\\" passed in recur to protocol method head\"))\n\n(defmethod error-message :multiple-variadic-overloads\n  [warning-type info]\n  (str (:name info) \": Can't have more than 1 variadic overload\"))\n\n(defmethod error-message :variadic-max-arity\n  [warning-type info]\n  (str (:name info) \": Can't have fixed arity function with more params than variadic function\"))\n\n(defmethod error-message :overload-arity\n  [warning-type info]\n  (str (:name info) \": Can't have 2 overloads with same arity\"))\n\n(defmethod error-message :extending-base-js-type\n  [warning-type info]\n  (str \"Extending an existing JavaScript type - use a different symbol name \"\n       \"instead of \" (:current-symbol info) \" e.g \" (:suggested-symbol info)))\n\n(defmethod error-message :invalid-arithmetic\n  [warning-type info]\n  (str (:js-op info) \", all arguments must be numbers, got \" (:types info) \" instead\"))\n\n(defmethod error-message :invalid-array-access\n  [warning-type {:keys [name types]}]\n  (case name\n    (cljs.core/checked-aget cljs.core/checked-aget')\n    (str \"cljs.core/aget, arguments must be an array followed by numeric indices, got \" types \" instead\"\n      (when (or (= 'object (first types))\n                (every? #{'string} (rest types)))\n        (str \" (consider \"\n          (if (== 2 (count types))\n            \"goog.object/get\"\n            \"goog.object/getValueByKeys\")\n          \" for object access)\")))\n\n    (cljs.core/checked-aset cljs.core/checked-aset')\n    (str \"cljs.core/aset, arguments must be an array, followed by numeric indices, followed by a value, got \" types \" instead\"\n      (when (or (= 'object (first types))\n                (every? #{'string} (butlast (rest types))))\n        \" (consider goog.object/set for object access)\"))))\n\n(defmethod error-message :invoke-ctor\n  [warning-type info]\n  (str \"Cannot invoke type constructor \" (-> info :fexpr :info :name) \" as function \"))\n\n(defmethod error-message :single-segment-namespace\n  [warning-type info]\n  (str (:name info) \" is a single segment namespace\"))\n\n(defmethod error-message :munged-namespace\n  [warning-type {:keys [name] :as info}]\n  (let [munged (->> (string/split (clojure.core/name name) #\"\\.\")\n                 (map #(if (js-reserved %) (str % \"$\") %))\n                 (string/join \".\")\n                 (munge))]\n    (str \"Namespace \" name \" contains a reserved JavaScript keyword,\"\n         \" the corresponding Google Closure namespace will be munged to \" munged)))\n\n(defmethod error-message :ns-var-clash\n  [warning-type {:keys [ns var] :as info}]\n  (str \"Namespace \" ns \" clashes with var \" var))\n\n(defmethod error-message :non-dynamic-earmuffed-var\n  [warning-type {:keys [var] :as info}]\n  (str var \" not declared dynamic and thus is not dynamically rebindable, but its name \"\n    \"suggests otherwise. Please either indicate ^:dynamic \" var \" or change the name\"))\n\n(defmethod error-message :extend-type-invalid-method-shape\n  [warning-type {:keys [protocol method] :as info}]\n  (str \"Bad extend-type method shape for protocol \" protocol \" method \" method\n       \", method arities must be grouped together\"))\n\n(defmethod error-message :unsupported-js-module-type\n  [warning-type {:keys [module-type file] :as info}]\n  (str \"Unsupported JavaScript module type \" module-type \" for foreign library \"\n       file \".\"))\n\n(defmethod error-message :unsupported-preprocess-value\n  [warning-type {:keys [preprocess file]}]\n  (str \"Unsupported preprocess value \" preprocess \" for foreign library \"\n       file \".\"))\n\n(defmethod error-message :js-shadowed-by-local\n  [warning-type {:keys [name]}]\n  (str name \" is shadowed by a local\"))\n\n(defmethod error-message :infer-warning\n  [warning-type {:keys [warn-type form type property]}]\n  (case warn-type\n    :target   (str \"Cannot infer target type in expression \" form \"\")\n    :property (str \"Cannot resolve property \" property\n                   \" for inferred type \" type  \" in expression \" form)\n    :object   (str \"Adding extern to Object for property \" property \" due to \"\n                   \"ambiguous expression \" form)))\n\n(defn default-warning-handler [warning-type env extra]\n  (when (warning-type *cljs-warnings*)\n    (when-let [s (error-message warning-type extra)]\n      #?(:clj  (binding [*out* *err*]\n                 (println (message env (str \"WARNING: \" s))))\n         :cljs (binding [*print-fn* *print-err-fn*]\n                 (println (message env (str \"WARNING: \" s))))))))\n\n(def ^:dynamic *cljs-warning-handlers*\n  [default-warning-handler])\n\n#?(:clj\n   (defmacro with-warning-handlers [handlers & body]\n     `(binding [*cljs-warning-handlers* ~handlers]\n        ~@body)))\n\n(defn- repeat-char [c n]\n  (loop [ret c n n]\n    (if (pos? n)\n      (recur (str ret c) (dec n))\n      ret)))\n\n(defn- hex-format [s pad]\n  #?(:clj  (str \"_u\" (format (str \"%0\" pad \"x\") (int (first s))) \"_\")\n     :cljs (let [hex (.toString (.charCodeAt s 0) 16)\n                 len (. hex -length)\n                 hex (if (< len pad)\n                       (str (repeat-char \"0\" (- pad len)) hex)\n                       hex)]\n             (str \"_u\" hex \"_\"))))\n\n(defn gen-constant-id [value]\n  (let [prefix (cond\n                 (keyword? value) \"cst$kw$\"\n                 (symbol? value)  \"cst$sym$\"\n                 :else\n                 (throw\n                   #?(:clj (Exception. (str \"constant type \" (type value) \" not supported\"))\n                      :cljs (js/Error. (str \"constant type \" (type value) \" not supported\")))))\n        name   (if (keyword? value)\n                 (subs (str value) 1)\n                 (str value))\n        name   (if (= \".\" name)\n                 \"_DOT_\"\n                 (-> name\n                     (string/replace \"-\" \"_DASH_\")\n                     (munge)\n                     (string/replace \".\" \"$\")\n                     (string/replace #\"(?i)[^a-z0-9$_]\" #(hex-format % 4))))]\n    (symbol (str prefix name))))\n\n(defn- register-constant!\n  ([val] (register-constant! nil val))\n  ([env val]\n   (swap! env/*compiler*\n     (fn [cenv]\n       (cond->\n         (-> cenv\n           (update-in [::constant-table]\n             (fn [table]\n               (if (get table val)\n                 table\n                 (assoc table val (gen-constant-id val))))))\n         env (update-in [::namespaces (-> env :ns :name) ::constants]\n               (fn [{:keys [seen order] :or {seen #{} order []} :as constants}]\n                 (cond-> constants\n                   (not (contains? seen val))\n                   (assoc\n                     :seen (conj seen val)\n                     :order (conj order val))))))))))\n\n(def default-namespaces '{cljs.core {:name cljs.core}\n                          cljs.user {:name cljs.user}})\n\n;; this exists solely to support read-only namespace access from macros.\n;; External tools should look at the authoritative ::namespaces slot in the\n;; compiler-env atoms/maps they're using already; this value will yield only\n;; `default-namespaces` when accessed outside the scope of a\n;; compilation/analysis call\n(def namespaces\n  #?(:clj\n     (reify clojure.lang.IDeref\n       (deref [_]\n         (if (some? env/*compiler*)\n           (::namespaces @env/*compiler*)\n           default-namespaces)))\n     :cljs\n     (reify IDeref\n       (-deref [_]\n         (if (some? env/*compiler*)\n           (::namespaces @env/*compiler*)\n           default-namespaces)))))\n\n(defn get-namespace\n  ([key]\n    (get-namespace env/*compiler* key))\n  ([cenv key]\n   (if-some [ns (get-in @cenv [::namespaces key])]\n       ns\n       (when (= 'cljs.user key)\n         {:name 'cljs.user}))))\n\n#?(:clj\n   (defmacro no-warn [& body]\n     (let [no-warnings (zipmap (keys *cljs-warnings*) (repeat false))]\n       `(binding [*cljs-warnings* ~no-warnings]\n          ~@body))))\n\n#?(:clj\n   (defmacro all-warn [& body]\n     (let [all-warnings (zipmap (keys *cljs-warnings*) (repeat true))]\n       `(binding [*cljs-warnings* ~all-warnings]\n          ~@body))))\n\n(defn get-line [x env]\n  (or (-> x meta :line) (:line env)))\n\n(defn get-col [x env]\n  (or (-> x meta :column) (:column env)))\n\n(defn intern-macros\n  \"Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment.\"\n  ([ns] (intern-macros ns false))\n  ([ns reload]\n    (when (or (nil? (gets @env/*compiler* ::namespaces ns :macros))\n              reload)\n      (swap! env/*compiler* assoc-in [::namespaces ns :macros]\n        (->> #?(:clj (ns-interns ns) :cljs (ns-interns* ns))\n             (filter (fn [[_ ^Var v]] (.isMacro v)))\n             (map (fn [[k v]]\n                    [k (as-> (meta v) vm\n                         (let [ns (.getName ^Namespace (:ns vm))]\n                           (assoc vm\n                             :ns ns\n                             :name (symbol (str ns) (str k))\n                             :macro true)))]))\n             (into {}))))))\n\n#?(:clj\n   (def load-mutex (Object.)))\n\n#?(:clj\n   (defn load-core []\n     (when (not @-cljs-macros-loaded)\n       (reset! -cljs-macros-loaded true)\n       (if *cljs-macros-is-classpath*\n         (locking load-mutex\n           (load *cljs-macros-path*))\n         (locking load-mutex\n           (load-file *cljs-macros-path*))))\n     (intern-macros 'cljs.core)))\n\n#?(:clj\n   (defmacro with-core-macros\n     [path & body]\n     `(do\n        (when (not= *cljs-macros-path* ~path)\n          (reset! -cljs-macros-loaded false))\n        (binding [*cljs-macros-path* ~path]\n          ~@body))))\n\n#?(:clj\n   (defmacro with-core-macros-file\n     [path & body]\n     `(do\n        (when (not= *cljs-macros-path* ~path)\n          (reset! -cljs-macros-loaded false))\n        (binding [*cljs-macros-path* ~path\n                  *cljs-macros-is-classpath* false]\n          ~@body))))\n\n(defn empty-env\n  \"Construct an empty analysis environment. Required to analyze forms.\"\n  []\n  (ensure\n    {:ns (get-namespace *cljs-ns*)\n     :context :statement\n     :locals {}\n     :fn-scope []\n     :js-globals (into {}\n                   (map #(vector % {:op :js-var :name % :ns 'js})\n                     '(alert window document console escape unescape\n                       screen location navigator history location\n                       global process require module exports)))}))\n\n(defn- source-info->error-data\n  [{:keys [file line column]}]\n  {:clojure.error/source file\n   :clojure.error/line   line\n   :clojure.error/column column})\n\n(defn source-info\n  ([env]\n   (when (:line env)\n     (source-info nil env)))\n  ([name env]\n   (cond-> {:file (if (= (-> env :ns :name) 'cljs.core)\n                    \"cljs/core.cljs\"\n                    *cljs-file*)\n            :line (get-line name env)\n            :column (get-col name env)}\n     (:root-source-info env)\n     (merge (select-keys env [:root-source-info])))))\n\n(defn message [env s]\n  (str s\n    (if (:line env)\n      (str \" at line \" (:line env) \" \" *cljs-file*)\n      (when *cljs-file*\n        (str \" in file \" *cljs-file*)))))\n\n(defn warning [warning-type env extra]\n  (doseq [handler *cljs-warning-handlers*]\n    (handler warning-type env extra)))\n\n(defn- accumulating-warning-handler [warn-acc]\n  (fn [warning-type env extra]\n    (when (warning-type *cljs-warnings*)\n      (swap! warn-acc conj [warning-type env extra]))))\n\n(defn- replay-accumulated-warnings [warn-acc]\n  (run! #(apply warning %) @warn-acc))\n\n(defn- error-data\n  ([env phase]\n   (error-data env phase nil))\n  ([env phase symbol]\n   (merge (-> (source-info env) source-info->error-data)\n     {:clojure.error/phase phase}\n     (when symbol\n       {:clojure.error/symbol symbol}))))\n\n(defn- compile-syntax-error\n  [env msg symbol]\n  (ex-info nil (error-data env :compile-syntax-check symbol)\n    #?(:clj (RuntimeException. ^String msg) :cljs (js/Error. msg))))\n\n(defn error\n  ([env msg]\n   (error env msg nil))\n  ([env msg cause]\n   (ex-info (message env msg)\n     (assoc (source-info env) :tag :cljs/analysis-error)\n     cause)))\n\n(defn analysis-error?\n  #?(:cljs {:tag boolean})\n  [ex]\n  (= :cljs/analysis-error (:tag (ex-data ex))))\n\n(defn has-error-data?\n  #?(:cljs {:tag boolean})\n  [ex]\n  (contains? (ex-data ex) :clojure.error/phase))\n\n#?(:clj\n   (defmacro wrapping-errors [env & body]\n     `(try\n        ~@body\n        (catch Throwable err#\n          (cond\n            (has-error-data? err#) (throw err#)\n            (analysis-error? err#) (throw (ex-info nil (error-data ~env :compilation) err#))\n            :else (throw (ex-info nil (error-data ~env :compilation) (error ~env (.getMessage err#) err#))))))))\n\n;; namespaces implicit to the inclusion of cljs.core\n(def implicit-nses '#{goog goog.object goog.string goog.array Math String})\n\n(defn implicit-import?\n  #?(:cljs {:tag boolean})\n  [env prefix suffix]\n  (contains? implicit-nses prefix))\n\n(declare get-expander)\n\n(defn confirm-var-exist-warning [env prefix suffix]\n  (fn [env prefix suffix]\n    (warning :undeclared-var env\n      {:prefix         prefix\n       :suffix         suffix\n       :macro-present? (not (nil? (get-expander (symbol (str prefix) (str suffix)) env)))})))\n\n(defn loaded-js-ns?\n  \"Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked.\"\n  #?(:cljs {:tag boolean})\n  [env prefix]\n  (when-not (gets @env/*compiler* ::namespaces prefix)\n    (let [ns (:ns env)]\n      (or (some? (get (:requires ns) prefix))\n          (some? (get (:imports ns) prefix))))))\n\n(defn- internal-js-module-exists?\n  [js-module-index module]\n  ;; we need to check both keys and values of the JS module index, because\n  ;; macroexpansion will be looking for the provided name - Ant\u00F3nio Monteiro\n  (contains?\n    (into #{}\n      (mapcat (fn [[k v]]\n                [k (:name v)]))\n      js-module-index)\n    (str module)))\n\n(def js-module-exists?* (memoize internal-js-module-exists?))\n\n(defn js-module-exists?\n  [module]\n  (js-module-exists?* (get-in @env/*compiler* [:js-module-index]) module))\n\n(defn node-module-dep?\n  #?(:cljs {:tag boolean})\n  [module]\n  #?(:clj (contains?\n            (get-in @env/*compiler* [:node-module-index])\n            (str module))\n     :cljs (try\n             (and (= *target* \"nodejs\")\n                  (boolean (js/require.resolve (str module))))\n             (catch :default _\n               false))))\n\n(defn dep-has-global-exports?\n  [module]\n  (let [global-exports (get-in @env/*compiler* [:js-dependency-index (str module) :global-exports])]\n    (or (contains? global-exports (symbol module))\n        (contains? global-exports (name module)))))\n\n(defn confirm-var-exists\n  ([env prefix suffix]\n   (let [warn (confirm-var-exist-warning env prefix suffix)]\n     (confirm-var-exists env prefix suffix warn)))\n  ([env prefix suffix missing-fn]\n   (let [sufstr     (str suffix)\n         suffix-str (if (and #?(:clj  (not= \"..\" sufstr)\n                                :cljs (not (identical? \"..\" sufstr))) ;; leave cljs.core$macros/.. alone\n                          #?(:clj  (re-find #\"\\.\" sufstr)\n                             :cljs ^boolean (.test #\"\\.\" sufstr)))\n                      (first (string/split sufstr #\"\\.\"))\n                      suffix)\n         suffix     (symbol suffix-str)]\n     (when (and (not (implicit-import? env prefix suffix))\n                (not (loaded-js-ns? env prefix))\n                (not (and (= 'cljs.core prefix) (= 'unquote suffix)))\n                (nil? (gets @env/*compiler* ::namespaces prefix :defs suffix))\n                (not (js-module-exists? prefix)))\n       (missing-fn env prefix suffix)))))\n\n(defn confirm-var-exists-throw []\n  (fn [env prefix suffix]\n    (confirm-var-exists env prefix suffix\n      (fn [env prefix suffix]\n        (throw (error env (str \"Unable to resolve var: \" suffix \" in this context\")))))))\n\n(defn resolve-ns-alias\n  ([env name]\n   (resolve-ns-alias env name (symbol name)))\n  ([env name not-found]\n   (let [sym (symbol name)]\n     (get (:requires (:ns env)) sym not-found))))\n\n(defn resolve-macro-ns-alias\n  ([env name]\n   (resolve-macro-ns-alias env name (symbol name)))\n  ([env name not-found]\n   (let [sym (symbol name)]\n     (get (:require-macros (:ns env)) sym not-found))))\n\n(defn confirm-ns\n  \"Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found.\"\n  [env ns-sym]\n  (when (and (not= 'cljs.core ns-sym)\n             (nil? (get implicit-nses ns-sym))\n             (nil? (get (-> env :ns :requires) ns-sym))\n             ;; something else may have loaded the namespace, i.e. load-file\n             (nil? (gets @env/*compiler* ::namespaces ns-sym))\n             ;; macros may refer to namespaces never explicitly required\n             ;; confirm that the library at least exists\n             #?(:clj (nil? (util/ns->source ns-sym)))\n             (not (js-module-exists? ns-sym)))\n    (warning :undeclared-ns env {:ns-sym ns-sym :js-provide ns-sym})))\n\n(defn core-name?\n  \"Is sym visible from core in the current compilation namespace?\"\n  #?(:cljs {:tag boolean})\n  [env sym]\n  (and (or (some? (gets @env/*compiler* ::namespaces 'cljs.core :defs sym))\n           (if-some [mac (get-expander sym env)]\n             (let [^Namespace ns (-> mac meta :ns)]\n               (= (.getName ns) #?(:clj 'cljs.core :cljs 'cljs.core$macros)))\n             false))\n       (not (contains? (-> env :ns :excludes) sym))))\n\n(defn public-name?\n  \"Is sym public?\"\n  #?(:cljs {:tag boolean})\n  [ns sym]\n  (let [var-ast (or (gets @env/*compiler* ::namespaces ns :defs sym)\n                    #?(:clj  (gets @env/*compiler* ::namespaces ns :macros sym)\n                       :cljs (gets @env/*compiler* ::namespaces (symbol (str (name ns) \"$macros\")) :defs sym)))]\n    (and (some? var-ast)\n         (not (or (:private var-ast)\n                  (:anonymous var-ast))))))\n\n(defn js-tag? [x]\n  (and (symbol? x)\n       (or (= 'js x)\n           (= \"js\" (namespace x)))))\n\n(defn normalize-js-tag [x]\n  ;; if not 'js, assume constructor\n  (if-not (= 'js x)\n    (with-meta 'js\n      {:prefix (conj (->> (string/split (name x) #\"\\.\")\n                       (map symbol) vec)\n                 'prototype)})\n    x))\n\n(defn ->type-set\n  \"Ensures that a type tag is a set.\"\n  [t]\n  (if #?(:clj  (set? t)\n         :cljs (cljs-set? t))\n    t\n    #{t}))\n\n(defn canonicalize-type [t]\n  \"Ensures that a type tag is either nil, a type symbol, or a non-singleton\n  set of type symbols, absorbing clj-nil into seq and all types into any.\"\n  (cond\n    (symbol? t) t\n    (empty? t) nil\n    (== 1 (count t)) (first t)\n    (contains? t 'any) 'any\n    (contains? t 'seq) (let [res (disj t 'clj-nil)]\n                         (if (== 1 (count res))\n                           'seq\n                           res))\n    :else t))\n\n(defn add-types\n  \"Produces a union of types.\"\n  ([] 'any)\n  ([t1] t1)\n  ([t1 t2]\n   (if (or (nil? t1)\n           (nil? t2))\n     'any\n     (-> (set/union (->type-set t1) (->type-set t2))\n       canonicalize-type)))\n  ([t1 t2 & ts]\n   (apply add-types (add-types t1 t2) ts)))\n\n(def alias->type\n  '{object   Object\n    string   String\n    number   Number\n    array    Array\n    function Function\n    boolean  Boolean\n    symbol   Symbol})\n\n(defn has-extern?*\n  ([pre externs]\n   (let [pre (if-some [me (find\n                            (get-in externs '[Window prototype])\n                            (first pre))]\n               (if-some [tag (-> me first meta :tag)]\n                 (into [tag 'prototype] (next pre))\n                 pre)\n               pre)]\n     (has-extern?* pre externs externs)))\n  ([pre externs top]\n   (cond\n     (empty? pre) true\n     :else\n     (let [x  (first pre)\n           me (find externs x)]\n       (cond\n         (not me) false\n         :else\n         (let [[x' externs'] me\n               xmeta (meta x')]\n           (if (and (= 'Function (:tag xmeta)) (:ctor xmeta))\n             (or (has-extern?* (into '[prototype] (next pre)) externs' top)\n                 (has-extern?* (next pre) externs' top))\n             (recur (next pre) externs' top))))))))\n\n(defn has-extern?\n  ([pre]\n    (has-extern? pre (get @env/*compiler* ::externs)))\n  ([pre externs]\n   (or (has-extern?* pre externs)\n       (when (= 1 (count pre))\n         (let [x (first pre)]\n           (or (get-in externs (conj '[Window prototype] x))\n               (get-in externs (conj '[Number] x)))))\n       (-> (last pre) str (string/starts-with? \"cljs$\")))))\n\n(defn js-tag\n  ([pre]\n   (js-tag pre :tag))\n  ([pre tag-type]\n   (js-tag pre tag-type (get @env/*compiler* ::externs)))\n  ([pre tag-type externs]\n   (js-tag pre tag-type externs externs))\n  ([pre tag-type externs top]\n   (when-let [[p externs' :as me] (find externs (first pre))]\n     (let [tag (-> p meta tag-type)]\n       (if (= (count pre) 1)\n         (when tag (symbol \"js\" (str (alias->type tag tag))))\n         (or (js-tag (next pre) tag-type externs' top)\n             (js-tag (into '[prototype] (next pre)) tag-type (get top tag) top)))))))\n\n(defn dotted-symbol? [sym]\n  (let [s (str sym)]\n    #?(:clj  (and (.contains s \".\")\n                  (not (.contains s \"..\")))\n       :cljs (and ^boolean (goog.string/contains s \".\")\n                  (not ^boolean (goog.string/contains s \"..\"))))))\n\n(defn munge-node-lib [name]\n  (str \"node$module$\" (munge (string/replace (str name) #\"[.\\/]\" #?(:clj \"\\\\$\"\n                                                                    :cljs \"$$\")))))\n\n(defn munge-global-export [name]\n  (str \"global$module$\" (munge (string/replace (str name) #\"[.\\/]\" #?(:clj \"\\\\$\"\n                                                                      :cljs \"$$\")))))\n\n(defn resolve-alias\n  \"Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original.\"\n  [ns sym]\n  ;; Conditionally alias aget/aset fns to checked variants\n  (if (and (= 'cljs.core ns)\n           ('#{aget aset} sym)\n           (checked-arrays))\n    (get-in '{:warn  {aget checked-aget\n                      aset checked-aset}\n              :error {aget checked-aget'\n                      aset checked-aset'}}\n      [(checked-arrays) sym])\n    sym))\n\n(defn ns->module-type [ns]\n  (cond\n    (js-module-exists? ns) :js\n    (node-module-dep? ns) :node\n    (dep-has-global-exports? ns) :global))\n\n(defmulti resolve* (fn [env sym full-ns current-ns] (ns->module-type full-ns)))\n\n(defmethod resolve* :js\n  [env sym full-ns current-ns]\n  {:name (symbol (str full-ns) (str (name sym)))\n   :op :js-var\n   :ns full-ns})\n\n(defmethod resolve* :node\n  [env sym full-ns current-ns]\n  {:name (symbol (str current-ns) (str (munge-node-lib full-ns) \".\" (name sym)))\n   :op :js-var\n   :ns current-ns})\n\n(defmethod resolve* :global\n  [env sym full-ns current-ns]\n  (let [pre (into '[Object] (->> (string/split (name sym) #\"\\.\") (map symbol) vec))]\n    (when-not (has-extern? pre)\n      (swap! env/*compiler* update-in\n        (into [::namespaces current-ns :externs] pre) merge {}))\n    {:name (symbol (str current-ns) (str (munge-global-export full-ns) \".\" (name sym)))\n     :op :js-var\n     :ns current-ns\n     :tag (with-meta 'js {:prefix pre})}))\n\n(def ^:private private-var-access-exceptions\n  \"Specially-treated symbols for which we don't trigger :private-var-access warnings.\"\n  '#{cljs.core/checked-aget\n     cljs.core/checked-aset\n     cljs.core/checked-aget'\n     cljs.core/checked-aset'})\n\n(defmethod resolve* :default\n  [env sym full-ns current-ns]\n  (let [sym-ast (gets @env/*compiler* ::namespaces full-ns :defs (symbol (name sym)))\n        sym-name (symbol (str full-ns) (str (name sym)))]\n    (when (and (not= current-ns full-ns)\n               (:private sym-ast)\n               (not *private-var-access-nowarn*)\n               (not (contains? private-var-access-exceptions sym-name)))\n      (warning :private-var-access env\n        {:sym sym-name}))\n    (merge sym-ast\n      {:name sym-name\n       :op :var\n       :ns   full-ns})))\n\n(defn required? [ns env]\n  (or (contains? (set (vals (gets env :ns :requires))) ns)\n      (contains? (set (vals (gets env :ns :uses))) ns)))\n\n(defn invokeable-ns?\n  \"Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function.\"\n  [ns env]\n  (let [ns (resolve-ns-alias env ns)]\n    (and (required? ns env)\n         (or (js-module-exists? ns)\n             (node-module-dep? ns)\n             (dep-has-global-exports? ns)))))\n\n(defn resolve-invokeable-ns [ns current-ns env]\n  (let [ns (resolve-ns-alias env ns)\n        module-type (ns->module-type ns)]\n    (case module-type\n      :js     {:name (symbol\n                       (or (gets @env/*compiler* :js-module-index ns :name)\n                           (resolve-ns-alias env ns)))\n               :op :js-var\n               :ns 'js}\n      :node   {:name (symbol (str current-ns)\n                       (munge-node-lib (resolve-ns-alias env ns)))\n               :op :js-var\n               :ns current-ns}\n      :global {:name (symbol (str current-ns)\n                       (munge-global-export (resolve-ns-alias env ns)))\n               :op :js-var\n               :ns current-ns})))\n\n;; core.async calls `macroexpand-1` manually with an ill-formed\n;; :locals map. Normally :locals maps symbols maps, but\n;; core.async adds entries mapping symbols to symbols. We work\n;; around that specific case here. This is called defensively\n;; every time we lookup the :locals map.\n(defn handle-symbol-local [sym lb]\n  (if (symbol? lb)\n    {:name sym}\n    lb))\n\n(defn resolve-var\n  \"Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars.\"\n  ([env sym] (resolve-var env sym nil))\n  ([env sym confirm]\n   (let [locals (:locals env)]\n     (if #?(:clj  (= \"js\" (namespace sym))\n            :cljs (identical? \"js\" (namespace sym)))\n       (let [symn (-> sym name symbol)\n             shadowed-by-local (handle-symbol-local symn (get locals symn))]\n         (cond\n           (some? shadowed-by-local)\n           (do (warning :js-shadowed-by-local env {:name sym})\n               (assoc shadowed-by-local :op :local))\n\n           :else\n           (let [pre (->> (string/split (name sym) #\"\\.\") (map symbol) vec)]\n             (when (and (not (has-extern? pre))\n                        ;; ignore exists? usage\n                        (not (-> sym meta ::no-resolve)))\n               (swap! env/*compiler* update-in\n                 (into [::namespaces (-> env :ns :name) :externs] pre) merge {}))\n             (merge\n               {:name sym\n                :op :js-var\n                :ns   'js\n                :tag  (with-meta (or (js-tag pre) (:tag (meta sym)) 'js) {:prefix pre})}\n               (when-let [ret-tag (js-tag pre :ret-tag)]\n                 {:js-fn-var true\n                  :ret-tag ret-tag})))))\n       (let [s  (str sym)\n             lb (handle-symbol-local sym (get locals sym))\n             current-ns (-> env :ns :name)]\n         (cond\n           (some? lb) (assoc lb :op :local)\n\n           (some? (namespace sym))\n           (let [ns      (namespace sym)\n                 ns      (if #?(:clj  (= \"clojure.core\" ns)\n                                :cljs (identical? \"clojure.core\" ns))\n                           \"cljs.core\"\n                           ns)\n                 full-ns (resolve-ns-alias env ns\n                           (or (and (js-module-exists? ns)\n                                    (gets @env/*compiler* :js-module-index ns :name))\n                             (symbol ns)))]\n             (when (some? confirm)\n               (when (not= current-ns full-ns)\n                 (confirm-ns env full-ns))\n               (confirm env full-ns (symbol (name sym))))\n             (resolve* env sym full-ns current-ns))\n\n           (dotted-symbol? sym)\n           (let [idx    (.indexOf s \".\")\n                 prefix (symbol (subs s 0 idx))\n                 suffix (subs s (inc idx))]\n             (if-some [lb (handle-symbol-local prefix (get locals prefix))]\n               {:op :local\n                :name (symbol (str (:name lb) \".\" suffix))}\n               (if-some [full-ns (gets @env/*compiler* ::namespaces current-ns :imports prefix)]\n                 {:op :js-var\n                  :name (symbol (str full-ns) suffix)}\n                 (if-some [info (gets @env/*compiler* ::namespaces current-ns :defs prefix)]\n                   (merge info\n                     {:name (symbol (str current-ns) (str sym))\n                      :op :var\n                      :ns current-ns})\n                   (merge (gets @env/*compiler* ::namespaces prefix :defs (symbol suffix))\n                     {:name (if (= \"\" prefix) (symbol suffix) (symbol (str prefix) suffix))\n                      :op :var\n                      :ns prefix})))))\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :uses sym))\n           (let [full-ns (gets @env/*compiler* ::namespaces current-ns :uses sym)]\n             (resolve* env sym full-ns current-ns))\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :renames sym))\n           (let [qualified-symbol (gets @env/*compiler* ::namespaces current-ns :renames sym)\n                 full-ns (symbol (namespace qualified-symbol))\n                 sym     (symbol (name qualified-symbol))]\n             (resolve* env sym full-ns current-ns))\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :imports sym))\n           (recur env (gets @env/*compiler* ::namespaces current-ns :imports sym) confirm)\n\n           (some? (gets @env/*compiler* ::namespaces current-ns :defs sym))\n           (do\n             (when (some? confirm)\n               (confirm env current-ns sym))\n             (merge (gets @env/*compiler* ::namespaces current-ns :defs sym)\n               {:name (symbol (str current-ns) (str sym))\n                :op :var\n                :ns current-ns}))\n\n           (core-name? env sym)\n           (do\n             (when (some? confirm)\n               (confirm env 'cljs.core sym))\n             (merge (gets @env/*compiler* ::namespaces 'cljs.core :defs sym)\n               {:name (symbol \"cljs.core\" (str sym))\n                :op :var\n                :ns 'cljs.core}))\n\n           (invokeable-ns? s env)\n           (resolve-invokeable-ns s current-ns env)\n\n           :else\n           (do\n             (when (some? confirm)\n               (confirm env current-ns sym))\n             (merge (gets @env/*compiler* ::namespaces current-ns :defs sym)\n               {:name (symbol (str current-ns) (str sym))\n                :op :var\n                :ns current-ns}))))))))\n\n(defn resolve-existing-var\n  \"Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists.\"\n  [env sym]\n  (if-not (-> sym meta ::no-resolve)\n    (resolve-var env sym confirm-var-exists)\n    (resolve-var env sym)))\n\n(defn confirm-bindings\n  \"Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars.\"\n  [env names]\n  (doseq [name names]\n    (let [env (assoc env :ns (get-namespace *cljs-ns*))\n          ev (resolve-existing-var env name)]\n      (when (and ev (not (-> ev :dynamic)))\n        (warning :dynamic env {:ev ev :name (:name ev)})))))\n\n(defn resolve-macro-var\n  \"Given env, an analysis environment, and sym, a symbol, resolve a macro.\"\n  [env sym]\n  (let [ns (-> env :ns :name)\n        namespaces (get @env/*compiler* ::namespaces)]\n    (cond\n      (some? (namespace sym))\n      (let [ns (namespace sym)\n            ns (if (= \"clojure.core\" ns) \"cljs.core\" ns)\n            full-ns (resolve-macro-ns-alias env ns)\n            #?@(:cljs [full-ns (if-not (string/ends-with? (str full-ns) \"$macros\")\n                                 (symbol (str full-ns \"$macros\"))\n                                 full-ns)])]\n        #?(:clj (get-in namespaces [full-ns :macros (symbol (name sym))])\n           :cljs (get-in namespaces [full-ns :defs (symbol (name sym))])))\n\n      (some? (get-in namespaces [ns :use-macros sym]))\n      (let [full-ns (get-in namespaces [ns :use-macros sym])]\n        (get-in namespaces [full-ns :macros sym]))\n\n      (some? (get-in namespaces [ns :rename-macros sym]))\n      (let [qualified-symbol (get-in namespaces [ns :rename-macros sym])\n            full-ns (symbol (namespace qualified-symbol))\n            sym     (symbol (name qualified-symbol))]\n        (get-in namespaces [full-ns :macros sym]))\n\n      :else\n      (let [ns (cond\n                 (some? (get-in namespaces [ns :macros sym])) ns\n                 (core-name? env sym) #?(:clj  'cljs.core\n                                         :cljs CLJS_CORE_MACROS_SYM))]\n        (when (some? ns)\n          #?(:clj  (get-in namespaces [ns :macros sym])\n             :cljs (get-in namespaces [ns :defs sym])))))))\n\n(declare analyze analyze-symbol analyze-seq)\n\n;; Note: This is the set of parse multimethod dispatch values,\n;; along with '&, and differs from cljs.core/special-symbol?\n(def specials '#{if def fn* do let* loop* letfn* throw try recur new set!\n                 ns deftype* defrecord* . js* & quote case* var ns*})\n\n(def ^:dynamic *recur-frames* nil)\n(def ^:dynamic *loop-lets* ())\n(def ^:dynamic *allow-redef* false)\n(def ^:dynamic *allow-ns* true)\n\n#?(:clj\n   (defmacro disallowing-recur [& body]\n     `(binding [*recur-frames* (cons nil *recur-frames*)] ~@body)))\n\n#?(:clj\n   (defmacro allowing-redef [& body]\n     `(binding [*allow-redef* true] ~@body)))\n\n#?(:clj\n   (defmacro disallowing-ns* [& body]\n     `(binding [*allow-ns* false] ~@body)))\n\n;; TODO: move this logic out - David\n(defn analyze-keyword\n  [env sym]\n  (register-constant! env sym)\n  {:op :const :val sym :env env :form sym :tag 'cljs.core/Keyword})\n\n(defn get-tag [e]\n  (if-some [tag (-> e :form meta :tag)]\n    tag\n    (if-some [tag (-> e :tag)]\n      tag\n      (-> e :info :tag))))\n\n(defn find-matching-method [f params]\n  ;; if local fn, need to look in :info\n  (let [methods (or (:methods f) (-> f :info :methods))\n        c       (count params)]\n    (some\n      (fn [m]\n        (and (or (== (:fixed-arity m) c)\n                 (:variadic? m))\n             m))\n      methods)))\n\n(defn type?\n  #?(:cljs {:tag boolean})\n  [env t]\n  ;; don't use resolve-existing-var to avoid warnings\n  (when (and (some? t) (symbol? t))\n    (let [var (resolve-var env t)]\n      (if-some [type (:type var)]\n        type\n          (if-some [type (-> var :info :type)]\n            type\n              (if-some [proto (:protocol-symbol var)]\n                proto\n                (get '#{cljs.core/PersistentHashMap cljs.core/List} t)))))))\n\n(declare infer-tag)\n\n(def NOT_NATIVE '#{clj not-native})\n\n(def BOOLEAN_OR_SEQ '#{boolean seq})\n\n(defn unwrap-quote [{:keys [op] :as expr}]\n  (if #?(:clj (= op :quote)\n         :cljs (keyword-identical? op :quote))\n    (:expr expr)\n    expr))\n\n(defn infer-if [env e]\n  (let [{:keys [op form]} (unwrap-quote (:test e))\n        then-tag (infer-tag env (:then e))]\n    (if (and #?(:clj (= op :const)\n                :cljs (keyword-identical? op :const))\n             (not (nil? form))\n             (not (false? form)))\n      then-tag\n      (let [else-tag (infer-tag env (:else e))]\n        (cond\n          (or #?(:clj (= then-tag else-tag)\n                 :cljs (symbol-identical? then-tag else-tag))\n              #?(:clj (= else-tag IGNORE_SYM)\n                 :cljs (symbol-identical? else-tag IGNORE_SYM))) then-tag\n          #?(:clj (= then-tag IGNORE_SYM)\n             :cljs (symbol-identical? then-tag IGNORE_SYM)) else-tag\n          ;; TODO: temporary until we move not-native -> clj - David\n          (and (or (some? (get NOT_NATIVE then-tag)) (type? env then-tag))\n               (or (some? (get NOT_NATIVE else-tag)) (type? env else-tag)))\n          'clj\n          :else\n          (if (and (some? (get BOOLEAN_OR_SEQ then-tag))\n                   (some? (get BOOLEAN_OR_SEQ else-tag)))\n            'seq\n            (let [then-tag (if #?(:clj (set? then-tag)\n                                  :cljs (cljs-set? then-tag))\n                             then-tag #{then-tag})\n                  else-tag (if #?(:clj (set? else-tag)\n                                  :cljs (cljs-set? else-tag))\n                             else-tag #{else-tag})]\n              (into then-tag else-tag))))))))\n\n(defn infer-invoke [env {f :fn :keys [args] :as e}]\n  (let [me (assoc (find-matching-method f args) :op :fn-method)]\n    (if-some [ret-tag (infer-tag env me)]\n      ret-tag\n      (let [{:keys [info]} f]\n        (if-some [ret-tag (if (or (true? (:fn-var info))\n                                  (true? (:js-fn-var info)))\n                            (:ret-tag info)\n                            (when (= 'js (:ns info)) 'js))]\n          ret-tag\n          ANY_SYM)))))\n\n(defn infer-tag\n  \"Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node\"\n  [env e]\n    (if-some [tag (get-tag e)]\n      tag\n      (case (:op e)\n        :recur    IGNORE_SYM\n        :throw    IGNORE_SYM\n        :let      (infer-tag env (:body e))\n        :loop     (infer-tag env (:body e))\n        :do       (infer-tag env (:ret e))\n        :fn-method (infer-tag env (:body e))\n        :def      (infer-tag env (:init e))\n        :invoke   (infer-invoke env e)\n        :if       (infer-if env e)\n        :const    (case (:form e)\n                    true BOOLEAN_SYM\n                    false BOOLEAN_SYM\n                    ANY_SYM)\n        :quote    (infer-tag env (:expr e))\n        (:var :local :js-var :binding)\n                  (if-some [init (:init e)]\n                    (infer-tag env init)\n                    (infer-tag env (:info e)))\n        (:host-field :host-call)      ANY_SYM\n        :js       ANY_SYM\n        nil)))\n\n(defmulti parse (fn [op & rest] op))\n\n(defn var-meta\n  ([var]\n    (var-meta var nil))\n  ([var expr-env]\n   (let [sym (:name var)\n         ks [:ns :doc :file :line :column]\n         m (merge\n             (let [user-meta (:meta var)\n                   uks (keys user-meta)]\n               (zipmap uks\n                 (map #(list 'quote (get user-meta %)) uks)))\n             (assoc (zipmap ks (map #(list 'quote (get var %)) ks))\n               :name `(quote ~(symbol (name (:name var))))\n               :test `(when ~sym (.-cljs$lang$test ~sym))\n               :arglists (let [arglists (:arglists var)\n                               arglists' (if (= 'quote (first arglists))\n                                           (second arglists)\n                                           arglists)]\n                           (list 'quote\n                             (doall (map with-meta arglists'\n                                      (:arglists-meta var)))))))]\n     (if expr-env\n       (analyze expr-env m)\n       m))))\n\n(defn var-ast\n  [env sym]\n  ;; we need to dissoc locals for the `(let [x 1] (def x x))` case, because we\n  ;; want the var's AST and `resolve-var` will check locals first. - Ant\u00F3nio Monteiro\n  (binding [*private-var-access-nowarn* true]\n    (let [env      (dissoc env :locals)\n          var      (resolve-var env sym (confirm-var-exists-throw))\n          expr-env (assoc env :context :expr)]\n      (when-some [var-ns (:ns var)]\n        {:var  (analyze expr-env sym)\n         :sym  (analyze expr-env `(quote ~(symbol (name var-ns) (name (:name var)))))\n         :meta (var-meta var expr-env)}))))\n\n(defmethod parse 'var\n  [op env [_ sym :as form] _ _]\n  (when (not= 2 (count form))\n    (throw (error env \"Wrong number of args to var\")))\n  (when-not (symbol? sym)\n    (throw (error env \"Argument to var must be symbol\")))\n  (merge\n    {:env env\n     :op :the-var\n     :children [:var :sym :meta]\n     :form form}\n    (var-ast env sym)))\n\n(def ^:private predicate->tag\n  '{\n    ;; Base values\n    cljs.core/nil?            clj-nil\n    cljs.core/undefined?      clj-nil\n    cljs.core/false?          boolean\n    cljs.core/true?           boolean\n    cljs.core/zero?           number\n    cljs.core/infinite?       number\n\n    ;; Base types\n    cljs.core/boolean?        boolean\n    cljs.core/string?         string\n    cljs.core/char?           string\n    cljs.core/number?         number\n    cljs.core/integer?        number\n    cljs.core/float?          number\n    cljs.core/double?         number\n    cljs.core/array?          array\n    cljs.core/seq?            seq\n\n    ;; JavaScript types\n    cljs.core/regexp?         js/RegExp\n\n    ;; Types\n    cljs.core/keyword?        cljs.core/Keyword\n    cljs.core/var?            cljs.core/Var\n    cljs.core/symbol?         cljs.core/Symbol\n    cljs.core/volatile?       cljs.core/Volatile\n    cljs.core/delay?          cljs.core/Delay\n    cljs.core/reduced?        cljs.core/Reduced\n\n    ;;; Note: For non-marker protocol entries below, we\n    ;;; omit predicates that are based on satisfies? because\n    ;;; we cannot safely apply the fast-path optimization\n    ;;; which is enabled when the protocol type is inferred.\n    ;;; If adding a non-marker entry here, also add a test to\n    ;;; cljs.extend-to-native-test/test-extend-to-protocols.\n\n    ;; Protocols\n    cljs.core/map-entry?      cljs.core/IMapEntry\n    cljs.core/uuid?           cljs.core/IUUID\n    cljs.core/tagged-literal? cljs.core/ITaggedLiteral\n    cljs.core/inst?           cljs.core/Inst\n    cljs.core/sequential?     cljs.core/ISequential\n    cljs.core/list?           cljs.core/IList\n    cljs.core/record?         cljs.core/IRecord\n    cljs.core/chunked-seq?    cljs.core/IChunkedSeq\n\n    ;; Composites\n    cljs.core/seqable?        #{cljs.core/ISeqable array string}\n    cljs.core/ident?          #{cljs.core/Keyword cljs.core/Symbol}\n    })\n\n(defn- simple-predicate-induced-tag\n  \"Look for a predicate-induced tag when the test expression is a simple\n   application of a predicate to a local, as in (string? x).\"\n  [env test]\n  (when (and (list? test)\n             (== 2 (count test))\n             (every? symbol? test))\n    (let [analyzed-fn (no-warn (analyze (assoc env :context :expr) (first test)))]\n      (when (= :var (:op analyzed-fn))\n        (when-let [tag (predicate->tag (:name analyzed-fn))]\n          (let [sym (last test)]\n            (when (and (nil? (namespace sym))\n                       (get-in env [:locals sym]))\n              [sym tag])))))))\n\n(defn- type-check-induced-tag\n  \"Look for a type-check-induced tag when the test expression is the use of\n   instance? on a local, as in (instance? ICounted x).\"\n  [env test]\n  (when (and (list? test)\n             (== 3 (count test))\n             (every? symbol? test))\n    (let [analyzed-fn (no-warn (analyze (assoc env :context :expr) (first test)))]\n      (when (= :var (:op analyzed-fn))\n        (when ('#{cljs.core/instance?} (:name analyzed-fn))\n          (let [analyzed-type (no-warn (analyze (assoc env :context :expr) (second test)))\n                tag (:name analyzed-type)\n                sym (last test)]\n            (when (and (= :var (:op analyzed-type))\n                       (nil? (namespace sym))\n                       (get-in env [:locals sym]))\n              [sym tag])))))))\n\n(defn- truth-induced-tag\n  \"Refine a tag to exclude clj-nil if the test is a simple symbol.\"\n  [env test]\n  (when (and (symbol? test)\n             (nil? (namespace test)))\n    (let [analyzed-symbol (no-warn (analyze (assoc env :context :expr) test))]\n      (when-let [tag (:tag analyzed-symbol)]\n        (when (and (set? tag)\n                   (contains? tag 'clj-nil))\n          [test (canonicalize-type (disj tag 'clj-nil))])))))\n\n(defn- set-test-induced-tags\n  \"Looks at the test and sets any tags which are induced by virtue\n  of the test being truthy. For example in (if (string? x) x :bar)\n  the local x in the then branch must be of string type.\"\n  [env test]\n  (let [[local tag] (or (simple-predicate-induced-tag env test)\n                        (type-check-induced-tag env test)\n                        (truth-induced-tag env test))]\n    (cond-> env\n      local (assoc-in [:locals local :tag] tag))))\n\n(defmethod parse 'if\n  [op env [_ test then else :as form] name _]\n  (when (< (count form) 3)\n    (throw (compile-syntax-error env \"Too few arguments to if\" 'if)))\n  (when (> (count form) 4)\n    (throw (compile-syntax-error env \"Too many arguments to if\" 'if)))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (allowing-redef (analyze (set-test-induced-tags env test) then))\n        else-expr (allowing-redef (analyze env else))]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked *unchecked-if*\n     :children [:test :then :else]}))\n\n(defmethod parse 'case*\n  [op env [_ sym tests thens default :as form] name _]\n  (assert (symbol? sym) \"case* must switch on symbol\")\n  (assert (every? vector? tests) \"case* tests must be grouped in vectors\")\n  (let [expr-env (assoc env :context :expr)\n        v        (disallowing-recur (analyze expr-env sym))\n        tests    (mapv #(mapv (fn [t] (analyze expr-env t)) %) tests)\n        thens    (mapv #(analyze env %) thens)\n        nodes    (mapv (fn [tests then]\n                         {:op :case-node\n                          ;synthetic node, no :form\n                          :env env\n                          :tests (mapv (fn [test]\n                                         {:op :case-test\n                                          :form (:form test)\n                                          :env expr-env\n                                          :test test\n                                          :children [:test]})\n                                       tests)\n                          :then {:op :case-then\n                                 :form (:form then)\n                                 :env env\n                                 :then then\n                                 :children [:then]}\n                          :children [:tests :then]})\n                       tests\n                       thens)\n        default  (analyze env default)]\n    (assert (every? (fn [t]\n                      (or\n                        (-> t :info :const)\n                        (and (= :const (:op t))\n                             ((some-fn number? string? char?) (:form t)))))\n              (apply concat tests))\n      \"case* tests must be numbers, strings, or constants\")\n    {:env env :op :case :form form\n     :test v :nodes nodes :default default\n     :children [:test :nodes :default]}))\n\n(defmethod parse 'throw\n  [op env [_ throw-form :as form] name _]\n  (cond\n    (= 1 (count form))\n    (throw\n      (error env \"Too few arguments to throw, throw expects a single Error instance\"))\n    (< 2 (count form))\n    (throw\n      (error env \"Too many arguments to throw, throw expects a single Error instance\")))\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw-form))]\n    {:env env :op :throw :form form\n     :exception throw-expr\n     :children [:exception]}))\n\n(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (-> (disallowing-recur (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n                      (assoc :body? true)))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (disallowing-recur (analyze (assoc catchenv :locals locals) cblock)))\n        try (disallowing-recur (analyze (if (or e finally) catchenv env) `(do ~@body)))]\n\n    {:env env :op :try :form form\n     :body (assoc try :body? true)\n     :finally finally\n     :name e\n     :catch catch\n     :children (vec\n                 (concat [:body]\n                         (when catch\n                           [:catch])\n                         (when finally\n                           [:finally])))}))\n\n(defn valid-proto [x]\n  (when (symbol? x) x))\n\n(defn elide-env [env ast opts]\n  (dissoc ast :env))\n\n(defn replace-env-pass [new-env]\n  (fn [env ast opts]\n    (assoc ast :env new-env)))\n\n(defn ast-children [ast]\n  (mapcat (fn [c]\n            (let [g (get ast c)]\n              (cond\n                (vector? g) g\n                g [g])))\n          (:children ast)))\n\n(defn constant-value?\n  [{:keys [op] :as ast}]\n  (or (#{:quote :const} op)\n      (and (#{:map :set :vector} op)\n           (every? constant-value? (ast-children ast)))))\n\n(defn const-expr->constant-value [{:keys [op] :as e}]\n  (case op\n    :quote  (const-expr->constant-value (:expr e))\n    :const  (:val e)\n    :map    (zipmap (map const-expr->constant-value (:keys e))\n                    (map const-expr->constant-value (:vals e)))\n    :set    (into #{} (map const-expr->constant-value (:items e)))\n    :vector (into [] (map const-expr->constant-value (:items e)))))\n\n(defn- earmuffed? [sym]\n  (let [s (name sym)]\n    (and (> (count s) 2)\n         (string/starts-with? s \"*\")\n         (string/ends-with? s \"*\"))))\n\n(defn- core-ns? [ns-sym]\n  (let [s (name ns-sym)]\n    (and (not= 'cljs.user ns-sym)\n         (or (string/starts-with? s \"cljs.\")\n             (string/starts-with? s \"clojure.\")))))\n\n(defmethod parse 'def\n  [op env form _ _]\n  (when (> (count form) 4)\n    (throw (error env \"Too many arguments to def\")))\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        const? (-> sym meta :const)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol valid-proto)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)\n        locals (:locals env)\n        clash-ns (symbol (str ns-name \".\" sym))\n        sym-ns   (namespace sym)\n        sym      (cond\n                   (and sym-ns (not #?(:clj  (= (symbol sym-ns) ns-name)\n                                       :cljs (symbol-identical? (symbol sym-ns) ns-name))))\n                   (throw (error env (str \"Can't def ns-qualified name in namespace \" sym-ns)))\n\n                   (some? sym-ns)\n                   (symbol (name sym))\n\n                   :else sym)]\n    (when (some? (get-in @env/*compiler* [::namespaces clash-ns]))\n      (warning :ns-var-clash env\n        {:ns (symbol (str ns-name \".\" sym))\n         :var (symbol (str ns-name) (str sym))}))\n    (when (some? (:const (resolve-var (dissoc env :locals) sym)))\n      (throw (error env \"Can't redefine a constant\")))\n    (when-some [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env \"Too many arguments to def\"))))\n    (when (and (not dynamic)\n               (earmuffed? sym)\n               (not (core-ns? ns-name)))\n      (warning :non-dynamic-earmuffed-var env\n        {:var (str sym)}))\n    (when-some [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n      (when (and (not *allow-redef*)\n                 (not (:declared v))\n                 (not (:declared sym-meta))\n                 *file-defs*\n                 (get @*file-defs* sym))\n        (warning :redef-in-file env {:sym sym :line (:line v)}))\n      (when (and (:declared v)\n                 (:arglists v)\n                 (not= (:arglists v) (:arglists sym-meta)))\n        (warning :declared-arglists-mismatch env {:ns-name  ns-name :sym sym\n                                                  :declared (second (:arglists v))\n                                                  :defined  (second (:arglists sym-meta))})))\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (some? (get-in @env/*compiler* [::namespaces ns-name :uses sym])))\n                (let [ev (resolve-existing-var (dissoc env :locals)\n                           ;; ::no-resolve true is to suppress \"can't take value\n                           ;; of macro warning\" when sym resolves to a macro\n                           (with-meta sym {::no-resolve true}))\n                      conj-to-set (fnil conj #{})]\n                  (when (public-name? (:ns ev) sym)\n                    (warning :redef env {:sym sym :ns (:ns ev) :ns-name ns-name}))\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes]\n                     conj-to-set sym)\n                  (update-in env [:ns :excludes] conj-to-set sym))\n                env)\n          var-name (:name (resolve-var (dissoc env :locals) sym))\n          init-expr (when (contains? args :init)\n                      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n                        (merge\n                          {:name var-name}\n                          sym-meta\n                          (when (true? dynamic) {:dynamic true})\n                          (source-info var-name env)))\n                      (disallowing-recur\n                        (disallowing-ns*\n                          (analyze (assoc env :context :expr) (:init args) sym))))\n          fn-var? (and (some? init-expr) (= (:op init-expr) :fn))\n          tag (if fn-var?\n                (or (:ret-tag init-expr) tag (:inferred-ret-tag init-expr))\n                (or tag (:tag init-expr)))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) var-name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-some [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-> sym meta :declared))\n                   (and (true? (:fn-var v)) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n\n      ;; declare must not replace any analyzer data of an already def'd sym\n      (when (or (nil? (get-in @env/*compiler* [::namespaces ns-name :defs sym]))\n                (not (:declared sym-meta)))\n        (when *file-defs*\n          (swap! *file-defs* conj sym))\n\n        (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n          (merge\n            {:name var-name}\n            ;; remove actual test metadata, as it includes non-valid EDN and\n            ;; cannot be present in analysis cached to disk - David\n            (cond-> sym-meta\n              (:test sym-meta) (assoc :test true))\n            {:meta (-> sym-meta\n                       (dissoc :test)\n                       (update-in [:file]\n                         (fn [f]\n                           (if (= (-> env :ns :name) 'cljs.core)\n                             \"cljs/core.cljs\"\n                             f))))}\n            (when doc {:doc doc})\n            (when const?\n              (let [const-expr\n                    (binding [*passes* (conj *passes* (replace-env-pass {:context :expr}))]\n                      (analyze env (:init args)))]\n                (when (constant-value? const-expr)\n                  {:const-expr const-expr})))\n            (when (true? dynamic) {:dynamic true})\n            (source-info var-name env)\n            ;; the protocol a protocol fn belongs to\n            (when protocol\n              {:protocol protocol})\n            ;; symbol for reified protocol\n            (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n              {:protocol-symbol protocol-symbol\n               :info (-> protocol-symbol meta :protocol-info)\n               :impls #{}})\n            (when fn-var?\n              (let [params (map #(vec (map :name (:params %))) (:methods init-expr))]\n                (merge\n                  {:fn-var (not (:macro sym-meta))\n                   ;; protocol implementation context\n                   :protocol-impl (:protocol-impl init-expr)\n                   ;; inline protocol implementation context\n                   :protocol-inline (:protocol-inline init-expr)}\n                  (if-some [top-fn-meta (:top-fn sym-meta)]\n                    top-fn-meta\n                    {:variadic? (:variadic? init-expr)\n                     :max-fixed-arity (:max-fixed-arity init-expr)\n                     :method-params params\n                     :arglists (:arglists sym-meta)\n                     :arglists-meta (doall (map meta (:arglists sym-meta)))}))))\n            (when (and (:declared sym-meta)\n                       (:arglists sym-meta))\n              {:declared true\n               :fn-var true\n               :method-params (second (:arglists sym-meta))})\n            (if (and fn-var? (some? tag))\n              {:ret-tag tag}\n              (when tag {:tag tag})))))\n      (merge\n        {:env env\n         :op :def\n         :form form\n         :ns ns-name\n         :name var-name\n         :var (assoc\n                (analyze\n                  (-> env (dissoc :locals)\n                    (assoc :context :expr)\n                    (assoc :def-var true))\n                  sym)\n                :op :var)\n         :doc doc\n         :jsdoc (:jsdoc sym-meta)}\n        (when (true? (:def-emits-var env))\n          {:var-ast (var-ast env sym)})\n        (when-some [test (:test sym-meta)]\n          {:test (analyze (assoc env :context :expr) test)})\n        (when (some? tag)\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when (true? dynamic) {:dynamic true})\n        (when (some? export-as) {:export export-as})\n        (if (some? init-expr)\n          {:init init-expr\n           :children [:var :init]}\n          {:children [:var]})))))\n\n(defn analyze-fn-method-param [env]\n  (fn [[locals params] [arg-id name]]\n    (when (namespace name)\n      (throw (error env (str \"Can't use qualified name as parameter: \" name))))\n    (let [line   (get-line name env)\n          column (get-col name env)\n          nmeta  (meta name)\n          tag    (:tag nmeta)\n          shadow (when (some? locals)\n                   (handle-symbol-local name (locals name)))\n          env    (merge (select-keys env [:context])\n                   {:line line :column column})\n          param  {:op :binding\n                  :name name\n                  :line line\n                  :column column\n                  :tag tag\n                  :shadow shadow\n                  :local :arg\n                  :arg-id arg-id\n                  ;; Give the fn params the same shape\n                  ;; as a :var, so it gets routed\n                  ;; correctly in the compiler\n                  :env env\n                  :info {:name name :shadow shadow}\n                  :binding-form? true}]\n     [(assoc locals name param) (conj params param)])))\n\n(defn analyze-fn-method-body [env form recur-frames]\n  (binding [*recur-frames* recur-frames]\n    (analyze env form)))\n\n(defn- analyze-fn-method [env locals form type analyze-body?]\n  (let [param-names     (first form)\n        variadic        (boolean (some '#{&} param-names))\n        param-names     (vec (remove '#{&} param-names))\n        body            (next form)\n        step            (analyze-fn-method-param env)\n        step-init       [locals []]\n        [locals params] (reduce step step-init (map-indexed vector param-names))\n        params'         (if (true? variadic)\n                          (butlast params)\n                          params)\n        fixed-arity     (count params')\n        recur-frame     {:protocol-impl (:protocol-impl env)\n                         :params        params\n                         :flag          (atom nil)\n                         :tags          (atom [])}\n        recur-frames    (cons recur-frame *recur-frames*)\n        body-env        (assoc env :context :return :locals locals)\n        body-form       `(do ~@body)\n        expr            (when analyze-body?\n                          (analyze-fn-method-body body-env body-form recur-frames))\n        recurs          @(:flag recur-frame)]\n    (merge\n      {:env env\n       :op :fn-method\n       :variadic? variadic\n       :params params\n       :fixed-arity fixed-arity\n       :type type\n       :form form\n       :recurs recurs}\n      (if (some? expr)\n        {:body (assoc expr :body? true)\n         :children [:params :body]}\n        {:children [:params]}))))\n\n(declare analyze-wrap-meta)\n\n(defn fn-name-var [env locals name]\n  (when (some? name)\n    (let [ns       (-> env :ns :name)\n          shadow   (handle-symbol-local name (get locals name))\n          shadow   (when (nil? shadow)\n                     (get-in env [:js-globals name]))\n          fn-scope (:fn-scope env)\n          name-var {:name name\n                    :op :binding\n                    :local :fn\n                    :info {:fn-self-name true\n                           :fn-scope fn-scope\n                           :ns ns\n                           :shadow shadow}}\n          tag      (-> name meta :tag)\n          ret-tag  (when (some? tag)\n                     {:ret-tag tag})]\n      (merge name-var ret-tag))))\n\n(defn analyze-fn-methods-pass2* [menv locals type meths]\n  (mapv #(analyze-fn-method menv locals % type true) meths))\n\n(defn analyze-fn-methods-pass2 [menv locals type meths]\n  (analyze-fn-methods-pass2* menv locals type meths))\n\n(defmethod parse 'fn*\n  [op env [_ & args :as form] name _]\n  (let [named-fn?    (symbol? (first args))\n        [name meths] (if named-fn?\n                         [(first args) (next args)]\n                         [name (seq args)])\n        ;; turn (fn [] ...) into (fn ([]...))\n        meths        (if (vector? (first meths))\n                       (list meths)\n                       meths)\n        locals       (:locals env)\n        name-var     (fn-name-var env locals name)\n        env          (if (some? name)\n                       (update-in env [:fn-scope] conj name-var)\n                       env)\n        locals       (if (and (some? locals)\n                              named-fn?)\n                       (assoc locals name name-var)\n                       locals)\n        form-meta    (meta form)\n        type         (::type form-meta)\n        proto-impl   (::protocol-impl form-meta)\n        proto-inline (::protocol-inline form-meta)\n        menv         (if (> (count meths) 1)\n                       (assoc env :context :expr)\n                       env)\n        menv         (merge menv\n                       {:protocol-impl proto-impl\n                        :protocol-inline proto-inline})\n        methods      (map #(disallowing-ns* (analyze-fn-method menv locals % type (nil? name))) meths)\n        mfa          (transduce (map :fixed-arity) max 0 methods)\n        variadic     (boolean (some :variadic? methods))\n        locals       (if named-fn?\n                       (update-in locals [name] assoc\n                         ;; TODO: can we simplify? - David\n                         :fn-var true\n                         :variadic? variadic\n                         :max-fixed-arity mfa\n                         :method-params (map :params methods))\n                       locals)\n        methods      (if (some? name)\n                       ;; a second pass with knowledge of our function-ness/arity\n                       ;; lets us optimize self calls\n                       (disallowing-ns* (analyze-fn-methods-pass2 menv locals type meths))\n                       (vec methods))\n        form         (vary-meta form dissoc ::protocol-impl ::protocol-inline ::type)\n        js-doc       (when (true? variadic)\n                       \"@param {...*} var_args\")\n        children     (if (some? name-var)\n                       [:local :methods]\n                       [:methods])\n        inferred-ret-tag (let [inferred-tags (map (partial infer-tag env) (map :body methods))]\n                           (when (apply = inferred-tags)\n                             (first inferred-tags)))\n        ast   (merge {:op :fn\n                      :env env\n                      :form form\n                      :name name-var\n                      :methods methods\n                      :variadic? variadic\n                      :tag 'function\n                      :inferred-ret-tag inferred-ret-tag\n                      :recur-frames *recur-frames*\n                      :loop-lets *loop-lets*\n                      :jsdoc [js-doc]\n                      :max-fixed-arity mfa\n                      :protocol-impl proto-impl\n                      :protocol-inline proto-inline\n                      :children children}\n                     (when (some? name-var)\n                       {:local name-var}))]\n    (let [variadic-methods (into []\n                             (comp (filter :variadic?) (take 1))\n                             methods)\n          variadic-params  (if (pos? (count variadic-methods))\n                             (count (:params (nth variadic-methods 0)))\n                             0)\n          param-counts     (into [] (map (comp count :params)) methods)]\n      (when (< 1 (count variadic-methods))\n        (warning :multiple-variadic-overloads env {:name name-var}))\n      (when (not (or (zero? variadic-params) (== variadic-params (+ 1 mfa))))\n        (warning :variadic-max-arity env {:name name-var}))\n      (when (not= (distinct param-counts) param-counts)\n        (warning :overload-arity env {:name name-var})))\n    (analyze-wrap-meta ast)))\n\n(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name _]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error env \"bindings must be vector of even number of elements\")))\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-> n meta :tag)\n                        fexpr (no-warn (analyze env (n->fexpr n)))\n                        be (cond->\n                             {:name n\n                              :op :binding\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local :letfn\n                              :shadow (handle-symbol-local n (locals n))\n                              :variadic? (:variadic? fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n->fexpr name))\n                        be' (assoc be\n                              :init fexpr\n                              :variadic? (:variadic? fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr)))]\n                    [(assoc-in env [:locals name] be')\n                     (conj bes be')]))\n          [meth-env []] bes)\n        expr (-> (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))\n                 (assoc :body? true))]\n    {:env env :op :letfn :bindings bes :body expr :form form\n     :children [:bindings :body]}))\n\n(defn analyze-do-statements* [env exprs]\n  (mapv #(analyze (assoc env :context :statement) %) (butlast exprs)))\n\n(defn analyze-do-statements [env exprs]\n  (disallowing-recur (analyze-do-statements* env exprs)))\n\n(defmethod parse 'do\n  [op env [_ & exprs :as form] _ _]\n  (let [statements (analyze-do-statements env exprs)]\n    (if (<= (count exprs) 1)\n      (let [ret      (analyze env (first exprs))\n            children [:statements :ret]]\n        {:op :do\n         :env env\n         :form form\n         :statements statements :ret ret\n         :children children})\n      (let [ret-env  (if (= :statement (:context env))\n                       (assoc env :context :statement)\n                       (assoc env :context :return))\n            ret      (analyze ret-env (last exprs))\n            children [:statements :ret]]\n        {:op :do\n         :env env\n         :form form\n         :statements statements\n         :ret ret\n         :children children}))))\n\n(defn analyze-let-binding-init [env init loop-lets]\n  (binding [*loop-lets* loop-lets]\n    (analyze env init)))\n\n(defn get-let-tag [name init-expr]\n  (if-some [tag (-> name meta :tag)]\n      tag\n        (if-some [tag (-> init-expr :tag)]\n          tag\n          (-> init-expr :info :tag))))\n\n(defn analyze-let-bindings* [encl-env bindings op]\n  (loop [bes []\n         env (assoc encl-env :context :expr)\n         bindings (seq (partition 2 bindings))]\n\n      (if-some [[name init] (first bindings)]\n        (let []\n          (when (or (some? (namespace name))\n                  #?(:clj  (.contains (str name) \".\")\n                     :cljs ^boolean (goog.string/contains (str name) \".\")))\n            (throw (error encl-env (str \"Invalid local name: \" name))))\n          (let [init-expr (analyze-let-binding-init env init (cons {:params bes} *loop-lets*))\n                line (get-line name env)\n                col (get-col name env)\n                shadow (handle-symbol-local name (get-in env [:locals name]))\n                be {:name name\n                    :line line\n                    :column col\n                    :init init-expr\n                    :tag (get-let-tag name init-expr)\n                    :local op\n                    :shadow shadow\n                    ;; Give let* bindings same shape as var so\n                    ;; they get routed correctly in the compiler\n                    :op :binding\n                    :env {:line line :column col}\n                    :info {:name name\n                           :shadow shadow}\n                    :binding-form? true}\n                be (if (= :fn (:op init-expr))\n                     ;; TODO: can we simplify - David\n                     (merge be\n                       {:fn-var true\n                        ;; copy over the :fn-method information we need for invoke type inference\n                        :methods (into [] (map #(select-keys % [:tag :fixed-arity :variadic?]) (:methods init-expr)))\n                        :variadic? (:variadic? init-expr)\n                        :max-fixed-arity (:max-fixed-arity init-expr)\n                        :method-params (map :params (:methods init-expr))})\n                     be)\n                be (add-identity be)]\n            (recur (conj bes be)\n              (assoc-in env [:locals name] be)\n              (next bindings))))\n        [bes env])))\n\n(defn analyze-let-bindings [encl-env bindings op]\n  (disallowing-recur (analyze-let-bindings* encl-env bindings op)))\n\n(defn analyze-let-body* [env context exprs]\n  (analyze (assoc env :context (if (= :expr context) :return context)) `(do ~@exprs)))\n\n(defn analyze-let-body [env context exprs recur-frames loop-lets]\n  (binding [*recur-frames* recur-frames\n            *loop-lets* loop-lets]\n    (analyze-let-body* env context exprs)))\n\n(defn analyze-let\n  [encl-env [_ bindings & exprs :as form] is-loop widened-tags]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error encl-env \"bindings must be vector of even number of elements\")))\n  (let [context      (:context encl-env)\n        op           (if (true? is-loop) :loop :let)\n        bindings     (if widened-tags\n                       (vec (mapcat\n                              (fn [[name init] widened-tag]\n                                [(vary-meta name assoc :tag widened-tag) init])\n                              (partition 2 bindings)\n                              widened-tags))\n                       bindings)\n        [bes env]    (analyze-let-bindings encl-env bindings op)\n        recur-frame  (when (true? is-loop)\n                       {:params bes\n                        :flag (atom nil)\n                        :tags (atom (mapv :tag bes))})\n        recur-frames (if recur-frame\n                       (cons recur-frame *recur-frames*)\n                       *recur-frames*)\n        loop-lets    (cond\n                       (true? is-loop) *loop-lets*\n                       (some? *loop-lets*) (cons {:params bes} *loop-lets*))\n        ;; Accumulate warnings for deferred replay iff there's a possibility of re-analyzing\n        warn-acc     (when (and is-loop\n                                (not widened-tags))\n                       (atom []))\n        expr         (if warn-acc\n                       (with-warning-handlers [(accumulating-warning-handler warn-acc)]\n                         (analyze-let-body env context exprs recur-frames loop-lets))\n                       (analyze-let-body env context exprs recur-frames loop-lets))\n        children     [:bindings :body]\n        nil->any     (fnil identity 'any)]\n    (if (and is-loop\n             (not widened-tags)\n             (not= (mapv nil->any @(:tags recur-frame))\n                   (mapv (comp nil->any :tag) bes)))\n      (recur encl-env form is-loop @(:tags recur-frame))\n      (do\n        (when warn-acc\n          (replay-accumulated-warnings warn-acc))\n        {:op       op\n         :env      encl-env\n         :bindings bes\n         :body     (assoc expr :body? true)\n         :form     form\n         :children children}))))\n\n(defmethod parse 'let*\n  [op encl-env form _ _]\n  (analyze-let encl-env form false nil))\n\n(defmethod parse 'loop*\n  [op encl-env form _ _]\n  (analyze-let encl-env form true nil))\n\n(defmethod parse 'recur\n  [op env [_ & exprs :as form] _ _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        ;; Add dummy implicit target object if recuring to proto impl method head\n        add-implicit-target-object? (and (:protocol-impl frame)\n                                         (= (count exprs) (dec (count (:params frame)))))\n        exprs (cond->> exprs add-implicit-target-object? (cons nil))\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame\n      (throw (error env \"Can't recur here\")))\n    (when-not (= (count exprs) (count (:params frame)))\n      (throw (error env (str \"recur argument count mismatch, expected: \"\n                          (count (:params frame)) \" args, got: \" (count exprs)))))\n    (when (and (:protocol-impl frame)\n               (not add-implicit-target-object?))\n      (warning :protocol-impl-recur-with-target env {:form (:form (first exprs))}))\n    (reset! (:flag frame) true)\n    (swap! (:tags frame) (fn [tags]\n                           (mapv (fn [tag expr]\n                                   (add-types tag (:tag expr)))\n                             tags exprs)))\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children [:exprs])))\n\n(defn analyze-const\n  [env form]\n  (let [;; register constants\n        {:keys [tag]} (analyze (assoc env :quoted? true) form)]\n    {:op       :const\n     :env      env\n     :literal? true\n     :val      form\n     :tag      tag\n     :form     form}))\n\n(defmethod parse 'quote\n  [_ env [_ x :as form] _ _]\n  (when (not= 2 (count form))\n    (throw (error env \"Wrong number of args to quote\")))\n  (let [expr (analyze-const env x)]\n    {:op :quote\n     :expr expr\n     :env env\n     :form form\n     :tag (:tag expr)\n     :children [:expr]}))\n\n(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _ _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         ctor-var (when (#{:var :local :js-var} (:op ctorexpr))\n                    (resolve-existing-var env ctor))\n         record-args\n         (when (and (:record ctor-var) (not (-> ctor meta :internal-ctor)))\n           (repeat 3 (analyze enve nil)))\n         argexprs (into (vec (map #(analyze enve %) args)) record-args)\n         known-num-fields (:num-fields ctor-var)\n         argc (count args)]\n     (when (and (not (-> ctor meta :internal-ctor))\n                (some? known-num-fields) (not= known-num-fields argc))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :class ctorexpr :args argexprs\n      :children [:class :args]\n      :tag (let [name (-> ctorexpr :info :name)]\n             (or ('{js/Object object\n                    js/String string\n                    js/Array  array\n                    js/Number number\n                    js/Function function\n                    js/Boolean boolean} name)\n                 name))})))\n\n(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _ _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n      (binding [*private-var-access-nowarn* true]\n        (let [enve  (assoc env :context :expr)\n              texpr (cond\n                      (symbol? target)\n                      (do\n                        (cond\n                          (and (= target '*unchecked-if*)   ;; TODO: proper resolve\n                               (or (true? val) (false? val)))\n                          (set! *unchecked-if* val)\n\n                          (and (= target '*unchecked-arrays*) ;; TODO: proper resolve\n                               (or (true? val) (false? val)))\n                          (set! *unchecked-arrays* val)\n\n                          (and (= target '*warn-on-infer*)\n                               (or (true? val) (false? val)))\n                          (set! *cljs-warnings* (assoc *cljs-warnings* :infer-warning val)))\n                        (when (some? (:const (resolve-var (dissoc env :locals) target)))\n                          (throw (error env \"Can't set! a constant\")))\n                        (let [local (handle-symbol-local target (-> env :locals target))]\n                          (when-not (or (nil? local)\n                                        (and (:field local)\n                                             (or (:mutable local)\n                                                 (:unsynchronized-mutable local)\n                                                 (:volatile-mutable local))))\n                            (throw (error env \"Can't set! local var or non-mutable field\"))))\n                        (analyze-symbol enve target))\n\n                      :else\n                      (when (seq? target)\n                        (let [texpr (analyze-seq enve target nil)]\n                          (when (:field texpr)\n                            texpr))))\n              vexpr (analyze enve val)]\n          ;; as top level fns are decomposed for Closure cross-module code motion, we need to\n          ;; restore their :methods information\n          (when (seq? target)\n            (let [sym  (some-> target second)\n                  meta (meta sym)]\n              (when-let [info (and (= :fn (:op vexpr)) (:top-fn meta))]\n                (swap! env/*compiler* update-in\n                  [::namespaces (-> env :ns :name) :defs sym :methods]\n                  (fnil conj [])\n                  ;; just use original fn meta, as the fn method is already desugared\n                  ;; only get tag from analysis\n                  (merge\n                    (select-keys info [:fixed-arity :variadic?])\n                    (select-keys (-> vexpr :methods first) [:tag]))))))\n          (when-not texpr\n            (throw (error env \"set! target must be a field or a symbol naming a var\")))\n          (cond\n            (and (not (:def-emits-var env))                 ;; non-REPL context\n                 (some? ('#{*unchecked-if* *unchecked-arrays* *warn-on-infer*} target)))\n            {:env env :op :no-op}\n\n            :else\n            {:env env :op :set! :form form :target texpr :val vexpr\n             :children [:target :val]}))))))\n\n#?(:clj (declare analyze-file))\n\n#?(:clj\n   (defn locate-src\n     \"Given a namespace return the corresponding ClojureScript (.cljs or .cljc)\n     resource on the classpath or file from the root of the build.\"\n     [ns]\n     (or (util/ns->source ns)\n       ;; Find sources available in inputs given to cljs.closure/build - Juho Teperi\n       (some (fn [source]\n               (if (= ns (:ns source))\n                 (:source-file source)))\n             (:sources @env/*compiler*))\n       ;; Find sources in directory given to cljs.compiler/compile-root - Juho Teperi\n       (let [rootp (when-let [root (:root @env/*compiler*)]\n                     (.getPath ^File root))\n             cljsf (io/file rootp (ns->relpath ns :cljs))\n             cljcf (io/file rootp (ns->relpath ns :cljc))]\n         (if (and (.exists cljsf) (.isFile cljsf))\n           cljsf\n           (if (and (.exists cljcf) (.isFile cljcf))\n             cljcf))))))\n\n(defn foreign-dep?\n  #?(:cljs {:tag boolean})\n  [dep]\n  (let [js-index (:js-dependency-index @env/*compiler*)]\n    (if-some [[_ {:keys [foreign]}] (find js-index (name dep))]\n      foreign\n      false)))\n\n(defn analyze-deps\n  \"Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces.\"\n  ([lib deps env]\n   (analyze-deps lib deps env\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([lib deps env opts]\n   (let [compiler @env/*compiler*]\n     (binding [*cljs-dep-set* (vary-meta (conj *cljs-dep-set* lib) update-in [:dep-path] conj lib)]\n       (assert (every? #(not (contains? *cljs-dep-set* %)) deps)\n         (str \"Circular dependency detected, \"\n           (apply str\n             (interpose \" -> \"\n               (conj (-> *cljs-dep-set* meta :dep-path)\n                 (some *cljs-dep-set* deps))))))\n       (doseq [dep deps]\n         (when-not (or (some? (get-in compiler [::namespaces dep :defs]))\n                       (contains? (:js-dependency-index compiler) (name dep))\n                       (node-module-dep? dep)\n                       (js-module-exists? (name dep))\n                       #?(:clj (deps/find-classpath-lib dep)))\n           #?(:clj (if-some [src (locate-src dep)]\n                     (analyze-file src opts)\n                     (throw\n                       (error env\n                         (error-message :undeclared-ns {:ns-sym dep :js-provide (name dep)}))))\n              :cljs (throw\n                      (error env\n                        (error-message :undeclared-ns {:ns-sym dep :js-provide (name dep)}))))))))))\n\n(defn missing-use? [lib sym cenv]\n  (let [js-lib (get-in cenv [:js-dependency-index (name lib)])]\n    (and (= (get-in cenv [::namespaces lib :defs sym] ::not-found) ::not-found)\n         (not (= (get js-lib :group) :goog))\n         (not (get js-lib :closure-lib))\n         (not (node-module-dep? lib))\n         (not (dep-has-global-exports? lib)))))\n\n(defn missing-rename? [sym cenv]\n  (let [lib (symbol (namespace sym))\n        sym (symbol (name sym))]\n    (missing-use? lib sym cenv)))\n\n(defn missing-use-macro? [lib sym]\n  ;; guard against string requires\n  (when (symbol? lib)\n    (let [the-ns #?(:clj (find-ns lib) :cljs (find-macros-ns lib))]\n      (or (nil? the-ns) (nil? (.findInternedVar ^clojure.lang.Namespace the-ns sym))))))\n\n(defn missing-rename-macro? [sym]\n  (let [lib (symbol (namespace sym))\n        sym (symbol (name sym))\n        the-ns #?(:clj (find-ns lib) :cljs (find-macros-ns lib))]\n    (or (nil? the-ns) (nil? (.findInternedVar ^clojure.lang.Namespace the-ns sym)))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn missing-uses\n  [uses env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[sym lib]] (missing-use? lib sym cenv)) uses))))\n\n;; returns (s/map-of symbol? qualified-symbol?)\n(defn missing-renames [renames env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[_ qualified-sym]] (missing-rename? qualified-sym cenv)) renames))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn missing-use-macros [use-macros env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[sym lib]] (missing-use-macro? lib sym)) use-macros))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn inferred-use-macros [use-macros env]\n  (let [cenv @env/*compiler*]\n    (into {} (filter (fn [[sym lib]] (not (missing-use-macro? lib sym))) use-macros))))\n\n;; returns (s/map-of symbol? symbol?)\n(defn inferred-rename-macros [rename-macros env]\n  (into {} (filter (fn [[_ qualified-sym]] (not (missing-rename-macro? qualified-sym))) rename-macros)))\n\n(defn check-uses [uses env]\n  (let [cenv @env/*compiler*]\n    (doseq [[sym lib] uses]\n      (when (missing-use? lib sym cenv)\n        (throw\n          (error env\n            (error-message :undeclared-ns-form {:type \"var\" :lib lib :sym sym})))))))\n\n(defn check-use-macros\n  ([use-macros env]\n    (check-use-macros use-macros nil env))\n  ([use-macros missing-uses env]\n   (let [cenv @env/*compiler*]\n     (doseq [[sym lib] use-macros]\n       (when (missing-use-macro? lib sym)\n         (throw\n           (error env\n             (error-message :undeclared-ns-form {:type \"macro\" :lib lib :sym sym})))))\n     (check-uses (missing-use-macros missing-uses env) env)\n     (inferred-use-macros missing-uses env))))\n\n(defn check-use-macros-inferring-missing\n  [{:keys [name uses use-macros] :as ast} env]\n  (let [missing-uses        (when (and *analyze-deps* (seq uses))\n                              (missing-uses uses env))\n        maybe-macros        (apply dissoc uses (keys missing-uses))\n        remove-missing-uses #(apply dissoc % (keys missing-uses))\n        ast' (-> ast\n               (update-in [:use-macros]\n                 #(-> %\n                   (merge (check-use-macros use-macros missing-uses env))\n                   (merge (inferred-use-macros maybe-macros env))))\n               (update-in [:uses] remove-missing-uses))]\n    (swap! env/*compiler*\n      #(-> %\n        (update-in [::namespaces name :use-macros] merge (:use-macros ast'))\n        (update-in [::namespaces name :uses] remove-missing-uses)))\n    ast'))\n\n(defn check-rename-macros-inferring-missing\n  [{:keys [name renames] :as ast} env]\n  (let [missing-renames        (when (and *analyze-deps* (seq renames))\n                                 (missing-renames renames env))\n        maybe-macros           (apply dissoc renames (keys missing-renames))\n        missing-rename-macros  (inferred-rename-macros missing-renames env)\n        remove-missing-renames #(apply dissoc % (keys missing-renames))\n        ast' (-> ast\n               (update-in [:rename-macros]\n                 #(-> %\n                   (merge missing-rename-macros)\n                   (merge (inferred-rename-macros maybe-macros env))))\n               (update-in [:renames] remove-missing-renames))]\n    (swap! env/*compiler*\n      #(-> %\n        (update-in [::namespaces name :rename-macros] merge (:rename-macros ast'))\n        (update-in [::namespaces name :renames] remove-missing-renames)))\n    ast'))\n\n(defn parse-ns-error-msg [spec msg]\n  (str msg \"; offending spec: \" (pr-str spec)))\n\n(defn basic-validate-ns-spec [env macros? spec]\n  (when-not (or (symbol? spec) (string? spec) (sequential? spec))\n    (throw\n      (error env\n        (parse-ns-error-msg spec\n          \"Only [lib.ns & options] and lib.ns specs supported in :require / :require-macros\"))))\n  (when (sequential? spec)\n    (when-not (or (symbol? (first spec)) (string? (first spec)))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            \"Library name must be specified as a symbol in :require / :require-macros\"))))\n    (when-not (odd? (count spec))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            \"Only :as alias, :refer (names) and :rename {from to} options supported in :require\"))))\n    (when-not (every? #{:as :refer :rename} (map first (partition 2 (next spec))))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            \"Only :as, :refer and :rename options supported in :require / :require-macros\"))))\n    (when-not (let [fs (frequencies (next spec))]\n                (and (<= (fs :as 0) 1)\n                     (<= (fs :refer 0) 1)))\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            \"Each of :as and :refer options may only be specified once in :require / :require-macros\"))))))\n\n(defn parse-ns-excludes [env args]\n  (reduce\n    (fn [s [k & filters]]\n      (if (= k :refer-clojure)\n        (do\n          (when (seq (:excludes s))\n            (throw (error env \"Only one :refer-clojure form is allowed per namespace definition\")))\n          (let [valid-kws #{:exclude :rename}\n                xs\n                (loop [fs (seq filters)\n                       ret {:excludes #{}\n                            :renames {}}\n                       err (not (even? (count filters)))]\n                  (cond\n                    (true? err)\n                    (throw\n                      (error env \"Only [:refer-clojure :exclude (names)] and optionally `:rename {from to}` specs supported\"))\n\n                    (some? fs)\n                    (let [kw (first fs)]\n                      (if (valid-kws kw)\n                        (let [refs (second fs)]\n                          (cond\n                            (not (or (and (= kw :exclude) (sequential? refs) (every? symbol? refs))\n                                     (and (= kw :rename) (map? refs) (every? #(every? symbol? %) refs))))\n                            (recur fs ret true)\n\n                            (= kw :exclude)\n                            (recur (nnext fs) (update-in ret [:excludes] into refs) false)\n\n                            (= kw :rename)\n                            (recur (nnext fs) (update-in ret [:renames] merge refs) false)))\n                        (recur fs ret true)))\n\n                    :else ret))]\n            (merge-with into s xs)))\n        s))\n    {:excludes #{}\n     :renames {}} args))\n\n(defn use->require [env [lib & filters :as spec]]\n  (when-not (and (symbol? lib) (odd? (count spec)))\n    (throw\n      (error env\n        (parse-ns-error-msg spec\n          \"Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros\"))))\n  (loop [fs (seq filters) ret [lib] err false]\n    (cond\n      (true? err)\n      (throw\n        (error env\n          (parse-ns-error-msg spec\n            \"Only [lib.ns :only (names)] and optionally `:rename {from to}` specs supported in :use / :use-macros\")))\n\n      (some? fs)\n      (let [kw (first fs)\n            only? (= kw :only)]\n        (if (or only? (= kw :rename))\n          (if (some? (some #{(if only? :refer kw)} ret))\n            (throw\n              (error env\n                (parse-ns-error-msg spec\n                  \"Each of :only and :rename options may only be specified once in :use / :use-macros\")))\n            (let [refs (second fs)]\n              (if-not (or (and only? (sequential? refs) (every? symbol? refs))\n                          (and (= kw :rename) (map? refs) (every? #(every? symbol? %) refs)))\n                (recur fs ret true)\n                (recur (nnext fs) (into ret [(if only? :refer kw) refs]) false))))\n          (recur fs ret true )))\n\n      :else (if (some? (some #{:refer} ret))\n              ret\n              (recur fs ret true)))))\n\n(defn parse-require-spec [env macros? deps aliases spec]\n  (if (or (symbol? spec) (string? spec))\n    (recur env macros? deps aliases [spec])\n    (do\n      (basic-validate-ns-spec env macros? spec)\n      (let [[lib & opts] spec\n            ;; We need to load JS modules by the name that has been created by the\n            ;; Google Closure compiler, e.g. module$resources$libs$calculator.\n            ;; This means that we need to create an alias from the module name\n            ;; given with :provides to the new name.\n            [lib js-module-provides] (if-some [js-module-name (gets @env/*compiler* :js-module-index (str lib) :name)]\n                                       [(symbol js-module-name) lib]\n                                       [lib nil])\n            {alias :as referred :refer renamed :rename\n             :or {alias (if (string? lib)\n                          (symbol (munge lib))\n                          lib)}}\n            (apply hash-map opts)\n            referred-without-renamed (seq (remove (set (keys renamed)) referred))\n            [rk uk renk] (if macros? [:require-macros :use-macros :rename-macros] [:require :use :rename])]\n        (when-not (or (symbol? alias) (nil? alias))\n          (throw\n            (error env\n              (parse-ns-error-msg spec\n                \":as must be followed by a symbol in :require / :require-macros\"))))\n        (when (some? alias)\n          (let [alias-type (if macros? :macros :fns)\n                lib'       ((alias-type @aliases) alias)]\n            (when (and (some? lib') (not= lib lib'))\n              (throw (error env (parse-ns-error-msg spec \":as alias must be unique\"))))\n            (swap! aliases\n              update-in [alias-type]\n              conj [alias lib] (when js-module-provides [js-module-provides lib]))))\n        (when-not (or (and (sequential? referred)\n                           (every? symbol? referred))\n                      (nil? referred))\n          (throw\n            (error env\n              (parse-ns-error-msg spec\n                \":refer must be followed by a sequence of symbols in :require / :require-macros\"))))\n        (when-not macros?\n          (swap! deps conj lib))\n        (merge\n          (when (some? alias)\n            {rk (merge {alias lib} {lib lib}\n                  (when js-module-provides {js-module-provides lib}))})\n          (when (some? referred-without-renamed)\n            {uk (apply hash-map (interleave referred-without-renamed (repeat lib)))})\n          (when (some? renamed)\n            {renk (reduce (fn [m [original renamed]]\n                            (when-not (some #{original} referred)\n                              (throw (error env\n                                       (str \"Renamed symbol \" original \" not referred\"))))\n                            (assoc m renamed (symbol (str lib) (str original))))\n                    {} renamed)}))))))\n\n(defn parse-import-spec [env deps spec]\n  (when-not (or (and (sequential? spec)\n                     (every? symbol? spec))\n                (and (symbol? spec) (nil? (namespace spec))))\n    (throw (error env (parse-ns-error-msg spec \"Only lib.ns.Ctor or [lib.ns Ctor*] spec supported in :import\"))))\n  (let [import-map (if (sequential? spec)\n                     (->> (rest spec)\n                       (map #(vector % (symbol (str (first spec) \".\" %))))\n                       (into {}))\n                     {(symbol (last (string/split (str spec) #\"\\.\"))) spec})]\n    (doseq [[_ spec] import-map]\n      (swap! deps conj spec))\n    {:import  import-map\n     :require import-map}))\n\n#?(:clj (declare parse-ns))\n\n(defn macro-autoload-ns?\n  \"Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true.\"\n  #?(:cljs {:tag boolean})\n  [form]\n  (when *macro-infer*\n    (let [ns (if (sequential? form) (first form) form)\n         {:keys [use-macros require-macros]}\n         (or (get-in @env/*compiler* [::namespaces ns])\n             #?(:clj\n                (when-let [res (util/ns->source ns)]\n                  (:ast (parse-ns res)))))]\n      (or (some #{ns} (vals use-macros))\n          (some #{ns} (vals require-macros))))))\n\n(defn clj-ns->cljs-ns\n  \"Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs\"\n  [sym]\n  (let [segs (string/split (clojure.core/name sym) #\"\\.\")]\n    (if (= \"clojure\" (first segs))\n      (symbol (string/join \".\" (cons \"cljs\" (next segs))))\n      sym)))\n\n#?(:clj\n   (defn aliasable-clj-ns?\n     \"Predicate for testing with a symbol represents an aliasable clojure namespace.\"\n     [sym]\n     (when-not (util/ns->source sym)\n       (let [[seg1 :as segs] (string/split (clojure.core/name sym) #\"\\.\")]\n         (when (= \"clojure\" seg1)\n           (let [sym' (clj-ns->cljs-ns sym)]\n             (util/ns->source sym')))))))\n\n#?(:clj\n   (defn process-rewrite-form [[k & specs :as form]]\n     (letfn [(process-spec [maybe-spec]\n               (let [[lib & xs] (if (sequential? maybe-spec)\n                                  maybe-spec\n                                  [maybe-spec])]\n                 (if (and (symbol? lib) (aliasable-clj-ns? lib))\n                   (let [lib' (clj-ns->cljs-ns lib)\n                         spec (cons lib' xs)]\n                     (into (if xs [spec] []) [(list lib' :as lib)]))\n                   [maybe-spec])))]\n       (if (#{:use :require} k)\n         (cons k (mapcat process-spec specs))\n         form))))\n\n#?(:clj\n   (defn rewrite-cljs-aliases\n     \"Alias non-existing clojure.* namespaces to existing cljs.* namespaces if\n      possible.\"\n     [args]\n     (map process-rewrite-form args)))\n\n(defn canonicalize-specs [specs]\n  (letfn [(canonicalize [quoted-spec-or-kw]\n            (if (keyword? quoted-spec-or-kw)\n              quoted-spec-or-kw\n              (as-> (second quoted-spec-or-kw) spec\n                (if (or (vector? spec) (map? spec)) spec [spec]))))]\n    (map canonicalize specs)))\n\n(defn canonicalize-import-specs [specs]\n  (letfn [(canonicalize [quoted-spec-or-kw]\n            (if (keyword? quoted-spec-or-kw)\n              quoted-spec-or-kw\n              (second quoted-spec-or-kw)))]\n    (map canonicalize specs)))\n\n(defn desugar-ns-specs\n  \"Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared.\"\n  [args]\n  (let [{:keys [require] :as indexed}\n        (->> args\n          (map (fn [[k & specs]] [k (into [] specs)]))\n          (into {}))\n        sugar-keys #{:include-macros :refer-macros}\n        ;; drop spec k and value from spec for generated :require-macros\n        remove-from-spec\n        (fn [pred spec]\n          (if-not (and (sequential? spec) (some pred spec))\n            spec\n            (let [[l r] (split-with (complement pred) spec)]\n              (recur pred (concat l (drop 2 r))))))\n        ;; rewrite :refer-macros to :refer for generated :require-macros\n        replace-refer-macros\n        (fn [spec]\n          (if-not (sequential? spec)\n            spec\n            (map (fn [x] (if (= x :refer-macros) :refer x)) spec)))\n        reload-spec? #(#{:reload :reload-all} %)\n        to-macro-specs\n        (fn [specs]\n          (->> specs\n            (filter\n              (fn [x]\n                (or (and (sequential? x)\n                         (some sugar-keys x))\n                    (reload-spec? x)\n                    (macro-autoload-ns? x))))\n            (map (fn [x]\n                   (if-not (reload-spec? x)\n                     (->> x (remove-from-spec #{:include-macros})\n                            (remove-from-spec #{:refer})\n                            (remove-from-spec #{:rename})\n                            (replace-refer-macros))\n                     x)))))\n        remove-sugar (partial remove-from-spec sugar-keys)]\n    (if-some [require-specs (seq (to-macro-specs require))]\n      (map (fn [x]\n             (if-not (reload-spec? x)\n               (let [[k v] x]\n                 (cons k (map remove-sugar v)))\n               x))\n        (update-in indexed [:require-macros] (fnil into []) require-specs))\n      args)))\n\n(defn find-def-clash [env ns segments]\n  (let [to-check (map (fn [xs]\n                        [(symbol (string/join \".\" (butlast xs)))\n                         (symbol (last xs))])\n                   (drop 2 (reductions conj [] segments)))]\n    (doseq [[clash-ns name] to-check]\n      (when (get-in @env/*compiler* [::namespaces clash-ns :defs name])\n        (warning :ns-var-clash env\n          {:ns ns\n           :var (symbol (str clash-ns) (str name))})))))\n\n(defn macro-ns-name [name]\n  (let [name-str (str name)]\n    (if-not #?(:clj  (.endsWith name-str \"$macros\")\n               :cljs (gstring/endsWith name-str \"$macros\"))\n      (symbol (str name-str \"$macros\"))\n      name)))\n\n(defmethod parse 'ns\n  [_ env [_ name & args :as form] _ opts]\n  (when-not *allow-ns*\n    (throw (error env \"Namespace declarations must appear at the top-level.\")))\n  (when-not (symbol? name)\n    (throw (error env \"Namespaces must be named by a symbol.\")))\n  (let [name (cond-> name (:macros-ns opts) macro-ns-name)]\n    (let [segments (string/split (clojure.core/name name) #\"\\.\")]\n      (when (= 1 (count segments))\n        (warning :single-segment-namespace env {:name name}))\n      (let [segment (some js-reserved segments)]\n        (when (some? segment)\n          (warning :munged-namespace env {:name name})))\n      (find-def-clash env name segments)\n      #?(:clj\n         (when (some (complement util/valid-js-id-start?) segments)\n           (throw\n             (AssertionError.\n               (str \"Namespace \" name \" has a segment starting with an invaild \"\n                    \"JavaScript identifier\"))))))\n    (let [docstring    (when (string? (first args)) (first args))\n          mdocstr      (-> name meta :doc)\n          args         (if (some? docstring) (next args) args)\n          metadata     (when (map? (first args)) (first args))\n          args         (desugar-ns-specs\n                         #?(:clj  (rewrite-cljs-aliases\n                                    (if metadata (next args) args))\n                            :cljs (if (some? metadata) (next args) args)))\n          name         (vary-meta name merge metadata)\n          {excludes :excludes core-renames :renames} (parse-ns-excludes env args)\n          core-renames (reduce (fn [m [original renamed]]\n                                 (assoc m renamed (symbol \"cljs.core\" (str original))))\n                         {} core-renames)\n          deps         (atom [])\n          aliases      (atom {:fns {} :macros {}})\n          spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                        :require-macros (partial parse-require-spec env true deps aliases)\n                        :use            (comp (partial parse-require-spec env false deps aliases)\n                                          (partial use->require env))\n                        :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                          (partial use->require env))\n                        :import         (partial parse-import-spec env deps)}\n          valid-forms  (atom #{:use :use-macros :require :require-macros :import})\n          reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n          reloads      (atom {})\n          {uses :use requires :require renames :rename\n           use-macros :use-macros require-macros :require-macros\n           rename-macros :rename-macros imports :import :as params}\n          (reduce\n            (fn [m [k & libs :as libspec]]\n              (when-not (#{:use :use-macros :require :require-macros :import} k)\n                (throw (error env (str \"Only :refer-clojure, :require, :require-macros, :use, :use-macros, and :import libspecs supported. Got \" libspec \" instead.\"))))\n              (when-not (@valid-forms k)\n                (throw (error env (str \"Only one \" k \" form is allowed per namespace definition\"))))\n              (swap! valid-forms disj k)\n              ;; check for spec type reloads\n              (when-not (= :import k)\n                (when (some? (some #{:reload} libs))\n                  (swap! reload assoc k :reload))\n                (when (some? (some #{:reload-all} libs))\n                  (swap! reload assoc k :reload-all)))\n              ;; check for individual ns reloads from REPL interactions\n              (when-let [xs (seq (filter #(-> % meta :reload) libs))]\n                (swap! reloads assoc k\n                  (zipmap (map first xs) (map #(-> % meta :reload) xs))))\n              (apply merge-with merge m\n                (map (spec-parsers k)\n                  (remove #{:reload :reload-all} libs))))\n            {} (remove (fn [[r]] (= r :refer-clojure)) args))\n          ;; patch `require-macros` and `use-macros` in Bootstrap for namespaces\n          ;; that require their own macros\n          #?@(:cljs [[require-macros use-macros]\n                     (map (fn [spec-map]\n                            (if (:macros-ns opts)\n                              (let [ns (symbol (subs (str name) 0 (- (count (str name)) 7)))]\n                                (reduce (fn [m [k v]]\n                                          (cond-> m\n                                            (not (symbol-identical? v ns))\n                                            (assoc k v)))\n                                  {} spec-map))\n                              spec-map)) [require-macros use-macros])])]\n      (set! *cljs-ns* name)\n      (let [ns-info\n            {:name           name\n             :doc            (or docstring mdocstr)\n             :excludes       excludes\n             :use-macros     use-macros\n             :require-macros require-macros\n             :rename-macros  rename-macros\n             :uses           uses\n             :requires       requires\n             :renames        (merge renames core-renames)\n             :imports        imports}]\n        (swap! env/*compiler* update-in [::namespaces name] merge ns-info)\n        (merge {:op      :ns\n                :env     env\n                :form    form\n                :deps    (into [] (distinct @deps))\n                :reload  @reload\n                :reloads @reloads}\n          (cond-> ns-info\n            (@reload :use)\n            (update-in [:uses]\n              (fn [m] (with-meta m {(@reload :use) true})))\n            (@reload :require)\n            (update-in [:requires]\n              (fn [m] (with-meta m {(@reload :require) true})))))))))\n\n(defn- check-duplicate-aliases\n  [env old new]\n  (let [ns-name (:name old)]\n    (doseq [k [:requires :require-macros]]\n      (let [old-aliases (get old k)\n            new-aliases (get new k)]\n        (when-some [alias (some (set (keys new-aliases))\n                            (->> old-aliases\n                              (remove (fn [[k v :as entry]]\n                                        (or (= k v)\n                                            (= entry (find new-aliases k)))))\n                              keys))]\n          (throw (error env\n                   (str \"Alias \" alias \" already exists in namespace \" ns-name\n                     \", aliasing \" (get old-aliases alias)))))))))\n\n(defmethod parse 'ns*\n  [_ env [_ quoted-specs :as form] _ opts]\n  (when-let [not-quoted (->> (remove keyword? quoted-specs)\n                          (remove #(and (seq? %) (= 'quote (first %))) )\n                          first)]\n    (throw (error env (str \"Arguments to \" (name (first quoted-specs))\n                        \" must be quoted. Offending spec: \" not-quoted))))\n  (when-not *allow-ns*\n    (throw (error env (str \"Calls to `\" (name (first quoted-specs))\n                        \"` must appear at the top-level.\"))))\n  (let [specs        (if (= :import (first quoted-specs))\n                       (canonicalize-import-specs quoted-specs)\n                       (canonicalize-specs quoted-specs))\n        name         (-> env :ns :name)\n        args         (desugar-ns-specs\n                       #?(:clj  (list (process-rewrite-form\n                                        specs))\n                          :cljs (list specs)))\n        {excludes :excludes core-renames :renames} (parse-ns-excludes env args)\n        core-renames (reduce (fn [m [original renamed]]\n                               (assoc m renamed (symbol \"cljs.core\" (str original))))\n                       {} core-renames)\n        deps         (atom [])\n        aliases      (atom {:fns {} :macros {}})\n        spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                      :require-macros (partial parse-require-spec env true deps aliases)\n                      :use            (comp (partial parse-require-spec env false deps aliases)\n                                        (partial use->require env))\n                      :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                        (partial use->require env))\n                      :import         (partial parse-import-spec env deps)}\n        reload       (atom {:use nil :require nil :use-macros nil :require-macros nil})\n        reloads      (atom {})\n        {uses :use requires :require renames :rename\n         use-macros :use-macros require-macros :require-macros\n         rename-macros :rename-macros imports :import :as params}\n        (reduce\n          (fn [m [k & libs]]\n            ;; check for spec type reloads\n            (when-not (= :import k)\n              (when (some? (some #{:reload} libs))\n                (swap! reload assoc k :reload))\n              (when (some? (some #{:reload-all} libs))\n                (swap! reload assoc k :reload-all)))\n            ;; check for individual ns reloads from REPL interactions\n            (when-some [xs (seq (filter #(-> % meta :reload) libs))]\n              (swap! reloads assoc k\n                (zipmap (map first xs) (map #(-> % meta :reload) xs))))\n            (apply merge-with merge m\n              (map (spec-parsers k)\n                (remove #{:reload :reload-all} libs))))\n          {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (let [require-info\n          {:name           name\n           :excludes       excludes\n           :use-macros     use-macros\n           :require-macros require-macros\n           :rename-macros  rename-macros\n           :uses           uses\n           :requires       requires\n           :renames        (merge renames core-renames)\n           :imports        imports}\n          ns-info\n          (let [ns-info' (get-in @env/*compiler* [::namespaces name])]\n            (if (pos? (count ns-info'))\n              (let [merge-keys\n                    [:use-macros :require-macros :rename-macros\n                     :uses :requires :renames :imports]]\n                #?(:clj\n                   (when *check-alias-dupes*\n                     (check-duplicate-aliases env ns-info' require-info)))\n                (merge\n                  ns-info'\n                  {:excludes excludes}\n                  (merge-with merge\n                    (select-keys ns-info' merge-keys)\n                    (select-keys require-info merge-keys))))\n              require-info))]\n      (swap! env/*compiler* update-in [::namespaces name] merge ns-info)\n      (merge {:op      :ns*\n              :env     env\n              :form    form\n              :deps    (into [] (distinct @deps))\n              :reload  @reload\n              :reloads @reloads}\n        (cond-> require-info\n          (@reload :use)\n          (update-in [:uses]\n            (fn [m] (with-meta m {(@reload :use) true})))\n          (@reload :require)\n          (update-in [:requires]\n            (fn [m] (with-meta m {(@reload :require) true}))))))))\n\n(defn parse-type\n  [op env [_ tsym fields pmasks body :as form]]\n  (let [t (:name (resolve-var (dissoc env :locals) tsym))\n        locals (reduce (fn [m fld]\n                         (assoc m fld\n                                {:name fld\n                                 :line (get-line fld env)\n                                 :column (get-col fld env)\n                                 :local :field\n                                 :field true\n                                 :mutable (-> fld meta :mutable)\n                                 :unsynchronized-mutable (-> fld meta :unsynchronized-mutable)\n                                 :volatile-mutable (-> fld meta :volatile-mutable)\n                                 :tag (-> fld meta :tag)\n                                 :shadow (m fld)}))\n                       {} (if (= :defrecord op)\n                            (concat fields '[__meta __extmap ^:mutable __hash])\n                            fields))\n        protocols (-> tsym meta :protocols)]\n    (swap! env/*compiler* update-in [::namespaces (-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {})\n                       :name t\n                       :tag 'function\n                       :type true\n                       :num-fields (count fields)\n                       :record (= :defrecord op))]\n               (merge m\n                      (dissoc (meta tsym) :protocols)\n                      {:protocols protocols}\n                      (source-info tsym env)))))\n    {:op op :env env :form form :t t :fields fields :pmasks pmasks\n     :tag 'function\n     :protocols (disj protocols 'cljs.core/Object)\n     :children [#_:fields :body]\n     :body (analyze (assoc env :locals locals) body)}))\n\n(defmethod parse 'deftype*\n  [_ env form _ _]\n  (parse-type :deftype env form))\n\n(defmethod parse 'defrecord*\n  [_ env form _ _]\n  (parse-type :defrecord env form) )\n\n;; dot accessor code\n\n(def ^:private property-symbol? #(boolean (and (symbol? %) (re-matches #\"^-.*\" (name %)))))\n\n(defn- classify-dot-form\n  [[target member args]]\n  [(cond (nil? target) ::error\n         :default      ::expr)\n   (cond (property-symbol? member) ::property\n         (symbol? member)          ::symbol\n         (seq? member)             ::list\n         :default                  ::error)\n   (cond (nil? args) ()\n         :default    ::expr)])\n\n(defmulti build-dot-form #(classify-dot-form %))\n\n;; (. o -p)\n;; (. (...) -p)\n(defmethod build-dot-form [::expr ::property ()]\n  [[target prop _]]\n  {:dot-action ::access :target target :field (-> prop name (.substring 1) symbol)})\n\n;; (. o -p <args>)\n(defmethod build-dot-form [::expr ::property ::list]\n  [[target prop args]]\n  #?(:clj  (throw (Error. (str \"Cannot provide arguments \" args \" on property access \" prop)))\n     :cljs (throw (js/Error. (str \"Cannot provide arguments \" args \" on property access \" prop)))))\n\n(defn- build-method-call\n  \"Builds the intermediate method call map used to reason about the parsed form during\n  compilation.\"\n  [target meth args]\n  (if (symbol? meth)\n    {:dot-action ::call :target target :method meth :args args}\n    {:dot-action ::call :target target :method (first meth) :args args}))\n\n;; (. o m 1 2)\n(defmethod build-dot-form [::expr ::symbol ::expr]\n  [[target meth args]]\n  (build-method-call target meth args))\n\n;; (. o m)\n(defmethod build-dot-form [::expr ::symbol ()]\n  [[target meth args]]\n  (build-method-call target meth args))\n\n;; (. o (m))\n;; (. o (m 1 2))\n(defmethod build-dot-form [::expr ::list ()]\n  [[target meth-expr _]]\n  (build-method-call target (first meth-expr) (rest meth-expr)))\n\n(defmethod build-dot-form :default\n  [dot-form]\n  #?(:clj  (throw\n             (Error.\n               (str \"Unknown dot form of \"\n                 (list* '. dot-form) \" with classification \"\n                 (classify-dot-form dot-form))))\n     :cljs (throw\n             (js/Error.\n               (str \"Unknown dot form of \"\n                 (list* '. dot-form) \" with classification \"\n                 (classify-dot-form dot-form))))))\n\n(defn analyze-dot [env target field member+ form]\n  (let [v [target field member+]\n        {:keys [dot-action target method field args]} (build-dot-form v)\n        enve       (assoc env :context :expr)\n        targetexpr (analyze enve target)\n        form-meta  (meta form)\n        target-tag (:tag targetexpr)\n        prop       (or field method)\n        tag        (or (:tag form-meta)\n                       (and (js-tag? target-tag)\n                            (vary-meta (normalize-js-tag target-tag)\n                              update-in [:prefix] (fnil conj '[Object]) prop))\n                       nil)]\n    (when (and (not= 'constructor prop)\n               (not (string/starts-with? (str prop) \"cljs$\")))\n      ;; Adding to Object\n      (when (= 'Object (first (-> tag meta :prefix)))\n        (warning :infer-warning env\n          {:warn-type :object :form form :property prop}))\n      (when (not= 'js target-tag)\n        ;; Cannot determine type of the target\n        (when (or (nil? target-tag) ('#{any} target-tag))\n          (warning :infer-warning env\n            {:warn-type :target :form form}))\n        ;; Unresolveable property on existing extern\n        (let [[pre' pre] ((juxt butlast identity) (-> tag meta :prefix))]\n          (when (and (has-extern? pre') (not (has-extern? pre)))\n            (warning :infer-warning env\n              {:warn-type :property :form form\n               :type (symbol \"js\"\n                       (string/join \".\"\n                         (cond-> pre' (= 'prototype (last pre')) butlast)))\n               :property prop})))))\n    (when (js-tag? tag)\n      (let [pre (-> tag meta :prefix)]\n        (when-not (has-extern? pre)\n          (swap! env/*compiler* update-in\n            (into [::namespaces (-> env :ns :name) :externs] pre) merge {}))))\n    (case dot-action\n      ::access (let [children [:target]]\n                 {:op :host-field\n                  :env env\n                  :form form\n                  :target targetexpr\n                  :field field\n                  :children children\n                  :tag (if (js-tag? tag)\n                         (or (js-tag (-> tag meta :prefix) :tag) tag)\n                         tag)})\n      ::call   (let [argexprs (mapv #(analyze enve %) args)\n                     children [:target :args]]\n                 {:op :host-call\n                  :env env\n                  :form form\n                  :target targetexpr\n                  :method method\n                  :args argexprs\n                  :children children\n                  :tag (if (js-tag? tag)\n                         (or (js-tag (-> tag meta :prefix) :ret-tag) 'js)\n                         tag)}))))\n\n(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _ _]\n  (disallowing-recur (analyze-dot env target field member+ form)))\n\n(defn get-js-tag [form]\n  (let [form-meta (meta form)]\n    (if-some [tag (:tag form-meta)]\n      tag\n      (when (true? (:numeric form-meta))\n        'number))))\n\n(defn js-star-interp\n  [env ^String s]\n  (let [idx (.indexOf s \"~{\")]\n    (if (== -1 idx)\n      (list s)\n      (let [end (.indexOf s \"}\" idx)\n            inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n        (lazy-seq\n          (cons (subs s 0 idx)\n            (cons inner\n              (js-star-interp env (subs s (inc end))))))))))\n\n(defn js-star-seg\n  [^String s]\n  (let [idx (.indexOf s \"~{\")]\n    (if (== -1 idx)\n      (list s)\n      (let [end (.indexOf s \"}\" idx)]\n        (lazy-seq\n          (cons (subs s 0 idx)\n            (js-star-seg (subs s (inc end)))))))))\n\n(def NUMERIC_SET '#{any number long double})\n\n(defn numeric-type?\n  #?(:cljs {:tag boolean})\n  [t]\n  ;; TODO: type inference is not strong enough to detect that\n  ;; when functions like first won't return nil, so variadic\n  ;; numeric functions like cljs.core/< would produce a spurious\n  ;; warning without this - David\n  (cond\n    (nil? t) true\n    (= 'clj-nil t) true\n    (js-tag? t) true ;; TODO: revisit\n    :else\n    (if (and (symbol? t) (some? (get NUMERIC_SET t)))\n      true\n      (when #?(:clj  (set? t)\n               :cljs (cljs-set? t))\n        (or (contains? t 'number)\n            (contains? t 'long)\n            (contains? t 'double)\n            (contains? t 'any)\n            (contains? t 'js))))))\n\n(def array-types\n  '#{array objects ints longs floats doubles chars shorts bytes boolean})\n\n(defn array-type?\n  #?(:cljs {:tag boolean})\n  [t]\n  ;; TODO same inference caveats as the numeric-type? fn above\n  (cond\n    (nil? t) true\n    (= 'clj-nil t) true\n    (js-tag? t) true ;; TODO: revisit\n    (= 'any t) true\n    (contains? array-types t) true\n    :else\n    (boolean\n      (when #?(:clj  (set? t)\n               :cljs (cljs-set? t))\n        (or (contains? t 'any)\n            (contains? t 'js)\n            (some array-types t))))))\n\n(defn analyze-js-star* [env jsform args form]\n  (let [enve      (assoc env :context :expr)\n        argexprs  (vec (map #(analyze enve %) args))\n        form-meta (meta form)\n        segs      (js-star-seg jsform)\n        tag       (get-js-tag form)\n        js-op     (:js-op form-meta)\n        numeric   (:numeric form-meta)\n        validate  (fn [warning-type valid-types?]\n                    (let [types (map #(infer-tag env %) argexprs)]\n                      (when-not (valid-types? types)\n                        (warning warning-type env\n                          {:js-op js-op\n                           :types (into [] types)}))))\n        op-match? (fn [sym]\n                    #?(:clj  (= sym (:js-op form-meta))\n                       :cljs (symbol-identical? sym (:js-op form-meta))))]\n    (when (true? numeric)\n      (validate :invalid-arithmetic #(every? numeric-type? %)))\n    {:op :js\n     :env env\n     :segs segs\n     :args argexprs\n     :tag tag\n     :form form\n     :children [:args]\n     :js-op js-op\n     :numeric numeric}))\n\n(defn analyze-js-star [env jsform args form]\n  (disallowing-recur (analyze-js-star* env jsform args form)))\n\n(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _ _]\n  (when-not (string? jsform)\n    (throw (error env \"Invalid js* form\")))\n  (if (some? args)\n    (analyze-js-star env jsform args form)\n    (let [code      (apply str (js-star-interp env jsform))\n          tag       (get-js-tag form)\n          form-meta (meta form)\n          js-op     (:js-op form-meta)\n          numeric   (:numeric form-meta)]\n      {:op :js\n       :env env\n       :form form\n       :code code\n       :tag tag\n       :js-op js-op\n       :numeric numeric})))\n\n;; TODO: analyzed analyzed? should take pass name as qualified keyword arg\n;; then compiler passes can mark/check individually - David\n\n(defn- unsorted-map? [x]\n  (and (map? x)\n       (not (sorted? x))))\n\n(defn analyzed\n  \"Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass.\"\n  [x]\n  (cond\n    (unsorted-map? x) (assoc x ::analyzed true)\n    :else (vary-meta x assoc ::analyzed true)))\n\n(defn analyzed?\n  \"Returns boolean if the form has already been marked as analyzed.\"\n  #?(:cljs {:tag boolean})\n  [x]\n  (boolean\n    (cond\n      (unsorted-map? x) (::analyzed x)\n      :else (::analyzed (meta x)))))\n\n(defn- all-values?\n  #?(:cljs {:tag boolean})\n  [exprs]\n  (every? #(or (nil? %) (symbol? %) (string? %) (number? %) (true? %) (false? %)) exprs))\n\n(defn- valid-arity?\n  #?(:cljs {:tag boolean})\n  [argc method-params]\n  (boolean (some #{argc} (map count method-params))))\n\n(defn parse-invoke*\n  [env [f & args :as form]]\n  (let [enve    (assoc env :context :expr)\n        fexpr   (analyze enve f)\n        argc    (count args)\n        fn-var? (-> fexpr :info :fn-var)\n        kw?     (= 'cljs.core/Keyword (:tag fexpr))\n        cur-ns  (-> env :ns :name)\n        HO-invoke? (and (boolean *cljs-static-fns*)\n                        (not fn-var?)\n                        (not (js-tag? f))\n                        (not kw?)\n                        (not (analyzed? f)))\n        ;; function expressions, eg: ((deref m) x) or ((:x m) :a)\n        bind-f-expr? (and HO-invoke?\n                          (not (symbol? f)))\n        ;; Higher order invokes with (some) argument expressions. Bind the arguments\n        ;; to avoid exponential complexity that is created by the IFn arity check branch.\n        bind-args? (and HO-invoke?\n                        (not (all-values? args)))]\n    (when ^boolean fn-var?\n      (let [{^boolean variadic :variadic? :keys [max-fixed-arity method-params name ns macro]} (:info fexpr)]\n        ;; don't warn about invalid arity when when compiling a macros namespace\n        ;; that requires itself, as that code is not meant to be executed in the\n        ;; `$macros` ns - Ant\u00F3nio Monteiro\n        (when (and #?(:cljs (not (and (gstring/endsWith (str cur-ns) \"$macros\")\n                                      (symbol-identical? cur-ns ns)\n                                      (true? macro))))\n                   (not (valid-arity? argc method-params))\n                   (or (not variadic)\n                       (and variadic (< argc max-fixed-arity))))\n          (warning :fn-arity env {:name name :argc argc}))))\n    (when (and kw? (not (or (== 1 argc) (== 2 argc))))\n      (warning :fn-arity env {:name (first form) :argc argc}))\n    (let [deprecated? (-> fexpr :info :deprecated)\n          no-warn? (-> form meta :deprecation-nowarn)]\n      (when (and (boolean deprecated?)\n                 (not (boolean no-warn?)))\n        (warning :fn-deprecated env {:fexpr fexpr})))\n    (when (some? (-> fexpr :info :type))\n      (warning :invoke-ctor env {:fexpr fexpr}))\n    (if (or bind-args? bind-f-expr?)\n      (let [arg-syms (when bind-args? (take argc (repeatedly gensym)))\n            f-sym (when bind-f-expr? (gensym \"fexpr__\"))\n            bindings (cond-> []\n                       bind-args? (into (interleave arg-syms args))\n                       bind-f-expr? (conj f-sym (analyzed f)))]\n        (analyze env\n          `(let [~@bindings]\n             (~(analyzed (if bind-f-expr? f-sym f))\n               ~@(if bind-args? arg-syms args)))))\n      (let [ana-expr #(analyze enve %)\n            argexprs (mapv ana-expr args)]\n        {:env env :op :invoke :form form :fn fexpr :args argexprs\n         :children [:fn :args]}))))\n\n(defn parse-invoke\n  [env form]\n  (disallowing-recur (parse-invoke* env form)))\n\n(defn desugar-dotted-expr [{:keys [op] :as expr}]\n  (case op\n    (:var :local) (if (dotted-symbol? (symbol (name (:name expr))))\n                    (let [s      (name (:name expr))\n                          idx    (.lastIndexOf s \".\")\n                          _ (assert (not= (inc idx) (count s)))\n                          prefix (with-meta (symbol (namespace (:name expr)) (subs s 0 idx))\n                                            (meta (:form expr)))\n                          field (symbol (subs s (inc idx)))]\n                      (assert (not (:const-expr expr)))\n                      {:op :host-field\n                       :env (:env expr)\n                       :form (list '. prefix field)\n                       :target (desugar-dotted-expr (-> expr\n                                                        (assoc :name prefix\n                                                               :form prefix)\n                                                        (dissoc :tag)\n                                                        (assoc-in [:info :name] prefix)\n                                                        (assoc-in [:env :context] :expr)))\n                       :field field\n                       :tag (:tag expr)\n                       :children [:target]})\n                    expr)\n    ;:var\n    expr))\n\n\n(defn analyze-symbol\n  \"Finds the var associated with sym\"\n  [env sym]\n  (if ^boolean (:quoted? env)\n    (do\n      (register-constant! env sym)\n      (analyze-wrap-meta {:op :const :val sym :env env :form sym :tag 'cljs.core/Symbol}))\n    (let [{:keys [line column]} (meta sym)\n          env  (if-not (nil? line)\n                 (assoc env :line line)\n                 env)\n          env  (if-not (nil? column)\n                 (assoc env :column column)\n                 env)\n          ret  {:env env :form sym}\n          lcls (:locals env)]\n      (if-some [lb (handle-symbol-local sym (get lcls sym))]\n        (merge\n          (assoc ret :op :local :info lb)\n          ;; this is a temporary workaround for core.async see CLJS-3030 - David\n          (when (map? lb)\n            (select-keys lb [:name :local :arg-id :variadic? :init])))\n        (let [sym-meta (meta sym)\n              sym-ns (namespace sym)\n              cur-ns (str (-> env :ns :name))\n              ;; when compiling a macros namespace that requires itself, we need\n              ;; to resolve calls to `my-ns.core/foo` to `my-ns.core$macros/foo`\n              ;; to avoid undeclared variable warnings - Ant\u00F3nio Monteiro\n              #?@(:cljs [sym (if (and sym-ns\n                                   (not= sym-ns \"cljs.core\")\n                                   (gstring/endsWith cur-ns \"$macros\")\n                                   (not (gstring/endsWith sym-ns \"$macros\"))\n                                   (= sym-ns (subs cur-ns 0 (- (count cur-ns) 7))))\n                               (symbol (str sym-ns \"$macros\") (name sym))\n                               sym)])\n              info     (if-not (contains? sym-meta ::analyzed)\n                         (resolve-existing-var env sym)\n                         (resolve-var env sym))]\n          (assert (:op info) (:op info))\n          (desugar-dotted-expr\n            (if-not (true? (:def-var env))\n              (merge\n                (assoc ret :info info)\n                (select-keys info [:op :name :ns :tag])\n                (when-let [const-expr (:const-expr info)]\n                  {:const-expr const-expr}))\n              (let [info (resolve-var env sym)]\n                (merge (assoc ret :op :var :info info)\n                       (select-keys info [:op :name :ns :tag]))))))))))\n\n(defn excluded?\n  #?(:cljs {:tag boolean})\n  [env sym]\n  (or (some? (gets env :ns :excludes sym))\n      (some? (gets @env/*compiler* ::namespaces (gets env :ns :name) :excludes sym))))\n\n(defn used?\n  #?(:cljs {:tag boolean})\n  [env sym]\n  (or (some? (gets env :ns :use-macros sym))\n      (some? (gets @env/*compiler* ::namespaces (gets env :ns :name) :use-macros sym))))\n\n(defn get-expander-ns [env ^String nstr]\n  ;; first check for clojure.* -> cljs.* cases\n  (let [res  (or (resolve-macro-ns-alias env nstr nil)\n                 (resolve-ns-alias env nstr nil))\n        nstr (if (some? res) (str res) nstr)]\n    (cond\n     #?@(:clj  [(= \"clojure.core\" nstr) (find-ns 'cljs.core)]\n         :cljs [(identical? \"clojure.core\" nstr) (find-macros-ns CLJS_CORE_MACROS_SYM)])\n     #?@(:clj  [(= \"clojure.repl\" nstr) (find-ns 'cljs.repl)]\n         :cljs [(identical? \"clojure.repl\" nstr) (find-macros-ns 'cljs.repl)])\n     #?@(:clj  [(.contains nstr \".\") (find-ns (symbol nstr))]\n         :cljs [(goog.string/contains nstr \".\") (find-macros-ns (symbol nstr))])\n     :else (some-> env :ns :require-macros (get (symbol nstr)) #?(:clj  find-ns\n                                                                  :cljs find-macros-ns)))))\n\n(defn get-expander* [sym env]\n  (when-not (or (some? (gets env :locals sym)) ; locals hide macros\n                (and (excluded? env sym) (not (used? env sym))))\n    (let [nstr (namespace sym)]\n      (cond\n        (some? nstr)\n        (let [ns (get-expander-ns env nstr)]\n          (when (some? ns)\n            (.findInternedVar ^clojure.lang.Namespace ns (symbol (name sym)))))\n\n        (some? (gets env :ns :rename-macros sym))\n        (let [qualified-symbol (gets env :ns :rename-macros sym)\n              nsym (symbol (namespace qualified-symbol))\n              sym  (symbol (name qualified-symbol))]\n          (.findInternedVar ^clojure.lang.Namespace\n            #?(:clj (find-ns nsym) :cljs (find-macros-ns nsym)) sym))\n\n        :else\n        (let [nsym (gets env :ns :use-macros sym)]\n          (if (and (some? nsym) (symbol? nsym))\n            (.findInternedVar ^clojure.lang.Namespace\n              #?(:clj (find-ns nsym) :cljs (find-macros-ns nsym)) sym)\n            (.findInternedVar ^clojure.lang.Namespace\n              #?(:clj (find-ns 'cljs.core) :cljs (find-macros-ns CLJS_CORE_MACROS_SYM)) sym)))))))\n\n(defn get-expander\n  \"Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander.\"\n  [sym env]\n  (let [mvar (get-expander* sym env)]\n    (when (and (some? mvar)\n            #?(:clj  (.isMacro ^clojure.lang.Var mvar)\n               :cljs ^boolean (.isMacro mvar)))\n      mvar)))\n\n#?(:cljs\n   (let [cached-var (delay (get (ns-interns* 'cljs.spec.alpha) 'macroexpand-check))]\n     (defn get-macroexpand-check-var []\n       (when (some? (find-ns-obj 'cljs.spec.alpha))\n         @cached-var))))\n\n(defn- var->sym [var]\n  #?(:clj  (symbol (str (.-ns ^clojure.lang.Var var)) (str (.-sym ^clojure.lang.Var var)))\n     :cljs (.-sym var)))\n\n(defn- do-macroexpand-check\n  [env form mac-var]\n  (when (not (-> @env/*compiler* :options :spec-skip-macros))\n    (let [mchk #?(:clj (some-> (find-ns 'clojure.spec.alpha)\n                       (ns-resolve 'macroexpand-check))\n                :cljs (get-macroexpand-check-var))]\n    (when (some? mchk)\n      (try\n        (mchk mac-var (next form))\n        (catch #?(:clj Throwable :cljs :default) e\n          (throw (ex-info nil (error-data env :macro-syntax-check (var->sym mac-var)) e))))))))\n\n(defn macroexpand-1*\n  [env form]\n  (let [op (first form)]\n    (if (contains? specials op)\n      (do\n        (when (= 'ns op)\n          (do-macroexpand-check env form (get-expander 'cljs.core/ns-special-form env)))\n        form)\n      ;else\n        (if-some [mac-var (when (symbol? op) (get-expander op env))]\n          (#?@(:clj [binding [*ns* (create-ns *cljs-ns*)]]\n               :cljs [do])\n            (do-macroexpand-check env form mac-var)\n            (let [form' (try\n                          (apply @mac-var form env (rest form))\n                          #?(:clj (catch ArityException e\n                                    (throw (ArityException. (- (.actual e) 2) (.name e)))))\n                          (catch #?(:clj Throwable :cljs :default) e\n                            (throw (ex-info nil (error-data env :macroexpansion (var->sym mac-var)) e))))]\n              (if #?(:clj (seq? form') :cljs (cljs-seq? form'))\n                (let [sym' (first form')\n                      sym  (first form)]\n                  (if #?(:clj  (= sym' 'js*)\n                         :cljs (symbol-identical? sym' JS_STAR_SYM))\n                    (let [sym   (if (some? (namespace sym))\n                                  sym\n                                  (symbol \"cljs.core\" (str sym)))\n                          js-op {:js-op sym}\n                          numeric #?(:clj  (-> mac-var meta ::numeric)\n                                     :cljs (let [mac-var-ns   (symbol (namespace (.-sym mac-var)))\n                                                 mac-var-name (symbol (name (.-sym mac-var)))]\n                                             (get-in @env/*compiler*\n                                               [::namespaces mac-var-ns :defs mac-var-name :meta ::numeric])))\n                          js-op (if (true? numeric)\n                                  (assoc js-op :numeric true)\n                                  js-op)]\n                      (vary-meta form' merge js-op))\n                    form'))\n                form')))\n          (if (symbol? op)\n            (let [opname (str op)]\n              (cond\n                (identical? \\.\n                  #?(:clj  (first opname)\n                     :cljs (.charAt opname 0)))\n                (let [[target & args] (next form)]\n                  (with-meta (list* #?(:clj '. :cljs DOT_SYM) target (symbol (subs opname 1)) args)\n                    (meta form)))\n\n                (identical? \\.\n                  #?(:clj  (last opname)\n                     :cljs (.charAt opname (dec (. opname -length)))))\n                (with-meta\n                  (list* #?(:clj 'new :cljs NEW_SYM) (symbol (subs opname 0 (dec (count opname)))) (next form))\n                  (meta form))\n\n                :else form))\n            form)))))\n\n(defn macroexpand-1\n  \"Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once.\"\n  [env form]\n  (wrapping-errors env (macroexpand-1* env form)))\n\n(declare analyze-list)\n\n(defn analyze-seq* [op env form name opts]\n  (if (contains? specials op)\n    (parse op env form name opts)\n    (parse-invoke env form)))\n\n(defn analyze-seq*-wrap [op env form name opts]\n  (wrapping-errors env\n    (analyze-seq* op env form name opts)))\n\n(defn analyze-seq\n  ([env form name]\n   (analyze-seq env form name\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([env form name opts]\n   (if ^boolean (:quoted? env)\n     (analyze-list env form)\n     (let [line (-> form meta :line)\n           line (if (nil? line)\n                  (:line env)\n                  line)\n           col  (-> form meta :column)\n           col  (if (nil? col)\n                  (:column env)\n                  col)\n           env  (assoc env :line line :column col)]\n       (let [op (first form)]\n         (when (nil? op)\n           (throw (error env \"Can't call nil\")))\n         (let [mform (macroexpand-1 env form)]\n           (if (identical? form mform)\n             (analyze-seq*-wrap op env form name opts)\n             (analyze env mform name opts))))))))\n\n(defn analyze-map\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        ks (disallowing-recur (mapv #(analyze expr-env %) (keys form)))\n        vs (disallowing-recur (mapv #(analyze expr-env %) (vals form)))]\n    (analyze-wrap-meta {:op :map :env env :form form\n                        :keys ks :vals vs\n                        :children [:keys :vals]\n                        :tag 'cljs.core/IMap})))\n\n;; :list is not used in the emitter any more, but analyze-list is called from analyze-const\n;; to hit the `register-constant!` cases for symbols and keywords.\n(defn analyze-list\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        items (disallowing-recur (mapv #(analyze expr-env %) form))]\n    (analyze-wrap-meta {:op :list :env env :form form :items items :children [:items] :tag 'cljs.core/IList})))\n\n(defn analyze-vector\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        items (disallowing-recur (mapv #(analyze expr-env %) form))]\n    (analyze-wrap-meta {:op :vector :env env :form form :items items :children [:items] :tag 'cljs.core/IVector})))\n\n(defn analyze-set\n  [env form]\n  (let [expr-env (assoc env :context :expr)\n        items (disallowing-recur (mapv #(analyze expr-env %) form))]\n    (analyze-wrap-meta {:op :set :env env :form form :items items :children [:items] :tag 'cljs.core/ISet})))\n\n(defn analyze-js-value\n  [env ^JSValue form]\n  (let [val (.-val form)\n        expr-env (assoc env :context :expr)]\n    (if (map? val)\n      (let [keys (vec (keys val))\n            vals (disallowing-recur\n                   (mapv #(analyze expr-env %) (vals val)))]\n        {:op :js-object\n         :env env\n         :form form\n         :keys keys\n         :vals vals\n         :children [:vals]\n         :tag 'object})\n      (let [items (disallowing-recur\n                    (mapv #(analyze expr-env %) val))]\n        {:op :js-array\n         :env env\n         :form form\n         :items items\n         :children [:items]\n         :tag 'array}))))\n\n(defn record-ns+name [x]\n  (map symbol\n       #?(:clj\n          ((juxt (comp #(string/join \".\" %) butlast) last)\n           (string/split (.getName ^Class (type x)) #\"\\.\"))\n          :cljs\n          (string/split (pr-str (type x)) #\"/\"))))\n\n(defn analyze-record\n  [env x]\n  (let [;; register constansts\n        _items_   (disallowing-recur\n                    (analyze (assoc env :context :expr) (into {} x)))\n        [ns name] (record-ns+name x)]\n    {:op :const\n     :val x\n     :env env\n     :form x\n     :tag (symbol (str ns) (str name))}))\n\n(defn elide-reader-meta [m]\n  (dissoc m :file :line :column :end-column :end-line :source))\n\n(defn elide-analyzer-meta [m]\n  (dissoc m ::analyzed))\n\n(defn elide-irrelevant-meta [m]\n  (-> m elide-reader-meta elide-analyzer-meta))\n\n(defn analyze-wrap-meta [expr]\n  (let [form (:form expr)\n        m    (elide-irrelevant-meta (meta form))]\n    (if (some? (seq m))\n      (let [env (:env expr) ; take on expr's context ourselves\n            expr (assoc-in expr [:env :context] :expr) ; change expr to :expr\n            meta-expr (analyze-map (:env expr) m)]\n        {:op :with-meta :env env :form form\n         :meta meta-expr :expr expr :children [:meta :expr]})\n      expr)))\n\n(defn infer-type [env {:keys [tag] :as ast} _]\n  (if (or (nil? tag) (= 'function tag))\n    ;; infer-type won't get a chance to process :methods\n    ;; so treat :fn as a special case for now, could probably\n    ;; fix up to use :children to walk child nodes\n    (if (= :fn (:op ast))\n      (update ast :methods\n        (fn [ms] (into [] (map #(infer-type env % _)) ms)))\n      (if-some [tag (infer-tag env ast)]\n        (assoc ast :tag tag)\n        ast))\n    ast))\n\n(defn- repl-self-require? [env deps]\n  (and (:repl-env env) (some #{*cljs-ns*} deps)))\n\n#?(:clj\n   (defn ns-side-effects\n     [env {:keys [op] :as ast} opts]\n     (if (#{:ns :ns*} op)\n       (let [{:keys [name deps uses require-macros use-macros reload reloads]} ast]\n         (when (and *analyze-deps* (seq deps))\n           (analyze-deps\n             (if (repl-self-require? env deps) 'cljs.user name)\n             deps env (dissoc opts :macros-ns)))\n         (if *load-macros*\n           (do\n             (load-core)\n             (doseq [nsym (vals use-macros)]\n               (let [k (or (:use-macros reload)\n                         (get-in reloads [:use-macros nsym])\n                         (and (= nsym name) *reload-macros* :reload))]\n                 (if k\n                   (locking load-mutex\n                     (clojure.core/require nsym k))\n                   (locking load-mutex\n                     (clojure.core/require nsym)))\n                 (intern-macros nsym k)))\n             (doseq [nsym (vals require-macros)]\n               (let [k (or (:require-macros reload)\n                         (get-in reloads [:require-macros nsym])\n                         (and (= nsym name) *reload-macros* :reload))]\n                 (if k\n                   (locking load-mutex\n                     (clojure.core/require nsym k))\n                   (locking load-mutex\n                     (clojure.core/require nsym)))\n                 (intern-macros nsym k)))\n             (-> ast\n               (check-use-macros-inferring-missing env)\n               (check-rename-macros-inferring-missing env)))\n           (do\n             (check-uses\n               (when (and *analyze-deps* (seq uses))\n                 (missing-uses uses env))\n               env)\n             ast)))\n       ast)))\n\n;; A set of validators that can be used to do static type\n;; checking of runtime fns based on inferred argument types.\n(def invoke-arg-type-validators\n  (let [aget-validator {:valid?       #(and (array-type? (first %))\n                                            (every? numeric-type? (rest %)))\n                        :warning-type :invalid-array-access}\n        aset-validator {:valid?       #(and (array-type? (first %))\n                                            (every? numeric-type? (butlast (rest %))))\n                        :warning-type :invalid-array-access}]\n    {'cljs.core/checked-aget  aget-validator\n     'cljs.core/checked-aset  aset-validator\n     'cljs.core/checked-aget' aget-validator\n     'cljs.core/checked-aset' aset-validator}))\n\n(defn check-invoke-arg-types\n  [env {:keys [op] :as ast} opts]\n  (when (and (not (analyzed? ast))\n             #?(:clj  (= :invoke op)\n                :cljs (keyword-identical? :invoke op)))\n    (when-some [[name {:keys [valid? warning-type]}] (find invoke-arg-type-validators (-> ast :fn :info :name))]\n      (let [types (mapv :tag (:args ast))]\n        (when-not (valid? types)\n          (warning warning-type env\n            {:name  name\n             :types types})))))\n  (analyzed ast))\n\n#?(:clj\n   (defn analyze-form [env form name opts]\n     (cond\n       (symbol? form) (analyze-symbol env form)\n       (and (seq? form) (seq form)) (analyze-seq env form name opts)\n       (record? form) (analyze-record env form)\n       (map? form) (analyze-map env form)\n       (vector? form) (analyze-vector env form)\n       (set? form) (analyze-set env form)\n       (keyword? form) (analyze-keyword env form)\n       (instance? JSValue form) (analyze-js-value env form)\n       :else\n       (let [tag (cond\n                   (nil? form) 'clj-nil\n                   (number? form) 'number\n                   (string? form) 'string\n                   (instance? Character form) 'string\n                   (true? form) 'boolean\n                   (false? form) 'boolean\n                   (= () form) 'cljs.core/IList)]\n         (cond-> {:op :const :val form :env env :form form}\n           tag (assoc :tag tag))))))\n\n#?(:cljs\n   (defn analyze-form [env form name opts]\n     (cond\n       (symbol? form) (analyze-symbol env form)\n       (and (cljs-seq? form) (some? (seq form))) (analyze-seq env form name opts)\n       (record? form) (analyze-record env form)\n       (cljs-map? form) (analyze-map env form)\n       (cljs-vector? form) (analyze-vector env form)\n       (cljs-set? form) (analyze-set env form)\n       (keyword? form) (analyze-keyword env form)\n       (instance? cljs.tagged-literals/JSValue form) (analyze-js-value env form)\n       :else\n       (let [tag (cond\n                   (nil? form) CLJ_NIL_SYM\n                   (number? form) NUMBER_SYM\n                   (string? form) STRING_SYM\n                   (true? form) BOOLEAN_SYM\n                   (false? form) BOOLEAN_SYM\n                   (= () form) 'cljs.core/IList)]\n         (cond-> {:op :const :val form :env env :form form}\n           tag (assoc :tag tag))))))\n\n(defn analyze* [env form name opts]\n  (let [passes *passes*\n        passes (if (nil? passes)\n                 #?(:clj  [infer-type check-invoke-arg-types ns-side-effects]\n                    :cljs [infer-type check-invoke-arg-types])\n                 passes)\n        form   (if (instance? LazySeq form)\n                 (if (seq form) form ())\n                 form)\n        ast    (analyze-form env form name opts)]\n    (reduce (fn [ast pass] (pass env ast opts)) ast passes)))\n\n(defn analyze\n  \"Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have a :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set.\"\n  ([env form] (analyze env form nil))\n  ([env form name]\n   (analyze env form name\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([env form name opts]\n   (wrapping-errors env\n     (if (analyzed? form)\n       (no-warn (analyze* env form name opts))\n       (analyze* env form name opts)))))\n\n(defn add-consts\n  \"Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source.\"\n  [compiler-state constants-map]\n  (reduce-kv\n    (fn [compiler-state sym value]\n      (let [ns (symbol (namespace sym))]\n        (update-in compiler-state\n          [::namespaces ns :defs (symbol (name sym))] merge\n          {:const-expr\n           (binding [*passes* (conj *passes* (replace-env-pass {:context :expr}))]\n             (analyze (empty-env) value))})))\n    compiler-state constants-map))\n\n#?(:clj\n   (defn- source-path\n     \"Returns a path suitable for providing to tools.reader as a 'filename'.\"\n     [x]\n     (cond\n       (instance? File x) (.getAbsolutePath ^File x)\n       :default (str x))))\n\n(defn resolve-symbol [sym]\n  (if (and (not (namespace sym))\n           (dotted-symbol? sym))\n    sym\n    (:name (binding [*private-var-access-nowarn* true]\n             (resolve-var (assoc @env/*compiler* :ns (get-namespace *cljs-ns*))\n               sym)))))\n\n#?(:clj\n   (defn forms-seq*\n     \"Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors.\"\n     ([^Reader rdr] (forms-seq* rdr nil))\n     ([^Reader rdr filename]\n      {:pre [(instance? Reader rdr)]}\n      (let [eof-sentinel (Object.)\n            opts (merge\n                   {:eof eof-sentinel}\n                   (if (and filename (= (util/ext filename) \"cljc\"))\n                     {:read-cond :allow :features #{:cljs}}))\n            pbr (readers/indexing-push-back-reader\n                  (PushbackReader. rdr) 1 filename)\n            data-readers tags/*cljs-data-readers*\n            forms-seq_\n            (fn forms-seq_ []\n              (lazy-seq\n                (let [form (binding [*ns* (create-ns *cljs-ns*)\n                                     reader/*data-readers* data-readers\n                                     reader/*alias-map*\n                                     (apply merge\n                                       ((juxt :requires :require-macros)\n                                         (get-namespace *cljs-ns*)))\n                                     reader/resolve-symbol resolve-symbol]\n                             (reader/read opts pbr))]\n                  (if (identical? form eof-sentinel)\n                    (.close rdr)\n                    (cons form (forms-seq_))))))]\n        (forms-seq_)))))\n\n#?(:clj\n   (defn forms-seq\n     \"DEPRECATED: Seq of Clojure/ClojureScript forms from [f], which can be anything\n     for which `clojure.java.io/reader` can produce a `java.io.Reader`. Optionally\n     accepts a [filename] argument, which the reader will use in any emitted errors.\"\n     ([f] (forms-seq f (source-path f)))\n     ([f filename] (forms-seq f filename false))\n     ([f filename return-reader?]\n      (let [rdr (io/reader f)\n            pbr (readers/indexing-push-back-reader\n                  (PushbackReader. rdr) 1 filename)\n            data-readers tags/*cljs-data-readers*\n            forms-seq*\n            (fn forms-seq* []\n              (lazy-seq\n                (let [eof-sentinel (Object.)\n                      form (binding [*ns* (create-ns *cljs-ns*)\n                                     reader/*data-readers* data-readers\n                                     reader/*alias-map*\n                                     (apply merge\n                                       ((juxt :requires :require-macros)\n                                         (get-namespace *cljs-ns*)))]\n                             (reader/read pbr nil eof-sentinel))]\n                  (if (identical? form eof-sentinel)\n                    (.close rdr)\n                    (cons form (forms-seq*))))))]\n        (if (true? return-reader?)\n          [(forms-seq*) rdr]\n          (forms-seq*))))))\n\n#?(:clj\n   (defn gen-user-ns\n     [src]\n     (if (sequential? src)\n       (symbol (str \"cljs.user.source$form$\" (util/content-sha (pr-str src) 7)))\n       (let [full-name (str src)\n             name (.substring full-name\n                    (inc (.lastIndexOf full-name \"/\"))\n                    (.lastIndexOf full-name \".\"))]\n         (symbol (str \"cljs.user.\" name (util/content-sha full-name 7)))))))\n\n#?(:clj\n   (defn ^:dynamic parse-ns\n     \"Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n\n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false.\"\n     ([src]\n      (parse-ns src nil\n        (when env/*compiler*\n          (:options @env/*compiler*))))\n     ([src opts] (parse-ns src nil opts))\n     ([src dest opts]\n      (ensure\n        (let [src (if (symbol? src)\n                    (util/ns->source src)\n                    src)\n              ijs\n              (binding [env/*compiler* (if (false? (:restore opts))\n                                         env/*compiler*\n                                         (atom @env/*compiler*))\n                        *cljs-ns* 'cljs.user\n                        *cljs-file* src\n                        *macro-infer*\n                        (or (when (contains? opts :macro-infer)\n                              (:macro-infer opts))\n                          false)\n                        *analyze-deps*\n                        (or (when (contains? opts :analyze-deps)\n                              (:analyze-deps opts))\n                          false)\n                        *load-macros*\n                        (or (when (contains? opts :load-macros)\n                              (:load-macros opts))\n                          false)]\n                (let [rdr (when-not (sequential? src) (io/reader src))]\n                  (try\n                    (loop [forms (if rdr\n                                   (forms-seq* rdr (source-path src))\n                                   src)\n                           ret (merge\n                                 {:file         dest\n                                  :source-file  (when rdr src)\n                                  :source-forms (when-not rdr src)\n                                  :macros-ns    (:macros-ns opts)\n                                  :requires     (cond-> #{'cljs.core}\n                                                  (get-in @env/*compiler* [:options :emit-constants])\n                                                  (conj constants-ns-sym))}\n                                 (when (and dest (.exists ^File dest))\n                                   {:lines (with-open [reader (io/reader dest)]\n                                             (-> reader line-seq count))}))]\n                      (if (seq forms)\n                        (let [env (empty-env)\n                              ast (no-warn (analyze env (first forms) nil opts))]\n                          (cond\n                            (= :ns (:op ast))\n                            (let [ns-name (:name ast)\n                                  ns-name (if (and (= 'cljs.core ns-name)\n                                                   (= \"cljc\" (util/ext src)))\n                                            'cljs.core$macros\n                                            ns-name)\n                                  deps (merge (:uses ast) (:requires ast))]\n                              (merge\n                                {:ns           (or ns-name 'cljs.user)\n                                 :provides     [ns-name]\n                                 :requires     (if (= 'cljs.core ns-name)\n                                                 (set (vals deps))\n                                                 (cond-> (conj (set (vals deps)) 'cljs.core)\n                                                   (get-in @env/*compiler* [:options :emit-constants])\n                                                   (conj constants-ns-sym)))\n                                 :file         dest\n                                 :source-file  (when rdr src)\n                                 :source-forms (when-not rdr src)\n                                 :ast          ast\n                                 :macros-ns    (or (:macros-ns opts)\n                                                   (= 'cljs.core$macros ns-name))}\n                                (when (and dest (.exists ^File dest))\n                                  {:lines (with-open [reader (io/reader dest)]\n                                            (-> reader line-seq count))})))\n\n                            (= :ns* (:op ast))\n                            (let [deps (merge (:uses ast) (:requires ast))]\n                              (recur (rest forms)\n                                (cond-> (update-in ret [:requires] into (set (vals deps)))\n                                  ;; we need to defer generating the user namespace\n                                  ;; until we actually need or it will break when\n                                  ;; `src` is a sequence of forms - Ant\u00F3nio Monteiro\n                                  (not (:ns ret))\n                                  (assoc :ns (gen-user-ns src) :provides [(gen-user-ns src)]))))\n\n                            :else ret))\n                        ret))\n                    (finally\n                      (when rdr\n                        (.close ^Reader rdr))))))]\n          (cond-> ijs\n            (not (contains? ijs :ns))\n            (merge\n              {:ns (gen-user-ns src)\n               :provides [(gen-user-ns src)]})))))))\n\n#?(:clj\n   (defn- cache-analysis-ext\n     ([] (cache-analysis-ext (get-in @env/*compiler* [:options :cache-analysis-format] :transit)))\n     ([format]\n      (if (and (= format :transit) @transit) \"json\" \"edn\"))))\n\n#?(:clj\n   (defn build-affecting-options [opts]\n     (select-keys opts\n       [:static-fns :fn-invoke-direct :optimize-constants :elide-asserts :target\n        :cache-key :checked-arrays :language-out])))\n\n#?(:clj\n   (defn build-affecting-options-sha [path opts]\n     (let [m (assoc (build-affecting-options opts) :path path)]\n       (util/content-sha (pr-str m) 7))))\n\n#?(:clj\n   (defn ^File cache-base-path\n     ([path]\n      (cache-base-path path nil))\n     ([path opts]\n      (io/file (System/getProperty \"user.home\")\n        \".cljs\" \".aot_cache\" (util/clojurescript-version)\n        (build-affecting-options-sha path opts)))))\n\n#?(:clj\n   (defn cacheable-files\n     ([rsrc ext]\n      (cacheable-files rsrc ext nil))\n     ([rsrc ext opts]\n      (let [{:keys [ns]} (parse-ns rsrc)\n            path (cache-base-path (util/path rsrc) opts)\n            name (util/ns->relpath ns nil File/separatorChar)]\n        (into {}\n          (map\n            (fn [[k v]]\n              [k (io/file path\n                   (if (and (= (str \"cljs\" File/separatorChar \"core$macros\") name)\n                         (= :source k))\n                     (str \"cljs\" File/separatorChar \"core.cljc\")\n                     (str name v)))]))\n          {:source (str \".\" ext)\n           :output-file \".js\"\n           :source-map \".js.map\"\n           :analysis-cache-edn (str \".\" ext \".cache.edn\")\n           :analysis-cache-json (str \".\" ext \".cache.json\")})))))\n\n#?(:clj\n   (defn cache-file\n     \"Given a ClojureScript source file returns the read/write path to the analysis\n      cache file. Defaults to the read path which is usually also the write path.\"\n     ([src] (cache-file src \"out\"))\n     ([src output-dir] (cache-file src (parse-ns src) output-dir))\n     ([src ns-info output-dir]\n      (cache-file src ns-info output-dir :read nil))\n     ([src ns-info output-dir mode]\n      (cache-file src ns-info output-dir mode nil))\n     ([src ns-info output-dir mode opts]\n      {:pre [(map? ns-info)]}\n      (let [ext (cache-analysis-ext)]\n        (if-let [core-cache\n                 (and (= mode :read)\n                      (= (:ns ns-info) 'cljs.core)\n                      (io/resource (str \"cljs/core.cljs.cache.aot.\" ext)))]\n          core-cache\n          (let [aot-cache-file\n                (when (util/url? src)\n                  ((keyword (str \"analysis-cache-\" ext))\n                    (cacheable-files src (util/ext src) opts)))]\n            (if (and aot-cache-file (.exists ^File aot-cache-file))\n              aot-cache-file\n              (let [target-file (util/to-target-file output-dir ns-info\n                                  (util/ext (:source-file ns-info)))]\n                (io/file (str target-file \".cache.\" ext))))))))))\n\n#?(:clj\n   (defn requires-analysis?\n     \"Given a src, a resource, and output-dir, a compilation output directory\n      return true or false depending on whether src needs to be (re-)analyzed.\n      Can optionally pass cache, the analysis cache file.\"\n     ([src] (requires-analysis? src \"out\"))\n     ([src output-dir]\n      (let [cache (cache-file src output-dir)]\n        (requires-analysis? src cache output-dir nil)))\n     ([src cache output-dir]\n      (requires-analysis? src cache output-dir nil))\n     ([src cache output-dir opts]\n      (cond\n        (util/url? cache)\n        (let [path (.getPath ^URL cache)]\n          (if (or (.endsWith path \"cljs/core.cljs.cache.aot.edn\")\n                  (.endsWith path \"cljs/core.cljs.cache.aot.json\"))\n            false\n            (throw (Exception. (str \"Invalid anlaysis cache, must be file not URL \" cache)))))\n\n        (and (util/file? cache)\n             (not (.exists ^File cache)))\n        true\n\n        :else\n        (let [out-src   (util/to-target-file output-dir (parse-ns src))\n              cache-src (:output-file (cacheable-files src (util/ext src) opts))]\n          (if (and (not (.exists out-src))\n                   (not (.exists ^File cache-src)))\n            true\n            (or (not cache) (util/changed? src cache))))))))\n\n#?(:clj\n   (defn- get-spec-vars\n     []\n     (when-let [spec-ns (find-ns 'cljs.spec.alpha)]\n       (locking load-mutex\n         {:registry-ref (ns-resolve spec-ns 'registry-ref)\n          :speced-vars  (ns-resolve spec-ns '_speced_vars)})))\n   :cljs\n   (let [registry-ref (delay (get (ns-interns* 'cljs.spec.alpha$macros) 'registry-ref))\n         ;; Here, we look up the symbol '-speced-vars because ns-interns*\n         ;; is implemented by invoking demunge on the result of js-keys.\n         speced-vars  (delay (get (ns-interns* 'cljs.spec.alpha$macros) '-speced-vars))]\n     (defn- get-spec-vars []\n       (when (some? (find-ns-obj 'cljs.spec.alpha$macros))\n         {:registry-ref @registry-ref\n          :speced-vars  @speced-vars}))))\n\n(defn dump-specs\n  \"Dumps registered speced vars for a given namespace into the compiler\n  environment.\"\n  [ns]\n  (let [spec-vars (get-spec-vars)\n        ns-str    (str ns)]\n    (swap! env/*compiler* update-in [::namespaces ns]\n      merge\n      (when-let [registry-ref (:registry-ref spec-vars)]\n        {:cljs.spec/registry-ref\n         (into []\n           (filter (fn [[k _]] (= ns-str (namespace k))))\n           @@registry-ref)})\n      (when-let [speced-vars (:speced-vars spec-vars)]\n        {:cljs.spec/speced-vars\n         (into []\n           (filter\n             (fn [v]\n               (or (= ns-str (namespace v))\n                   (= ns (-> v meta :fdef-ns)))))\n           @@speced-vars)}))))\n\n(defn register-specs\n  \"Registers speced vars found in a namespace analysis cache.\"\n  [cached-ns]\n  #?(:clj (try\n            (locking load-mutex\n              (clojure.core/require 'cljs.spec.alpha))\n            (catch Throwable t)))\n  (let [{:keys [registry-ref speced-vars]} (get-spec-vars)]\n    (when-let [registry (seq (:cljs.spec/registry-ref cached-ns))]\n      (when registry-ref\n        (swap! @registry-ref into registry)))\n    (when-let [vars (seq (:cljs.spec/speced-vars cached-ns))]\n      (when speced-vars\n        (swap! @speced-vars into vars)))))\n\n#?(:clj\n   (defn write-analysis-cache\n     ([ns cache-file]\n       (write-analysis-cache ns cache-file nil))\n     ([ns ^File cache-file src]\n      (util/mkdirs cache-file)\n      (dump-specs ns)\n      (let [ext (util/ext cache-file)\n            analysis (dissoc (get-in @env/*compiler* [::namespaces ns]) :macros)]\n        (case ext\n          \"edn\"  (spit cache-file\n                   (str \";; Analyzed by ClojureScript \" (util/clojurescript-version) \"\\n\"\n                     (pr-str analysis)))\n          \"json\" (when-let [{:keys [writer write]} @transit]\n                   (write\n                     (writer (FileOutputStream. cache-file) :json\n                       transit-write-opts)\n                     analysis))))\n      (when src\n        (.setLastModified ^File cache-file (util/last-modified src))))))\n\n#?(:clj\n   (defn read-analysis-cache\n     ([cache-file src]\n      (read-analysis-cache cache-file src nil))\n     ([^File cache-file src opts]\n       ;; we want want to keep dependency analysis information\n       ;; don't revert the environment - David\n      (let [{:keys [ns]} (parse-ns src\n                           (merge opts\n                             {:restore false\n                              :analyze-deps true\n                              :load-macros true}))\n            ext          (util/ext cache-file)\n            cached-ns    (case ext\n                           \"edn\"  (edn/read-string (slurp cache-file))\n                           \"json\" (let [{:keys [reader read]} @transit]\n                                    (with-open [is (io/input-stream cache-file)]\n                                      (read (reader is :json transit-read-opts)))))]\n        (when (or *verbose* (:verbose opts))\n          (util/debug-prn \"Reading analysis cache for\" (str src)))\n        (swap! env/*compiler*\n          (fn [cenv]\n            (do\n              (register-specs cached-ns)\n              (doseq [x (get-in cached-ns [::constants :order])]\n                (register-constant! x))\n              (-> cenv\n                (assoc-in [::namespaces ns] cached-ns)))))))))\n\n(defn analyze-form-seq\n  ([forms]\n   (analyze-form-seq forms\n     (when env/*compiler*\n       (:options @env/*compiler*))))\n  ([forms opts]\n   (analyze-form-seq forms opts false))\n  ([forms opts return-last?]\n   (let [env (assoc (empty-env) :build-options opts)]\n     (binding [*file-defs* nil\n               #?@(:clj [*unchecked-if* false\n                         *unchecked-arrays* false])\n               *cljs-ns* 'cljs.user\n               *cljs-file* nil\n               reader/*alias-map* (or reader/*alias-map* {})]\n       (loop [ns nil forms forms last-ast nil]\n         (if (some? forms)\n           (let [form (first forms)\n                 env  (assoc env :ns (get-namespace *cljs-ns*))\n                 ast  (analyze env form nil opts)]\n             (if (= (:op ast) :ns)\n               (recur (:name ast) (next forms) ast)\n               (recur ns (next forms) ast)))\n           (if return-last?\n             last-ast\n             ns)))))))\n\n(defn ensure-defs\n  \"Ensures that a non-nil defs map exists in the compiler state for a given\n  ns. (A non-nil defs map signifies that the namespace has been analyzed.)\"\n  [ns]\n  (swap! env/*compiler* update-in [::namespaces ns :defs] #(or % {})))\n\n#?(:clj\n   (defn analyze-file\n     \"Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n\n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \\\":output-dir/some/ns/foo.cljs.cache.edn\\\". This function does not return a\n      meaningful value.\"\n     ([f]\n      (analyze-file f\n        (when env/*compiler*\n          (:options @env/*compiler*))))\n     ([f opts]\n      (analyze-file f false opts))\n     ([f skip-cache opts]\n      (binding [*file-defs*        (atom #{})\n                *unchecked-if*     false\n                *unchecked-arrays* false\n                *cljs-warnings*    *cljs-warnings*]\n        (let [output-dir (util/output-directory opts)\n              res        (cond\n                           (instance? File f) f\n                           (instance? URL f) f\n                           (re-find #\"^file://\" f) (URL. f)\n                           :else (io/resource f))]\n          (assert res (str \"Can't find \" f \" in classpath\"))\n          (ensure\n            (let [ns-info (parse-ns res)\n                  path    (if (instance? File res)\n                            (.getPath ^File res)\n                            (.getPath ^URL res))\n                  cache   (when (:cache-analysis opts)\n                            (cache-file res ns-info output-dir :read opts))]\n              (when-not (get-in @env/*compiler* [::namespaces (:ns ns-info) :defs])\n                (if (or skip-cache (not cache) (requires-analysis? res cache output-dir opts))\n                  (binding [*cljs-ns* 'cljs.user\n                            *cljs-file* path\n                            reader/*alias-map* (or reader/*alias-map* {})]\n                    (when (or *verbose* (:verbose opts))\n                      (util/debug-prn \"Analyzing\" (str res)))\n                    (let [env (assoc (empty-env) :build-options opts)\n                          ns  (with-open [rdr (io/reader res)]\n                                (loop [ns nil forms (seq (forms-seq* rdr (util/path res)))]\n                                  (if forms\n                                    (let [form (first forms)\n                                          env (assoc env :ns (get-namespace *cljs-ns*))\n                                          ast (analyze env form nil opts)]\n                                      (cond\n                                        (= (:op ast) :ns)\n                                        (recur (:name ast) (next forms))\n\n                                        (and (nil? ns) (= (:op ast) :ns*))\n                                        (recur (gen-user-ns res) (next forms))\n\n                                        :else\n                                        (recur ns (next forms))))\n                                    ns)))]\n                      (ensure-defs ns)\n                      (when (and cache (true? (:cache-analysis opts)))\n                        (write-analysis-cache ns cache res))))\n                  (try\n                    (read-analysis-cache cache res opts)\n                    (catch Throwable e\n                      (analyze-file f true opts))))))))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/spec/alpha.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.spec.alpha",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.alpha\n  (:refer-clojure :exclude [+ * and or cat def keys merge])\n  (:require-macros [cljs.core :as c]\n                   [cljs.spec.alpha :as s])\n  (:require [goog.object :as gobj]\n            [cljs.core :as c]\n            [clojure.walk :as walk]\n            [cljs.spec.gen.alpha :as gen]\n            [clojure.string :as str]))\n\n(def ^:const MAX_INT 9007199254740991)\n\n(def ^:dynamic *recursion-limit*\n  \"A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.\"\n  4)\n\n(def ^:dynamic *fspec-iterations*\n  \"The number of times an anonymous fn specified by fspec will be (generatively) tested during conform\"\n  21)\n\n(def ^:dynamic *coll-check-limit*\n  \"The number of items validated in a collection spec'ed with 'every'\"\n  101)\n\n(def ^:dynamic *coll-error-limit*\n  \"The number of errors reported by explain in a collection spec'ed with 'every'\"\n  20)\n\n(defprotocol Spec\n  (conform* [spec x])\n  (unform* [spec y])\n  (explain* [spec path via in x])\n  (gen* [spec overrides path rmap])\n  (with-gen* [spec gfn])\n  (describe* [spec]))\n\n(defonce ^:private registry-ref (atom {}))\n\n(defn- deep-resolve [reg k]\n  (loop [spec k]\n    (if (ident? spec)\n      (recur (get reg spec))\n      spec)))\n\n(defn- reg-resolve\n  \"returns the spec/regex at end of alias chain starting with k, nil if not found, k if k not ident\"\n  [k]\n  (if (ident? k)\n    (let [reg @registry-ref\n          spec (get reg k)]\n      (if-not (ident? spec)\n        spec\n        (deep-resolve reg spec)))\n    k))\n\n(defn- reg-resolve!\n  \"returns the spec/regex at end of alias chain starting with k, throws if not found, k if k not ident\"\n  [k]\n  (if (ident? k)\n    (c/or (reg-resolve k)\n          (throw (js/Error. (str \"Unable to resolve spec: \" k))))\n    k))\n\n(defn spec?\n  \"returns x if x is a spec object, else logical false\"\n  [x]\n  (when (implements? Spec x)\n    x))\n\n(defn regex?\n  \"returns x if x is a (cljs.spec.alpha) regex op, else logical false\"\n  [x]\n  (c/and (::op x) x))\n\n(defn- with-name [spec name]\n  (cond\n   (ident? spec) spec\n   (regex? spec) (assoc spec ::name name)\n\n   (implements? IMeta spec)\n   (with-meta spec (assoc (meta spec) ::name name))))\n\n(defn- spec-name [spec]\n  (cond\n   (ident? spec) spec\n\n   (regex? spec) (::name spec)\n\n   (implements? IMeta spec)\n   (-> (meta spec) ::name)))\n\n(declare ^{:arglists '([form pred gfn cpred?] [form pred gfn cpred? unc])} spec-impl)\n(declare ^{:arglists '([re gfn])} regex-spec-impl)\n\n(defn- maybe-spec\n  \"spec-or-k must be a spec, regex or resolvable kw/sym, else returns nil.\"\n  [spec-or-k]\n  (let [s (c/or (c/and (ident? spec-or-k) (reg-resolve spec-or-k))\n                (spec? spec-or-k)\n                (regex? spec-or-k)\n                nil)]\n    (if (regex? s)\n      (with-name (regex-spec-impl s nil) (spec-name s))\n      s)))\n\n(defn- the-spec\n  \"spec-or-k must be a spec, regex or kw/sym, else returns nil. Throws if unresolvable kw/sym\"\n  [spec-or-k]\n  (c/or (maybe-spec spec-or-k)\n        (when (ident? spec-or-k)\n          (throw (js/Error. (str \"Unable to resolve spec: \" spec-or-k))))))\n\n(defn- fn-sym [f-n]\n  (when-not (str/blank? f-n)\n    (let [xs (map demunge (str/split f-n \"$\"))]\n      (when (c/and (<= 2 (count xs))\n                   (every? #(not (str/blank? %)) xs))\n        (let [[xs y] ((juxt butlast last) xs)]\n          (symbol (str (str/join \".\" xs) \"/\" y)))))))\n\n(defprotocol Specize\n  (specize* [_] [_ form]))\n\n(extend-protocol Specize\n  Keyword\n  (specize* ([k] (specize* (reg-resolve! k)))\n            ([k _] (specize* (reg-resolve! k))))\n\n  Symbol\n  (specize* ([s] (specize* (reg-resolve! s)))\n            ([s _] (specize* (reg-resolve! s))))\n\n  PersistentHashSet\n  (specize* ([s] (spec-impl s s nil nil))\n            ([s form] (spec-impl form s nil nil)))\n\n  PersistentTreeSet\n  (specize* ([s] (spec-impl s s nil nil))\n            ([s form] (spec-impl form s nil nil)))\n\n  default\n  (specize*\n    ([o]\n     (if-let [f-n (c/and (fn? o) (fn-sym (.-name o)))]\n       (spec-impl f-n o nil nil)\n       (spec-impl ::unknown o nil nil)))\n    ([o form] (spec-impl form o nil nil))))\n\n(defn- specize\n  ([s] (c/or (spec? s) (specize* s)))\n  ([s form] (c/or (spec? s) (specize* s form))))\n\n(defn invalid?\n  \"tests the validity of a conform return value\"\n  [ret]\n  (keyword-identical? ::invalid ret))\n\n(defn conform\n  \"Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.\"\n  [spec x]\n  (conform* (specize spec) x))\n\n(defn unform\n  \"Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.\"\n  [spec x]\n  (unform* (specize spec) x))\n\n(defn form\n  \"returns the spec as data\"\n  [spec]\n  ;;TODO - incorporate gens\n  (describe* (specize spec)))\n\n(defn abbrev [form]\n  (cond\n    (seq? form)\n    (walk/postwalk (fn [form]\n                     (cond\n                       (c/and (symbol? form) (namespace form))\n                       (-> form name symbol)\n\n                       (c/and (seq? form) (= 'fn (first form)) (= '[%] (second form)))\n                       (last form)\n\n                       :else form))\n                   form)\n\n    (c/and (symbol? form) (namespace form))\n    (-> form name symbol)\n\n    :else form))\n\n(defn describe\n  \"returns an abbreviated description of the spec as data\"\n  [spec]\n  (abbrev (form spec)))\n\n(defn with-gen\n  \"Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator\"\n  [spec gen-fn]\n  (let [spec (reg-resolve spec)]\n    (if (regex? spec)\n      (assoc spec ::gfn gen-fn)\n      (with-gen* (specize spec) gen-fn))))\n\n(defn explain-data* [spec path via in x]\n  (when-let [probs (explain* (specize spec) path via in x)]\n    (when-not (empty? probs)\n      {::problems probs\n       ::spec spec\n       ::value x})))\n\n(defn explain-data\n  \"Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.\"\n  [spec x]\n  (explain-data* spec [] (if-let [name (spec-name spec)] [name] []) [] x))\n\n(defn explain-printer\n  \"Default printer for explain-data. nil indicates a successful validation.\"\n  [ed]\n  (if ed\n    (let [problems (->> (::problems ed)\n                     (sort-by #(- (count (:in %))))\n                     (sort-by #(- (count (:path %)))))]\n      (print\n        (with-out-str\n          ;;(prn {:ed ed})\n          (doseq [{:keys [path pred val reason via in] :as prob} problems]\n            (pr val)\n            (print \" - failed: \")\n            (if reason (print reason) (pr (abbrev pred)))\n            (when-not (empty? in)\n              (print (str \" in: \" (pr-str in))))\n            (when-not (empty? path)\n              (print (str \" at: \" (pr-str path))))\n            (when-not (empty? via)\n              (print (str \" spec: \" (pr-str (last via)))))\n            (doseq [[k v] prob]\n              (when-not (#{:path :pred :val :reason :via :in} k)\n                (print \"\\n\\t\" (pr-str k) \" \")\n                (pr v)))\n            (newline)))))\n    (println \"Success!\")))\n\n(def ^:dynamic *explain-out* explain-printer)\n\n(defn explain-out\n  \"Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.\"\n  [ed]\n  (*explain-out* ed))\n\n(defn explain\n  \"Given a spec and a value that fails to conform, prints an explanation to *out*.\"\n  [spec x]\n  (explain-out (explain-data spec x)))\n\n(defn explain-str\n  \"Given a spec and a value that fails to conform, returns an explanation as a string.\"\n  [spec x]\n  (with-out-str (explain spec x)))\n\n(declare ^{:arglists '([spec x] [spec x form])} valid?)\n\n(defn- gensub\n  [spec overrides path rmap form]\n  ;;(prn {:spec spec :over overrides :path path :form form})\n  (let [spec (specize spec)]\n    (if-let [g (c/or (when-let [gfn (c/or (get overrides (c/or (spec-name spec) spec))\n                                          (get overrides path))]\n                       (gfn))\n                 (gen* spec overrides path rmap))]\n      (gen/such-that #(valid? spec %) g 100)\n      (throw (js/Error. (str \"Unable to construct gen at: \" path \" for: \" (abbrev form)))))))\n\n(defn gen\n  \"Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)\"\n  ([spec] (gen spec nil))\n  ([spec overrides] (gensub spec overrides [] {::recursion-limit *recursion-limit*} spec)))\n\n(defn ^:skip-wiki def-impl\n  \"Do not call this directly, use 'def'\"\n  [k form spec]\n  (assert (c/and (ident? k) (namespace k)) \"k must be namespaced keyword or resolveable symbol\")\n  (if (nil? spec)\n    (swap! registry-ref dissoc k)\n    (let [spec (if (c/or (spec? spec) (regex? spec) (get @registry-ref spec))\n                 spec\n                 (spec-impl form spec nil nil))]\n      (swap! registry-ref assoc k (with-name spec k))))\n  k)\n\n(defn registry\n  \"returns the registry map, prefer 'get-spec' to lookup a spec by name\"\n  []\n  @registry-ref)\n\n(defn- ->sym\n  \"Returns a symbol from a symbol or var\"\n  [x]\n  (if (var? x)\n    (.-sym x)\n    x))\n\n(defn get-spec\n  \"Returns spec registered for keyword/symbol/var k, or nil.\"\n  [k]\n  (get (registry) (if (keyword? k) k (->sym k))))\n\n(declare map-spec)\n\n(defn- macroexpand-check\n  [v args]\n  (let [specs (get-spec v)]\n    (when-let [arg-spec (:args specs)]\n      (when (invalid? (conform arg-spec args))\n        (let [ed (assoc (explain-data* arg-spec []\n                          (if-let [name (spec-name arg-spec)] [name] []) [] args)\n                   ::args args)]\n          (throw (ex-info\n                   (str\n                     \"Call to \" (->sym v) \" did not conform to spec.\")\n                   ed)))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; impl ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- recur-limit? [rmap id path k]\n  (c/and (> (get rmap id) (::recursion-limit rmap))\n         (contains? (set path) k)))\n\n(defn- inck [m k]\n  (assoc m k (inc (c/or (get m k) 0))))\n\n(defn- dt\n  ([pred x form] (dt pred x form nil))\n  ([pred x form cpred?]\n   (if pred\n     (if-let [spec (the-spec pred)]\n       (conform spec x)\n       (if (ifn? pred)\n         (if cpred?\n           (pred x)\n           (if (pred x) x ::invalid))\n         (throw (js/Error. (str (pr-str form) \" is not a fn, expected predicate fn\")))))\n     x)))\n\n(defn valid?\n  \"Helper function that returns true when x is valid for spec.\"\n  ([spec x]\n   (let [spec (specize spec)]\n     (not (invalid? (conform* spec x)))))\n  ([spec x form]\n   (let [spec (specize spec form)]\n     (not (invalid? (conform* spec x))))))\n\n(defn- pvalid?\n  \"internal helper function that returns true when x is valid for spec.\"\n  ([pred x]\n   (not (invalid? (dt pred x ::unknown))))\n  ([pred x form]\n   (not (invalid? (dt pred x form)))))\n\n(defn- explain-1 [form pred path via in v]\n  ;;(prn {:form form :pred pred :path path :in in :v v})\n  (let [pred (maybe-spec pred)]\n    (if (spec? pred)\n      (explain* pred path (if-let [name (spec-name pred)] (conj via name) via) in v)\n      [{:path path :pred form :val v :via via :in in}])))\n\n(declare ^{:arglists '([s] [min-count s])} or-k-gen\n         ^{:arglists '([s])} and-k-gen)\n\n(defn- k-gen\n  \"returns a generator for form f, which can be a keyword or a list\n  starting with 'or or 'and.\"\n  [f]\n  (cond\n    (keyword? f)       (gen/return f)\n    (= 'or  (first f)) (or-k-gen 1 (rest f))\n    (= 'and (first f)) (and-k-gen (rest f))))\n\n(defn- or-k-gen\n  \"returns a tuple generator made up of generators for a random subset\n  of min-count (default 0) to all elements in s.\"\n  ([s] (or-k-gen 0 s))\n  ([min-count s]\n   (gen/bind (gen/tuple\n               (gen/choose min-count (count s))\n               (gen/shuffle (map k-gen s)))\n     (fn [[n gens]]\n       (apply gen/tuple (take n gens))))))\n\n(defn- and-k-gen\n  \"returns a tuple generator made up of generators for every element\n  in s.\"\n  [s]\n  (apply gen/tuple (map k-gen s)))\n\n(defn ^:skip-wiki map-spec-impl\n  \"Do not call this directly, use 'spec' with a map argument\"\n  [{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn]\n    :as argm}]\n  (let [k->s (zipmap (concat req-keys opt-keys) (concat req-specs opt-specs))\n        keys->specnames #(c/or (k->s %) %)\n        id (random-uuid)]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ m]\n        (if (keys-pred m)\n          (let [reg (registry)]\n            (loop [ret m, [[k v] & ks :as keys] m]\n              (if keys\n                (let [sname (keys->specnames k)]\n                  (if-let [s (get reg sname)]\n                    (let [cv (conform s v)]\n                      (if (invalid? cv)\n                        ::invalid\n                        (recur (if (identical? cv v) ret (assoc ret k cv))\n                          ks)))\n                    (recur ret ks)))\n                ret)))\n          ::invalid))\n      (unform* [_ m]\n        (let [reg (registry)]\n          (loop [ret m, [k & ks :as keys] (c/keys m)]\n            (if keys\n              (if (contains? reg (keys->specnames k))\n                (let [cv (get m k)\n                      v (unform (keys->specnames k) cv)]\n                  (recur (if (identical? cv v) ret (assoc ret k v))\n                    ks))\n                (recur ret ks))\n              ret))))\n      (explain* [_ path via in x]\n        (if-not (map? x)\n          [{:path path :pred `map? :val x :via via :in in}]\n          (let [reg (registry)]\n            (apply concat\n                   (when-let [probs (->> (map (fn [pred form] (when-not (pred x) form))\n                                              pred-exprs pred-forms)\n                                         (keep identity)\n                                         seq)]\n                     (map\n                       #(identity {:path path :pred % :val x :via via :in in})\n                       probs))\n                   (map (fn [[k v]]\n                          (when-not (c/or (not (contains? reg (keys->specnames k)))\n                                      (pvalid? (keys->specnames k) v k))\n                            (explain-1 (keys->specnames k) (keys->specnames k) (conj path k) via (conj in k) v)))\n                     (seq x))))))\n      (gen* [_ overrides path rmap]\n        (if gfn\n          (gfn)\n          (let [rmap (inck rmap id)\n                rgen (fn [k s] [k (gensub s overrides (conj path k) rmap k)])\n                ogen (fn [k s]\n                       (when-not (recur-limit? rmap id path k)\n                         [k (gen/delay (gensub s overrides (conj path k) rmap k))]))\n                reqs (map rgen req-keys req-specs)\n                opts (remove nil? (map ogen opt-keys opt-specs))]\n            (when (every? identity (concat (map second reqs) (map second opts)))\n              (gen/bind\n                (gen/tuple\n                  (and-k-gen req)\n                  (or-k-gen opt)\n                  (and-k-gen req-un)\n                  (or-k-gen opt-un))\n                (fn [[req-ks opt-ks req-un-ks opt-un-ks]]\n                  (let [qks (flatten (concat req-ks opt-ks))\n                        unqks (map (comp keyword name) (flatten (concat req-un-ks opt-un-ks)))]\n                    (->> (into reqs opts)\n                      (filter #((set (concat qks unqks)) (first %)))\n                      (apply concat)\n                      (apply gen/hash-map)))))))))\n      (with-gen* [_ gfn] (map-spec-impl (assoc argm :gfn gfn)))\n      (describe* [_] (cons `keys\n                           (cond-> []\n                                   req (conj :req req)\n                                   opt (conj :opt opt)\n                                   req-un (conj :req-un req-un)\n                                   opt-un (conj :opt-un opt-un)))))))\n\n(defn ^:skip-wiki spec-impl\n  \"Do not call this directly, use 'spec'\"\n  ([form pred gfn cpred?] (spec-impl form pred gfn cpred? nil))\n  ([form pred gfn cpred? unc]\n   (cond\n     (spec? pred) (cond-> pred gfn (with-gen gfn))\n     (regex? pred) (regex-spec-impl pred gfn)\n     (ident? pred) (cond-> (the-spec pred) gfn (with-gen gfn))\n     :else\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x] (let [ret (pred x)]\n                         (if cpred?\n                           ret\n                           (if ret x ::invalid))))\n       (unform* [_ x] (if cpred?\n                        (if unc\n                          (unc x)\n                          (throw (js/Error. \"no unform fn for conformer\")))\n                        x))\n       (explain* [_ path via in x]\n         (when (invalid? (dt pred x form cpred?))\n           [{:path path :pred form :val x :via via :in in}]))\n       (gen* [_ _ _ _] (if gfn\n                         (gfn)\n                         (gen/gen-for-pred pred)))\n       (with-gen* [_ gfn] (spec-impl form pred gfn cpred? unc))\n       (describe* [_] form)))))\n\n(defn ^:skip-wiki multi-spec-impl\n  \"Do not call this directly, use 'multi-spec'\"\n  ([form mmvar retag] (multi-spec-impl form mmvar retag nil))\n  ([form mmvar retag gfn]\n   (let [id (random-uuid)\n         predx #(let [mm @mmvar]\n                 (c/and (-get-method mm ((-dispatch-fn mm) %))\n                        (mm %)))\n         dval #((-dispatch-fn @mmvar) %)\n         tag (if (keyword? retag)\n               #(assoc %1 retag %2)\n               retag)]\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x] (if-let [pred (predx x)]\n                         (dt pred x form)\n                         ::invalid))\n       (unform* [_ x] (if-let [pred (predx x)]\n                        (unform pred x)\n                        (throw (js/Error. (str \"No method of: \" form \" for dispatch value: \" (dval x))))))\n       (explain* [_ path via in x]\n         (let [dv (dval x)\n               path (conj path dv)]\n           (if-let [pred (predx x)]\n             (explain-1 form pred path via in x)\n             [{:path path :pred form :val x :reason \"no method\" :via via :in in}])))\n       (gen* [_ overrides path rmap]\n         (if gfn\n           (gfn)\n           (let [gen (fn [[k f]]\n                       (let [p (f nil)]\n                         (let [rmap (inck rmap id)]\n                           (when-not (recur-limit? rmap id path k)\n                             (gen/delay\n                               (gen/fmap\n                                 #(tag % k)\n                                 (gensub p overrides (conj path k) rmap (list 'method form k))))))))\n                 gs (->> (methods @mmvar)\n                         (remove (fn [[k]] (invalid? k)))\n                         (map gen)\n                         (remove nil?))]\n             (when (every? identity gs)\n               (gen/one-of gs)))))\n       (with-gen* [_ gfn] (multi-spec-impl form mmvar retag gfn))\n       (describe* [_] `(multi-spec ~form ~retag))))))\n\n(defn ^:skip-wiki tuple-impl\n  \"Do not call this directly, use 'tuple'\"\n  ([forms preds] (tuple-impl forms preds nil))\n  ([forms preds gfn]\n   (let [specs (delay (mapv specize preds forms))\n         cnt (count preds)]\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x]\n         (let [specs @specs]\n           (if-not (c/and (vector? x)\n                     (= (count x) cnt))\n             ::invalid\n             (loop [ret x, i 0]\n               (if (= i cnt)\n                 ret\n                 (let [v (x i)\n                       cv (conform* (specs i) v)]\n                   (if (invalid? cv)\n                     ::invalid\n                     (recur (if (identical? cv v) ret (assoc ret i cv))\n                            (inc i)))))))))\n       (unform* [_ x]\n         (assert (c/and (vector? x)\n                   (= (count x) (count preds))))\n         (loop [ret x, i 0]\n           (if (= i (count x))\n             ret\n             (let [cv (x i)\n                   v (unform (preds i) cv)]\n               (recur (if (identical? cv v) ret (assoc ret i v))\n                 (inc i))))))\n       (explain* [_ path via in x]\n         (cond\n           (not (vector? x))\n           [{:path path :pred `vector? :val x :via via :in in}]\n\n           (not= (count x) (count preds))\n           [{:path path :pred `(= (count ~'%) ~(count preds)) :val x :via via :in in}]\n\n           :else\n           (apply concat\n             (map (fn [i form pred]\n                    (let [v (x i)]\n                      (when-not (pvalid? pred v)\n                        (explain-1 form pred (conj path i) via (conj in i) v))))\n               (range (count preds)) forms preds))))\n       (gen* [_ overrides path rmap]\n         (if gfn\n           (gfn)\n           (let [gen (fn [i p f]\n                       (gensub p overrides (conj path i) rmap f))\n                 gs (map gen (range (count preds)) preds forms)]\n             (when (every? identity gs)\n               (apply gen/tuple gs)))))\n       (with-gen* [_ gfn] (tuple-impl forms preds gfn))\n       (describe* [_] `(tuple ~@forms))))))\n\n(defn- tagged-ret [tag ret]\n  (MapEntry. tag ret nil))\n\n(defn ^:skip-wiki or-spec-impl\n  \"Do not call this directly, use 'or'\"\n  [keys forms preds gfn]\n  (let [id (random-uuid)\n        kps (zipmap keys preds)\n        specs (delay (mapv specize preds forms))\n        cform (case (count preds)\n                2 (fn [x]\n                    (let [specs @specs\n                          ret (conform* (specs 0) x)]\n                      (if (invalid? ret)\n                        (let [ret (conform* (specs 1) x)]\n                          (if (invalid? ret)\n                            ::invalid\n                            (tagged-ret (keys 1) ret)))\n                        (tagged-ret (keys 0) ret))))\n                3 (fn [x]\n                    (let [specs @specs\n                          ret (conform* (specs 0) x)]\n                      (if (invalid? ret)\n                        (let [ret (conform* (specs 1) x)]\n                          (if (invalid? ret)\n                            (let [ret (conform* (specs 2) x)]\n                              (if (invalid? ret)\n                                ::invalid\n                                (tagged-ret (keys 2) ret)))\n                            (tagged-ret (keys 1) ret)))\n                        (tagged-ret (keys 0) ret))))\n                (fn [x]\n                  (let [specs @specs]\n                    (loop [i 0]\n                      (if (< i (count specs))\n                        (let [spec (specs i)]\n                          (let [ret (conform* spec x)]\n                            (if (invalid? ret)\n                              (recur (inc i))\n                              (tagged-ret (keys i) ret))))\n                        ::invalid)))))]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ x] (cform x))\n      (unform* [_ [k x]] (unform (kps k) x))\n      (explain* [this path via in x]\n        (when-not (pvalid? this x)\n          (apply concat\n                 (map (fn [k form pred]\n                        (when-not (pvalid? pred x)\n                          (explain-1 form pred (conj path k) via in x)))\n                      keys forms preds))))\n      (gen* [_ overrides path rmap]\n        (if gfn\n          (gfn)\n          (let [gen (fn [k p f]\n                      (let [rmap (inck rmap id)]\n                        (when-not (recur-limit? rmap id path k)\n                          (gen/delay\n                            (gensub p overrides (conj path k) rmap f)))))\n                gs (remove nil? (map gen keys preds forms))]\n            (when-not (empty? gs)\n              (gen/one-of gs)))))\n      (with-gen* [_ gfn] (or-spec-impl keys forms preds gfn))\n      (describe* [_] `(or ~@(mapcat vector keys forms))))))\n\n(defn- and-preds [x preds forms]\n  (loop [ret x\n         [pred & preds] preds\n         [form & forms] forms]\n    (if pred\n      (let [nret (dt pred ret form)]\n        (if (invalid? nret)\n          ::invalid\n          ;;propagate conformed values\n          (recur nret preds forms)))\n      ret)))\n\n(defn- explain-pred-list\n  [forms preds path via in x]\n  (loop [ret x\n         [form & forms] forms\n         [pred & preds] preds]\n    (when pred\n      (let [nret (dt pred ret form)]\n        (if (invalid? nret)\n          (explain-1 form pred path via in ret)\n          (recur nret forms preds))))))\n\n(defn ^:skip-wiki and-spec-impl\n  \"Do not call this directly, use 'and'\"\n  [forms preds gfn]\n  (let [specs (delay (mapv specize preds forms))\n        cform\n        (case (count preds)\n          2 (fn [x]\n              (let [specs @specs\n                    ret (conform* (specs 0) x)]\n                (if (invalid? ret)\n                  ::invalid\n                  (conform* (specs 1) ret))))\n          3 (fn [x]\n              (let [specs @specs\n                    ret (conform* (specs 0) x)]\n                (if (invalid? ret)\n                  ::invalid\n                  (let [ret (conform* (specs 1) ret)]\n                    (if (invalid? ret)\n                      ::invalid\n                      (conform* (specs 2) ret))))))\n          (fn [x]\n            (let [specs @specs]\n              (loop [ret x i 0]\n                (if (< i (count specs))\n                  (let [nret (conform* (specs i) ret)]\n                    (if (invalid? nret)\n                      ::invalid\n                      ;;propagate conformed values\n                      (recur nret (inc i))))\n                  ret)))))]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ x] (cform x))\n      (unform* [_ x] (reduce #(unform %2 %1) x (reverse preds)))\n      (explain* [_ path via in x] (explain-pred-list forms preds path via in x))\n      (gen* [_ overrides path rmap] (if gfn (gfn) (gensub (first preds) overrides path rmap (first forms))))\n      (with-gen* [_ gfn] (and-spec-impl forms preds gfn))\n      (describe* [_] `(and ~@forms)))))\n\n(defn- coll-prob [x kfn kform distinct count min-count max-count\n                  path via in]\n  (let [pred (c/or kfn coll?)\n        kform (c/or kform `coll?)]\n    (cond\n     (not (pvalid? pred x))\n     (explain-1 kform pred path via in x)\n\n     (c/and count (not= count (bounded-count count x)))\n     [{:path path :pred `(= ~count (c/count ~'%)) :val x :via via :in in}]\n\n     (c/and (c/or min-count max-count)\n       (not (<= (c/or min-count 0)\n              (bounded-count (if max-count (inc max-count) min-count) x)\n              (c/or max-count MAX_INT))))\n     [{:path path :pred `(<= ~(c/or min-count 0) (c/count ~'%) ~(c/or max-count MAX_INT)) :val x :via via :in in}]\n\n     (c/and distinct (not (empty? x)) (not (apply distinct? x)))\n     [{:path path :pred 'distinct? :val x :via via :in in}])))\n\n(defn ^:skip-wiki merge-spec-impl\n  \"Do not call this directly, use 'merge'\"\n  [forms preds gfn]\n  (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n\n    Spec\n    (conform* [_ x] (let [ms (map #(dt %1 x %2) preds forms)]\n                      (if (some invalid? ms)\n                        ::invalid\n                        (apply c/merge ms))))\n    (unform* [_ x] (apply c/merge (map #(unform % x) (reverse preds))))\n    (explain* [_ path via in x]\n      (apply concat\n        (map #(explain-1 %1 %2 path via in x)\n          forms preds)))\n    (gen* [_ overrides path rmap]\n      (if gfn\n        (gfn)\n        (gen/fmap\n          #(apply c/merge %)\n          (apply gen/tuple (map #(gensub %1 overrides path rmap %2)\n                             preds forms)))))\n    (with-gen* [_ gfn] (merge-spec-impl forms preds gfn))\n    (describe* [_] `(merge ~@forms))))\n\n(def ^:private empty-coll {`vector? [], `set? #{}, `list? (), `map? {}})\n\n(defn ^:skip-wiki every-impl\n  \"Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'\"\n  ([form pred opts] (every-impl form pred opts nil))\n  ([form pred {conform-into :into\n               describe-form ::describe\n               :keys [kind ::kind-form count max-count min-count distinct gen-max ::kfn ::cpred\n                      conform-keys ::conform-all]\n               :or {gen-max 20}\n               :as opts}\n    gfn]\n   (let [gen-into (if conform-into (empty conform-into) (get empty-coll kind-form))\n         spec (delay (specize pred))\n         check? #(valid? @spec %)\n         kfn (c/or kfn (fn [i v] i))\n         addcv (fn [ret i v cv] (conj ret cv))\n         cfns (fn [x]\n                ;;returns a tuple of [init add complete] fns\n                (cond\n                  (c/and (vector? x) (c/or (not conform-into) (vector? conform-into)))\n                  [identity\n                   (fn [ret i v cv]\n                     (if (identical? v cv)\n                       ret\n                       (assoc ret i cv)))\n                   identity]\n\n                  (c/and (map? x) (c/or (c/and kind (not conform-into)) (map? conform-into)))\n                  [(if conform-keys empty identity)\n                   (fn [ret i v cv]\n                     (if (c/and (identical? v cv) (not conform-keys))\n                       ret\n                       (assoc ret (nth (if conform-keys cv v) 0) (nth cv 1))))\n                   identity]\n\n                  (c/or (list? conform-into) (seq? conform-into) (c/and (not conform-into) (c/or (list? x) (seq? x))))\n                  [empty addcv reverse]\n\n                  :else [#(empty (c/or conform-into %)) addcv identity]))]\n     (reify\n       Specize\n       (specize* [s] s)\n       (specize* [s _] s)\n\n       Spec\n       (conform* [_ x]\n         (let [spec @spec]\n           (cond\n             (not (cpred x)) ::invalid\n\n             conform-all\n             (let [[init add complete] (cfns x)]\n               (loop [ret (init x), i 0, [v & vs :as vseq] (seq x)]\n                 (if vseq\n                   (let [cv (conform* spec v)]\n                     (if (invalid? cv)\n                       ::invalid\n                       (recur (add ret i v cv) (inc i) vs)))\n                   (complete ret))))\n\n             :else\n             (if (indexed? x)\n               (let [step (max 1 (long (/ (c/count x) *coll-check-limit*)))]\n                 (loop [i 0]\n                   (if (>= i (c/count x))\n                     x\n                     (if (valid? spec (nth x i))\n                       (recur (c/+ i step))\n                       ::invalid))))\n               (let [limit *coll-check-limit*]\n                 (loop [i 0 [v & vs :as vseq] (seq x)]\n                   (cond\n                     (c/or (nil? vseq) (= i limit)) x\n                     (valid? spec v) (recur (inc i) vs)\n                     :else ::invalid)))))))\n       (unform* [_ x]\n         (if conform-all\n           (let [spec @spec\n                 [init add complete] (cfns x)]\n             (loop [ret (init x), i 0, [v & vs :as vseq] (seq x)]\n               (if (>= i (c/count x))\n                 (complete ret)\n                 (recur (add ret i v (unform* spec v)) (inc i) vs))))\n           x))\n       (explain* [_ path via in x]\n         (c/or (coll-prob x kind kind-form distinct count min-count max-count\n                          path via in)\n           (apply concat\n             ((if conform-all identity (partial take *coll-error-limit*))\n               (keep identity\n                 (map (fn [i v]\n                        (let [k (kfn i v)]\n                          (when-not (check? v)\n                            (let [prob (explain-1 form pred path via (conj in k) v)]\n                              prob))))\n                   (range) x))))))\n       (gen* [_ overrides path rmap]\n         (if gfn\n           (gfn)\n           (let [pgen (gensub pred overrides path rmap form)]\n             (gen/bind\n               (cond\n                 gen-into (gen/return gen-into)\n                 kind (gen/fmap #(if (empty? %) % (empty %))\n                        (gensub kind overrides path rmap form))\n                 :else (gen/return []))\n               (fn [init]\n                 (gen/fmap\n                   #(if (vector? init) % (into init %))\n                   (cond\n                     distinct\n                     (if count\n                       (gen/vector-distinct pgen {:num-elements count :max-tries 100})\n                       (gen/vector-distinct pgen {:min-elements (c/or min-count 0)\n                                                  :max-elements (c/or max-count (max gen-max (c/* 2 (c/or min-count 0))))\n                                                  :max-tries 100}))\n\n                     count\n                     (gen/vector pgen count)\n\n                     (c/or min-count max-count)\n                     (gen/vector pgen (c/or min-count 0) (c/or max-count (max gen-max (c/* 2 (c/or min-count 0)))))\n\n                     :else\n                     (gen/vector pgen 0 gen-max))))))))\n\n       (with-gen* [_ gfn] (every-impl form pred opts gfn))\n       (describe* [_] (c/or describe-form `(every ~(s/mres form) ~@(mapcat identity opts))))))))\n\n;;;;;;;;;;;;;;;;;;;;;;; regex ;;;;;;;;;;;;;;;;;;;\n;;See:\n;; http://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/\n;; http://www.ccs.neu.edu/home/turon/re-deriv.pdf\n\n;;ctors\n(defn- accept [x] {::op ::accept :ret x})\n\n(defn- accept? [{:keys [::op]}]\n  (= ::accept op))\n\n(defn- pcat* [{[p1 & pr :as ps] :ps,  [k1 & kr :as ks] :ks, [f1 & fr :as forms] :forms, ret :ret, rep+ :rep+}]\n  (when (every? identity ps)\n    (if (accept? p1)\n      (let [rp (:ret p1)\n            ret (conj ret (if ks {k1 rp} rp))]\n        (if pr\n          (pcat* {:ps pr :ks kr :forms fr :ret ret})\n          (accept ret)))\n      {::op ::pcat, :ps ps, :ret ret, :ks ks, :forms forms :rep+ rep+})))\n\n(defn- pcat [& ps] (pcat* {:ps ps :ret []}))\n\n(defn ^:skip-wiki cat-impl\n  \"Do not call this directly, use 'cat'\"\n  [ks ps forms]\n  (pcat* {:ks ks, :ps ps, :forms forms, :ret {}}))\n\n(defn- rep* [p1 p2 ret splice form]\n  (when p1\n    (let [r {::op ::rep, :p2 p2, :splice splice, :forms form :id (random-uuid)}]\n      (if (accept? p1)\n        (assoc r :p1 p2 :ret (conj ret (:ret p1)))\n        (assoc r :p1 p1, :ret ret)))))\n\n(defn ^:skip-wiki rep-impl\n  \"Do not call this directly, use '*'\"\n  [form p] (rep* p p [] false form))\n\n(defn ^:skip-wiki rep+impl\n  \"Do not call this directly, use '+'\"\n  [form p]\n  (pcat* {:ps [p (rep* p p [] true form)] :forms `[~form (* ~form)] :ret [] :rep+ form}))\n\n(defn ^:skip-wiki amp-impl\n  \"Do not call this directly, use '&'\"\n  [re re-form preds pred-forms]\n  {::op ::amp :p1 re :amp re-form :ps preds :forms pred-forms})\n\n(defn- filter-alt [ps ks forms f]\n  (if (c/or ks forms)\n    (let [pks (->> (map vector ps\n                        (c/or (seq ks) (repeat nil))\n                        (c/or (seq forms) (repeat nil)))\n                   (filter #(-> % first f)))]\n      [(seq (map first pks)) (when ks (seq (map second pks))) (when forms (seq (map #(nth % 2) pks)))])\n    [(seq (filter f ps)) ks forms]))\n\n(defn- alt* [ps ks forms]\n  (let [[[p1 & pr :as ps] [k1 :as ks] forms] (filter-alt ps ks forms identity)]\n    (when ps\n      (let [ret {::op ::alt, :ps ps, :ks ks :forms forms}]\n        (if (nil? pr)\n          (if k1\n            (if (accept? p1)\n              (accept (tagged-ret k1 (:ret p1)))\n              ret)\n            p1)\n          ret)))))\n\n(defn- alts [& ps] (alt* ps nil nil))\n(defn- alt2 [p1 p2] (if (c/and p1 p2) (alts p1 p2) (c/or p1 p2)))\n\n(defn ^:skip-wiki alt-impl\n  \"Do not call this directly, use 'alt'\"\n  [ks ps forms] (assoc (alt* ps ks forms) :id (random-uuid)))\n\n(defn ^:skip-wiki maybe-impl\n  \"Do not call this directly, use '?'\"\n  [p form] (assoc (alt* [p (accept ::nil)] nil [form ::nil]) :maybe form))\n\n(defn- noret? [p1 pret]\n  (c/or (= pret ::nil)\n        (c/and (#{::rep ::pcat} (::op (reg-resolve! p1))) ;;hrm, shouldn't know these\n               (empty? pret))\n        nil))\n\n(declare ^{:arglists '([p])} preturn)\n\n(defn- accept-nil? [p]\n  (let [{:keys [::op ps p1 p2 forms] :as p} (reg-resolve! p)]\n    (case op\n      ::accept true\n      nil nil\n      ::amp (c/and (accept-nil? p1)\n                   (let [ret (-> (preturn p1) (and-preds ps (next forms)))]\n                     (not (invalid? ret))))\n      ::rep (c/or (identical? p1 p2) (accept-nil? p1))\n      ::pcat (every? accept-nil? ps)\n      ::alt (c/some accept-nil? ps))))\n\n(declare ^{:arglists '([p r k])} add-ret)\n\n(defn- preturn [p]\n  (let [{[p0 & pr :as ps] :ps, [k :as ks] :ks, :keys [::op p1 ret forms] :as p} (reg-resolve! p)]\n    (case op\n      ::accept ret\n      nil nil\n      ::amp (let [pret (preturn p1)]\n              (if (noret? p1 pret)\n                ::nil\n                (and-preds pret ps forms)))\n      ::rep (add-ret p1 ret k)\n      ::pcat (add-ret p0 ret k)\n      ::alt (let [[[p0] [k0]] (filter-alt ps ks forms accept-nil?)\n                  r (if (nil? p0) ::nil (preturn p0))]\n              (if k0 (tagged-ret k0 r) r)))))\n\n(defn- op-unform [p x]\n  ;;(prn {:p p :x x})\n  (let [{[p0 & pr :as ps] :ps, [k :as ks] :ks, :keys [::op p1 ret forms rep+ maybe] :as p} (reg-resolve! p)\n        kps (zipmap ks ps)]\n    (case op\n      ::accept [ret]\n      nil [(unform p x)]\n      ::amp (let [px (reduce #(unform %2 %1) x (reverse ps))]\n              (op-unform p1 px))\n      ::rep (mapcat #(op-unform p1 %) x)\n      ::pcat (if rep+\n               (mapcat #(op-unform p0 %) x)\n               (mapcat (fn [k]\n                         (when (contains? x k)\n                           (op-unform (kps k) (get x k))))\n                 ks))\n      ::alt (if maybe\n              [(unform p0 x)]\n              (let [[k v] x]\n                (op-unform (kps k) v))))))\n\n(defn- add-ret [p r k]\n  (let [{:keys [::op ps splice] :as p} (reg-resolve! p)\n        prop #(let [ret (preturn p)]\n               (if (empty? ret) r ((if splice into conj) r (if k {k ret} ret))))]\n    (case op\n      nil r\n      (::alt ::accept ::amp)\n      (let [ret (preturn p)]\n        ;;(prn {:ret ret})\n        (if (= ret ::nil) r (conj r (if k {k ret} ret))))\n\n      (::rep ::pcat) (prop))))\n\n(defn- deriv\n  [p x]\n  (let [{[p0 & pr :as ps] :ps, [k0 & kr :as ks] :ks, :keys [::op p1 p2 ret splice forms amp] :as p} (reg-resolve! p)]\n    (when p\n      (case op\n        ::accept nil\n        nil (let [ret (dt p x p)]\n              (when-not (invalid? ret) (accept ret)))\n        ::amp (when-let [p1 (deriv p1 x)]\n                (if (= ::accept (::op p1))\n                  (let [ret (-> (preturn p1) (and-preds ps (next forms)))]\n                    (when-not (invalid? ret)\n                      (accept ret)))\n                  (amp-impl p1 amp ps forms)))\n        ::pcat (alt2 (pcat* {:ps (cons (deriv p0 x) pr), :ks ks, :forms forms, :ret ret})\n                     (when (accept-nil? p0) (deriv (pcat* {:ps pr, :ks kr, :forms (next forms), :ret (add-ret p0 ret k0)}) x)))\n        ::alt (alt* (map #(deriv % x) ps) ks forms)\n        ::rep (alt2 (rep* (deriv p1 x) p2 ret splice forms)\n                    (when (accept-nil? p1) (deriv (rep* p2 p2 (add-ret p1 ret nil) splice forms) x)))))))\n\n(defn- op-describe [p]\n  (let [{:keys [::op ps ks forms splice p1 rep+ maybe amp] :as p} (reg-resolve! p)]\n    ;;(prn {:op op :ks ks :forms forms :p p})\n    (when p\n      (case op\n        ::accept nil\n        nil p\n        ::amp (list* 'cljs.spec.alpha/& amp forms)\n        ::pcat (if rep+\n                 (list `+ rep+)\n                 (cons `cat (mapcat vector (c/or (seq ks) (repeat :_)) forms)))\n        ::alt (if maybe\n                (list `? maybe)\n                (cons `alt (mapcat vector ks forms)))\n        ::rep (list (if splice `+ `*) forms)))))\n\n(defn- op-explain [form p path via in input]\n  ;;(prn {:form form :p p :path path :input input})\n  (let [[x :as input] input\n        {:keys [::op ps ks forms splice p1 p2] :as p} (reg-resolve! p)\n        via (if-let [name (spec-name p)] (conj via name) via)\n        insufficient (fn [path form]\n                       [{:path path\n                         :reason \"Insufficient input\"\n                         :pred form\n                         :val ()\n                         :via via\n                         :in in}])]\n    (when p\n      (case op\n        ::accept nil\n        nil (if (empty? input)\n              (insufficient path form)\n              (explain-1 form p path via in x))\n        ::amp (if (empty? input)\n                (if (accept-nil? p1)\n                  (explain-pred-list forms ps path via in (preturn p1))\n                  (insufficient path (:amp p)))\n                (if-let [p1 (deriv p1 x)]\n                  (explain-pred-list forms ps path via in (preturn p1))\n                  (op-explain (:amp p) p1 path via in input)))\n        ::pcat (let [pkfs (map vector\n                               ps\n                               (c/or (seq ks) (repeat nil))\n                               (c/or (seq forms) (repeat nil)))\n                     [pred k form] (if (= 1 (count pkfs))\n                                     (first pkfs)\n                                     (first (remove (fn [[p]] (accept-nil? p)) pkfs)))\n                     path (if k (conj path k) path)\n                     form (c/or form (op-describe pred))]\n                 (if (c/and (empty? input) (not pred))\n                   (insufficient path form)\n                   (op-explain form pred path via in input)))\n        ::alt (if (empty? input)\n                (insufficient path (op-describe p))\n                (apply concat\n                       (map (fn [k form pred]\n                              (op-explain (c/or form (op-describe pred))\n                                          pred\n                                          (if k (conj path k) path)\n                                          via\n                                          in\n                                          input))\n                            (c/or (seq ks) (repeat nil))\n                            (c/or (seq forms) (repeat nil))\n                            ps)))\n        ::rep (op-explain (if (identical? p1 p2)\n                            forms\n                            (op-describe p1))\n                          p1 path via in input)))))\n\n(defn- re-gen [p overrides path rmap f]\n  ;;(prn {:op op :ks ks :forms forms})\n  (let [{:keys [::op ps ks p1 p2 forms splice ret id ::gfn] :as p} (reg-resolve! p)\n        rmap (if id (inck rmap id) rmap)\n        ggens (fn [ps ks forms]\n                (let [gen (fn [p k f]\n                            ;;(prn {:k k :path path :rmap rmap :op op :id id})\n                            (when-not (c/and rmap id k (recur-limit? rmap id path k))\n                              (if id\n                                (gen/delay (re-gen p overrides (if k (conj path k) path) rmap (c/or f p)))\n                                (re-gen p overrides (if k (conj path k) path) rmap (c/or f p)))))]\n                  (map gen ps (c/or (seq ks) (repeat nil)) (c/or (seq forms) (repeat nil)))))]\n    (c/or (when-let [g (get overrides path)]\n            (case op\n              (:accept nil) (gen/fmap vector g)\n              g))\n          (when gfn\n            (gfn))\n          (when p\n            (case op\n              ::accept (if (= ret ::nil)\n                         (gen/return [])\n                         (gen/return [ret]))\n              nil (when-let [g (gensub p overrides path rmap f)]\n                    (gen/fmap vector g))\n              ::amp (re-gen p1 overrides path rmap (op-describe p1))\n              ::pcat (let [gens (ggens ps ks forms)]\n                       (when (every? identity gens)\n                         (apply gen/cat gens)))\n              ::alt (let [gens (remove nil? (ggens ps ks forms))]\n                      (when-not (empty? gens)\n                        (gen/one-of gens)))\n              ::rep (if (recur-limit? rmap id [id] id)\n                      (gen/return [])\n                      (when-let [g (re-gen p2 overrides path rmap forms)]\n                        (gen/fmap #(apply concat %)\n                                  (gen/vector g)))))))))\n\n(defn- re-conform [p [x & xs :as data]]\n  ;;(prn {:p p :x x :xs xs})\n  (if (empty? data)\n    (if (accept-nil? p)\n      (let [ret (preturn p)]\n        (if (= ret ::nil)\n          nil\n          ret))\n      ::invalid)\n    (if-let [dp (deriv p x)]\n      (recur dp xs)\n      ::invalid)))\n\n(defn- re-explain [path via in re input]\n  (loop [p re [x & xs :as data] input i 0]\n    ;;(prn {:p p :x x :xs xs :re re}) (prn)\n    (if (empty? data)\n      (if (accept-nil? p)\n        nil ;;success\n        (op-explain (op-describe p) p path via in nil))\n      (if-let [dp (deriv p x)]\n        (recur dp xs (inc i))\n        (if (accept? p)\n          (if (= (::op p) ::pcat)\n            (op-explain (op-describe p) p path via (conj in i) (seq data))\n            [{:path path\n              :reason \"Extra input\"\n              :pred (op-describe re)\n              :val data\n              :via via\n              :in (conj in i)}])\n          (c/or (op-explain (op-describe p) p path via (conj in i) (seq data))\n                [{:path path\n                  :reason \"Extra input\"\n                  :pred (op-describe p)\n                  :val data\n                  :via via\n                  :in (conj in i)}]))))))\n\n(defn ^:skip-wiki regex-spec-impl\n  \"Do not call this directly, use 'spec' with a regex op argument\"\n  [re gfn]\n  (reify\n    Specize\n    (specize* [s] s)\n    (specize* [s _] s)\n\n    Spec\n    (conform* [_ x]\n      (if (c/or (nil? x) (sequential? x))\n        (re-conform re (seq x))\n        ::invalid))\n    (unform* [_ x] (op-unform re x))\n    (explain* [_ path via in x]\n      (if (c/or (nil? x) (sequential? x))\n        (re-explain path via in re (seq x))\n        [{:path path :pred `(fn [~'%] (c/or (nil? ~'%) (sequential? ~'%))) :val x :via via :in in}]))\n    (gen* [_ overrides path rmap]\n      (if gfn\n        (gfn)\n        (re-gen re overrides path rmap (op-describe re))))\n    (with-gen* [_ gfn] (regex-spec-impl re gfn))\n    (describe* [_] (op-describe re))))\n\n;;;;;;;;;;;;;;;;; HOFs ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- call-valid?\n  [f specs args]\n  (let [cargs (conform (:args specs) args)]\n    (when-not (invalid? cargs)\n      (let [ret (apply f args)\n            cret (conform (:ret specs) ret)]\n        (c/and (not (invalid? cret))\n               (if (:fn specs)\n                 (pvalid? (:fn specs) {:args cargs :ret cret})\n                 true))))))\n\n(defn- validate-fn\n  \"returns f if valid, else smallest\"\n  [f specs iters]\n  (let [g (gen (:args specs))\n        prop (gen/for-all* [g] #(call-valid? f specs %))]\n    (let [ret (gen/quick-check iters prop)]\n      (if-let [[smallest] (-> ret :shrunk :smallest)]\n        smallest\n        f))))\n\n(defn ^:skip-wiki fspec-impl\n  \"Do not call this directly, use 'fspec'\"\n  [argspec aform retspec rform fnspec fform gfn]\n  (let [specs {:args argspec :ret retspec :fn fnspec}]\n    (reify\n      ILookup\n      (-lookup [this k] (get specs k))\n      (-lookup [_ k not-found] (get specs k not-found))\n\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ f] (if (ifn? f)\n                        (if (identical? f (validate-fn f specs *fspec-iterations*)) f ::invalid)\n                        ::invalid))\n      (unform* [_ f] f)\n      (explain* [_ path via in f]\n        (if (ifn? f)\n          (let [args (validate-fn f specs 100)]\n            (if (identical? f args) ;;hrm, we might not be able to reproduce\n              nil\n              (let [ret (try (apply f args) (catch js/Error t t))]\n                (if (instance? js/Error ret)\n                  ;;TODO add exception data\n                  [{:path path :pred '(apply fn) :val args :reason (.-message ret) :via via :in in}]\n\n                  (let [cret (dt retspec ret rform)]\n                    (if (invalid? cret)\n                      (explain-1 rform retspec (conj path :ret) via in ret)\n                      (when fnspec\n                        (let [cargs (conform argspec args)]\n                          (explain-1 fform fnspec (conj path :fn) via in {:args cargs :ret cret})))))))))\n          [{:path path :pred 'ifn? :val f :via via :in in}]))\n      (gen* [_ overrides _ _] (if gfn\n                        (gfn)\n                        (gen/return\n                          (fn [& args]\n                            (assert (pvalid? argspec args) (with-out-str (explain argspec args)))\n                            (gen/generate (gen retspec overrides))))))\n      (with-gen* [_ gfn] (fspec-impl argspec aform retspec rform fnspec fform gfn))\n      (describe* [_] `(fspec :args ~aform :ret ~rform :fn ~fform)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; non-primitives ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(cljs.spec.alpha/def ::kvs->map (cljs.spec.alpha/conformer #(zipmap (map ::k %) (map ::v %)) #(map (fn [[k v]] {::k k ::v v}) %)))\n\n(defn nonconforming\n  \"takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.\"\n  [spec]\n  (let [spec (delay (specize spec))]\n    (reify\n     Specize\n     (specize* [s] s)\n     (specize* [s _] s)\n\n     Spec\n     (conform* [_ x] (let [ret (conform* @spec x)]\n                       (if (invalid? ret)\n                         ::invalid\n                         x)))\n     (unform* [_ x] (unform* @spec x))\n     (explain* [_ path via in x] (explain* @spec path via in x))\n     (gen* [_ overrides path rmap] (gen* @spec overrides path rmap))\n     (with-gen* [_ gfn] (nonconforming (with-gen* @spec gfn)))\n     (describe* [_] `(nonconforming ~(describe* @spec))))))\n\n(defn ^:skip-wiki nilable-impl\n  \"Do not call this directly, use 'nilable'\"\n  [form pred gfn]\n  (let [spec (delay (specize pred form))]\n    (reify\n      Specize\n      (specize* [s] s)\n      (specize* [s _] s)\n\n      Spec\n      (conform* [_ x] (if (nil? x) nil (conform* @spec x)))\n      (unform* [_ x] (if (nil? x) nil (unform* @spec x)))\n      (explain* [_ path via in x]\n        (when-not (c/or (pvalid? @spec x) (nil? x))\n          (conj\n            (explain-1 form pred (conj path ::pred) via in x)\n            {:path (conj path ::nil) :pred 'nil? :val x :via via :in in})))\n      (gen* [_ overrides path rmap]\n        (if gfn\n          (gfn)\n          (gen/frequency\n            [[1 (gen/delay (gen/return nil))]\n             [9 (gen/delay (gensub pred overrides (conj path ::pred) rmap form))]])))\n      (with-gen* [_ gfn] (nilable-impl form pred gfn))\n      (describe* [_] `(nilable ~(s/mres form))))))\n\n(defn exercise\n  \"generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen\"\n  ([spec] (exercise spec 10))\n  ([spec n] (exercise spec n nil))\n  ([spec n overrides]\n   (map #(vector % (conform spec %)) (gen/sample (gen spec overrides) n))))\n\n(defn inst-in-range?\n  \"Return true if inst at or after start and before end\"\n  [start end inst]\n  (c/and (inst? inst)\n         (let [t (inst-ms inst)]\n           (c/and (<= (inst-ms start) t) (< t (inst-ms end))))))\n\n(defn int-in-range?\n  \"Return true if start <= val, val < end and val is a fixed\n  precision integer.\"\n  [start end val]\n  (cond\n    (integer? val) (c/and (<= start val) (< val end))\n\n    (instance? goog.math.Long val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    (instance? goog.math.Integer val)\n    (c/and (.lessThanOrEqual start val)\n           (.lessThan val end))\n\n    :else false))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; assert ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defonce\n  ^{:dynamic true\n    :doc \"If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.\"}\n  *compile-asserts*\n  (s/init-compile-asserts))\n\n(defonce ^{:private true\n           :dynamic true}\n  *runtime-asserts*\n  false)\n\n(defn ^boolean check-asserts?\n  \"Returns the value set by check-asserts.\"\n  []\n  *runtime-asserts*)\n\n(defn check-asserts\n  \"Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.\"\n  [^boolean flag]\n  (set! *runtime-asserts* flag))\n\n(defn assert*\n  \"Do not call this directly, use 'assert'.\"\n  [spec x]\n  (if (valid? spec x)\n    x\n    (let [ed (c/merge (assoc (explain-data* spec [] [] [] x)\n                        ::failure :assertion-failed))]\n      (throw (js/Error.\n              (str \"Spec assertion failed\\n\" (with-out-str (explain-out ed))))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/spec/gen/alpha.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.spec.gen.alpha",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.gen.alpha\n  (:refer-clojure :exclude [delay])\n  (:require [cljs.core :as c]\n            [clojure.string :as string]))\n\n(defmacro dynaload [[quote s]]\n  `(cljs.spec.gen.alpha/LazyVar.\n     (fn []\n       (if (c/exists? ~s)\n         ~(vary-meta s assoc :cljs.analyzer/no-resolve true)\n         (throw\n           (js/Error.\n             (str \"Var \" '~s \" does not exist, \"\n                  (namespace '~s) \" never required\")))))\n     nil))\n\n(defmacro delay\n  \"given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.\"\n  [& body]\n  `(delay-impl (c/delay ~@body)))\n\n(defmacro ^:skip-wiki lazy-combinator\n  \"Implementation macro, do not call directly.\"\n  [s]\n  (let [fqn (symbol \"clojure.test.check.generators\" (name s))\n        doc (str \"Lazy loaded version of \" fqn)]\n    `(let [g# (dynaload '~fqn)]\n       (defn ~s\n         ~doc\n         [& ~'args]\n         (apply @g# ~'args)))))\n\n(defmacro ^:skip-wiki lazy-combinators\n  \"Implementation macro, do not call directly.\"\n  [& syms]\n  `(do\n     ~@(map\n         (fn [s] (list `lazy-combinator s))\n         syms)))\n\n(defmacro ^:skip-wiki lazy-prim\n  \"Implementation macro, do not call directly.\"\n  [s]\n  (let [fqn (symbol \"clojure.test.check.generators\" (name s))\n        doc (str \"Fn returning \" fqn)]\n    `(let [g# (dynaload '~fqn)]\n       (defn ~s\n         ~doc\n         [& ~'args]\n         @g#))))\n\n(defmacro ^:skip-wiki lazy-prims\n  \"Implementation macro, do not call directly.\"\n  [& syms]\n  `(do\n     ~@(map\n         (fn [s] (list `lazy-prim s))\n         syms)))"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/reader.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.reader",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.reader\n  (:require-macros [cljs.reader :refer [add-data-readers]])\n  (:require [goog.object :as gobject]\n            [cljs.tools.reader :as treader]\n            [cljs.tools.reader.edn :as edn])\n  (:import [goog.string StringBuffer]))\n\n(defn ^:private zero-fill-right-and-truncate [s width]\n  (cond\n    (= width (count s)) s\n    (< width (count s)) (subs s 0 width)\n    :else\n    (loop [b (StringBuffer. s)]\n      (if (< (.getLength b) width)\n        (recur (.append b \"0\"))\n        (.toString b)))))\n\n(defn ^:private divisible?\n  [num div]\n  (zero? (mod num div)))\n\n(defn ^:private indivisible?\n  [num div]\n  (not (divisible? num div)))\n\n(defn ^:private leap-year?\n  [year]\n  (and (divisible? year 4)\n       (or (indivisible? year 100)\n           (divisible? year 400))))\n\n(def ^:private days-in-month\n  (let [dim-norm [nil 31 28 31 30 31 30 31 31 30 31 30 31]\n        dim-leap [nil 31 29 31 30 31 30 31 31 30 31 30 31]]\n    (fn [month leap-year?]\n      (get (if leap-year? dim-leap dim-norm) month))))\n\n(def ^:private timestamp-regex #\"(\\d\\d\\d\\d)(?:-(\\d\\d)(?:-(\\d\\d)(?:[T](\\d\\d)(?::(\\d\\d)(?::(\\d\\d)(?:[.](\\d+))?)?)?)?)?)?(?:[Z]|([-+])(\\d\\d):(\\d\\d))?\")\n\n(defn ^:private parse-int [s]\n  (let [n (js/parseInt s 10)]\n    (if-not (js/isNaN n)\n      n)))\n\n(defn ^:private check [low n high msg]\n  (when-not (<= low n high)\n    (throw (js/Error. (str msg \" Failed:  \" low \"<=\" n \"<=\" high))))\n  n)\n\n(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v]\n        (re-matches timestamp-regex s)]\n    (if-not v\n      (throw (js/Error. (str \"Unrecognized date/time syntax: \" s)))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (= offset-sign \"-\") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 \"timestamp month field must be in range 1..12\")\n         (check 1 days (days-in-month months (leap-year? years)) \"timestamp day field must be in range 1..last day in month\")\n         (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n         (check 0 minutes 59 \"timestamp minute field must be in range 0..59\")\n         (check 0 seconds (if (= minutes 59) 60 59) \"timestamp second field must be in range 0..60\")\n         (check 0 fraction 999 \"timestamp millisecond field must be in range 0..999\")\n         offset]))))\n\n(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n      (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (throw (js/Error. (str \"Unrecognized date/time syntax: \" ts)))))\n\n(defn ^:private read-date\n  [s]\n  (if (string? s)\n    (parse-timestamp s)\n    (throw (js/Error. \"Instance literal expects a string for its timestamp.\"))))\n\n(defn ^:private read-queue\n  [elems]\n  (if (vector? elems)\n    (into cljs.core/PersistentQueue.EMPTY elems)\n    (throw (js/Error. \"Queue literal expects a vector for its elements.\"))))\n\n(defn ^:private read-js\n  [form]\n  (cond\n    (vector? form)\n    (let [arr (array)]\n      (doseq [x form]\n        (.push arr x))\n      arr)\n\n    (map? form)\n    (let [obj (js-obj)]\n      (doseq [[k v] form]\n        (gobject/set obj (name k) v))\n      obj)\n\n    :else\n    (throw\n      (js/Error.\n        (str \"JS literal expects a vector or map containing \"\n             \"only string or unqualified keyword keys\")))))\n\n(defn ^:private read-uuid\n  [uuid]\n  (if (string? uuid)\n    (cljs.core/uuid uuid)\n    (throw (js/Error. \"UUID literal expects a string as its representation.\"))))\n\n(def ^:dynamic *default-data-reader-fn*\n  (atom nil))\n\n(def ^:dynamic *tag-table*\n  (atom\n    (add-data-readers\n      {'inst  read-date\n       'uuid  read-uuid\n       'queue read-queue\n       'js    read-js})))\n\n(defn read\n  \"Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.\"\n  ([reader]\n   (edn/read\n     {:readers @*tag-table*\n      :default @*default-data-reader-fn*\n      :eof nil}\n     reader))\n  ([{:keys [eof] :as opts} reader]\n   (edn/read\n     (update (merge opts {:default @*default-data-reader-fn*})\n       :readers (fn [m] (merge @*tag-table* m))) reader))\n  ([reader eof-error? eof opts]\n   (edn/read reader eof-error? eof\n     (update (merge opts {:default @*default-data-reader-fn*})\n       :readers (fn [m] (merge @*tag-table* m))))))\n\n(defn read-string\n  \"Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read\"\n  ([s]\n   (edn/read-string\n     {:readers @*tag-table*\n      :default @*default-data-reader-fn*\n      :eof nil} s))\n  ([opts s]\n   (edn/read-string\n     (update (merge {:default @*default-data-reader-fn*} opts)\n       :readers (fn [m] (merge @*tag-table* m))) s)))\n\n(defn register-tag-parser!\n  [tag f]\n  (let [old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))\n\n(defn deregister-tag-parser!\n  [tag]\n  (let [old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))\n\n(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))\n\n(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/repl.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.repl",new cljs.core.Keyword(null,"source","source",-433931539),";; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.repl\n  (:require-macros cljs.repl)\n  (:require [cljs.spec.alpha :as spec]\n            [goog.string :as gstring]\n            [goog.string.format]))\n\n(defn print-doc [{n :ns nm :name :as m}]\n  (println \"-------------------------\")\n  (println (or (:spec m) (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m))))\n  (when (:protocol m)\n    (println \"Protocol\"))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (println \"  \" f))\n    (:arglists m) (let [arglists (:arglists m)]\n                    (if (or (:macro m)\n                         (:repl-special-function m))\n                     (prn arglists)\n                     (prn\n                       (if (= 'quote (first arglists))\n                         (second arglists)\n                         arglists)))))\n  (if (:special-form m)\n    (do\n      (println \"Special Form\")\n      (println \" \" (:doc m))\n      (if (contains? m :url)\n        (when (:url m)\n          (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n        (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                   (:name m)))))\n    (do\n      (when (:macro m)\n        (println \"Macro\"))\n      (when (:spec m)\n        (println \"Spec\"))\n      (when (:repl-special-function m)\n        (println \"REPL Special Function\"))\n      (println \" \" (:doc m))\n      (when (:protocol m)\n        (doseq [[name {:keys [doc arglists]}] (:methods m)]\n          (println)\n          (println \" \" name)\n          (println \" \" arglists)\n          (when doc\n            (println \" \" doc))))\n      (when n\n        (when-let [fnspec (spec/get-spec (symbol (str (ns-name n)) (name nm)))]\n          (print \"Spec\")\n          (doseq [role [:args :ret :fn]]\n            (when-let [spec (get fnspec role)]\n              (print (str \"\\n \" (name role) \":\") (spec/describe spec)))))))))\n\n(defn Error->map\n  \"Constructs a data representation for a Error with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements\"\n  [o]\n  (let [base (fn [t]\n               (merge {:type (cond\n                               (instance? ExceptionInfo t) 'ExceptionInfo\n                               (instance? js/EvalError t) 'js/EvalError\n                               (instance? js/RangeError t) 'js/RangeError\n                               (instance? js/ReferenceError t) 'js/ReferenceError\n                               (instance? js/SyntaxError t) 'js/SyntaxError\n                               (instance? js/URIError t) 'js/URIError\n                               (instance? js/Error t) 'js/Error\n                               :else nil)}\n                 (when-let [msg (ex-message t)]\n                   {:message msg})\n                 (when-let [ed (ex-data t)]\n                   {:data ed})\n                 #_(let [st (extract-canonical-stacktrace t)]\n                   (when (pos? (count st))\n                     {:at st}))))\n        via (loop [via [], t o]\n              (if t\n                (recur (conj via t) (ex-cause t))\n                via))\n        root (peek via)]\n    (merge {:via   (vec (map base via))\n            :trace nil #_(extract-canonical-stacktrace (or root o))}\n      (when-let [root-msg (ex-message root)]\n        {:cause root-msg})\n      (when-let [data (ex-data root)]\n        {:data data})\n      (when-let [phase (-> o ex-data :clojure.error/phase)]\n        {:phase phase}))))\n\n(defn ex-triage\n  \"Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error\"\n  [datafied-throwable]\n  (let [{:keys [via trace phase] :or {phase :execution}} datafied-throwable\n        {:keys [type message data]} (last via)\n        {:cljs.spec.alpha/keys [problems fn] :cljs.spec.test.alpha/keys [caller]} data\n        {:keys [:clojure.error/source] :as top-data} (:data (first via))]\n    (assoc\n     (case phase\n       :read-source\n       (let [{:keys [:clojure.error/line :clojure.error/column]} data]\n         (cond-> (merge (-> via second :data) top-data)\n           source (assoc :clojure.error/source source)\n           (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} source) (dissoc :clojure.error/source)\n           message (assoc :clojure.error/cause message)))\n\n       (:compile-syntax-check :compilation :macro-syntax-check :macroexpansion)\n       (cond-> top-data\n         source (assoc :clojure.error/source source)\n         (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} source) (dissoc :clojure.error/source)\n         type (assoc :clojure.error/class type)\n         message (assoc :clojure.error/cause message)\n         problems (assoc :clojure.error/spec data))\n\n       (:read-eval-result :print-eval-result)\n       (let [[source method file line] (-> trace first)]\n         (cond-> top-data\n           line (assoc :clojure.error/line line)\n           file (assoc :clojure.error/source file)\n           (and source method) (assoc :clojure.error/symbol (vector #_java-loc->source source method))\n           type (assoc :clojure.error/class type)\n           message (assoc :clojure.error/cause message)))\n\n       :execution\n       (let [[source method file line] (->> trace #_(drop-while #(core-class? (name (first %)))) first)\n             file (first (remove #(or (nil? %) (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} %)) [(:file caller) file]))\n             err-line (or (:line caller) line)]\n         (cond-> {:clojure.error/class type}\n           err-line (assoc :clojure.error/line err-line)\n           message (assoc :clojure.error/cause message)\n           (or fn (and source method)) (assoc :clojure.error/symbol (or fn (vector #_java-loc->source source method)))\n           file (assoc :clojure.error/source file)\n           problems (assoc :clojure.error/spec data))))\n      :clojure.error/phase phase)))\n\n(defn ex-str\n  \"Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.\"\n  [{:clojure.error/keys [phase source line column symbol class cause spec] :as triage-data}]\n  (let [loc          (str (or source \"<cljs repl>\") \":\" (or line 1) (if column (str \":\" column) \"\"))\n        class-name   (name (or class \"\"))\n        simple-class class-name\n        cause-type   (if (contains? #{\"Exception\" \"RuntimeException\"} simple-class)\n                       \"\"                                   ;; omit, not useful\n                       (str \" (\" simple-class \")\"))\n        format       gstring/format]\n    (case phase\n      :read-source\n      (format \"Syntax error reading source at (%s).\\n%s\\n\" loc cause)\n\n      :macro-syntax-check\n      (format \"Syntax error macroexpanding %sat (%s).\\n%s\"\n        (if symbol (str symbol \" \") \"\")\n        loc\n        (if spec\n          (with-out-str\n            (spec/explain-out\n              (if true #_(= s/*explain-out* s/explain-printer)\n                (update spec ::spec/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec)))\n          (format \"%s\\n\" cause)))\n\n      :macroexpansion\n      (format \"Unexpected error%s macroexpanding %sat (%s).\\n%s\\n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :compile-syntax-check\n      (format \"Syntax error%s compiling %sat (%s).\\n%s\\n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :compilation\n      (format \"Unexpected error%s compiling %sat (%s).\\n%s\\n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :read-eval-result\n      (format \"Error reading eval result%s at %s (%s).\\n%s\\n\" cause-type symbol loc cause)\n\n      :print-eval-result\n      (format \"Error printing return value%s at %s (%s).\\n%s\\n\" cause-type symbol loc cause)\n\n      :execution\n      (if spec\n        (format \"Execution error - invalid arguments to %s at (%s).\\n%s\"\n          symbol\n          loc\n          (with-out-str\n            (spec/explain-out\n              (if true #_(= s/*explain-out* s/explain-printer)\n                (update spec ::spec/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec))))\n        (format \"Execution error%s at %s(%s).\\n%s\\n\"\n          cause-type\n          (if symbol (str symbol \" \") \"\")\n          loc\n          cause)))))\n\n(defn error->str [error]\n  (ex-str (ex-triage (Error->map error))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/test/check.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.test.check",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.results :as results]\n            [clojure.test.check.rose-tree :as rose]\n            [clojure.test.check.impl :refer [get-current-time-millis]]))\n\n(declare shrink-loop failure)\n\n(defn- make-rng\n  [seed]\n  (if seed\n    [seed (random/make-random seed)]\n    (let [non-nil-seed (get-current-time-millis)]\n      [non-nil-seed (random/make-random non-nil-seed)])))\n\n(defn- complete\n  [property num-trials seed start-time reporter-fn]\n  (let [time-elapsed-ms (- (get-current-time-millis) start-time)]\n    (reporter-fn {:type :complete\n                  :property property\n                  :result true\n                  :pass? true\n                  :num-tests num-trials\n                  :time-elapsed-ms time-elapsed-ms\n                  :seed seed})\n    {:result true\n     :pass? true\n     :num-tests num-trials\n     :time-elapsed-ms time-elapsed-ms\n     :seed seed}))\n\n\n(defn ^:private legacy-result\n  \"Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions.\"\n  [result]\n  (if (satisfies? results/Result result)\n    (let [d (results/result-data result)]\n      (if-let [[_ e] (find d :clojure.test.check.properties/error)]\n        #?(:clj e\n           :cljs (if (instance? js/Error e)\n                   e\n                   (ex-info \"Non-Error object thrown in test\"\n                            {}\n                            e)))\n        (results/pass? result)))\n    result))\n\n(defn quick-check\n  \"Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \\\"Uh oh...\\\"))))\"\n  [num-tests property & {:keys [seed max-size reporter-fn]\n                         :or {max-size 200, reporter-fn (constantly nil)}}]\n  (let [[created-seed rng] (make-rng seed)\n        size-seq (gen/make-size-range-seq max-size)\n        start-time (get-current-time-millis)]\n    (loop [so-far 0\n           size-seq size-seq\n           rstate rng]\n      (if (== so-far num-tests)\n        (complete property num-tests created-seed start-time reporter-fn)\n        (let [[size & rest-size-seq] size-seq\n              [r1 r2] (random/split rstate)\n              result-map-rose (gen/call-gen property r1 size)\n              result-map (rose/root result-map-rose)\n              result (:result result-map)\n              args (:args result-map)\n              so-far (inc so-far)]\n          (if (results/pass? result)\n            (do\n              (reporter-fn {:type            :trial\n                            :args            args\n                            :num-tests       so-far\n                            :num-tests-total num-tests\n                            :pass?           true\n                            :property        property\n                            :result          result\n                            :result-data     (results/result-data result)\n                            :seed            seed})\n              (recur so-far rest-size-seq r2))\n            (failure property result-map-rose so-far size\n                     created-seed start-time reporter-fn)))))))\n\n(defn- smallest-shrink\n  [total-nodes-visited depth smallest start-time]\n  (let [{:keys [result]} smallest]\n    {:total-nodes-visited total-nodes-visited\n     :depth depth\n     :pass? false\n     :result (legacy-result result)\n     :result-data (results/result-data result)\n     :time-shrinking-ms (- (get-current-time-millis) start-time)\n     :smallest (:args smallest)}))\n\n(defn- shrink-loop\n  \"Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step.\"\n  [rose-tree reporter-fn]\n  (let [start-time (get-current-time-millis)\n        shrinks-this-depth (rose/children rose-tree)]\n    (loop [nodes shrinks-this-depth\n           current-smallest (rose/root rose-tree)\n           total-nodes-visited 0\n           depth 0]\n      (if (empty? nodes)\n        (smallest-shrink total-nodes-visited depth current-smallest start-time)\n        (let [;; can't destructure here because that could force\n              ;; evaluation of (second nodes)\n              head (first nodes)\n              tail (rest nodes)\n              result (:result (rose/root head))\n              args (:args (rose/root head))\n              pass? (results/pass? result)\n              reporter-fn-arg {:type :shrink-step\n                               :shrinking {:args                args\n                                           :depth               depth\n                                           :pass?               (boolean pass?)\n                                           :result              result\n                                           :result-data         (results/result-data result)\n                                           :smallest            (:args current-smallest)\n                                           :total-nodes-visited total-nodes-visited}}]\n          (if pass?\n            ;; this node passed the test, so now try testing its right-siblings\n            (do\n              (reporter-fn reporter-fn-arg)\n              (recur tail current-smallest (inc total-nodes-visited) depth))\n            ;; this node failed the test, so check if it has children,\n            ;; if so, traverse down them. If not, save this as the best example\n            ;; seen now and then look at the right-siblings\n            ;; children\n            (let [new-smallest (rose/root head)]\n              (reporter-fn (assoc-in reporter-fn-arg\n                                     [:shrinking :smallest]\n                                     (:args new-smallest)))\n              (if-let [children (seq (rose/children head))]\n                (recur children new-smallest (inc total-nodes-visited) (inc depth))\n                (recur tail new-smallest (inc total-nodes-visited) depth)))))))))\n\n(defn- failure\n  [property failing-rose-tree trial-number size seed start-time reporter-fn]\n  (let [failed-after-ms (- (get-current-time-millis) start-time)\n        root (rose/root failing-rose-tree)\n        result (:result root)\n        failure-data {:fail            (:args root)\n                      :failing-size    size\n                      :num-tests       trial-number\n                      :pass?           false\n                      :property        property\n                      :result          (legacy-result result)\n                      :result-data     (results/result-data result)\n                      :failed-after-ms failed-after-ms\n                      :seed            seed}]\n\n    (reporter-fn (assoc failure-data :type :failure))\n\n    (let [shrunk (shrink-loop failing-rose-tree\n                              #(reporter-fn (merge failure-data %)))]\n      (reporter-fn (assoc failure-data\n                          :type :shrunk\n                          :shrunk shrunk))\n      (-> failure-data\n          (dissoc :property)\n          (assoc :shrunk shrunk)))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/pprint.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.pprint",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.pprint\n  (:refer-clojure :exclude [deftype print println pr prn float?])\n  (:require-macros\n    [cljs.pprint :as m :refer [with-pretty-writer getf setf deftype\n                               pprint-logical-block print-length-loop\n                               defdirectives formatter-out]])\n  (:require\n    [cljs.core :refer [IWriter IDeref]]\n    [clojure.string :as string]\n    [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))\n\n;;======================================================================\n;; override print fns to use *out*\n;;======================================================================\n\n(defn- print [& more]\n  (-write *out* (apply print-str more)))\n\n(defn- println [& more]\n  (apply print more)\n  (-write *out* \\newline))\n\n(defn- print-char [c]\n  (-write *out* (condp = c\n                  \\backspace \"\\\\backspace\"\n                  \\tab \"\\\\tab\"\n                  \\newline \"\\\\newline\"\n                  \\formfeed \"\\\\formfeed\"\n                  \\return \"\\\\return\"\n                  \\\" \"\\\\\\\"\"\n                  \\\\ \"\\\\\\\\\"\n                  (str \"\\\\\" c))))\n\n(defn- ^:dynamic pr [& more]\n  (-write *out* (apply pr-str more)))\n\n(defn- prn [& more]\n  (apply pr more)\n  (-write *out* \\newline))\n\n;;======================================================================\n;; cljs specific utils\n;;======================================================================\n\n(defn float?\n  \"Returns true if n is an float.\"\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (not (== (js/parseFloat n) (js/parseInt n 10)))))\n\n(defn char-code\n  \"Convert char to int\"\n  [c]\n  (cond\n    (number? c) c\n    (and (string? c) (== (.-length c) 1)) (.charCodeAt c 0)\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))\n\n;;======================================================================\n;; Utilities\n;;======================================================================\n\n(defn- map-passing-context [func initial-context lis]\n  (loop [context initial-context\n         lis lis\n         acc []]\n    (if (empty? lis)\n      [acc context]\n      (let [this (first lis)\n            remainder (next lis)\n            [result new-context] (apply func [this context])]\n        (recur new-context remainder (conj acc result))))))\n\n(defn- consume [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result new-context] (apply func [context])]\n      (if (not result)\n        [acc new-context]\n        (recur new-context (conj acc result))))))\n\n(defn- consume-while [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result continue new-context] (apply func [context])]\n      (if (not continue)\n        [acc context]\n        (recur new-context (conj acc result))))))\n\n(defn- unzip-map [m]\n  \"Take a  map that has pairs in the value slots and produce a pair of maps,\n   the first having all the first elements of the pairs and the second all\n   the second elements of the pairs\"\n  [(into {} (for [[k [v1 v2]] m] [k v1]))\n   (into {} (for [[k [v1 v2]] m] [k v2]))])\n\n(defn- tuple-map [m v1]\n  \"For all the values, v, in the map, replace them with [v v1]\"\n  (into {} (for [[k v] m] [k [v v1]])))\n\n(defn- rtrim [s c]\n  \"Trim all instances of c from the end of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s (dec (count s))) c))\n      (loop [n (dec len)]\n        (cond\n          (neg? n) \"\"\n          (not (= (nth s n) c)) (subs s 0 (inc n))\n          true (recur (dec n))))\n      s)))\n\n(defn- ltrim [s c]\n  \"Trim all instances of c from the beginning of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s 0) c))\n      (loop [n 0]\n        (if (or (= n len) (not (= (nth s n) c)))\n          (subs s n)\n          (recur (inc n))))\n      s)))\n\n(defn- prefix-count [aseq val]\n  \"Return the number of times that val occurs at the start of sequence aseq,\nif val is a seq itself, count the number of times any element of val occurs at the\nbeginning of aseq\"\n  (let [test (if (coll? val) (set val) #{val})]\n    (loop [pos 0]\n      (if (or (= pos (count aseq)) (not (test (nth aseq pos))))\n        pos\n        (recur (inc pos))))))\n\n;; Flush the pretty-print buffer without flushing the underlying stream\n(defprotocol IPrettyFlush\n  (-ppflush [pp]))\n\n;;======================================================================\n;; column_writer.clj\n;;======================================================================\n\n(def ^:dynamic ^{:private true} *default-page-width* 72)\n\n(defn- get-field [this sym]\n  (sym @@this))\n\n(defn- set-field [this sym new-val]\n  (swap! @this assoc sym new-val))\n\n(defn- get-column [this]\n  (get-field this :cur))\n\n(defn- get-line [this]\n  (get-field this :line))\n\n(defn- get-max-column [this]\n  (get-field this :max))\n\n(defn- set-max-column [this new-max]\n  (set-field this :max new-max)\n  nil)\n\n(defn- get-writer [this]\n  (get-field this :base))\n\n;; Why is the c argument an integer?\n(defn- c-write-char [this c]\n  (if (= c \\newline)\n    (do\n      (set-field this :cur 0)\n      (set-field this :line (inc (get-field this :line))))\n    (set-field this :cur (inc (get-field this :cur))))\n  (-write (get-field this :base) c))\n\n(defn- column-writer\n  ([writer] (column-writer writer *default-page-width*))\n  ([writer max-columns]\n   (let [fields (atom {:max max-columns, :cur 0, :line 0 :base writer})]\n     (reify\n\n       IDeref\n       (-deref [_] fields)\n\n       IWriter\n       (-flush [_]\n         (-flush writer))\n       (-write\n         ;;-write isn't multi-arity, so need different way to do this\n         #_([this ^chars cbuf ^Number off ^Number len]\n          (let [writer (get-field this :base)]\n            (-write writer cbuf off len)))\n         [this x]\n         (condp = (type x)\n           js/String\n           (let [s x\n                 nl (.lastIndexOf s \\newline)]\n             (if (neg? nl)\n               (set-field this :cur (+ (get-field this :cur) (count s)))\n               (do\n                 (set-field this :cur (- (count s) nl 1))\n                 (set-field this :line (+ (get-field this :line)\n                                          (count (filter #(= % \\newline) s))))))\n             (-write (get-field this :base) s))\n           js/Number\n           (c-write-char this x)))))))\n\n;;======================================================================\n;; pretty_writer.clj\n;;======================================================================\n\n;;======================================================================\n;; Forward declarations\n;;======================================================================\n\n(declare ^{:arglists '([this])} get-miser-width)\n\n;;======================================================================\n;; The data structures used by pretty-writer\n;;======================================================================\n\n(defrecord ^{:private true} logical-block\n  [parent section start-col indent\n   done-nl intra-block-nl\n   prefix per-line-prefix suffix\n   logical-block-callback])\n\n(defn- ancestor? [parent child]\n  (loop [child (:parent child)]\n    (cond\n      (nil? child) false\n      (identical? parent child) true\n      :else (recur (:parent child)))))\n\n(defn- buffer-length [l]\n  (let [l (seq l)]\n    (if l\n      (- (:end-pos (last l)) (:start-pos (first l)))\n      0)))\n\n;; A blob of characters (aka a string)\n(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)\n\n;; A newline\n(deftype nl-t :type :logical-block :start-pos :end-pos)\n\n(deftype start-block-t :logical-block :start-pos :end-pos)\n\n(deftype end-block-t :logical-block :start-pos :end-pos)\n\n(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)\n\n(def ^:private pp-newline (fn [] \"\\n\"))\n\n(declare emit-nl)\n\n(defmulti ^{:private true} write-token #(:type-tag %2))\n\n(defmethod write-token :start-block-t [this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :start))\n  (let [lb (:logical-block token)]\n    (when-let [prefix (:prefix lb)]\n      (-write (getf :base) prefix))\n    (let [col (get-column (getf :base))]\n      (reset! (:start-col lb) col)\n      (reset! (:indent lb) col))))\n\n(defmethod write-token :end-block-t [this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :end))\n  (when-let [suffix (:suffix (:logical-block token))]\n    (-write (getf :base) suffix)))\n\n(defmethod write-token :indent-t [this token]\n  (let [lb (:logical-block token)]\n    (reset! (:indent lb)\n            (+ (:offset token)\n               (condp = (:relative-to token)\n                 :block @(:start-col lb)\n                 :current (get-column (getf :base)))))))\n\n(defmethod write-token :buffer-blob [this token]\n  (-write (getf :base) (:data token)))\n\n(defmethod write-token :nl-t [this token]\n  (if (or (= (:type token) :mandatory)\n          (and (not (= (:type token) :fill))\n               @(:done-nl (:logical-block token))))\n    (emit-nl this token)\n    (if-let [tws (getf :trailing-white-space)]\n      (-write (getf :base) tws)))\n  (setf :trailing-white-space nil))\n\n(defn- write-tokens [this tokens force-trailing-whitespace]\n  (doseq [token tokens]\n    (if-not (= (:type-tag token) :nl-t)\n      (if-let [tws (getf :trailing-white-space)]\n        (-write (getf :base) tws)))\n    (write-token this token)\n    (setf :trailing-white-space (:trailing-white-space token))\n    (let [tws (getf :trailing-white-space)]\n      (when (and force-trailing-whitespace tws)\n        (-write (getf :base) tws)\n        (setf :trailing-white-space nil)))))\n\n;;======================================================================\n;; emit-nl? method defs for each type of new line. This makes\n;; the decision about whether to print this type of new line.\n;;======================================================================\n\n(defn- tokens-fit? [this tokens]\n  (let [maxcol (get-max-column (getf :base))]\n    (or\n      (nil? maxcol)\n      (< (+ (get-column (getf :base)) (buffer-length tokens)) maxcol))))\n\n(defn- linear-nl? [this lb section]\n  (or @(:done-nl lb)\n      (not (tokens-fit? this section))))\n\n(defn- miser-nl? [this lb section]\n  (let [miser-width (get-miser-width this)\n        maxcol (get-max-column (getf :base))]\n    (and miser-width maxcol\n         (>= @(:start-col lb) (- maxcol miser-width))\n         (linear-nl? this lb section))))\n\n(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))\n\n(defmethod emit-nl? :linear [newl this section _]\n  (let [lb (:logical-block newl)]\n    (linear-nl? this lb section)))\n\n(defmethod emit-nl? :miser [newl this section _]\n  (let [lb (:logical-block newl)]\n    (miser-nl? this lb section)))\n\n(defmethod emit-nl? :fill [newl this section subsection]\n  (let [lb (:logical-block newl)]\n    (or @(:intra-block-nl lb)\n        (not (tokens-fit? this subsection))\n        (miser-nl? this lb section))))\n\n(defmethod emit-nl? :mandatory [_ _ _ _]\n  true)\n\n;;======================================================================\n;; Various support functions\n;;======================================================================\n\n(defn- get-section [buffer]\n  (let [nl (first buffer)\n        lb (:logical-block nl)\n        section (seq (take-while #(not (and (nl-t? %) (ancestor? (:logical-block %) lb)))\n                                 (next buffer)))]\n    [section (seq (drop (inc (count section)) buffer))]))\n\n(defn- get-sub-section [buffer]\n  (let [nl (first buffer)\n        lb (:logical-block nl)\n        section (seq (take-while #(let [nl-lb (:logical-block %)]\n                                   (not (and (nl-t? %) (or (= nl-lb lb) (ancestor? nl-lb lb)))))\n                                 (next buffer)))]\n    section))\n\n(defn- update-nl-state [lb]\n  (reset! (:intra-block-nl lb) true)\n  (reset! (:done-nl lb) true)\n  (loop [lb (:parent lb)]\n    (if lb\n      (do (reset! (:done-nl lb) true)\n          (reset! (:intra-block-nl lb) true)\n          (recur (:parent lb))))))\n\n(defn- emit-nl [this nl]\n  (-write (getf :base) (pp-newline))\n  (setf :trailing-white-space nil)\n  (let [lb (:logical-block nl)\n        prefix (:per-line-prefix lb)]\n    (if prefix\n      (-write (getf :base) prefix))\n    (let [istr (apply str (repeat (- @(:indent lb) (count prefix)) \\space))]\n      (-write (getf :base) istr))\n    (update-nl-state lb)))\n\n(defn- split-at-newline [tokens]\n  (let [pre (seq (take-while #(not (nl-t? %)) tokens))]\n    [pre (seq (drop (count pre) tokens))]))\n\n;; write-token-string is called when the set of tokens in the buffer\n;; is long than the available space on the line\n(defn- write-token-string [this tokens]\n  (let [[a b] (split-at-newline tokens)]\n    (if a (write-tokens this a false))\n    (if b\n      (let [[section remainder] (get-section b)\n            newl (first b)]\n        (let [do-nl (emit-nl? newl this section (get-sub-section b))\n              result (if do-nl\n                       (do\n                         (emit-nl this newl)\n                         (next b))\n                       b)\n              long-section (not (tokens-fit? this result))\n              result (if long-section\n                       (let [rem2 (write-token-string this section)]\n                         (if (= rem2 section)\n                           (do ; If that didn't produce any output, it has no nls\n                             ; so we'll force it\n                             (write-tokens this section false)\n                             remainder)\n                           (into [] (concat rem2 remainder))))\n                       result)]\n          result)))))\n\n(defn- write-line [this]\n  (loop [buffer (getf :buffer)]\n    (setf :buffer (into [] buffer))\n    (if (not (tokens-fit? this buffer))\n      (let [new-buffer (write-token-string this buffer)]\n        (if-not (identical? buffer new-buffer)\n          (recur new-buffer))))))\n\n;; Add a buffer token to the buffer and see if it's time to start\n;; writing\n(defn- add-to-buffer [this token]\n  (setf :buffer (conj (getf :buffer) token))\n  (if (not (tokens-fit? this (getf :buffer)))\n    (write-line this)))\n\n;; Write all the tokens that have been buffered\n(defn- write-buffered-output [this]\n  (write-line this)\n  (if-let [buf (getf :buffer)]\n    (do\n      (write-tokens this buf true)\n      (setf :buffer []))))\n\n(defn- write-white-space [this]\n  (when-let [tws (getf :trailing-white-space)]\n    (-write (getf :base) tws)\n    (setf :trailing-white-space nil)))\n\n;;; If there are newlines in the string, print the lines up until the last newline,\n;;; making the appropriate adjustments. Return the remainder of the string\n(defn- write-initial-lines\n  [^Writer this ^String s]\n  (let [lines (string/split s \"\\n\" -1)]\n    (if (= (count lines) 1)\n      s\n      (let [^String prefix (:per-line-prefix (first (getf :logical-blocks)))\n            ^String l (first lines)]\n        (if (= :buffering (getf :mode))\n          (let [oldpos (getf :pos)\n                newpos (+ oldpos (count l))]\n            (setf :pos newpos)\n            (add-to-buffer this (make-buffer-blob l nil oldpos newpos))\n            (write-buffered-output this))\n          (do\n            (write-white-space this)\n            (-write (getf :base) l)))\n        (-write (getf :base) \\newline)\n        (doseq [^String l (next (butlast lines))]\n          (-write (getf :base) l)\n          (-write (getf :base) (pp-newline))\n          (if prefix\n            (-write (getf :base) prefix)))\n        (setf :buffering :writing)\n        (last lines)))))\n\n(defn- p-write-char [this c]\n  (if (= (getf :mode) :writing)\n    (do\n      (write-white-space this)\n      (-write (getf :base) c))\n    (if (= c \\newline)\n      (write-initial-lines this \\newline)\n      (let [oldpos (getf :pos)\n            newpos (inc oldpos)]\n        (setf :pos newpos)\n        (add-to-buffer this (make-buffer-blob (char c) nil oldpos newpos))))))\n\n;;======================================================================\n;; Initialize the pretty-writer instance\n;;======================================================================\n\n(defn- pretty-writer [writer max-columns miser-width]\n  (let [lb (logical-block. nil nil (atom 0) (atom 0) (atom false) (atom false)\n                           nil nil nil nil)\n        ; NOTE: may want to just `specify!` #js { ... fields ... } with the protocols\n        fields (atom {:pretty-writer true\n                      :base (column-writer writer max-columns)\n                      :logical-blocks lb\n                      :sections nil\n                      :mode :writing\n                      :buffer []\n                      :buffer-block lb\n                      :buffer-level 1\n                      :miser-width miser-width\n                      :trailing-white-space nil\n                      :pos 0})]\n    (reify\n\n      IDeref\n      (-deref [_] fields)\n\n      IWriter\n      (-write [this x]\n        (condp = (type x)\n          js/String\n          (let [s0 (write-initial-lines this x)\n                s (string/replace-first s0 #\"\\s+$\" \"\")\n                white-space (subs s0 (count s))\n                mode (getf :mode)]\n            (if (= mode :writing)\n              (do\n                (write-white-space this)\n                (-write (getf :base) s)\n                (setf :trailing-white-space white-space))\n              (let [oldpos (getf :pos)\n                    newpos (+ oldpos (count s0))]\n                (setf :pos newpos)\n                (add-to-buffer this (make-buffer-blob s white-space oldpos newpos)))))\n          js/Number\n          (p-write-char this x)))\n      (-flush [this]\n        (-ppflush this)\n        (-flush (getf :base)))\n\n      IPrettyFlush\n      (-ppflush [this]\n        (if (= (getf :mode) :buffering)\n          (do\n            (write-tokens this (getf :buffer) true)\n            (setf :buffer []))\n          (write-white-space this)))\n\n      )))\n\n;;======================================================================\n;; Methods for pretty-writer\n;;======================================================================\n\n(defn- start-block\n  [this prefix per-line-prefix suffix]\n  (let [lb (logical-block. (getf :logical-blocks) nil (atom 0) (atom 0)\n                           (atom false) (atom false)\n                           prefix per-line-prefix suffix nil)]\n    (setf :logical-blocks lb)\n    (if (= (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (when-let [cb (getf :logical-block-callback)] (cb :start))\n        (if prefix\n          (-write (getf :base) prefix))\n        (let [col (get-column (getf :base))]\n          (reset! (:start-col lb) col)\n          (reset! (:indent lb) col)))\n      (let [oldpos (getf :pos)\n            newpos (+ oldpos (if prefix (count prefix) 0))]\n        (setf :pos newpos)\n        (add-to-buffer this (make-start-block-t lb oldpos newpos))))))\n\n(defn- end-block [this]\n  (let [lb (getf :logical-blocks)\n        suffix (:suffix lb)]\n    (if (= (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (if suffix\n          (-write (getf :base) suffix))\n        (when-let [cb (getf :logical-block-callback)] (cb :end)))\n      (let [oldpos (getf :pos)\n            newpos (+ oldpos (if suffix (count suffix) 0))]\n        (setf :pos newpos)\n        (add-to-buffer this (make-end-block-t lb oldpos newpos))))\n    (setf :logical-blocks (:parent lb))))\n\n(defn- nl [this type]\n  (setf :mode :buffering)\n  (let [pos (getf :pos)]\n    (add-to-buffer this (make-nl-t type (getf :logical-blocks) pos pos))))\n\n(defn- indent [this relative-to offset]\n  (let [lb (getf :logical-blocks)]\n    (if (= (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (reset! (:indent lb)\n                (+ offset (condp = relative-to\n                            :block @(:start-col lb)\n                            :current (get-column (getf :base))))))\n      (let [pos (getf :pos)]\n        (add-to-buffer this (make-indent-t lb relative-to offset pos pos))))))\n\n(defn- get-miser-width [this]\n  (getf :miser-width))\n\n;;======================================================================\n;; pprint_base.clj\n;;======================================================================\n\n;;======================================================================\n;; Variables that control the pretty printer\n;;======================================================================\n\n;; *print-length*, *print-level*, *print-namespace-maps* and *print-dup* are defined in cljs.core\n(def ^:dynamic\n ^{:doc \"Bind to true if you want write to use pretty printing\"}\n *print-pretty* true)\n\n(defonce ^:dynamic\n ^{:doc \"The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify.\"\n   :added \"1.2\"}\n *print-pprint-dispatch* nil)\n\n(def ^:dynamic\n ^{:doc \"Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.\",\n   :added \"1.2\"}\n *print-right-margin* 72)\n\n(def ^:dynamic\n ^{:doc \"The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.\",\n   :added \"1.2\"}\n *print-miser-width* 40)\n\n;;; TODO implement output limiting\n(def ^:dynamic\n^{:private true,\n  :doc \"Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)\"}\n*print-lines* nil)\n\n;;; TODO: implement circle and shared\n(def ^:dynamic\n^{:private true,\n  :doc \"Mark circular structures (N.B. This is not yet used)\"}\n*print-circle* nil)\n\n;;; TODO: should we just use *print-dup* here?\n(def ^:dynamic\n^{:private true,\n  :doc \"Mark repeated structures rather than repeat them (N.B. This is not yet used)\"}\n*print-shared* nil)\n\n(def ^:dynamic\n^{:doc \"Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions\"\n  :added \"1.2\"}\n*print-suppress-namespaces* nil)\n\n;;; TODO: support print-base and print-radix in cl-format\n;;; TODO: support print-base and print-radix in rationals\n(def ^:dynamic\n^{:doc \"Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* \"\n  :added \"1.2\"}\n*print-radix* nil)\n\n(def ^:dynamic\n^{:doc \"The base to use for printing integers and rationals.\"\n  :added \"1.2\"}\n*print-base* 10)\n\n;;======================================================================\n;; Internal variables that keep track of where we are in the\n;; structure\n;;======================================================================\n\n(def ^:dynamic ^{:private true} *current-level* 0)\n\n(def ^:dynamic ^{:private true} *current-length* nil)\n\n;;======================================================================\n;; Support for the write function\n;;======================================================================\n\n(declare ^{:arglists '([n])} format-simple-number)\n\n;; This map causes var metadata to be included in the compiled output, even\n;; in advanced compilation. See CLJS-1853 - Ant\u00F3nio Monteiro\n;; (def ^{:private true} write-option-table\n;;   {;:array            *print-array*\n;;    :base             #'cljs.pprint/*print-base*,\n;;    ;;:case             *print-case*,\n;;    :circle           #'cljs.pprint/*print-circle*,\n;;    ;;:escape           *print-escape*,\n;;    ;;:gensym           *print-gensym*,\n;;    :length           #'cljs.core/*print-length*,\n;;    :level            #'cljs.core/*print-level*,\n;;    :lines            #'cljs.pprint/*print-lines*,\n;;    :miser-width      #'cljs.pprint/*print-miser-width*,\n;;    :dispatch         #'cljs.pprint/*print-pprint-dispatch*,\n;;    :pretty           #'cljs.pprint/*print-pretty*,\n;;    :radix            #'cljs.pprint/*print-radix*,\n;;    :readably         #'cljs.core/*print-readably*,\n;;    :right-margin     #'cljs.pprint/*print-right-margin*,\n;;    :suppress-namespaces #'cljs.pprint/*print-suppress-namespaces*})\n\n(defn- table-ize [t m]\n  (apply hash-map (mapcat\n                    #(when-let [v (get t (key %))] [v (val %)])\n                    m)))\n\n(defn- pretty-writer?\n  \"Return true iff x is a PrettyWriter\"\n  [x] (and (satisfies? IDeref x) (:pretty-writer @@x)))\n\n(defn- make-pretty-writer\n  \"Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width\"\n  [base-writer right-margin miser-width]\n  (pretty-writer base-writer right-margin miser-width))\n\n(defn write-out\n  \"Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \\\"write\\\" interface. \"\n  [object]\n  (let [length-reached (and *current-length*\n                            *print-length*\n                            (>= *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (-write *out* \"...\") ;;TODO could this (incorrectly) print ... on the next line?\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))\n\n(defn write\n  \"Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n\"\n  [object & kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    ;;TODO rewrite this as a macro\n    (binding [cljs.pprint/*print-base* (:base options cljs.pprint/*print-base*)\n              ;;:case             *print-case*,\n              cljs.pprint/*print-circle* (:circle options cljs.pprint/*print-circle*)\n              ;;:escape           *print-escape*\n              ;;:gensym           *print-gensym*\n              cljs.core/*print-length* (:length options cljs.core/*print-length*)\n              cljs.core/*print-level* (:level options cljs.core/*print-level*)\n              cljs.pprint/*print-lines* (:lines options cljs.pprint/*print-lines*)\n              cljs.pprint/*print-miser-width* (:miser-width options cljs.pprint/*print-miser-width*)\n              cljs.pprint/*print-pprint-dispatch* (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n              cljs.pprint/*print-pretty* (:pretty options cljs.pprint/*print-pretty*)\n              cljs.pprint/*print-radix* (:radix options cljs.pprint/*print-radix*)\n              cljs.core/*print-readably* (:readably options cljs.core/*print-readably*)\n              cljs.pprint/*print-right-margin* (:right-margin options cljs.pprint/*print-right-margin*)\n              cljs.pprint/*print-suppress-namespaces* (:suppress-namespaces options cljs.pprint/*print-suppress-namespaces*)]\n      ;;TODO enable printing base\n      #_[bindings (if (or (not (= *print-base* 10)) *print-radix*)\n                  {#'pr pr-with-base}\n                  {})]\n      (binding []\n        (let [sb (StringBuffer.)\n              optval (if (contains? options :stream)\n                       (:stream options)\n                       true)\n              base-writer (if (or (true? optval) (nil? optval))\n                            (StringBufferWriter. sb)\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n                                (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (true? optval)\n            (string-print (str sb)))\n          (if (nil? optval)\n            (str sb)))))))\n\n(defn pprint\n  ([object]\n   (let [sb (StringBuffer.)]\n     (binding [*out* (StringBufferWriter. sb)]\n       (pprint object *out*)\n       (string-print (str sb)))))\n  ([object writer]\n   (with-pretty-writer writer\n                       (binding [*print-pretty* true]\n                         (write-out object))\n                       (if (not (= 0 (get-column *out*)))\n                         (-write *out* \\newline)))))\n\n(defn set-pprint-dispatch\n  [function]\n  (set! *print-pprint-dispatch* function)\n  nil)\n\n;;======================================================================\n;; Support for the functional interface to the pretty printer\n;;======================================================================\n\n(defn- check-enumerated-arg [arg choices]\n  (if-not (choices arg)\n    ;; TODO clean up choices string\n    (throw (js/Error. (str \"Bad argument: \" arg \". It must be one of \" choices)))))\n\n(defn- level-exceeded []\n  (and *print-level* (>= *current-level* *print-level*)))\n\n(defn pprint-newline\n  \"Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.\"\n  [kind]\n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))\n\n(defn pprint-indent\n  \"Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\"\n  [relative-to n]\n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))\n\n;; TODO a real implementation for pprint-tab\n(defn pprint-tab\n  \"Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n  {:added \"1.2\"}\n  [kind colnum colinc]\n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (js/Error. \"pprint-tab is not yet implemented\")))\n\n;;======================================================================\n;; cl_format.clj\n;;======================================================================\n\n;; Forward references\n(declare ^{:arglists '([format-str])} compile-format)\n(declare ^{:arglists '([stream format args] [format args])} execute-format)\n(declare ^{:arglists '([s])} init-navigator)\n;; End forward references\n\n(defn cl-format\n  \"An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \\\"Common Lisp the\nLanguage, 2nd edition\\\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n  {:see-also [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n               \"Common Lisp the Language\"]\n              [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n               \"Common Lisp HyperSpec\"]]}\n  [writer format-in & args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))\n\n(def ^:dynamic ^{:private true} *format-str* nil)\n\n(defn- format-error [message offset]\n  (let [full-message (str message \\newline *format-str* \\newline\n                          (apply str (repeat offset \\space)) \"^\" \\newline)]\n    (throw (js/Error full-message))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Argument navigators manage the argument list\n;; as the format statement moves through the list\n;; (possibly going forwards and backwards as it does so)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defrecord ^{:private true}\n  arg-navigator [seq rest pos])\n\n(defn- init-navigator\n  \"Create a new arg-navigator from the sequence with the position set to 0\"\n  {:skip-wiki true}\n  [s]\n  (let [s (seq s)]\n    (arg-navigator. s s 0)))\n\n;; TODO call format-error with offset\n(defn- next-arg [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (arg-navigator. (:seq navigator) (next rst) (inc (:pos navigator)))]\n      (throw (js/Error \"Not enough arguments for format definition\")))))\n\n(defn- next-arg-or-nil [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (arg-navigator. (:seq navigator) (next rst) (inc (:pos navigator)))]\n      [nil navigator])))\n\n;; Get an argument off the arg list and compile it if it's not already compiled\n(defn- get-format-arg [navigator]\n  (let [[raw-format navigator] (next-arg navigator)\n        compiled-format (if (string? raw-format)\n                          (compile-format raw-format)\n                          raw-format)]\n    [compiled-format navigator]))\n\n(declare relative-reposition)\n\n(defn- absolute-reposition [navigator position]\n  (if (>= position (:pos navigator))\n    (relative-reposition navigator (- (:pos navigator) position))\n    (arg-navigator. (:seq navigator) (drop position (:seq navigator)) position)))\n\n(defn- relative-reposition [navigator position]\n  (let [newpos (+ (:pos navigator) position)]\n    (if (neg? position)\n      (absolute-reposition navigator newpos)\n      (arg-navigator. (:seq navigator) (drop position (:rest navigator)) newpos))))\n\n(defrecord ^{:private true}\n  compiled-directive [func def params offset])\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; When looking at the parameter list, we may need to manipulate\n;; the argument list as well (for 'V' and '#' parameter types).\n;; We hide all of this behind a function, but clients need to\n;; manage changing arg navigator\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO: validate parameters when they come from arg list\n(defn- realize-parameter [[param [raw-val offset]] navigator]\n  (let [[real-param new-navigator]\n        (cond\n          (contains? #{:at :colon} param) ;pass flags through unchanged - this really isn't necessary\n          [raw-val navigator]\n\n          (= raw-val :parameter-from-args)\n          (next-arg navigator)\n\n          (= raw-val :remaining-arg-count)\n          [(count (:rest navigator)) navigator]\n\n          true\n          [raw-val navigator])]\n    [[param [real-param offset]] new-navigator]))\n\n(defn- realize-parameter-list [parameter-map navigator]\n  (let [[pairs new-navigator]\n        (map-passing-context realize-parameter navigator parameter-map)]\n    [(into {} pairs) new-navigator]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Functions that support individual directives\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Common handling code for ~A and ~S\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^{:arglists '([base val])} opt-base-str)\n\n(def ^{:private true}\n  special-radix-markers {2 \"#b\" 8 \"#o\" 16 \"#x\"})\n\n(defn- format-simple-number [n]\n  (cond\n    (integer? n) (if (= *print-base* 10)\n                   (str n (if *print-radix* \".\"))\n                   (str\n                     (if *print-radix* (or (get special-radix-markers *print-base*) (str \"#\" *print-base* \"r\")))\n                     (opt-base-str *print-base* n)))\n    ;;(ratio? n) ;;no ratio support\n    :else nil))\n\n(defn- format-ascii [print-func params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)\n        base-output (or (format-simple-number arg) (print-func arg))\n        base-width (.-length base-output)\n        min-width (+ base-width (:minpad params))\n        width (if (>= min-width (:mincol params))\n                min-width\n                (+ min-width\n                   (* (+ (quot (- (:mincol params) min-width 1)\n                               (:colinc params))\n                         1)\n                      (:colinc params))))\n        chars (apply str (repeat (- width base-width) (:padchar params)))]\n    (if (:at params)\n      (print (str chars base-output))\n      (print (str base-output chars)))\n    arg-navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the integer directives ~D, ~X, ~O, ~B and some\n;; of ~R\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- integral?\n  \"returns true if a number is actually an integer (that is, has no fractional part)\"\n  [x]\n  (cond\n    (integer? x) true\n    ;;(decimal? x) ;;no decimal support\n    (float? x) (= x (Math/floor x))\n    ;;(ratio? x) ;;no ratio support\n    :else false))\n\n(defn- remainders\n  \"Return the list of remainders (essentially the 'digits') of val in the given base\"\n  [base val]\n  (reverse\n    (first\n      (consume #(if (pos? %)\n                 [(rem % base) (quot % base)]\n                 [nil nil])\n               val))))\n\n;; TODO: xlated-val does not seem to be used here.\n;; NB\n(defn- base-str\n  \"Return val as a string in the given base\"\n  [base val]\n  (if (zero? val)\n    \"0\"\n    (let [xlated-val (cond\n                       ;(float? val) (bigdec val) ;;No bigdec\n                       ;(ratio? val) nil ;;No ratio\n                       :else val)]\n      (apply str\n             (map\n               #(if (< % 10) (char (+ (char-code \\0) %)) (char (+ (char-code \\a) (- % 10))))\n               (remainders base val))))))\n\n;;Not sure if this is accurate or necessary\n(def ^{:private true}\n  javascript-base-formats {8 \"%o\", 10 \"%d\", 16 \"%x\"})\n\n(defn- opt-base-str\n  \"Return val as a string in the given base. No cljs format, so no improved performance.\"\n  [base val]\n  (base-str base val))\n\n(defn- group-by* [unit lis]\n  (reverse\n    (first\n      (consume (fn [x] [(seq (reverse (take unit x))) (seq (drop unit x))]) (reverse lis)))))\n\n(defn- format-integer [base params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)]\n    (if (integral? arg)\n      (let [neg (neg? arg)\n            pos-arg (if neg (- arg) arg)\n            raw-str (opt-base-str base pos-arg)\n            group-str (if (:colon params)\n                        (let [groups (map #(apply str %) (group-by* (:commainterval params) raw-str))\n                              commas (repeat (count groups) (:commachar params))]\n                          (apply str (next (interleave commas groups))))\n                        raw-str)\n            signed-str (cond\n                         neg (str \"-\" group-str)\n                         (:at params) (str \"+\" group-str)\n                         true group-str)\n            padded-str (if (< (.-length signed-str) (:mincol params))\n                         (str (apply str (repeat (- (:mincol params) (.-length signed-str))\n                                                 (:padchar params)))\n                              signed-str)\n                         signed-str)]\n        (print padded-str))\n      (format-ascii print-str {:mincol (:mincol params) :colinc 1 :minpad 0\n                               :padchar (:padchar params) :at true}\n                    (init-navigator [arg]) nil))\n    arg-navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for english formats (~R and ~:R)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     english-cardinal-units\n     [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"\n      \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\"\n      \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\"])\n\n(def ^{:private true}\n     english-ordinal-units\n     [\"zeroth\" \"first\" \"second\" \"third\" \"fourth\" \"fifth\" \"sixth\" \"seventh\" \"eighth\" \"ninth\"\n      \"tenth\" \"eleventh\" \"twelfth\" \"thirteenth\" \"fourteenth\"\n      \"fifteenth\" \"sixteenth\" \"seventeenth\" \"eighteenth\" \"nineteenth\"])\n\n(def ^{:private true}\n     english-cardinal-tens\n     [\"\" \"\" \"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"])\n\n(def ^{:private true}\n     english-ordinal-tens\n     [\"\" \"\" \"twentieth\" \"thirtieth\" \"fortieth\" \"fiftieth\"\n      \"sixtieth\" \"seventieth\" \"eightieth\" \"ninetieth\"])\n\n;; We use \"short scale\" for our units (see http://en.wikipedia.org/wiki/Long_and_short_scales)\n;; Number names from http://www.jimloy.com/math/billion.htm\n;; We follow the rules for writing numbers from the Blue Book\n;; (http://www.grammarbook.com/numbers/numbers.asp)\n(def ^{:private true}\n     english-scale-numbers\n     [\"\" \"thousand\" \"million\" \"billion\" \"trillion\" \"quadrillion\" \"quintillion\"\n      \"sextillion\" \"septillion\" \"octillion\" \"nonillion\" \"decillion\"\n      \"undecillion\" \"duodecillion\" \"tredecillion\" \"quattuordecillion\"\n      \"quindecillion\" \"sexdecillion\" \"septendecillion\"\n      \"octodecillion\" \"novemdecillion\" \"vigintillion\"])\n\n(defn- format-simple-cardinal\n  \"Convert a number less than 1000 to a cardinal english string\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n      (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n      (if (and (pos? hundreds) (pos? tens)) \" \")\n      (if (pos? tens)\n        (if (< tens 20)\n          (nth english-cardinal-units tens)\n          (let [ten-digit (quot tens 10)\n                unit-digit (rem tens 10)]\n            (str\n              (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n              (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n              (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))\n\n(defn- add-english-scales\n  \"Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\n  offset is a factor of 10^3 to multiply by\"\n  [parts offset]\n  (let [cnt (count parts)]\n    (loop [acc []\n           pos (dec cnt)\n           this (first parts)\n           remainder (next parts)]\n      (if (nil? remainder)\n        (str (apply str (interpose \", \" acc))\n             (if (and (not (empty? this)) (not (empty? acc))) \", \")\n             this\n             (if (and (not (empty? this)) (pos? (+ pos offset)))\n               (str \" \" (nth english-scale-numbers (+ pos offset)))))\n        (recur\n          (if (empty? this)\n            acc\n            (conj acc (str this \" \" (nth english-scale-numbers (+ pos offset)))))\n          (dec pos)\n          (first remainder)\n          (next remainder))))))\n\n(defn- format-cardinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zero\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs (is this true?)\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal parts)\n                full-str (add-english-scales parts-strs 0)]\n            (print (str (if (neg? arg) \"minus \") full-str)))\n          (format-integer ;; for numbers > 10^63, we fall back on ~D\n            10\n            {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n            (init-navigator [arg])\n            {:mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))\n    navigator))\n\n(defn- format-simple-ordinal\n  \"Convert a number less than 1000 to a ordinal english string\n  Note this should only be used for the last one in the sequence\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n      (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n      (if (and (pos? hundreds) (pos? tens)) \" \")\n      (if (pos? tens)\n        (if (< tens 20)\n          (nth english-ordinal-units tens)\n          (let [ten-digit (quot tens 10)\n                unit-digit (rem tens 10)]\n            (if (and (pos? ten-digit) (not (pos? unit-digit)))\n              (nth english-ordinal-tens ten-digit)\n              (str\n                (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n                (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n                (if (pos? unit-digit) (nth english-ordinal-units unit-digit))))))\n        (if (pos? hundreds) \"th\")))))\n\n(defn- format-ordinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zeroth\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs (is this true?)\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal (drop-last parts))\n                head-str (add-english-scales parts-strs 1)\n                tail-str (format-simple-ordinal (last parts))]\n            (print (str (if (neg? arg) \"minus \")\n                        (cond\n                          (and (not (empty? head-str)) (not (empty? tail-str)))\n                          (str head-str \", \" tail-str)\n\n                          (not (empty? head-str)) (str head-str \"th\")\n                          :else tail-str))))\n          (do (format-integer ;for numbers > 10^63, we fall back on ~D\n                10\n                {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n                (init-navigator [arg])\n                {:mincol 0, :padchar 0, :commachar 0 :commainterval 0})\n              (let [low-two-digits (rem arg 100)\n                    not-teens (or (< 11 low-two-digits) (> 19 low-two-digits))\n                    low-digit (rem low-two-digits 10)]\n                (print (cond\n                         (and (== low-digit 1) not-teens) \"st\"\n                         (and (== low-digit 2) not-teens) \"nd\"\n                         (and (== low-digit 3) not-teens) \"rd\"\n                         :else \"th\")))))))\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for roman numeral formats (~@R and ~@:R)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     old-roman-table\n     [[ \"I\" \"II\" \"III\" \"IIII\" \"V\" \"VI\" \"VII\" \"VIII\" \"VIIII\"]\n      [ \"X\" \"XX\" \"XXX\" \"XXXX\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"LXXXX\"]\n      [ \"C\" \"CC\" \"CCC\" \"CCCC\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"DCCCC\"]\n      [ \"M\" \"MM\" \"MMM\"]])\n\n(def ^{:private true}\n     new-roman-table\n     [[ \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n      [ \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n      [ \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n      [ \"M\" \"MM\" \"MMM\"]])\n\n(defn- format-roman\n  \"Format a roman numeral using the specified look-up table\"\n  [table params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (and (number? arg) (> arg 0) (< arg 4000))\n      (let [digits (remainders 10 arg)]\n        (loop [acc []\n               pos (dec (count digits))\n               digits digits]\n          (if (empty? digits)\n            (print (apply str acc))\n            (let [digit (first digits)]\n              (recur (if (= 0 digit)\n                       acc\n                       (conj acc (nth (nth table pos) (dec digit))))\n                     (dec pos)\n                     (next digits))))))\n      (format-integer ; for anything <= 0 or > 3999, we fall back on ~D\n        10\n        {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n        (init-navigator [arg])\n        {:mincol 0, :padchar 0, :commachar 0 :commainterval 0}))\n    navigator))\n\n(defn- format-old-roman [params navigator offsets]\n  (format-roman old-roman-table params navigator offsets))\n\n(defn- format-new-roman [params navigator offsets]\n  (format-roman new-roman-table params navigator offsets))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for character formats (~C)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     special-chars {8 \"Backspace\", 9 \"Tab\", 10 \"Newline\", 13 \"Return\", 32 \"Space\"})\n\n(defn- pretty-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)\n        as-int (char-code c)\n        base-char (bit-and as-int 127)\n        meta (bit-and as-int 128)\n        special (get special-chars base-char)]\n    (if (> meta 0) (print \"Meta-\"))\n    (print (cond\n             special special\n             (< base-char 32) (str \"Control-\" (char (+ base-char 64)))\n             (= base-char 127) \"Control-?\"\n             :else (char base-char)))\n    navigator))\n\n(defn- readable-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)]\n    (condp = (:char-format params)\n      \\o (cl-format true \"\\\\o~3, '0o\" (char-code c))\n      \\u (cl-format true \"\\\\u~4, '0x\" (char-code c))\n      nil (print-char c))\n    navigator))\n\n(defn- plain-character [params navigator offsets]\n  (let [[char navigator] (next-arg navigator)]\n    (print char)\n    navigator))\n\n;; Check to see if a result is an abort (~^) construct\n;; TODO: move these funcs somewhere more appropriate\n(defn- abort? [context]\n  (let [token (first context)]\n    (or (= :up-arrow token) (= :colon-up-arrow token))))\n\n;; Handle the execution of \"sub-clauses\" in bracket constructions\n(defn- execute-sub-format [format args base-args]\n  (second\n    (map-passing-context\n      (fn [element context]\n        (if (abort? context)\n          [nil context]    ; just keep passing it along\n          (let [[params args] (realize-parameter-list (:params element) context)\n                [params offsets] (unzip-map params)\n                params (assoc params :base-args base-args)]\n            [nil (apply (:func element) [params args offsets])])))\n      args\n      format)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for real number formats\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO - return exponent as int to eliminate double conversion\n(defn- float-parts-base\n  \"Produce string parts for the mantissa (normalize 1-9) and exponent\"\n  [f]\n  (let [s (string/lower-case (str f))\n        exploc (.indexOf s \\e)\n        dotloc (.indexOf s \\.)]\n    (if (neg? exploc)\n      (if (neg? dotloc)\n        [s (str (dec (count s)))]\n        [(str (subs s 0 dotloc) (subs s (inc dotloc))) (str (dec dotloc))])\n      (if (neg? dotloc)\n        [(subs s 0 exploc) (subs s (inc exploc))]\n        [(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))]))))\n\n(defn- float-parts\n  \"Take care of leading and trailing zeros in decomposed floats\"\n  [f]\n  (let [[m e] (float-parts-base f)\n        m1 (rtrim m \\0)\n        m2 (ltrim m1 \\0)\n        delta (- (count m1) (count m2))\n        e (if (and (pos? (count e)) (= (nth e 0) \\+)) (subs e 1) e)]\n    (if (empty? m2)\n      [\"0\" 0]\n      [m2 (- (js/parseInt e 10) delta)])))\n\n(defn- inc-s\n  \"Assumption: The input string consists of one or more decimal digits,\n  and no other characters. Return a string containing one or more\n  decimal digits containing a decimal number one larger than the input\n  string. The output string will always be the same length as the input\n  string, or one character longer.\"\n  [s]\n  (let [len-1 (dec (count s))]\n    (loop [i (int len-1)]\n      (cond\n        (neg? i) (apply str \"1\" (repeat (inc len-1) \"0\"))\n        (= \\9 (.charAt s i)) (recur (dec i))\n        :else (apply str (subs s 0 i)\n                     (char (inc (char-code (.charAt s i))))\n                     (repeat (- len-1 i) \"0\"))))))\n\n(defn- round-str [m e d w]\n  (if (or d w)\n    (let [len (count m)\n          ;; Every formatted floating point number should include at\n          ;; least one decimal digit and a decimal point.\n          w (if w (max 2 w)\n                  ;;NB: if w doesn't exist, it won't ever be used because d will\n                  ;; satisfy the cond below. cljs gives a compilation warning if\n                  ;; we don't provide a value here.\n                  0)\n          round-pos (cond\n                      ;; If d was given, that forces the rounding\n                      ;; position, regardless of any width that may\n                      ;; have been specified.\n                      d (+ e d 1)\n                      ;; Otherwise w was specified, so pick round-pos\n                      ;; based upon that.\n                      ;; If e>=0, then abs value of number is >= 1.0,\n                      ;; and e+1 is number of decimal digits before the\n                      ;; decimal point when the number is written\n                      ;; without scientific notation. Never round the\n                      ;; number before the decimal point.\n                      (>= e 0) (max (inc e) (dec w))\n                      ;; e < 0, so number abs value < 1.0\n                      :else (+ w e))\n          [m1 e1 round-pos len] (if (= round-pos 0)\n                                  [(str \"0\" m) (inc e) 1 (inc len)]\n                                  [m e round-pos len])]\n      (if round-pos\n        (if (neg? round-pos)\n          [\"0\" 0 false]\n          (if (> len round-pos)\n            (let [round-char (nth m1 round-pos)\n                  result (subs m1 0 round-pos)]\n              (if (>= (char-code round-char) (char-code \\5))\n                (let [round-up-result (inc-s result)\n                      expanded (> (count round-up-result) (count result))]\n                  [(if expanded\n                     (subs round-up-result 0 (dec (count round-up-result)))\n                     round-up-result)\n                   e1 expanded])\n                [result e1 false]))\n            [m e false]))\n        [m e false]))\n    [m e false]))\n\n(defn- expand-fixed [m e d]\n  (let [[m1 e1] (if (neg? e)\n                  [(str (apply str (repeat (dec (- e)) \\0)) m) -1]\n                  [m e])\n        len (count m1)\n        target-len (if d (+ e1 d 1) (inc e1))]\n    (if (< len target-len)\n      (str m1 (apply str (repeat (- target-len len) \\0)))\n      m1)))\n\n(defn- insert-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m e]\n  (if (neg? e)\n    (str \".\" m)\n    (let [loc (inc e)]\n      (str (subs m 0 loc) \".\" (subs m loc)))))\n\n(defn- get-fixed [m e d]\n  (insert-decimal (expand-fixed m e d) e))\n\n(defn- insert-scaled-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m k]\n  (if (neg? k)\n    (str \".\" m)\n    (str (subs m 0 k) \".\" (subs m k))))\n\n;;TODO: No ratio, so not sure what to do here\n(defn- convert-ratio [x]\n  x)\n\n;; the function to render ~F directives\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n(defn- fixed-float [params navigator offsets]\n  (let [w (:w params)\n        d (:d params)\n        [arg navigator] (next-arg navigator)\n        [sign abs] (if (neg? arg) [\"-\" (- arg)] [\"+\" arg])\n        abs (convert-ratio abs)\n        [mantissa exp] (float-parts abs)\n        scaled-exp (+ exp (:k params))\n        add-sign (or (:at params) (neg? arg))\n        append-zero (and (not d) (<= (dec (count mantissa)) scaled-exp))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa scaled-exp\n                                                          d (if w (- w (if add-sign 1 0))))\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        fixed-repr (if (and w d\n                            (>= d 1)\n                            (= (.charAt fixed-repr 0) \\0)\n                            (= (.charAt fixed-repr 1) \\.)\n                            (> (count fixed-repr) (- w (if add-sign 1 0))))\n                     (subs fixed-repr 1)    ;chop off leading 0\n                     fixed-repr)\n        prepend-zero (= (first fixed-repr) \\.)]\n    (if w\n      (let [len (count fixed-repr)\n            signed-len (if add-sign (inc len) len)\n            prepend-zero (and prepend-zero (not (>= signed-len w)))\n            append-zero (and append-zero (not (>= signed-len w)))\n            full-len (if (or prepend-zero append-zero)\n                       (inc signed-len)\n                       signed-len)]\n        (if (and (> full-len w) (:overflowchar params))\n          (print (apply str (repeat w (:overflowchar params))))\n          (print (str\n                   (apply str (repeat (- w full-len) (:padchar params)))\n                   (if add-sign sign)\n                   (if prepend-zero \"0\")\n                   fixed-repr\n                   (if append-zero \"0\")))))\n      (print (str\n               (if add-sign sign)\n               (if prepend-zero \"0\")\n               fixed-repr\n               (if append-zero \"0\"))))\n    navigator))\n\n;; the function to render ~E directives\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n;; TODO: define ~E representation for Infinity\n(defn- exponential-float [params navigator offset]\n  (let [[arg navigator] (next-arg navigator)\n        arg (convert-ratio arg)]\n    (loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))]\n      (let [w (:w params)\n            d (:d params)\n            e (:e params)\n            k (:k params)\n            expchar (or (:exponentchar params) \\E)\n            add-sign (or (:at params) (neg? arg))\n            prepend-zero (<= k 0)\n            scaled-exp (- exp (dec k))\n            scaled-exp-str (str (Math/abs scaled-exp))\n            scaled-exp-str (str expchar (if (neg? scaled-exp) \\- \\+)\n                                (if e (apply str\n                                             (repeat\n                                               (- e\n                                                  (count scaled-exp-str))\n                                               \\0)))\n                                scaled-exp-str)\n            exp-width (count scaled-exp-str)\n            base-mantissa-width (count mantissa)\n            scaled-mantissa (str (apply str (repeat (- k) \\0))\n                                 mantissa\n                                 (if d\n                                   (apply str\n                                          (repeat\n                                            (- d (dec base-mantissa-width)\n                                               (if (neg? k) (- k) 0)) \\0))))\n            w-mantissa (if w (- w exp-width))\n            [rounded-mantissa _ incr-exp] (round-str\n                                            scaled-mantissa 0\n                                            (cond\n                                              (= k 0) (dec d)\n                                              (pos? k) d\n                                              (neg? k) (dec d))\n                                            (if w-mantissa\n                                              (- w-mantissa (if add-sign 1 0))))\n            full-mantissa (insert-scaled-decimal rounded-mantissa k)\n            append-zero (and (= k (count rounded-mantissa)) (nil? d))]\n        (if (not incr-exp)\n          (if w\n            (let [len (+ (count full-mantissa) exp-width)\n                  signed-len (if add-sign (inc len) len)\n                  prepend-zero (and prepend-zero (not (= signed-len w)))\n                  full-len (if prepend-zero (inc signed-len) signed-len)\n                  append-zero (and append-zero (< full-len w))]\n              (if (and (or (> full-len w) (and e (> (- exp-width 2) e)))\n                       (:overflowchar params))\n                (print (apply str (repeat w (:overflowchar params))))\n                (print (str\n                         (apply str\n                                (repeat\n                                  (- w full-len (if append-zero 1 0))\n                                  (:padchar params)))\n                         (if add-sign (if (neg? arg) \\- \\+))\n                         (if prepend-zero \"0\")\n                         full-mantissa\n                         (if append-zero \"0\")\n                         scaled-exp-str))))\n            (print (str\n                     (if add-sign (if (neg? arg) \\- \\+))\n                     (if prepend-zero \"0\")\n                     full-mantissa\n                     (if append-zero \"0\")\n                     scaled-exp-str)))\n          (recur [rounded-mantissa (inc exp)]))))\n    navigator))\n\n;; the function to render ~G directives\n;; This just figures out whether to pass the request off to ~F or ~E based\n;; on the algorithm in CLtL.\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n;; TODO: refactor so that float-parts isn't called twice\n(defn- general-float [params navigator offsets]\n  (let [[arg _] (next-arg navigator)\n        arg (convert-ratio arg)\n        [mantissa exp] (float-parts (if (neg? arg) (- arg) arg))\n        w (:w params)\n        d (:d params)\n        e (:e params)\n        n (if (= arg 0.0) 0 (inc exp))\n        ee (if e (+ e 2) 4)\n        ww (if w (- w ee))\n        d (if d d (max (count mantissa) (min n 7)))\n        dd (- d n)]\n    (if (<= 0 dd d)\n      (let [navigator (fixed-float {:w ww, :d dd, :k 0,\n                                    :overflowchar (:overflowchar params),\n                                    :padchar (:padchar params), :at (:at params)}\n                                   navigator offsets)]\n        (print (apply str (repeat ee \\space)))\n        navigator)\n      (exponential-float params navigator offsets))))\n\n;; the function to render ~$ directives\n;; TODO: support rationals. Back off to ~D/~A in the appropriate cases\n(defn- dollar-float [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)\n        [mantissa exp] (float-parts (Math/abs arg))\n        d (:d params)  ; digits after the decimal\n        n (:n params)  ; minimum digits before the decimal\n        w (:w params)  ; minimum field width\n        add-sign (or (:at params) (neg? arg))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa exp d nil)\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        full-repr (str (apply str (repeat (- n (.indexOf fixed-repr \\.)) \\0)) fixed-repr)\n        full-len (+ (count full-repr) (if add-sign 1 0))]\n    (print (str\n             (if (and (:colon params) add-sign) (if (neg? arg) \\- \\+))\n             (apply str (repeat (- w full-len) (:padchar params)))\n             (if (and (not (:colon params)) add-sign) (if (neg? arg) \\- \\+))\n             full-repr))\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the '~[...~]' conditional construct in its\n;; different flavors\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; ~[...~] without any modifiers chooses one of the clauses based on the param or\n;; next argument\n;; TODO check arg is positive int\n(defn- choice-conditional [params arg-navigator offsets]\n  (let [arg (:selector params)\n        [arg navigator] (if arg [arg arg-navigator] (next-arg arg-navigator))\n        clauses (:clauses params)\n        clause (if (or (neg? arg) (>= arg (count clauses)))\n                 (first (:else params))\n                 (nth clauses arg))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))\n\n;; ~:[...~] with the colon reads the next argument treating it as a truth value\n(defn- boolean-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg\n                 (second clauses)\n                 (first clauses))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))\n\n;; ~@[...~] with the at sign executes the conditional if the next arg is not\n;; nil/false without consuming the arg\n(defn- check-arg-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg (first clauses))]\n    (if arg\n      (if clause\n        (execute-sub-format clause arg-navigator (:base-args params))\n        arg-navigator)\n      navigator)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the '~{...~}' iteration construct in its\n;; different flavors\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; ~{...~} without any modifiers uses the next argument as an argument list that\n;; is consumed by all the iterations\n(defn- iterate-sublist [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])\n        [arg-list navigator] (next-arg navigator)\n        args (init-navigator arg-list)]\n    (loop [count 0\n           args args\n           last-pos (int -1)]\n      (if (and (not max-count) (= (:pos args) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (js/Error \"%{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest args))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause args (:base-args params))]\n          (if (= :up-arrow (first iter-result))\n            navigator\n            (recur (inc count) iter-result (:pos args))))))))\n\n;; ~:{...~} with the colon treats the next argument as a list of sublists. Each of the\n;; sublists is used as the arglist for a single iteration.\n(defn- iterate-list-of-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])\n        [arg-list navigator] (next-arg navigator)]\n    (loop [count 0\n           arg-list arg-list]\n      (if (or (and (empty? arg-list)\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format\n                            clause\n                            (init-navigator (first arg-list))\n                            (init-navigator (next arg-list)))]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) (next arg-list))))))))\n\n;; ~@{...~} with the at sign uses the main argument list as the arguments to the iterations\n;; is consumed by all the iterations\n(defn- iterate-main-list [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator\n           last-pos (int -1)]\n      (if (and (not max-count) (= (:pos navigator) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (js/Error \"%@{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause navigator (:base-args params))]\n          (if (= :up-arrow (first iter-result))\n            (second iter-result)\n            (recur\n              (inc count) iter-result (:pos navigator))))))))\n\n;; ~@:{...~} with both colon and at sign uses the main argument list as a set of sublists, one\n;; of which is consumed with each iteration\n(defn- iterate-main-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator]\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [[sublist navigator] (next-arg-or-nil navigator)\n              iter-result (execute-sub-format clause (init-navigator sublist) navigator)]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) navigator)))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; The '~< directive has two completely different meanings\n;; in the '~<...~>' form it does justification, but with\n;; ~<...~:>' it represents the logical block operation of the\n;; pretty printer.\n;;\n;; Unfortunately, the current architecture decides what function\n;; to call at form parsing time before the sub-clauses have been\n;; folded, so it is left to run-time to make the decision.\n;;\n;; TODO: make it possible to make these decisions at compile-time.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^{:arglists '([params navigator offsets])} format-logical-block)\n(declare ^{:arglists '([params navigator offsets])} justify-clauses)\n\n(defn- logical-block-or-justify [params navigator offsets]\n  (if (:colon (:right-params params))\n    (format-logical-block params navigator offsets)\n    (justify-clauses params navigator offsets)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Support for the '~<...~>' justification directive\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- render-clauses [clauses navigator base-navigator]\n  (loop [clauses clauses\n         acc []\n         navigator navigator]\n    (if (empty? clauses)\n      [acc navigator]\n      (let [clause (first clauses)\n            [iter-result result-str] (let [sb (StringBuffer.)]\n                                       (binding [*out* (StringBufferWriter. sb)]\n                                         [(execute-sub-format clause navigator base-navigator)\n                                          (str sb)]))]\n        (if (= :up-arrow (first iter-result))\n          [acc (second iter-result)]\n          (recur (next clauses) (conj acc result-str) iter-result))))))\n\n;; TODO support for ~:; constructions\n(defn- justify-clauses [params navigator offsets]\n  (let [[[eol-str] new-navigator] (when-let [else (:else params)]\n                                    (render-clauses else navigator (:base-args params)))\n        navigator (or new-navigator navigator)\n        [else-params new-navigator] (when-let [p (:else-params params)]\n                                      (realize-parameter-list p navigator))\n        navigator (or new-navigator navigator)\n        min-remaining (or (first (:min-remaining else-params)) 0)\n        max-columns (or (first (:max-columns else-params))\n                        (get-max-column *out*))\n        clauses (:clauses params)\n        [strs navigator] (render-clauses clauses navigator (:base-args params))\n        slots (max 1\n                   (+ (dec (count strs)) (if (:colon params) 1 0) (if (:at params) 1 0)))\n        chars (reduce + (map count strs))\n        mincol (:mincol params)\n        minpad (:minpad params)\n        colinc (:colinc params)\n        minout (+ chars (* slots minpad))\n        result-columns (if (<= minout mincol)\n                         mincol\n                         (+ mincol (* colinc\n                                      (+ 1 (quot (- minout mincol 1) colinc)))))\n        total-pad (- result-columns chars)\n        pad (max minpad (quot total-pad slots))\n        extra-pad (- total-pad (* pad slots))\n        pad-str (apply str (repeat pad (:padchar params)))]\n    (if (and eol-str (> (+ (get-column (:base @@*out*)) min-remaining result-columns)\n                        max-columns))\n      (print eol-str))\n    (loop [slots slots\n           extra-pad extra-pad\n           strs strs\n           pad-only (or (:colon params)\n                        (and (= (count strs) 1) (not (:at params))))]\n      (if (seq strs)\n        (do\n          (print (str (if (not pad-only) (first strs))\n                      (if (or pad-only (next strs) (:at params)) pad-str)\n                      (if (pos? extra-pad) (:padchar params))))\n          (recur\n            (dec slots)\n            (dec extra-pad)\n            (if pad-only strs (next strs))\n            false))))\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Support for case modification with ~(...~).\n;;; We do this by wrapping the underlying writer with\n;;; a special writer to do the appropriate modification. This\n;;; allows us to support arbitrary-sized output and sources\n;;; that may block.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- downcase-writer\n  \"Returns a proxy that wraps writer, converting all characters to lower case\"\n  [writer]\n  (reify\n    IWriter\n    (-flush [_] (-flush writer))\n    (-write\n      ;;no multi-arity, not sure of importance\n      #_([^chars cbuf ^Integer off ^Integer len]\n             (.write writer cbuf off len))\n      [this x]\n      (condp = (type x)\n        js/String\n        (let [s x]\n          (-write writer (string/lower-case s)))\n\n        js/Number\n        (let [c x]\n          ;;TODO need to enforce integers only?\n          (-write writer (string/lower-case (char c))))))))\n\n(defn- upcase-writer\n  \"Returns a proxy that wraps writer, converting all characters to upper case\"\n  [writer]\n  (reify\n    IWriter\n    (-flush [_] (-flush writer))\n    (-write\n      ;;no multi-arity, not sure of importance\n      #_([^chars cbuf ^Integer off ^Integer len]\n             (.write writer cbuf off len))\n      [this x]\n      (condp = (type x)\n        js/String\n        (let [s x]\n          (-write writer (string/upper-case s)))\n\n        js/Number\n        (let [c x]\n          ;;TODO need to enforce integers only?\n          (-write writer (string/upper-case (char c))))))))\n\n(defn- capitalize-string\n  \"Capitalizes the words in a string. If first? is false, don't capitalize the\n                                      first character of the string even if it's a letter.\"\n  [s first?]\n  (let [f (first s)\n        s (if (and first? f (gstring/isUnicodeChar f))\n            (str (string/upper-case f) (subs s 1))\n            s)]\n    (apply str\n           (first\n             (consume\n               (fn [s]\n                 (if (empty? s)\n                   [nil nil]\n                   (let [m (.exec (js/RegExp \"\\\\W\\\\w\" \"g\") s)\n                         offset (and m (inc (.-index m)))]\n                     (if offset\n                       [(str (subs s 0 offset)\n                             (string/upper-case (nth s offset)))\n                        (subs s (inc offset))]\n                       [s nil]))))\n               s)))))\n\n(defn- capitalize-word-writer\n  \"Returns a proxy that wraps writer, capitalizing all words\"\n  [writer]\n  (let [last-was-whitespace? (atom true)]\n    (reify\n      IWriter\n      (-flush [_] (-flush writer))\n      (-write\n        ;;no multi-arity\n        #_([^chars cbuf ^Integer off ^Integer len]\n               (.write writer cbuf off len))\n        [this x]\n        (condp = (type x)\n          js/String\n          (let [s x]\n            (-write writer\n                    (capitalize-string (.toLowerCase s) @last-was-whitespace?))\n            (when (pos? (.-length s))\n              (reset! last-was-whitespace? (gstring/isEmptyOrWhitespace (nth s (dec (count s)))))))\n\n          js/Number\n          (let [c (char x)]\n            (let [mod-c (if @last-was-whitespace? (string/upper-case c) c)]\n              (-write writer mod-c)\n              (reset! last-was-whitespace? (gstring/isEmptyOrWhitespace c)))))))))\n\n(defn- init-cap-writer\n  \"Returns a proxy that wraps writer, capitalizing the first word\"\n  [writer]\n  (let [capped (atom false)]\n    (reify\n      IWriter\n      (-flush [_] (-flush writer))\n      (-write\n        ;;no multi-arity\n        #_([^chars cbuf ^Integer off ^Integer len]\n                    (.write writer cbuf off len))\n        [this x]\n        (condp = (type x)\n          js/String\n          (let [s (string/lower-case x)]\n            (if (not @capped)\n              (let [m (.exec (js/RegExp \"\\\\S\" \"g\") s)\n                    offset (and m (.-index m))]\n                (if offset\n                  (do (-write writer\n                              (str (subs s 0 offset)\n                                   (string/upper-case (nth s offset))\n                                   (string/lower-case (subs s (inc offset)))))\n                      (reset! capped true))\n                  (-write writer s)))\n              (-write writer (string/lower-case s))))\n\n          js/Number\n          (let [c (char x)]\n            (if (and (not @capped) (gstring/isUnicodeChar c))\n              (do\n                (reset! capped true)\n                (-write writer (string/upper-case c)))\n              (-write writer (string/lower-case c)))))))))\n\n(defn- modify-case [make-writer params navigator offsets]\n  (let [clause (first (:clauses params))]\n    (binding [*out* (make-writer *out*)]\n      (execute-sub-format clause navigator (:base-args params)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; If necessary, wrap the writer in a PrettyWriter object\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO update this doc string to show correct way to print\n(defn get-pretty-writer\n  \"Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000\"\n  [writer]\n  (if (pretty-writer? writer)\n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Support for column-aware operations ~&, ~T\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn fresh-line\n  \"Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n  []\n  (if (satisfies? IDeref *out*)\n    (if (not (= 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))\n\n(defn- absolute-tabulation [params navigator offsets]\n  (let [colnum (:colnum params)\n        colinc (:colinc params)\n        current (get-column (:base @@*out*))\n        space-count (cond\n                      (< current colnum) (- colnum current)\n                      (= colinc 0) 0\n                      :else (- colinc (rem (- current colnum) colinc)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)\n\n(defn- relative-tabulation [params navigator offsets]\n  (let [colrel (:colnum params)\n        colinc (:colinc params)\n        start-col (+ colrel (get-column (:base @@*out*)))\n        offset (if (pos? colinc) (rem start-col colinc) 0)\n        space-count (+ colrel (if (= 0 offset) 0 (- colinc offset)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Support for accessing the pretty printer from a format\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; TODO: support ~@; per-line-prefix separator\n;; TODO: get the whole format wrapped so we can start the lb at any column\n(defn- format-logical-block [params navigator offsets]\n  (let [clauses (:clauses params)\n        clause-count (count clauses)\n        prefix (cond\n                 (> clause-count 1) (:string (:params (first (first clauses))))\n                 (:colon params) \"(\")\n        body (nth clauses (if (> clause-count 1) 1 0))\n        suffix (cond\n                 (> clause-count 2) (:string (:params (first (nth clauses 2))))\n                 (:colon params) \")\")\n        [arg navigator] (next-arg navigator)]\n    (pprint-logical-block :prefix prefix :suffix suffix\n      (execute-sub-format\n        body\n        (init-navigator arg)\n        (:base-args params)))\n    navigator))\n\n(defn- set-indent [params navigator offsets]\n  (let [relative-to (if (:colon params) :current :block)]\n    (pprint-indent relative-to (:n params))\n    navigator))\n\n;;; TODO: support ~:T section options for ~T\n(defn- conditional-newline [params navigator offsets]\n  (let [kind (if (:colon params)\n               (if (:at params) :mandatory :fill)\n               (if (:at params) :miser :linear))]\n    (pprint-newline kind)\n    navigator))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The table of directives we support, each with its params,\n;;; properties, and the compilation function\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defdirectives\n  (\\A\n    [:mincol [0 js/Number] :colinc [1 js/Number] :minpad [0 js/Number] :padchar [\\space js/String]]\n    #{:at :colon :both} {}\n    #(format-ascii print-str %1 %2 %3))\n\n  (\\S\n    [:mincol [0 js/Number] :colinc [1 js/Number] :minpad [0 js/Number] :padchar [\\space js/String]]\n    #{:at :colon :both} {}\n    #(format-ascii pr-str %1 %2 %3))\n\n  (\\D\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 10 %1 %2 %3))\n\n  (\\B\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 2 %1 %2 %3))\n\n  (\\O\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 8 %1 %2 %3))\n\n  (\\X\n    [:mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    #(format-integer 16 %1 %2 %3))\n\n  (\\R\n    [:base [nil js/Number] :mincol [0 js/Number] :padchar [\\space js/String] :commachar [\\, js/String]\n     :commainterval [3 js/Number]]\n    #{:at :colon :both} {}\n    (do\n      (cond                          ; ~R is overloaded with bizareness\n        (first (:base params))     #(format-integer (:base %1) %1 %2 %3)\n        (and (:at params) (:colon params))   #(format-old-roman %1 %2 %3)\n        (:at params)               #(format-new-roman %1 %2 %3)\n        (:colon params)            #(format-ordinal-english %1 %2 %3)\n        true                       #(format-cardinal-english %1 %2 %3))))\n\n  (\\P\n    []\n    #{:at :colon :both} {}\n    (fn [params navigator offsets]\n      (let [navigator (if (:colon params) (relative-reposition navigator -1) navigator)\n            strs (if (:at params) [\"y\" \"ies\"] [\"\" \"s\"])\n            [arg navigator] (next-arg navigator)]\n        (print (if (= arg 1) (first strs) (second strs)))\n        navigator)))\n\n  (\\C\n    [:char-format [nil js/String]]\n    #{:at :colon :both} {}\n    (cond\n      (:colon params) pretty-character\n      (:at params) readable-character\n      :else plain-character))\n\n  (\\F\n    [:w [nil js/Number] :d [nil js/Number] :k [0 js/Number] :overflowchar [nil js/String]\n     :padchar [\\space js/String]]\n    #{:at} {}\n    fixed-float)\n\n  (\\E\n    [:w [nil js/Number] :d [nil js/Number] :e [nil js/Number] :k [1 js/Number]\n     :overflowchar [nil js/String] :padchar [\\space js/String]\n     :exponentchar [nil js/String]]\n    #{:at} {}\n    exponential-float)\n\n  (\\G\n    [:w [nil js/Number] :d [nil js/Number] :e [nil js/Number] :k [1 js/Number]\n     :overflowchar [nil js/String] :padchar [\\space js/String]\n     :exponentchar [nil js/String]]\n    #{:at} {}\n    general-float)\n\n  (\\$\n    [:d [2 js/Number] :n [1 js/Number] :w [0 js/Number] :padchar [\\space js/String]]\n    #{:at :colon :both} {}\n    dollar-float)\n\n  (\\%\n    [:count [1 js/Number]]\n    #{} {}\n    (fn [params arg-navigator offsets]\n      (dotimes [i (:count params)]\n        (prn))\n      arg-navigator))\n\n  (\\&\n    [:count [1 js/Number]]\n    #{:pretty} {}\n    (fn [params arg-navigator offsets]\n      (let [cnt (:count params)]\n        (if (pos? cnt) (fresh-line))\n        (dotimes [i (dec cnt)]\n          (prn)))\n      arg-navigator))\n\n  (\\|\n    [:count [1 js/Number]]\n    #{} {}\n    (fn [params arg-navigator offsets]\n      (dotimes [i (:count params)]\n        (print \\formfeed))\n      arg-navigator))\n\n  (\\~\n    [:n [1 js/Number]]\n    #{} {}\n    (fn [params arg-navigator offsets]\n      (let [n (:n params)]\n        (print (apply str (repeat n \\~)))\n        arg-navigator)))\n\n  (\\newline ;; Whitespace supression is handled in the compilation loop\n    []\n    #{:colon :at} {}\n    (fn [params arg-navigator offsets]\n      (if (:at params)\n        (prn))\n      arg-navigator))\n\n  (\\T\n    [:colnum [1 js/Number] :colinc [1 js/Number]]\n    #{:at :pretty} {}\n    (if (:at params)\n      #(relative-tabulation %1 %2 %3)\n      #(absolute-tabulation %1 %2 %3)))\n\n  (\\*\n    [:n [1 js/Number]]\n    #{:colon :at} {}\n    (fn [params navigator offsets]\n      (let [n (:n params)]\n        (if (:at params)\n          (absolute-reposition navigator n)\n          (relative-reposition navigator (if (:colon params) (- n) n))))))\n\n  (\\?\n    []\n    #{:at} {}\n    (if (:at params)\n      (fn [params navigator offsets]     ; args from main arg list\n        (let [[subformat navigator] (get-format-arg navigator)]\n          (execute-sub-format subformat navigator (:base-args params))))\n      (fn [params navigator offsets]     ; args from sub-list\n        (let [[subformat navigator] (get-format-arg navigator)\n              [subargs navigator] (next-arg navigator)\n              sub-navigator (init-navigator subargs)]\n          (execute-sub-format subformat sub-navigator (:base-args params))\n          navigator))))\n\n  (\\(\n    []\n    #{:colon :at :both} {:right \\), :allows-separator nil, :else nil}\n    (let [mod-case-writer (cond\n                            (and (:at params) (:colon params))\n                            upcase-writer\n\n                            (:colon params)\n                            capitalize-word-writer\n\n                            (:at params)\n                            init-cap-writer\n\n                            :else\n                            downcase-writer)]\n      #(modify-case mod-case-writer %1 %2 %3)))\n\n  (\\) [] #{} {} nil)\n\n  (\\[\n    [:selector [nil js/Number]]\n    #{:colon :at} {:right \\], :allows-separator true, :else :last}\n    (cond\n      (:colon params)\n      boolean-conditional\n\n      (:at params)\n      check-arg-conditional\n\n      true\n      choice-conditional))\n\n  (\\; [:min-remaining [nil js/Number] :max-columns [nil js/Number]]\n    #{:colon} {:separator true} nil)\n\n  (\\] [] #{} {} nil)\n\n  (\\{\n    [:max-iterations [nil js/Number]]\n    #{:colon :at :both} {:right \\}, :allows-separator false}\n    (cond\n      (and (:at params) (:colon params))\n      iterate-main-sublists\n\n      (:colon params)\n      iterate-list-of-sublists\n\n      (:at params)\n      iterate-main-list\n\n      true\n      iterate-sublist))\n\n  (\\} [] #{:colon} {} nil)\n\n  (\\<\n    [:mincol [0 js/Number] :colinc [1 js/Number] :minpad [0 js/Number] :padchar [\\space js/String]]\n    #{:colon :at :both :pretty} {:right \\>, :allows-separator true, :else :first}\n    logical-block-or-justify)\n\n  (\\> [] #{:colon} {} nil)\n\n  ;; TODO: detect errors in cases where colon not allowed\n  (\\^ [:arg1 [nil js/Number] :arg2 [nil js/Number] :arg3 [nil js/Number]]\n    #{:colon} {}\n    (fn [params navigator offsets]\n      (let [arg1 (:arg1 params)\n            arg2 (:arg2 params)\n            arg3 (:arg3 params)\n            exit (if (:colon params) :colon-up-arrow :up-arrow)]\n        (cond\n          (and arg1 arg2 arg3)\n          (if (<= arg1 arg2 arg3) [exit navigator] navigator)\n\n          (and arg1 arg2)\n          (if (= arg1 arg2) [exit navigator] navigator)\n\n          arg1\n          (if (= arg1 0) [exit navigator] navigator)\n\n          true     ; TODO: handle looking up the arglist stack for info\n          (if (if (:colon params)\n                (empty? (:rest (:base-args params)))\n                (empty? (:rest navigator)))\n            [exit navigator] navigator)))))\n\n  (\\W\n    []\n    #{:at :colon :both :pretty} {}\n    (if (or (:at params) (:colon params))\n      (let [bindings (concat\n                       (if (:at params) [:level nil :length nil] [])\n                       (if (:colon params) [:pretty true] []))]\n        (fn [params navigator offsets]\n          (let [[arg navigator] (next-arg navigator)]\n            (if (apply write arg bindings)\n              [:up-arrow navigator]\n              navigator))))\n      (fn [params navigator offsets]\n        (let [[arg navigator] (next-arg navigator)]\n          (if (write-out arg)\n            [:up-arrow navigator]\n            navigator)))))\n\n  (\\_\n    []\n    #{:at :colon :both} {}\n    conditional-newline)\n\n  (\\I\n    [:n [0 js/Number]]\n    #{:colon} {}\n    set-indent)\n  )\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Code to manage the parameters and flags associated with each\n;; directive in the format string.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true}\n     param-pattern #\"^([vV]|#|('.)|([+-]?\\d+)|(?=,))\")\n\n(def ^{:private true}\n     special-params #{:parameter-from-args :remaining-arg-count})\n\n(defn- extract-param [[s offset saw-comma]]\n  (let [m (js/RegExp. (.-source param-pattern) \"g\")\n        param (.exec m s)]\n    (if param\n      (let [token-str (first param)\n            remainder (subs s (.-lastIndex m))\n            new-offset (+ offset (.-lastIndex m))]\n        (if (not (= \\, (nth remainder 0)))\n          [[token-str offset] [remainder new-offset false]]\n          [[token-str offset] [(subs remainder 1) (inc new-offset) true]]))\n      (if saw-comma\n        (format-error \"Badly formed parameters in format directive\" offset)\n        [nil [s offset]]))))\n\n(defn- extract-params [s offset]\n  (consume extract-param [s offset false]))\n\n(defn- translate-param\n  \"Translate the string representation of a param to the internalized\n                                      representation\"\n  [[p offset]]\n  [(cond\n     (= (.-length p) 0) nil\n     (and (= (.-length p) 1) (contains? #{\\v \\V} (nth p 0))) :parameter-from-args\n     (and (= (.-length p) 1) (= \\# (nth p 0))) :remaining-arg-count\n     (and (= (.-length p) 2) (= \\' (nth p 0))) (nth p 1)\n     true (js/parseInt p 10))\n   offset])\n\n(def ^{:private true}\n     flag-defs {\\: :colon, \\@ :at})\n\n(defn- extract-flags [s offset]\n  (consume\n    (fn [[s offset flags]]\n      (if (empty? s)\n        [nil [s offset flags]]\n        (let [flag (get flag-defs (first s))]\n          (if flag\n            (if (contains? flags flag)\n              (format-error\n                (str \"Flag \\\"\" (first s) \"\\\" appears more than once in a directive\")\n                offset)\n              [true [(subs s 1) (inc offset) (assoc flags flag [true offset])]])\n            [nil [s offset flags]]))))\n    [s offset {}]))\n\n(defn- check-flags [def flags]\n  (let [allowed (:flags def)]\n    (if (and (not (:at allowed)) (:at flags))\n      (format-error (str \"\\\"@\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:at flags) 1)))\n    (if (and (not (:colon allowed)) (:colon flags))\n      (format-error (str \"\\\":\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:colon flags) 1)))\n    (if (and (not (:both allowed)) (:at flags) (:colon flags))\n      (format-error (str \"Cannot combine \\\"@\\\" and \\\":\\\" flags for format directive \\\"\"\n                         (:directive def) \"\\\"\")\n                    (min (nth (:colon flags) 1) (nth (:at flags) 1))))))\n\n(defn- map-params\n  \"Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.\"\n  [def params flags offset]\n  (check-flags def flags)\n  (if (> (count params) (count (:params def)))\n    (format-error\n      (cl-format\n        nil\n        \"Too many parameters for directive \\\"~C\\\": ~D~:* ~[were~;was~:;were~] specified but only ~D~:* ~[are~;is~:;are~] allowed\"\n        (:directive def) (count params) (count (:params def)))\n      (second (first params))))\n  (doall\n    (map #(let [val (first %1)]\n           (if (not (or (nil? val) (contains? special-params val)\n                        (= (second (second %2)) (type val))))\n             (format-error (str \"Parameter \" (name (first %2))\n                                \" has bad type in directive \\\"\" (:directive def) \"\\\": \"\n                                (type val))\n                           (second %1))) )\n         params (:params def)))\n\n  (merge                                ; create the result map\n    (into (array-map) ; start with the default values, make sure the order is right\n          (reverse (for [[name [default]] (:params def)] [name [default offset]])))\n    (reduce #(apply assoc %1 %2) {} (filter #(first (nth % 1)) (zipmap (keys (:params def)) params))) ; add the specified parameters, filtering out nils\n    flags)); and finally add the flags\n\n(defn- compile-directive [s offset]\n  (let [[raw-params [rest offset]] (extract-params s offset)\n        [_ [rest offset flags]] (extract-flags rest offset)\n        directive (first rest)\n        def (get directive-table (string/upper-case directive))\n        params (if def (map-params def (map translate-param raw-params) flags offset))]\n    (if (not directive)\n      (format-error \"Format string ended in the middle of a directive\" offset))\n    (if (not def)\n      (format-error (str \"Directive \\\"\" directive \"\\\" is undefined\") offset))\n    [(compiled-directive. ((:generator-fn def) params offset) def params offset)\n     (let [remainder (subs rest 1)\n           offset (inc offset)\n           trim? (and (= \\newline (:directive def))\n                      (not (:colon params)))\n           trim-count (if trim? (prefix-count remainder [\\space \\tab]) 0)\n           remainder (subs remainder trim-count)\n           offset (+ offset trim-count)]\n       [remainder offset])]))\n\n(defn- compile-raw-string [s offset]\n  (compiled-directive. (fn [_ a _] (print s) a) nil {:string s} offset))\n\n(defn- right-bracket [this] (:right (:bracket-info (:def this))))\n\n(defn- separator? [this] (:separator (:bracket-info (:def this))))\n\n(defn- else-separator? [this]\n  (and (:separator (:bracket-info (:def this)))\n       (:colon (:params this))))\n\n(declare ^{:arglists '([bracket-info offset remainder])} collect-clauses)\n\n(defn- process-bracket [this remainder]\n  (let [[subex remainder] (collect-clauses (:bracket-info (:def this))\n                                           (:offset this) remainder)]\n    [(compiled-directive.\n       (:func this) (:def this)\n       (merge (:params this) (tuple-map subex (:offset this)))\n       (:offset this))\n     remainder]))\n\n(defn- process-clause [bracket-info offset remainder]\n  (consume\n    (fn [remainder]\n      (if (empty? remainder)\n        (format-error \"No closing bracket found.\" offset)\n        (let [this (first remainder)\n              remainder (next remainder)]\n          (cond\n            (right-bracket this)\n            (process-bracket this remainder)\n\n            (= (:right bracket-info) (:directive (:def this)))\n            [ nil [:right-bracket (:params this) nil remainder]]\n\n            (else-separator? this)\n            [nil [:else nil (:params this) remainder]]\n\n            (separator? this)\n            [nil [:separator nil nil remainder]] ;; TODO: check to make sure that there are no params on ~;\n\n            true\n            [this remainder]))))\n    remainder))\n\n(defn- collect-clauses [bracket-info offset remainder]\n  (second\n    (consume\n      (fn [[clause-map saw-else remainder]]\n        (let [[clause [type right-params else-params remainder]]\n              (process-clause bracket-info offset remainder)]\n          (cond\n            (= type :right-bracket)\n            [nil [(merge-with concat clause-map\n                              {(if saw-else :else :clauses) [clause]\n                               :right-params right-params})\n                  remainder]]\n\n            (= type :else)\n            (cond\n              (:else clause-map)\n              (format-error \"Two else clauses (\\\"~:;\\\") inside bracket construction.\" offset)\n\n              (not (:else bracket-info))\n              (format-error \"An else clause (\\\"~:;\\\") is in a bracket type that doesn't support it.\"\n                            offset)\n\n              (and (= :first (:else bracket-info)) (seq (:clauses clause-map)))\n              (format-error\n                \"The else clause (\\\"~:;\\\") is only allowed in the first position for this directive.\"\n                offset)\n\n              true         ; if the ~:; is in the last position, the else clause\n              ; is next, this was a regular clause\n              (if (= :first (:else bracket-info))\n                [true [(merge-with concat clause-map {:else [clause] :else-params else-params})\n                       false remainder]]\n                [true [(merge-with concat clause-map {:clauses [clause]})\n                       true remainder]]))\n\n            (= type :separator)\n            (cond\n              saw-else\n              (format-error \"A plain clause (with \\\"~;\\\") follows an else clause (\\\"~:;\\\") inside bracket construction.\" offset)\n\n              (not (:allows-separator bracket-info))\n              (format-error \"A separator (\\\"~;\\\") is in a bracket type that doesn't support it.\"\n                            offset)\n\n              true\n              [true [(merge-with concat clause-map {:clauses [clause]})\n                     false remainder]]))))\n      [{:clauses []} false remainder])))\n\n(defn- process-nesting\n  \"Take a linearly compiled format and process the bracket directives to give it\n   the appropriate tree structure\"\n  [format]\n  (first\n    (consume\n      (fn [remainder]\n        (let [this (first remainder)\n              remainder (next remainder)\n              bracket (:bracket-info (:def this))]\n          (if (:right bracket)\n            (process-bracket this remainder)\n            [this remainder])))\n      format)))\n\n(defn- compile-format\n  \"Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved\nperformance when you're using the same format string repeatedly\"\n  [format-str]\n  (binding [*format-str* format-str]\n    (process-nesting\n      (first\n        (consume\n          (fn [[s offset]]\n            (if (empty? s)\n              [nil s]\n              (let [tilde (.indexOf s \\~)]\n                (cond\n                  (neg? tilde) [(compile-raw-string s offset) [\"\" (+ offset (.-length s))]]\n                  (zero? tilde) (compile-directive (subs s 1) (inc offset))\n                  true\n                  [(compile-raw-string (subs s 0 tilde) offset) [(subs s tilde) (+ tilde offset)]]))))\n          [format-str 0])))))\n\n(defn- needs-pretty\n  \"determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing\"\n  [format]\n  (loop [format format]\n    (if (empty? format)\n      false\n      (if (or (:pretty (:flags (:def (first format))))\n              (some needs-pretty (first (:clauses (:params (first format)))))\n              (some needs-pretty (first (:else (:params (first format))))))\n        true\n        (recur (next format))))))\n\n;;NB We depart from the original api. In clj, if execute-format is called multiple times with the same stream or\n;; called on *out*, the results are different than if the same calls are made with different streams or printing\n;; to a string. The reason is that mutating the underlying stream changes the result by changing spacing.\n;;\n;; clj:\n;;  * stream                       => \"1 2  3\"\n;;  * true (prints to *out*)       => \"1 2  3\"\n;;  * nil (prints to string)       => \"1 2 3\"\n;; cljs:\n;;  * stream                       => \"1 2  3\"\n;;  * true (prints via *print-fn*) => \"1 2 3\"\n;;  * nil (prints to string)       => \"1 2 3\"\n(defn- execute-format\n  \"Executes the format with the arguments.\"\n  {:skip-wiki true}\n  ([stream format args]\n   (let [sb (StringBuffer.)\n         real-stream (if (or (not stream) (true? stream))\n                       (StringBufferWriter. sb)\n                       stream)\n         wrapped-stream (if (and (needs-pretty format)\n                                 (not (pretty-writer? real-stream)))\n                          (get-pretty-writer real-stream)\n                          real-stream)]\n     (binding [*out* wrapped-stream]\n       (try\n         (execute-format format args)\n         (finally\n           (if-not (identical? real-stream wrapped-stream)\n             (-flush wrapped-stream))))\n       (cond\n         (not stream) (str sb)\n         (true? stream) (string-print (str sb))\n         :else nil))))\n  ([format args]\n   (map-passing-context\n     (fn [element context]\n       (if (abort? context)\n         [nil context]\n         (let [[params args] (realize-parameter-list\n                               (:params element) context)\n               [params offsets] (unzip-map params)\n               params (assoc params :base-args args)]\n           [nil (apply (:func element) [params args offsets])])))\n     args\n     format)\n   nil))\n\n;;; This is a bad idea, but it prevents us from leaking private symbols\n;;; This should all be replaced by really compiled formats anyway.\n(def ^{:private true} cached-compile (memoize compile-format))\n\n;;======================================================================\n;; dispatch.clj\n;;======================================================================\n\n(defn- use-method\n  \"Installs a function as a new method of multimethod associated with dispatch-value. \"\n  [multifn dispatch-val func]\n  (-add-method multifn dispatch-val func))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Implementations of specific dispatch table entries\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Handle forms that can be \"back-translated\" to reader macros\n;;; Not all reader macros can be dealt with this way or at all.\n;;; Macros that we can't deal with at all are:\n;;; ;  - The comment character is absorbed by the reader and never is part of the form\n;;; `  - Is fully processed at read time into a lisp expression (which will contain concats\n;;;      and regular quotes).\n;;; ~@ - Also fully eaten by the processing of ` and can't be used outside.\n;;; ,  - is whitespace and is lost (like all other whitespace). Formats can generate commas\n;;;      where they deem them useful to help readability.\n;;; ^  - Adding metadata completely disappears at read time and the data appears to be\n;;;      completely lost.\n;;;\n;;; Most other syntax stuff is dealt with directly by the formats (like (), [], {}, and #{})\n;;; or directly by printing the objects using Clojure's built-in print functions (like\n;;; :keyword, \\char, or \"\"). The notable exception is #() which is special-cased.\n\n(def ^{:private true} reader-macros\n  {'quote \"'\"\n   'var \"#'\"\n   'clojure.core/deref \"@\",\n   'clojure.core/unquote \"~\"\n   'cljs.core/deref \"@\",\n   'cljs.core/unquote \"~\"})\n\n(defn- pprint-reader-macro [alis]\n  (let [macro-char (reader-macros (first alis))]\n    (when (and macro-char (= 2 (count alis)))\n      (-write *out* macro-char)\n      (write-out (second alis))\n      true)))\n\n;;======================================================================\n;; Dispatch for the basic data types when interpreted\n;; as data (as opposed to code).\n;;======================================================================\n\n;;; TODO: inline these formatter statements into funcs so that we\n;;; are a little easier on the stack. (Or, do \"real\" compilation, a\n;;; la Common Lisp)\n\n;;; (def pprint-simple-list (formatter-out \"~:<~@{~w~^ ~_~}~:>\"))\n(defn- pprint-simple-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (print-length-loop [alis (seq alis)]\n      (when alis\n        (write-out (first alis))\n        (when (next alis)\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next alis)))))))\n\n(defn- pprint-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (pprint-simple-list alis)))\n\n;;; (def pprint-vector (formatter-out \"~<[~;~@{~w~^ ~_~}~;]~:>\"))\n(defn- pprint-vector [avec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [aseq (seq avec)]\n      (when aseq\n        (write-out (first aseq))\n        (when (next aseq)\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next aseq)))))))\n\n(def ^{:private true} pprint-array (formatter-out \"~<[~;~@{~w~^, ~:_~}~;]~:>\"))\n\n;;; (def pprint-map (formatter-out \"~<{~;~@{~<~w~^ ~_~w~:>~^, ~_~}~;}~:>\"))\n(defn- pprint-map [amap]\n  (let [[ns lift-map] (when (not (record? amap))\n                            (#'cljs.core/lift-ns amap))\n        amap (or lift-map amap)\n        prefix (if ns (str \"#:\" ns \"{\") \"{\")]\n    (pprint-logical-block :prefix prefix :suffix \"}\"\n      (print-length-loop [aseq (seq amap)]\n        (when aseq\n          ;;compiler gets confused with nested macro if it isn't namespaced\n          ;;it tries to use clojure.pprint/pprint-logical-block for some reason\n          (m/pprint-logical-block\n            (write-out (ffirst aseq))\n            (-write *out* \" \")\n            (pprint-newline :linear)\n            (set! *current-length* 0)   ;always print both parts of the [k v] pair\n            (write-out (fnext (first aseq))))\n          (when (next aseq)\n            (-write *out* \", \")\n            (pprint-newline :linear)\n            (recur (next aseq))))))))\n\n(defn- pprint-simple-default [obj]\n  ;;TODO: Update to handle arrays (?) and suppressing namespaces\n  (-write *out* (pr-str obj)))\n\n(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))\n\n(def ^{:private true}\ntype-map {\"core$future_call\" \"Future\",\n          \"core$promise\" \"Promise\"})\n\n(defn- map-ref-type\n  \"Map ugly type names to something simpler\"\n  [name]\n  (or (when-let [match (re-find #\"^[^$]+\\$[^$]+\" name)]\n        (type-map match))\n    name))\n\n(defn- pprint-ideref [o]\n  (let [prefix (str \"#<\" (map-ref-type (.-name (type o)))\n                    \"@\" (goog/getUid o) \": \")]\n    (pprint-logical-block  :prefix prefix :suffix \">\"\n      (pprint-indent :block (-> (count prefix) (- 2) -))\n      (pprint-newline :linear)\n      (write-out\n        (if (and (satisfies? IPending o) (not (-realized? o)))\n          :not-delivered\n          @o)))))\n\n(def ^{:private true} pprint-pqueue (formatter-out \"~<<-(~;~@{~w~^ ~_~}~;)-<~:>\"))\n\n(defn- type-dispatcher [obj]\n  (cond\n    (instance? PersistentQueue obj) :queue\n    (satisfies? IDeref obj) :deref\n    (symbol? obj) :symbol\n    (seq? obj) :list\n    (map? obj) :map\n    (vector? obj) :vector\n    (set? obj) :set\n    (nil? obj) nil\n    :default :default))\n\n(defmulti simple-dispatch\n  \"The pretty print dispatch function for simple data structure format.\"\n  type-dispatcher)\n\n(use-method simple-dispatch :list pprint-list)\n(use-method simple-dispatch :vector pprint-vector)\n(use-method simple-dispatch :map pprint-map)\n(use-method simple-dispatch :set pprint-set)\n(use-method simple-dispatch nil #(-write *out* (pr-str nil)))\n(use-method simple-dispatch :default pprint-simple-default)\n\n(set-pprint-dispatch simple-dispatch)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Dispatch for the code table\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^{:arglists '([alis])} pprint-simple-code-list)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format the namespace (\"ns\") macro. This is quite complicated because of all the\n;;; different forms supported and because programmers can choose lists or vectors\n;;; in various places.\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- brackets\n  \"Figure out which kind of brackets to use\"\n  [form]\n  (if (vector? form)\n    [\"[\" \"]\"]\n    [\"(\" \")\"]))\n\n(defn- pprint-ns-reference\n  \"Pretty print a single reference (import, use, etc.) from a namespace decl\"\n  [reference]\n  (if (sequential? reference)\n    (let [[start end] (brackets reference)\n          [keyw & args] reference]\n      (pprint-logical-block :prefix start :suffix end\n        ((formatter-out \"~w~:i\") keyw)\n        (loop [args args]\n          (when (seq args)\n            ((formatter-out \" \"))\n            (let [arg (first args)]\n              (if (sequential? arg)\n                (let [[start end] (brackets arg)]\n                  (pprint-logical-block :prefix start :suffix end\n                    (if (and (= (count arg) 3) (keyword? (second arg)))\n                      (let [[ns kw lis] arg]\n                        ((formatter-out \"~w ~w \") ns kw)\n                        (if (sequential? lis)\n                          ((formatter-out (if (vector? lis)\n                                            \"~<[~;~@{~w~^ ~:_~}~;]~:>\"\n                                            \"~<(~;~@{~w~^ ~:_~}~;)~:>\"))\n                            lis)\n                          (write-out lis)))\n                      (apply (formatter-out \"~w ~:i~@{~w~^ ~:_~}\") arg)))\n                  (when (next args)\n                    ((formatter-out \"~_\"))))\n                (do\n                  (write-out arg)\n                  (when (next args)\n                    ((formatter-out \"~:_\"))))))\n            (recur (next args))))))\n    (write-out reference)))\n\n(defn- pprint-ns\n  \"The pretty print dispatch chunk for the ns macro\"\n  [alis]\n  (if (next alis)\n    (let [[ns-sym ns-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map references] (if (map? (first stuff))\n                                  [(first stuff) (next stuff)]\n                                  [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") ns-sym ns-name)\n        (when (or doc-str attr-map (seq references))\n          ((formatter-out \"~@:_\")))\n        (when doc-str\n          (cl-format true \"\\\"~a\\\"~:[~;~:@_~]\" doc-str (or attr-map (seq references))))\n        (when attr-map\n          ((formatter-out \"~w~:[~;~:@_~]\") attr-map (seq references)))\n        (loop [references references]\n          (pprint-ns-reference (first references))\n          (when-let [references (next references)]\n            (pprint-newline :linear)\n            (recur references)))))\n    (write-out alis)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something that looks like a simple def (sans metadata, since the reader\n;;; won't give it to us now).\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true} pprint-hold-first (formatter-out \"~:<~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:>\"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something that looks like a defn or defmacro\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; Format the params and body of a defn with a single arity\n(defn- single-defn [alis has-doc-str?]\n  (if (seq alis)\n    (do\n      (if has-doc-str?\n        ((formatter-out \" ~_\"))\n        ((formatter-out \" ~@_\")))\n      ((formatter-out \"~{~w~^ ~_~}\") alis))))\n\n;;; Format the param and body sublists of a defn with multiple arities\n(defn- multi-defn [alis has-doc-str?]\n  (if (seq alis)\n    ((formatter-out \" ~_~{~w~^ ~_~}\") alis)))\n\n;;; TODO: figure out how to support capturing metadata in defns (we might need a\n;;; special reader)\n(defn- pprint-defn [alis]\n  (if (next alis)\n    (let [[defn-sym defn-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map stuff] (if (map? (first stuff))\n                             [(first stuff) (next stuff)]\n                             [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") defn-sym defn-name)\n        (if doc-str\n          ((formatter-out \" ~_~w\") doc-str))\n        (if attr-map\n          ((formatter-out \" ~_~w\") attr-map))\n        ;; Note: the multi-defn case will work OK for malformed defns too\n        (cond\n          (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n          :else (multi-defn stuff (or doc-str attr-map)))))\n    (pprint-simple-code-list alis)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something with a binding form\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- pprint-binding-form [binding-vec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [binding binding-vec]\n      (when (seq binding)\n        (pprint-logical-block binding\n          (write-out (first binding))\n          (when (next binding)\n            (-write *out* \" \")\n            (pprint-newline :miser)\n            (write-out (second binding))))\n        (when (next (rest binding))\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next (rest binding))))))))\n\n(defn- pprint-let [alis]\n  (let [base-sym (first alis)]\n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (if (and (next alis) (vector? (second alis)))\n        (do\n          ((formatter-out \"~w ~1I~@_\") base-sym)\n          (pprint-binding-form (second alis))\n          ((formatter-out \" ~_~{~w~^ ~_~}\") (next (rest alis))))\n        (pprint-simple-code-list alis)))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Format something that looks like \"if\"\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^{:private true} pprint-if (formatter-out \"~:<~1I~w~^ ~@_~w~@{ ~_~w~}~:>\"))\n\n(defn- pprint-cond [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (write-out (first alis))\n    (when (next alis)\n      (-write *out* \" \")\n      (pprint-newline :linear)\n      (print-length-loop [alis (next alis)]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (-write *out* \" \")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (-write *out* \" \")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))))\n\n(defn- pprint-condp [alis]\n  (if (> (count alis) 3)\n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (pprint-indent :block 1)\n      (apply (formatter-out \"~w ~@_~w ~@_~w ~_\") alis)\n      (print-length-loop [alis (seq (drop 3 alis))]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (-write *out* \" \")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (-write *out* \" \")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))\n    (pprint-simple-code-list alis)))\n\n;;; The map of symbols that are defined in an enclosing #() anonymous function\n(def ^:dynamic ^{:private true} *symbol-map* {})\n\n(defn- pprint-anon-func [alis]\n  (let [args (second alis)\n        nlis (first (rest (rest alis)))]\n    (if (vector? args)\n      (binding [*symbol-map* (if (= 1 (count args))\n                               {(first args) \"%\"}\n                               (into {}\n                                 (map\n                                   #(vector %1 (str \\% %2))\n                                   args\n                                   (range 1 (inc (count args))))))]\n        ((formatter-out \"~<#(~;~@{~w~^ ~_~}~;)~:>\") nlis))\n      (pprint-simple-code-list alis))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; The master definitions for formatting lists in code (that is, (fn args...) or\n;;; special forms).\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;;; This is the equivalent of (formatter-out \"~:<~1I~@{~w~^ ~_~}~:>\"), but is\n;;; easier on the stack.\n\n(defn- pprint-simple-code-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (print-length-loop [alis (seq alis)]\n      (when alis\n        (write-out (first alis))\n        (when (next alis)\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next alis)))))))\n\n;;; Take a map with symbols as keys and add versions with no namespace.\n;;; That is, if ns/sym->val is in the map, add sym->val to the result.\n(defn- two-forms [amap]\n  (into {}\n    (mapcat\n      identity\n      (for [x amap]\n        [x [(symbol (name (first x))) (second x)]]))))\n\n(defn- add-core-ns [amap]\n  (let [core \"clojure.core\"]\n    (into {}\n      (map #(let [[s f] %]\n             (if (not (or (namespace s) (special-symbol? s)))\n               [(symbol core (name s)) f]\n               %))\n        amap))))\n\n(def ^:dynamic ^{:private true} *code-table*\n  (two-forms\n    (add-core-ns\n      {'def pprint-hold-first, 'defonce pprint-hold-first,\n       'defn pprint-defn, 'defn- pprint-defn, 'defmacro pprint-defn, 'fn pprint-defn,\n       'let pprint-let, 'loop pprint-let, 'binding pprint-let,\n       'with-local-vars pprint-let, 'with-open pprint-let, 'when-let pprint-let,\n       'if-let pprint-let, 'doseq pprint-let, 'dotimes pprint-let,\n       'when-first pprint-let,\n       'if pprint-if, 'if-not pprint-if, 'when pprint-if, 'when-not pprint-if,\n       'cond pprint-cond, 'condp pprint-condp,\n       'fn* pprint-anon-func,\n       '. pprint-hold-first, '.. pprint-hold-first, '-> pprint-hold-first,\n       'locking pprint-hold-first, 'struct pprint-hold-first,\n       'struct-map pprint-hold-first, 'ns pprint-ns\n       })))\n\n(defn- pprint-code-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (if-let [special-form (*code-table* (first alis))]\n      (special-form alis)\n      (pprint-simple-code-list alis))))\n\n(defn- pprint-code-symbol [sym]\n  (if-let [arg-num (sym *symbol-map*)]\n    (print arg-num)\n    (if *print-suppress-namespaces*\n      (print (name sym))\n      (pr sym))))\n\n(defmulti\n  code-dispatch\n  \"The pretty print dispatch function for pretty printing Clojure code.\"\n  {:added \"1.2\" :arglists '[[object]]}\n  type-dispatcher)\n\n(use-method code-dispatch :list pprint-code-list)\n(use-method code-dispatch :symbol pprint-code-symbol)\n\n;; The following are all exact copies of simple-dispatch\n(use-method code-dispatch :vector pprint-vector)\n(use-method code-dispatch :map pprint-map)\n(use-method code-dispatch :set pprint-set)\n(use-method code-dispatch :queue pprint-pqueue)\n(use-method code-dispatch :deref pprint-ideref)\n(use-method code-dispatch nil pr)\n(use-method code-dispatch :default pprint-simple-default)\n\n(set-pprint-dispatch simple-dispatch)\n\n;;; For testing\n(comment\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      '(defn cl-format\n         \"An implementation of a Common Lisp compatible format function\"\n         [stream format-in & args]\n         (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n               navigator (init-navigator args)]\n           (execute-format stream compiled-format navigator)))))\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      '(defn cl-format\n         [stream format-in & args]\n         (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n               navigator (init-navigator args)]\n           (execute-format stream compiled-format navigator)))))\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      '(defn- -write\n         ([this x]\n          (condp = (class x)\n            String\n            (let [s0 (write-initial-lines this x)\n                  s (.replaceFirst s0 \"\\\\s+$\" \"\")\n                  white-space (.substring s0 (count s))\n                  mode (getf :mode)]\n              (if (= mode :writing)\n                (dosync\n                  (write-white-space this)\n                  (.col_write this s)\n                  (setf :trailing-white-space white-space))\n                (add-to-buffer this (make-buffer-blob s white-space))))\n\n            Integer\n            (let [c ^Character x]\n              (if (= (getf :mode) :writing)\n                (do\n                  (write-white-space this)\n                  (.col_write this x))\n                (if (= c (int \\newline))\n                  (write-initial-lines this \"\\n\")\n                  (add-to-buffer this (make-buffer-blob (str (char c)) nil))))))))))\n\n  (with-pprint-dispatch code-dispatch\n    (pprint\n      '(defn pprint-defn [writer alis]\n         (if (next alis)\n           (let [[defn-sym defn-name & stuff] alis\n                 [doc-str stuff] (if (string? (first stuff))\n                                   [(first stuff) (next stuff)]\n                                   [nil stuff])\n                 [attr-map stuff] (if (map? (first stuff))\n                                    [(first stuff) (next stuff)]\n                                    [nil stuff])]\n             (pprint-logical-block writer :prefix \"(\" :suffix \")\"\n               (cl-format true \"~w ~1I~@_~w\" defn-sym defn-name)\n               (if doc-str\n                 (cl-format true \" ~_~w\" doc-str))\n               (if attr-map\n                 (cl-format true \" ~_~w\" attr-map))\n               ;; Note: the multi-defn case will work OK for malformed defns too\n               (cond\n                 (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n                 :else (multi-defn stuff (or doc-str attr-map)))))\n           (pprint-simple-code-list writer alis)))))\n  )\n\n;;======================================================================\n;; print_table.clj\n;;======================================================================\n\n(defn- add-padding [width s]\n  (let [padding (max 0 (- width (count s)))]\n    (apply str (clojure.string/join (repeat padding \\space)) s)))\n\n(defn print-table\n  \"Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n  {:added \"1.3\"}\n  ([ks rows]\n   (when (seq rows)\n     (let [widths  (map\n                     (fn [k]\n                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                     ks)\n           spacers (map #(apply str (repeat % \"-\")) widths)\n           fmt-row (fn [leader divider trailer row]\n                     (str leader\n                       (apply str (interpose divider\n                                    (for [[col width] (map vector (map #(get row %) ks) widths)]\n                                      (add-padding width (str col)))))\n                       trailer))]\n       (cljs.core/println)\n       (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n       (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n       (doseq [row rows]\n         (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row))))))\n  ([rows] (print-table (keys (first rows)) rows)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/data.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.data",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns \n  ^{:author \"Stuart Halloway\",\n    :doc \"Non-core data functions.\"}\n  clojure.data\n  (:require [clojure.set :as set]))\n\n(declare diff)\n\n(defn- atom-diff\n  \"Internal helper for diff.\"\n  [a b]\n  (if (= a b) [nil nil a] [a b nil]))\n\n;; for big things a sparse vector class would be better\n(defn- vectorize\n  \"Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys\"\n  [m]\n  (when (seq m)\n    (reduce\n     (fn [result [k v]] (assoc result k v))\n     (vec (repeat (apply max (keys m))  nil))\n     m)))\n\n(defn- diff-associative-key\n  \"Diff associative things a and b, comparing only the key k.\"\n  [a b k]\n  (let [va (get a k)\n        vb (get b k)\n        [a* b* ab] (diff va vb)\n        in-a (contains? a k)\n        in-b (contains? b k)\n        same (and in-a in-b\n                  (or (not (nil? ab))\n                      (and (nil? va) (nil? vb))))]\n    [(when (and in-a (or (not (nil? a*)) (not same))) {k a*})\n     (when (and in-b (or (not (nil? b*)) (not same))) {k b*})\n     (when same {k ab})\n     ]))\n\n(defn- diff-associative\n  \"Diff associative things a and b, comparing only keys in ks.\"\n  [a b ks]\n  (reduce\n   (fn [diff1 diff2]\n     (doall (map merge diff1 diff2)))\n   [nil nil nil]\n   (map\n    (partial diff-associative-key a b)\n    ks)))\n\n(defn- diff-sequential\n  [a b]\n  (vec (map vectorize (diff-associative\n                       (if (vector? a) a (vec a))\n                       (if (vector? b) b (vec b))\n                       (range (max (count a) (count b)))))))\n\n(defprotocol ^{:added \"1.3\"} EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (^{:added \"1.3\"} equality-partition [x] \"Implementation detail. Subject to change.\"))\n\n(defprotocol ^{:added \"1.3\"} Diff\n  \"Implementation detail. Subject to change.\"\n  (^{:added \"1.3\"} diff-similar [a b] \"Implementation detail. Subject to change.\"))\n\n(extend nil\n        Diff\n        {:diff-similar atom-diff})\n\n(extend Object\n        Diff\n        {:diff-similar (fn [a b] ((if (.. a getClass isArray) diff-sequential atom-diff) a b))}\n        EqualityPartition\n        {:equality-partition (fn [x] (if (.. x getClass isArray) :sequential :atom))})\n\n(extend-protocol EqualityPartition\n  nil\n  (equality-partition [x] :atom)\n  \n  java.util.Set\n  (equality-partition [x] :set)\n\n  java.util.List\n  (equality-partition [x] :sequential)\n  \n  java.util.Map\n  (equality-partition [x] :map))\n\n(defn- as-set-value\n  [s]\n  (if (set? s) s (into #{} s)))\n\n(extend-protocol Diff\n  java.util.Set\n  (diff-similar\n   [a b]\n   (let [aval (as-set-value a)\n         bval (as-set-value b)]\n     [(not-empty (set/difference aval bval))\n      (not-empty (set/difference bval aval))\n      (not-empty (set/intersection aval bval))]))\n  \n  java.util.List\n  (diff-similar [a b]\n    (diff-sequential a b))\n  \n  java.util.Map\n  (diff-similar [a b]\n    (diff-associative a b (set/union (keys a) (keys b)))))\n\n(defn diff\n  \"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.\"\n  {:added \"1.3\"}\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))\n  \n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/js.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.js",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.js\n  (:require [cljs.env :as env]\n            [cljs.env.macros :as menv]\n            [cljs.analyzer :as ana]\n            [clojure.java.io :as io]))\n\n(defmacro with-state\n  [state & body]\n  `(menv/with-compiler-env ~state\n     ~@body))\n\n(defmacro dump-core []\n  (let [state @env/*compiler*]\n    (if-not (false? (get-in state [:options :dump-core]))\n      `(quote ~(get-in state [::ana/namespaces 'cljs.core]))\n      `(hash-map))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/zip.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.zip",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;functional hierarchical zipper, with navigation, editing and enumeration\n;see Huet\n\n(ns ^{:doc \"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet\"\n       :author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))\n\n(defn zipper\n  \"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.\"\n  {:added \"1.0\"}\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])\n\n(defn seq-zip\n  \"Returns a zipper for nested sequences, given a root sequence\"\n  {:added \"1.0\"}\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))\n\n(defn vector-zip\n  \"Returns a zipper for nested vectors, given a root vector\"\n  {:added \"1.0\"}\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))\n\n(defn xml-zip\n  \"Returns a zipper for xml elements (as from xml/parse),\n  given a root element\"\n  {:added \"1.0\"}\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))\n\n(defn node\n  \"Returns the node at loc\"\n  {:added \"1.0\"}\n  [loc] (loc 0))\n\n(defn branch?\n  \"Returns true if the node at loc is a branch\"\n  {:added \"1.0\"}\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))\n\n(defn children\n  \"Returns a seq of the children of node at loc, which must be a branch\"\n  {:added \"1.0\"}\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw (Exception. \"called children on a leaf node\"))))\n\n(defn make-node\n  \"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.\"\n  {:added \"1.0\"}\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))\n\n(defn path\n  \"Returns a seq of nodes leading to this loc\"\n  {:added \"1.0\"}\n  [loc]\n    (:pnodes (loc 1)))\n\n(defn lefts\n  \"Returns a seq of the left siblings of this loc\"\n  {:added \"1.0\"}\n  [loc]\n    (seq (:l (loc 1))))\n\n(defn rights\n  \"Returns a seq of the right siblings of this loc\"\n  {:added \"1.0\"}\n  [loc]\n    (:r (loc 1)))\n\n\n(defn down\n  \"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children\"\n  {:added \"1.0\"}\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))\n\n(defn up\n  \"Returns the loc of the parent of the node at this loc, or nil if at\n  the top\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))\n\n(defn root\n  \"zips all the way up and returns the root node, reflecting any\n changes.\"\n  {:added \"1.0\"}\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))\n\n(defn right\n  \"Returns the loc of the right sibling of the node at this loc, or nil\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))\n\n(defn rightmost\n  \"Returns the loc of the rightmost sibling of the node at this loc, or self\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))\n\n(defn left\n  \"Returns the loc of the left sibling of the node at this loc, or nil\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))\n\n(defn leftmost\n  \"Returns the loc of the leftmost sibling of the node at this loc, or self\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))\n\n(defn insert-left\n  \"Inserts the item as the left sibling of the node at this loc,\n without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception \"Insert at top\"))\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))\n\n(defn insert-right\n  \"Inserts the item as the right sibling of the node at this loc,\n  without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception \"Insert at top\"))\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))\n\n(defn replace\n  \"Replaces the node at this loc, without moving\"\n  {:added \"1.0\"}\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))\n\n(defn edit\n  \"Replaces the node at this loc with the value of (f node args)\"\n  {:added \"1.0\"}\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))\n\n(defn insert-child\n  \"Inserts the item as the leftmost child of the node at this loc,\n  without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))\n\n(defn append-child\n  \"Inserts the item as the rightmost child of the node at this loc,\n  without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))\n\n(defn next\n  \"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.\"\n  {:added \"1.0\"}\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))\n\n(defn prev\n  \"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.\"\n  {:added \"1.0\"}\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))\n\n(defn end?\n  \"Returns true if loc represents the end of a depth-first walk\"\n  {:added \"1.0\"}\n  [loc]\n    (= :end (loc 1)))\n\n(defn remove\n  \"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception \"Remove at top\"))\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))\n  \n(comment\n\n(load-file \"/Users/rich/dev/clojure/src/zip.clj\")\n(refer 'zip)\n(def data '[[a * b] + [c * d]])\n(def dz (vector-zip data))\n\n(right (down (right (right (down dz)))))\n(lefts (right (down (right (right (down dz))))))\n(rights (right (down (right (right (down dz))))))\n(up (up (right (down (right (right (down dz)))))))\n(path (right (down (right (right (down dz))))))\n\n(-> dz down right right down right)\n(-> dz down right right down right (replace '/) root)\n(-> dz next next (edit str) next next next (replace '/) root)\n(-> dz next next next next next next next next next remove root)\n(-> dz next next next next next next next next next remove (insert-right 'e) root)\n(-> dz next next next next next next next next next remove up (append-child 'e) root)\n\n(end? (-> dz next next next next next next next next next remove next))\n\n(-> dz next remove next remove root)\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (= '* (node loc)) \n                   (replace loc '/)\n                   loc)))))\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (= '* (node loc)) \n                   (remove loc)\n                   loc)))))\n)\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/analyzer/macros.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.analyzer.macros",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.analyzer.macros\n  (:refer-clojure :exclude [binding]))\n\n(defmacro with-warning-handlers [handlers & body]\n  `(cljs.core/binding [cljs.analyzer/*cljs-warning-handlers* ~handlers]\n     ~@body))\n\n(defmacro no-warn [& body]\n  `(cljs.core/binding [cljs.analyzer/*cljs-warnings*\n                       (zipmap (keys cljs.analyzer/*cljs-warnings*) (repeat false))]\n     ~@body))\n\n(defmacro with-core-macros\n  [path & body]\n  `(do\n     (when (not= cljs.analyzer/*cljs-macros-path* ~path)\n       (reset! cljs.analyzer/-cljs-macros-loaded false))\n     (cljs.core/binding [cljs.analyzer/*cljs-macros-path* ~path]\n       ~@body)))\n\n(defmacro with-core-macros-file\n  [path & body]\n  `(do\n     (when (not= cljs.analyzer/*cljs-macros-path* ~path)\n       (reset! cljs.analyzer/-cljs-macros-loaded false))\n     (cljs.core/binding [cljs.analyzer/*cljs-macros-path* ~path\n                         cljs.analyzer/*cljs-macros-is-classpath* false]\n       ~@body)))\n\n(defmacro wrapping-errors [env & body]\n  `(try\n     ~@body\n     (catch :default err#\n       (cond\n         (cljs.analyzer/has-error-data? err#) (throw err#)\n         (cljs.analyzer/analysis-error? err#) (throw (ex-info nil (cljs.analyzer/error-data ~env :compilation) err#))\n         :else (throw (ex-info nil (cljs.analyzer/error-data ~env :compilation) (cljs.analyzer/error ~env (.-message err#) err#)))))))\n\n(defmacro disallowing-recur [& body]\n  `(cljs.core/binding [cljs.analyzer/*recur-frames*\n                       (cons nil cljs.analyzer/*recur-frames*)]\n     ~@body))\n\n(defmacro allowing-redef [& body]\n  `(cljs.core/binding [cljs.analyzer/*allow-redef* true]\n     ~@body))\n\n(defmacro disallowing-ns* [& body]\n  `(cljs.core/binding [cljs.analyzer/*allow-ns* false] ~@body))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/string.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.string",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility.\"\n      :author \"Stuart Sierra, Stuart Halloway, David Liebke\"}\n  clojure.string\n  (:refer-clojure :exclude (replace reverse))\n  (:import (java.util.regex Pattern Matcher)\n           clojure.lang.LazilyPersistentVector))\n\n(set! *warn-on-reflection* true)\n\n(defn ^String reverse\n  \"Returns s with its characters reversed.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.toString (.reverse (StringBuilder. s))))\n\n(defn ^String re-quote-replacement\n  \"Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.\"\n  {:added \"1.5\"}\n  [^CharSequence replacement]\n  (Matcher/quoteReplacement (.toString ^CharSequence replacement)))\n\n(defn- replace-by\n  [^CharSequence s re f]\n  (let [m (re-matcher re s)]\n    (if (.find m)\n      (let [buffer (StringBuffer. (.length s))]\n        (loop [found true]\n          (if found\n            (do (.appendReplacement m buffer (Matcher/quoteReplacement (f (re-groups m))))\n                (recur (.find m)))\n            (do (.appendTail m buffer)\n                (.toString buffer)))))\n      s)))\n\n(defn ^String replace\n  \"Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \\\"Almost Pig Latin\\\" #\\\"\\\\b(\\\\w)(\\\\w+)\\\\b\\\" \\\"$2$1ay\\\")\n   -> \\\"lmostAay igPay atinLay\\\"\"\n  {:added \"1.2\"}\n  [^CharSequence s match replacement]\n  (let [s (.toString s)]\n    (cond \n     (instance? Character match) (.replace s ^Character match ^Character replacement)\n     (instance? CharSequence match) (.replace s ^CharSequence match ^CharSequence replacement)\n     (instance? Pattern match) (if (instance? CharSequence replacement)\n                                 (.replaceAll (re-matcher ^Pattern match s)\n                                              (.toString ^CharSequence replacement))\n                                 (replace-by s match replacement))\n     :else (throw (IllegalArgumentException. (str \"Invalid match arg: \" match))))))\n\n(defn- replace-first-by\n  [^CharSequence s ^Pattern re f]\n  (let [m (re-matcher re s)]\n    (if (.find m)\n      (let [buffer (StringBuffer. (.length s))\n            rep (Matcher/quoteReplacement (f (re-groups m)))]\n        (.appendReplacement m buffer rep)\n        (.appendTail m buffer)\n        (str buffer))\n      s)))\n\n(defn- replace-first-char\n  [^CharSequence s ^Character match replace]\n  (let [s (.toString s)\n        i (.indexOf s (int match))]\n    (if (= -1 i)\n      s\n      (str (subs s 0 i) replace (subs s (inc i))))))\n\n(defn- replace-first-str\n  [^CharSequence s ^String match ^String replace]\n  (let [^String s (.toString s)\n        i (.indexOf s match)]\n    (if (= -1 i)\n      s\n      (str (subs s 0 i) replace (subs s (+ i (.length match)))))))\n\n(defn ^String replace-first\n  \"Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \\\"swap first two words\\\"\n                                 #\\\"(\\\\w+)(\\\\s+)(\\\\w+)\\\" \\\"$3$2$1\\\")\n   -> \\\"first swap two words\\\"\"\n  {:added \"1.2\"}\n  [^CharSequence s match replacement]\n  (let [s (.toString s)]\n    (cond\n     (instance? Character match)\n     (replace-first-char s match replacement)\n     (instance? CharSequence match)\n     (replace-first-str s (.toString ^CharSequence match)\n                        (.toString ^CharSequence replacement))\n     (instance? Pattern match)\n     (if (instance? CharSequence replacement)\n       (.replaceFirst (re-matcher ^Pattern match s)\n                      (.toString ^CharSequence replacement))\n       (replace-first-by s match replacement))\n     :else (throw (IllegalArgumentException. (str \"Invalid match arg: \" match))))))\n\n\n(defn ^String join\n  \"Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.\"\n  {:added \"1.2\"}\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (loop [sb (StringBuilder. (str (first coll)))\n            more (next coll)\n            sep (str separator)]\n       (if more\n         (recur (-> sb (.append sep) (.append (str (first more))))\n                (next more)\n                sep)\n         (str sb)))))\n\n(defn ^String capitalize\n  \"Converts first character of the string to upper-case, all other\n  characters to lower-case.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (let [s (.toString s)]\n    (if (< (count s) 2)\n      (.toUpperCase s)\n      (str (.toUpperCase (subs s 0 1))\n           (.toLowerCase (subs s 1))))))\n\n(defn ^String upper-case\n  \"Converts string to all upper-case.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.. s toString toUpperCase))\n\n(defn ^String lower-case\n  \"Converts string to all lower-case.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.. s toString toLowerCase))\n\n(defn split\n  \"Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n  {:added \"1.2\"}\n  ([^CharSequence s ^Pattern re]\n     (LazilyPersistentVector/createOwning (.split re s)))\n  ([ ^CharSequence s ^Pattern re limit]\n     (LazilyPersistentVector/createOwning (.split re s limit))))\n\n(defn split-lines\n  \"Splits s on \\\\n or \\\\r\\\\n.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (split s #\"\\r?\\n\"))\n\n(defn ^String trim\n  \"Removes whitespace from both ends of string.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (let [len (.length s)]\n    (loop [rindex len]\n      (if (zero? rindex)\n        \"\"\n        (if (Character/isWhitespace (.charAt s (dec rindex)))\n          (recur (dec rindex))\n          ;; there is at least one non-whitespace char in the string,\n          ;; so no need to check for lindex reaching len.\n          (loop [lindex 0]\n            (if (Character/isWhitespace (.charAt s lindex))\n              (recur (inc lindex))\n              (.. s (subSequence lindex rindex) toString))))))))\n\n(defn ^String triml\n  \"Removes whitespace from the left side of string.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (let [len (.length s)]\n    (loop [index 0]\n      (if (= len index)\n        \"\"\n        (if (Character/isWhitespace (.charAt s index))\n          (recur (unchecked-inc index))\n          (.. s (subSequence index len) toString))))))\n\n(defn ^String trimr\n  \"Removes whitespace from the right side of string.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (loop [index (.length s)]\n    (if (zero? index)\n      \"\"\n      (if (Character/isWhitespace (.charAt s (unchecked-dec index)))\n        (recur (unchecked-dec index))\n        (.. s (subSequence 0 index) toString)))))\n\n(defn ^String trim-newline\n  \"Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl's chomp.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (loop [index (.length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (.charAt s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.. s (subSequence 0 index) toString))))))\n\n(defn blank?\n  \"True if s is nil, empty, or contains only whitespace.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (if s\n    (loop [index (int 0)]\n      (if (= (.length s) index)\n        true\n        (if (Character/isWhitespace (.charAt s index))\n          (recur (inc index))\n          false)))\n    true))\n\n(defn ^String escape\n  \"Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n  {:added \"1.2\"}\n  [^CharSequence s cmap]\n  (loop [index (int 0)\n         buffer (StringBuilder. (.length s))]\n    (if (= (.length s) index)\n      (.toString buffer)\n      (let [ch (.charAt s index)]\n        (if-let [replacement (cmap ch)]\n          (.append buffer replacement)\n          (.append buffer ch))\n        (recur (inc index) buffer)))))\n\n(defn index-of\n  \"Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.\"\n  {:added \"1.8\"}\n  ([^CharSequence s value]\n  (let [result ^long\n        (if (instance? Character value)\n          (.indexOf (.toString s) ^int (.charValue ^Character value))\n          (.indexOf (.toString s) ^String value))]\n    (if (= result -1)\n      nil\n      result)))\n  ([^CharSequence s value ^long from-index]\n  (let [result ^long\n        (if (instance? Character value)\n          (.indexOf (.toString s) ^int (.charValue ^Character value) (unchecked-int from-index))\n          (.indexOf (.toString s) ^String value (unchecked-int from-index)))]\n    (if (= result -1)\n      nil\n      result))))\n\n(defn last-index-of\n  \"Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.\"\n  {:added \"1.8\"}\n  ([^CharSequence s value]\n  (let [result ^long\n        (if (instance? Character value)\n          (.lastIndexOf (.toString s) ^int (.charValue ^Character value))\n          (.lastIndexOf (.toString s) ^String value))]\n    (if (= result -1)\n      nil\n      result)))\n  ([^CharSequence s value ^long from-index]\n  (let [result ^long\n        (if (instance? Character value)\n          (.lastIndexOf (.toString s) ^int (.charValue ^Character value) (unchecked-int from-index))\n          (.lastIndexOf (.toString s) ^String value (unchecked-int from-index)))]\n    (if (= result -1)\n      nil\n      result))))\n\n(defn starts-with?\n  \"True if s starts with substr.\"\n  {:added \"1.8\"}\n  [^CharSequence s ^String substr]\n  (.startsWith (.toString s) substr))\n\n(defn ends-with?\n  \"True if s ends with substr.\"\n  {:added \"1.8\"}\n  [^CharSequence s ^String substr]\n  (.endsWith (.toString s) substr))\n\n(defn includes?\n  \"True if s includes substr.\"\n  {:added \"1.8\"}\n  [^CharSequence s ^CharSequence substr]\n  (.contains (.toString s) substr))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/test/check/random.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.test.check.random",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author \"Gary Fredericks\"\n      :doc \"Purely functional and splittable pseudo-random number generators.\"}\n clojure.test.check.random\n  (:refer-clojure :exclude [unsigned-bit-shift-right]))\n\n(defprotocol IRandom\n  (rand-long [rng]\n    \"Returns a random long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (rand-double [rng]\n    \"Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (split [rng]\n    \"Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (split-n [rng n]\n    \"Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\"))\n\n;; Immutable version of Java 8's java.util.SplittableRandom\n;;\n;; Meant to give the same results as similar uses of\n;; java.util.SplittableRandom, in particular:\n;;\n;; (= (-> (make-java-util-splittable-random 42)\n;;        (rand-long))\n;;    (.nextLong (SplittableRandom. 42)))\n;;\n;; (= (-> (make-java-util-splittable-random 42)\n;;        (split)\n;;        (first)\n;;        (rand-long))\n;;    (.nextLong (doto (SplittableRandom. 42)\n;;                     (.split))))\n;;\n;; (= (-> (make-java-util-splittable-random 42)\n;;        (split)\n;;        (second)\n;;        (rand-long))\n;;    (.nextLong (.split (SplittableRandom. 42))))\n;;\n;; Also see the spec that checks this equivalency.\n\n\n;; backwards compatibility for clojure 1.5\n(def ^:private old-clojure?\n  (not (resolve 'clojure.core/unsigned-bit-shift-right)))\n(defmacro ^:private unsigned-bit-shift-right\n  [x n]\n  {:pre [(<= 1 n 63)]}\n  (if old-clojure?\n    (let [mask (-> Long/MIN_VALUE\n                   (bit-shift-right (dec n))\n                   (bit-not))]\n      `(-> ~x\n           (bit-shift-right ~n)\n           (bit-and ~mask)))\n    `(clojure.core/unsigned-bit-shift-right ~x ~n)))\n\n(defmacro ^:private longify\n  \"Macro for writing arbitrary longs in the java 0x syntax. E.g.\n  0x9e3779b97f4a7c15 (which is read as a bigint because it's out\n  of range) becomes -7046029254386353131.\"\n  [num]\n  (if (> num Long/MAX_VALUE)\n    (-> num\n        (- 18446744073709551616N)\n        (long)\n        (bit-or -9223372036854775808))\n    num))\n\n(set! *unchecked-math* :warn-on-boxed)\n\n(defmacro ^:private bxoubsr\n  \"Performs (-> x (unsigned-bit-shift-right n) (bit-xor x)).\"\n  [x n]\n  (vary-meta\n   `(let [x# ~x]\n      (-> x# (unsigned-bit-shift-right ~n) (bit-xor x#)))\n   assoc :tag 'long))\n\n(defmacro ^:private mix-64\n  [n]\n  `(-> ~n\n       (bxoubsr 30)\n       (* (longify 0xbf58476d1ce4e5b9))\n       (bxoubsr 27)\n       (* (longify 0x94d049bb133111eb))\n       (bxoubsr 31)))\n\n(defmacro ^:private mix-gamma\n  [n]\n  `(-> ~n\n       (bxoubsr 33)\n       (* (longify 0xff51afd7ed558ccd))\n       (bxoubsr 33)\n       (* (longify 0xc4ceb9fe1a85ec53))\n       (bxoubsr 33)\n       (bit-or 1)\n       (as-> z#\n             (cond-> z#\n               (> 24 (-> z#\n                         (bxoubsr 1)\n                         (Long/bitCount)))\n               (bit-xor (longify 0xaaaaaaaaaaaaaaaa))))))\n\n(def ^:private ^:const double-unit (/ 1.0 (double (bit-set 0 53))))\n;; Java: 0x1.0p-53 or (1.0 / (1L << 53))\n\n(deftype JavaUtilSplittableRandom [^long gamma ^long state]\n  IRandom\n  (rand-long [_]\n    (-> state (+ gamma) (mix-64)))\n  (rand-double [this]\n    (* double-unit (unsigned-bit-shift-right (long (rand-long this)) 11)))\n  (split [this]\n    (let [state' (+ gamma state)\n          state'' (+ gamma state')\n          gamma' (mix-gamma state'')]\n      [(JavaUtilSplittableRandom. gamma state'')\n       (JavaUtilSplittableRandom. gamma' (mix-64 state'))]))\n  (split-n [this n]\n    ;; immitates a particular series of 2-way splits, but avoids the\n    ;; intermediate allocation. See the `split-n-spec` for a test of\n    ;; the equivalence to 2-way splits.\n    (let [n (long n)]\n      (case n\n        0 []\n        1 [this]\n        (let [n-dec (dec n)]\n          (loop [state state\n                 ret (transient [])]\n            (if (= n-dec (count ret))\n              (-> ret\n                  (conj! (JavaUtilSplittableRandom. gamma state))\n                  (persistent!))\n              (let [state' (+ gamma state)\n                    state'' (+ gamma state')\n                    gamma' (mix-gamma state'')\n                    new-rng (JavaUtilSplittableRandom. gamma' (mix-64 state'))]\n                (recur state'' (conj! ret new-rng))))))))))\n\n(def ^:private golden-gamma\n  (longify 0x9e3779b97f4a7c15))\n\n(defn make-java-util-splittable-random\n  [^long seed]\n  (JavaUtilSplittableRandom. golden-gamma seed))\n\n;; some global state to make sure that seedless calls to make-random\n;; return independent results\n(def ^:private next-rng\n  \"Returns a random-number generator. Successive calls should return\n  independent results.\"\n  (let [a (atom (make-java-util-splittable-random (System/currentTimeMillis)))\n\n        thread-local\n        (proxy [ThreadLocal] []\n          (initialValue []\n            (first (split (swap! a #(second (split %)))))))]\n    (fn []\n      (let [rng (.get thread-local)\n            [rng1 rng2] (split rng)]\n        (.set thread-local rng2)\n        rng1))))\n\n(defn make-random\n  \"Given an optional Long seed, returns an object that satisfies the\n  IRandom protocol.\"\n  ([] (next-rng))\n  ([seed] (make-java-util-splittable-random seed)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader/reader_types.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader.reader-types",new cljs.core.Keyword(null,"source","source",-433931539),"(ns cljs.tools.reader.reader-types)\n\n(defmacro log-source\n  \"If reader is a SourceLoggingPushbackReader, execute body in a source\n  logging context. Otherwise, execute body, returning the result.\"\n  [reader & body]\n  `(if (and (source-logging-reader? ~reader)\n            (not (cljs.tools.reader.impl.utils/whitespace? (peek-char ~reader))))\n     (log-source* ~reader (^:once fn* [] ~@body))\n     (do ~@body)))"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/nodejs.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.nodejs",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n; Projects compiled with :target :nodejs can 'require' this namespace\n; to get the nodejs globals loaded into cljs.nodejs and get\n; ClojureScript's 'print' set up correctly.\n(ns cljs.nodejs\n  (:refer-clojure :exclude [require]))\n\n; Define namespaced references to Node's externed globals:\n(def require (js* \"require\"))\n(def process (js* \"process\"))\n\n(defn enable-util-print! []\n  (set! *print-newline* false)\n  (set-print-fn!\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args))))\n  (set-print-err-fn!\n    (fn [& args]\n      (.apply (.-error js/console) js/console (into-array args))))\n  nil)\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/set.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.set",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)\n\n(defn- bubble-max-key [k coll]\n  \"Move a maximal element of coll according to fn k (which returns a number) \n   to the front of coll.\"\n  (let [max (apply max-key k coll)]\n    (cons max (remove #(identical? max %) coll))))\n\n(defn union\n  \"Return a set that is the union of the input sets\"\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn intersection\n  \"Return a set that is the intersection of the input sets\"\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn difference\n  \"Return a set that is the first set without elements of the remaining sets\"\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))\n\n\n(defn select\n  \"Returns a set of the elements for which pred is true\"\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))\n\n(defn project\n  \"Returns a rel of the elements of xrel with only the keys in ks\"\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))\n\n(defn rename-keys\n  \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))\n\n(defn rename\n  \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))\n\n(defn index\n  \"Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.\"\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))\n   \n(defn map-invert\n  \"Returns the map with the vals mapped to the keys.\"\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))\n\n(defn join\n  \"When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.\"\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))\n\n(defn subset? \n  \"Is set1 a subset of set2?\"\n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))\n\n(defn superset? \n  \"Is set1 a superset of set2?\"\n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))\n\n(comment\n(refer 'set)\n(def xs #{{:a 11 :b 1 :c 1 :d 4}\n         {:a 2 :b 12 :c 2 :d 6}\n         {:a 3 :b 3 :c 3 :d 8 :f 42}})\n\n(def ys #{{:a 11 :b 11 :c 11 :e 5}\n         {:a 12 :b 11 :c 12 :e 3}\n         {:a 3 :b 3 :c 3 :e 7 }})\n\n(join xs ys)\n(join xs (rename ys {:b :yb :c :yc}) {:a :a})\n\n(union #{:a :b :c} #{:c :d :e })\n(difference #{:a :b :c} #{:c :d :e})\n(intersection #{:a :b :c} #{:c :d :e})\n\n(index ys [:b]))\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/pprint.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.pprint",new cljs.core.Keyword(null,"source","source",-433931539),";; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.pprint\n  (:refer-clojure :exclude [deftype #?(:cljs macroexpand)])\n  (:require [clojure.walk :as walk]\n            #?(:cljs [cljs.analyzer :as ana])))\n\n\n;; required the following changes:\n;;  replace .ppflush with -ppflush to switch from Interface to Protocol\n\n(defmacro with-pretty-writer [base-writer & body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (cljs.core/binding [cljs.core/*out* (if new-writer#\n                         (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                         base-writer#)]\n       ~@body\n       (-ppflush cljs.core/*out*))))\n\n\n(defmacro getf\n  \"Get the value of the field a named by the argument (which should be a keyword).\"\n  [sym]\n  `(~sym @@~'this))\n\n;; change alter to swap!\n\n(defmacro setf\n  \"Set the value of the field SYM to NEW-VAL\"\n  [sym new-val]\n  `(swap! @~'this assoc ~sym ~new-val))\n\n(defmacro deftype\n  [type-name & fields]\n  (let [name-str (name type-name)\n        fields (map (comp symbol name) fields)]\n    `(do\n       (defrecord ~type-name [~'type-tag ~@fields])\n       (defn- ~(symbol (str \"make-\" name-str))\n         ~(vec fields)\n         (~(symbol (str type-name \".\")) ~(keyword name-str) ~@fields))\n       (defn- ~(symbol (str name-str \"?\")) [x#] (= (:type-tag x#) ~(keyword name-str))))))\n\n(defn- parse-lb-options [opts body]\n  (loop [body body\n         acc []]\n    (if (opts (first body))\n      (recur (drop 2 body) (concat acc (take 2 body)))\n      [(apply hash-map acc) body])))\n\n(defmacro pprint-logical-block\n  \"Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.\"\n  [& args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (cljs.pprint/level-exceeded)\n           (~'-write cljs.core/*out* \"#\")\n           (do\n             (cljs.core/binding [cljs.pprint/*current-level* (inc cljs.pprint/*current-level*)\n                       cljs.pprint/*current-length* 0]\n               (cljs.pprint/start-block cljs.core/*out*\n                                        ~(:prefix options)\n                                        ~(:per-line-prefix options)\n                                        ~(:suffix options))\n               ~@body\n               (cljs.pprint/end-block cljs.core/*out*))))\n         nil)))\n\n#?(:cljs\n   (defn macroexpand [env form]\n     (loop [form form\n            form' (ana/macroexpand-1 env form)]\n       (if-not (identical? form form')\n         (recur form' (ana/macroexpand-1 env form'))\n         form'))))\n\n(defn- pll-mod-body [env var-sym body]\n  (letfn [(inner [form]\n                 (if (seq? form)\n                   (let [form #?(:clj  (macroexpand form)\n                                 :cljs (macroexpand env form))]\n                     (condp = (first form)\n                       'loop* form\n                       'recur (concat `(recur (inc ~var-sym)) (rest form))\n                       (walk/walk inner identity form)))\n                   form))]\n    (walk/walk inner identity body)))\n\n(defmacro print-length-loop\n  \"A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.\"\n  [bindings & body]\n  (let [count-var (gensym \"length-count\")\n        mod-body (pll-mod-body &env count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not cljs.core/*print-length*) (< ~count-var cljs.core/*print-length*))\n         (do ~@mod-body)\n         (~'-write cljs.core/*out* \"...\")))))\n\n(defn- process-directive-table-element [[char params flags bracket-info & generator-fn]]\n  [char,\n   {:directive char,\n    :params `(array-map ~@params),\n    :flags flags,\n    :bracket-info bracket-info,\n    :generator-fn (concat '(fn [params offset]) generator-fn)}])\n\n(defmacro ^{:private true}\n  defdirectives\n  [& directives]\n  `(def ^{:private true}\n        ~'directive-table (hash-map ~@(mapcat process-directive-table-element directives))))\n\n(defmacro formatter\n  \"Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.\"\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# cljs.pprint/cached-compile\n         my-e-f# cljs.pprint/execute-format\n         my-i-n# cljs.pprint/init-navigator\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# & args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))\n\n(defmacro formatter-out\n  \"Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.\"\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (cljs.pprint/cached-compile format-in#) format-in#)]\n     (fn [& args#]\n       (let [navigator# (cljs.pprint/init-navigator args#)]\n         (cljs.pprint/execute-format cf# navigator#)))))\n\n(defmacro with-pprint-dispatch\n  \"Execute body with the pretty print dispatch function bound to function.\"\n  [function & body]\n  `(cljs.core/binding [cljs.pprint/*print-pprint-dispatch* ~function]\n     ~@body))\n\n(defmacro pp\n  \"A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).\"\n  {:added \"1.2\"}\n  [] `(cljs.pprint/pprint *1))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/env.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.env",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"A namespace that exists solely to provide a place for \\\"compiler\\\"\nstate that is accessed/maintained by many different components.\"}\n  cljs.env\n  #?(:clj (:require [cljs.js-deps :as deps]\n                    [cljs.externs :as externs]))\n  (:refer-clojure :exclude [ensure]))\n\n;; bit of a misnomer, but: an atom containing a map that serves as the bag of\n;; state for the compiler, writ large (including analyzer, emitter, and\n;; optimization stages). Each namespace has its own local var, to accommodate\n;; multiple (lower-level) entry points.  Any state needed by the compiler across\n;; multiple applications should be put into this map/atom.  Aside from\n;; unfortunate current implementation details (e.g. depending on filesystem\n;; state for certain things), the compiler should be idempotent with regard to\n;; the environment passed to any entry point.\n;;\n;; Known slots in the compiler-env map:\n;;\n;; * :options - the [options] map argument, provided to this fn (defaults to {})\n;; * :js-dependency-index - result from calling cljs.js-deps/js-dependency-index\n;;   with [options]\n;; * :cljs.analyzer/constant-table - map of (currently only keyword) constant\n;;   values to fixed ids\n;; * :cljs.analyzer/namespaces - map of symbols to \"namespace\" maps\n;; * :cljs.analyzer/data-readers - literal map of symbols, where the first\n;;   symbol in each pair is a tag that will be recognized by the reader. The\n;;   second symbol in the pair is the fully-qualified name of a Var which will\n;;   be invoked by the reader to parse the form following the tag.\n;; * :cljs.compiler/compiled-cljs - cache of intermediate compilation results\n;;   that speeds incremental builds in conjunction with source map generation\n;; * :cljs.closure/compiled-cljs - cache from js file path to map of\n;;   {:file .. :provides .. :requires ..}\n;;\n;; Note that this var is functionally private to the compiler, and contains\n;; implementation-dependent data.\n(def ^:dynamic *compiler* nil)\n\n(defn default-compiler-env* [options]\n  (merge\n    {:cljs.analyzer/namespaces {'cljs.user {:name 'cljs.user}}\n     :cljs.analyzer/constant-table {}\n     :cljs.analyzer/data-readers {}\n     :cljs.analyzer/externs #?(:clj  (when (:infer-externs options)\n                                       (externs/externs-map (:externs-sources options)))\n                               :cljs nil)\n     :options options}\n    #?@(:clj [(when (= (:target options) :nodejs)\n                {:node-module-index deps/native-node-modules})\n              {:js-dependency-index (deps/js-dependency-index options)}])))\n\n(defn default-compiler-env\n  ([] (default-compiler-env {}))\n  ([options]\n   (atom (default-compiler-env* options))))\n\n#?(:clj\n   (defmacro with-compiler-env\n     \"Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n   this namespace.\"\n     [env & body]\n     `(let [env# ~env\n            env# (cond\n                   (map? env#) (atom env#)\n                   (and (instance? clojure.lang.Atom env#)\n                        (map? @env#)) env#\n                   :default (throw (IllegalArgumentException.\n                                     (str \"Compiler environment must be a map or atom containing a map, not \"\n                                       (class env#)))))]\n        (binding [*compiler* env#] ~@body))))\n\n#?(:clj\n   (defmacro ensure\n     [& body]\n     `(let [val# *compiler*]\n        (if (nil? val#)\n          (push-thread-bindings\n            (hash-map (var *compiler*) (default-compiler-env))))\n        (try\n          ~@body\n          (finally\n            (if (nil? val#)\n              (pop-thread-bindings)))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/test/check/random.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.test.check.random",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author \"Gary Fredericks\"\n      :doc \"Purely functional and splittable pseudo-random number generators.\"}\n clojure.test.check.random\n  (:refer-clojure :exclude [+ * bit-xor bit-or bit-count\n                            unsigned-bit-shift-right])\n  (:require [clojure.test.check.random.doubles :as doubles]\n            [clojure.test.check.random.longs :as longs\n             :refer [+ * bit-xor bit-or bit-count unsigned-bit-shift-right]]))\n\n(defprotocol IRandom\n  (rand-long [rng]\n    \"Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (rand-double [rng]\n    \"Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (split [rng]\n    \"Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\")\n  (split-n [rng n]\n    \"Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument\"))\n\n;;\n;; This is a port of the clojure-jvm port of\n;; java.util.SplittableRandom, and should give identical results.\n;;\n\n(defn ^:private hex-long\n  \"Helper for defining constants.\"\n  [s]\n  (longs/from-string s 16))\n\n(defn ^:private bxoubsr\n  \"Performs (-> x (unsigned-bit-shift-right n) (bit-xor x)).\"\n  [x n]\n  (-> x (unsigned-bit-shift-right n) (bit-xor x)))\n\n(def ^:private mix-64-const-1 (hex-long \"bf58476d1ce4e5b9\"))\n(def ^:private mix-64-const-2 (hex-long \"94d049bb133111eb\"))\n\n(defn ^:private mix-64\n  [n]\n  (-> n\n      (bxoubsr 30)\n      (* mix-64-const-1)\n      (bxoubsr 27)\n      (* mix-64-const-2)\n      (bxoubsr 31)))\n\n(def ^:private mix-gamma-const-1 (hex-long \"ff51afd7ed558ccd\"))\n(def ^:private mix-gamma-const-2 (hex-long \"c4ceb9fe1a85ec53\"))\n(def ^:private mix-gamma-const-3 (hex-long \"aaaaaaaaaaaaaaaa\"))\n\n(defn ^:private mix-gamma\n  [n]\n  (-> n\n      (bxoubsr 33)\n      (* mix-gamma-const-1)\n      (bxoubsr 33)\n      (* mix-gamma-const-2)\n      (bxoubsr 33)\n      (bit-or longs/ONE)\n      (as-> z\n            (cond-> z\n              (> 24 (-> z\n                        (bxoubsr 1)\n                        (bit-count)))\n              (bit-xor mix-gamma-const-3)))))\n\n(deftype JavaUtilSplittableRandom [gamma state]\n  IRandom\n  (rand-long [_]\n    (-> state (+ gamma) (mix-64)))\n  (rand-double [this]\n    (-> this rand-long doubles/rand-long->rand-double))\n  (split [this]\n    (let [state' (+ gamma state)\n          state'' (+ gamma state')\n          gamma' (mix-gamma state'')]\n      [(JavaUtilSplittableRandom. gamma state'')\n       (JavaUtilSplittableRandom. gamma' (mix-64 state'))]))\n  (split-n [this n]\n    (case n\n      0 []\n      1 [this]\n      (let [n-dec (dec n)]\n        (loop [state state\n               ret (transient [])]\n          (if (= n-dec (count ret))\n            (-> ret\n                (conj! (JavaUtilSplittableRandom. gamma state))\n                (persistent!))\n            (let [state' (+ gamma state)\n                  state'' (+ gamma state')\n                  gamma' (mix-gamma state'')\n                  new-rng (JavaUtilSplittableRandom. gamma' (mix-64 state'))]\n              (recur state'' (conj! ret new-rng)))))))))\n\n(def ^:private golden-gamma\n  (hex-long \"9e3779b97f4a7c15\"))\n\n(defn make-java-util-splittable-random\n  [seed]\n  (JavaUtilSplittableRandom. golden-gamma\n                             (or (longs/->long seed)\n                                 (throw (ex-info \"Bad random seed!\"\n                                                 {:seed seed})))))\n\n(def ^:private next-rng\n  (let [a (atom {:state\n                 (make-java-util-splittable-random (.valueOf (js/Date.)))})]\n    (fn []\n      (:returned\n       (swap! a (fn [{:keys [state]}]\n                  (let [[r1 r2] (split state)]\n                    {:state r1 :returned r2})))))))\n\n(defn make-random\n  \"Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol.\"\n  ([] (next-rng))\n  ([seed]\n   (make-java-util-splittable-random seed)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/test/check/generators.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.test.check.generators",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.generators\n  (:refer-clojure :exclude [int vector list hash-map map keyword\n                            char boolean byte bytes sequence\n                            shuffle not-empty symbol namespace\n                            set sorted-set uuid double let])\n  (:require [#?(:clj clojure.core :cljs cljs.core) :as core\n             #?@(:cljs [:include-macros true])]\n            [clojure.string :as string]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            #?@(:cljs [[goog.string :as gstring]\n                       [clojure.string]]))\n  #?(:cljs (:require-macros [clojure.test.check.generators :refer [let]])))\n\n;; Gen\n;; (internal functions)\n;; ---------------------------------------------------------------------------\n\n(defrecord Generator [gen])\n\n(defn generator?\n  \"Test if `x` is a generator. Generators should be treated as opaque values.\"\n  [x]\n  (instance? Generator x))\n\n(defn- make-gen\n  [generator-fn]\n  (Generator. generator-fn))\n\n(defn call-gen\n  \"Internal function.\"\n  {:no-doc true}\n  [{generator-fn :gen} rnd size]\n  (generator-fn rnd size))\n\n(defn gen-pure\n  \"Internal function.\"\n  {:no-doc true}\n  [value]\n  (make-gen\n   (fn [rnd size]\n     value)))\n\n(defn gen-fmap\n  \"Internal function.\"\n  {:no-doc true}\n  [k {h :gen}]\n  (make-gen\n   (fn [rnd size]\n     (k (h rnd size)))))\n\n(defn gen-bind\n  \"Internal function.\"\n  {:no-doc true}\n  [{h :gen} k]\n  (make-gen\n   (fn [rnd size]\n     (core/let [[r1 r2] (random/split rnd)\n                inner (h r1 size)\n                {result :gen} (k inner)]\n       (result r2 size)))))\n\n(defn lazy-random-states\n  \"Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators.\"\n  [rr]\n  (lazy-seq\n   (core/let [[r1 r2] (random/split rr)]\n     (cons r1\n           (lazy-random-states r2)))))\n\n(defn- gen-tuple\n  \"Takes a collection of generators and returns a generator of vectors.\"\n  [gens]\n  (make-gen\n   (fn [rnd size]\n     (mapv #(call-gen % %2 size) gens (random/split-n rnd (count gens))))))\n\n;; Exported generator functions\n;; ---------------------------------------------------------------------------\n\n(defn fmap\n  \"Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      => (\\\"0\\\" \\\"1\\\" \\\"0\\\" \\\"1\\\" \\\"4\\\" \\\"3\\\" \\\"6\\\" \\\"6\\\" \\\"4\\\" \\\"2\\\")\n\n  Also see gen/let for a macro with similar functionality.\"\n  [f gen]\n  (assert (generator? gen) \"Second arg to fmap must be a generator\")\n  (gen-fmap #(rose/fmap f %) gen))\n\n(defn return\n  \"Create a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      => (42 42 42 42 42 42 42 42 42 42)\"\n  [value]\n  (gen-pure (rose/pure value)))\n\n(defn- bind-helper\n  [f]\n  (fn [rose]\n    (gen-fmap rose/join\n              (make-gen\n               (fn [rnd size]\n                 (rose/fmap #(call-gen (f %) rnd size)\n                            rose))))))\n\n(defn bind\n  \"Create a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality.\"\n  [generator f]\n  (assert (generator? generator) \"First arg to bind must be a generator\")\n  (gen-bind generator (bind-helper f)))\n\n;; Helpers\n;; ---------------------------------------------------------------------------\n\n(defn make-size-range-seq\n  \"Internal function.\"\n  {:no-doc true}\n  [max-size]\n  (cycle (range 0 max-size)))\n\n(defn sample-seq\n  \"Return a sequence of realized values from `generator`.\"\n  ([generator] (sample-seq generator 200))\n  ([generator max-size]\n   (core/let [r (random/make-random)\n              size-seq (make-size-range-seq max-size)]\n     (core/map #(rose/root (call-gen generator %1 %2))\n               (lazy-random-states r)\n               size-seq))))\n\n(defn sample\n  \"Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\"\n  ([generator]\n   (sample generator 10))\n  ([generator num-samples]\n   (assert (generator? generator) \"First arg to sample must be a generator\")\n   (take num-samples (sample-seq generator))))\n\n(defn generate\n  \"Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer\"\n  {:added \"0.8.0\"}\n  ([generator]\n   (generate generator 30))\n  ([generator size]\n   (core/let [rng (random/make-random)]\n     (rose/root (call-gen generator rng size))))\n  ([generator size seed]\n   (core/let [rng (random/make-random seed)]\n     (rose/root (call-gen generator rng size)))))\n\n;; Internal Helpers\n;; ---------------------------------------------------------------------------\n\n(defn- halfs\n  [n]\n  (take-while #(not= 0 %) (iterate #(quot % 2) n)))\n\n(defn- shrink-int\n  [integer]\n  (core/map #(- integer %) (halfs integer)))\n\n(defn- int-rose-tree\n  [value]\n  (rose/make-rose value (core/map int-rose-tree (shrink-int value))))\n\n;; calc-long is factored out to support testing the surprisingly tricky double math.  Note:\n;; An extreme long value does not have a precision-preserving representation as a double.\n;; Be careful about changing this code unless you understand what's happening in these\n;; examples:\n;;\n;; (= (long (- Integer/MAX_VALUE (double (- Integer/MAX_VALUE 10)))) 10)\n;; (= (long (- Long/MAX_VALUE (double (- Long/MAX_VALUE 10)))) 0)\n\n(defn- calc-long\n  [factor lower upper]\n  ;; these pre- and post-conditions are disabled for deployment\n  #_ {:pre [(float? factor) (>= factor 0.0) (< factor 1.0)\n            (integer? lower) (integer? upper) (<= lower upper)]\n      :post [(integer? %)]}\n  ;; Use -' on width to maintain accuracy with overflow protection.\n  #?(:clj\n     (core/let [width (-' upper lower -1)]\n       ;; Preserve long precision if the width is in the long range.  Otherwise, we must accept\n       ;; less precision because doubles don't have enough bits to preserve long equivalence at\n       ;; extreme values.\n       (if (< width Long/MAX_VALUE)\n         (+ lower (long (Math/floor (* factor width))))\n         ;; Clamp down to upper because double math.\n         (min upper (long (Math/floor (+ lower (* factor width)))))))\n\n     :cljs\n     (long (Math/floor (+ lower (- (* factor (+ 1.0 upper))\n                                   (* factor lower)))))))\n\n(defn- rand-range\n  [rnd lower upper]\n  {:pre [(<= lower upper)]}\n  (calc-long (random/rand-double rnd) lower upper))\n\n(defn sized\n  \"Create a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n      TODO: example\"\n  [sized-gen]\n  (make-gen\n   (fn [rnd size]\n     (core/let [sized-gen (sized-gen size)]\n       (call-gen sized-gen rnd size)))))\n\n;; Combinators and helpers\n;; ---------------------------------------------------------------------------\n\n(defn resize\n  \"Create a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      => (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})\"\n  [n generator]\n  (assert (generator? generator) \"Second arg to resize must be a generator\")\n  (core/let [{:keys [gen]} generator]\n    (make-gen\n     (fn [rnd _size]\n       (gen rnd n)))))\n\n(defn scale\n  \"Create a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])\"\n  {:added \"0.8.0\"}\n  ([f generator]\n   (sized (fn [n] (resize (f n) generator)))))\n\n(defn choose\n  #?(:clj\n     \"Create a generator that returns long integers in the range\n     `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)\"\n\n     :cljs\n     \"Create a generator that returns integer numbers in the range\n     `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)\")\n  [lower upper]\n  ;; cast to long to support doubles as arguments per TCHECK-73\n  (core/let #?(:clj\n               [lower (long lower)\n                upper (long upper)]\n\n               :cljs ;; does nothing, no long in cljs\n               [])\n    (make-gen\n     (fn [rnd _size]\n       (core/let [value (rand-range rnd lower upper)]\n         (rose/filter\n          #(and (>= % lower) (<= % upper))\n          (int-rose-tree value)))))))\n\n(defn one-of\n  \"Create a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/int gen/boolean (gen/vector gen/int)]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)\"\n  [generators]\n  (assert (every? generator? generators)\n          \"Arg to one-of must be a collection of generators\")\n  (assert (seq generators)\n          \"one-of cannot be called with an empty collection\")\n  (bind (choose 0 (dec (count generators)))\n        #(nth generators %)))\n\n(defn- pick\n  \"Returns an index into the `likelihoods` sequence.\"\n  [likelihoods n]\n  (->> likelihoods\n       (reductions + 0)\n       (rest)\n       (take-while #(<= % n))\n       (count)))\n\n(defn frequency\n  \"Create a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/int] [3 (gen/vector gen/int)] [2 gen/boolean]]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)\"\n  [pairs]\n  (assert (every? (fn [[x g]] (and (number? x) (generator? g)))\n                  pairs)\n          \"Arg to frequency must be a list of [num generator] pairs\")\n  (core/let [pairs (filter (comp pos? first) pairs)\n             total (apply + (core/map first pairs))]\n    (assert (seq pairs)\n            \"frequency must be called with at least one non-zero weight\")\n    ;; low-level impl for shrinking control\n    (make-gen\n     (fn [rnd size]\n       (call-gen\n        (gen-bind (choose 0 (dec total))\n                  (fn [x]\n                    (core/let [idx (pick (core/map first pairs) (rose/root x))]\n                      (gen-fmap (fn [rose]\n                                  (rose/make-rose (rose/root rose)\n                                                  (lazy-seq\n                                                   (concat\n                                                    ;; try to shrink to earlier generators first\n                                                    (for [idx (range idx)]\n                                                      (call-gen (second (nth pairs idx))\n                                                                rnd\n                                                                size))\n                                                    (rose/children rose)))))\n                                (second (nth pairs idx))))))\n        rnd size)))))\n\n(defn elements\n  \"Create a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)\"\n  [coll]\n  (assert (seq coll) \"elements cannot be called with an empty collection\")\n  (core/let [v (vec coll)]\n    (gen-fmap #(rose/fmap v %)\n              (choose 0 (dec (count v))))))\n\n(defn- such-that-helper\n  [pred gen {:keys [ex-fn max-tries]} rng size]\n  (loop [tries-left max-tries\n         rng rng\n         size size]\n    (if (zero? tries-left)\n      (throw (ex-fn {:pred pred, :gen, gen :max-tries max-tries}))\n      (core/let [[r1 r2] (random/split rng)\n                 value (call-gen gen r1 size)]\n        (if (pred (rose/root value))\n          (rose/filter pred value)\n          (recur (dec tries-left) r2 (inc size)))))))\n\n(def ^:private\n  default-such-that-opts\n  {:ex-fn (fn [{:keys [max-tries] :as arg}]\n            (ex-info (str \"Couldn't satisfy such-that predicate after \"\n                          max-tries \" tries.\")\n                     arg))\n   :max-tries 10})\n\n(defn such-that\n  \"Create a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/int))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception\"\n  ([pred gen]\n   (such-that pred gen 10))\n  ([pred gen max-tries-or-opts]\n   (core/let [opts (cond (integer? max-tries-or-opts)\n                         {:max-tries max-tries-or-opts}\n\n                         (map? max-tries-or-opts)\n                         max-tries-or-opts\n\n                         :else\n                         (throw (ex-info \"Bad argument to such-that!\" {:max-tries-or-opts\n                                                                       max-tries-or-opts})))\n              opts (merge default-such-that-opts opts)]\n     (assert (generator? gen) \"Second arg to such-that must be a generator\")\n     (make-gen\n      (fn [rand-seed size]\n        (such-that-helper pred gen opts rand-seed size))))))\n\n(defn not-empty\n  \"Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      => ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])\"\n  [gen]\n  (assert (generator? gen) \"Arg to not-empty must be a generator\")\n  (such-that core/not-empty gen))\n\n(defn no-shrink\n  \"Create a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain.\"\n  [gen]\n  (assert (generator? gen) \"Arg to no-shrink must be a generator\")\n  (gen-fmap (fn [rose]\n              (rose/make-rose (rose/root rose) []))\n            gen))\n\n(defn shrink-2\n  \"Create a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level).\"\n  [gen]\n  (assert (generator? gen) \"Arg to shrink-2 must be a generator\")\n  (gen-fmap rose/collapse gen))\n\n(def boolean\n  \"Generates one of `true` or `false`. Shrinks to `false`.\"\n  (elements [false true]))\n\n(defn tuple\n  \"Create a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the value will never shrink in count.\n\n  Examples:\n\n      (def t (tuple gen/int gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))\"\n  [& generators]\n  (assert (every? generator? generators)\n          \"Args to tuple must be generators\")\n  (gen-fmap (fn [roses]\n              (rose/zip core/vector roses))\n            (gen-tuple generators)))\n\n(def int\n  \"Generates a positive or negative integer bounded by the generator's\n  `size` parameter.\"\n  (sized (fn [size] (choose (- size) size))))\n\n(def nat\n  \"Generates non-negative integers bounded by the generator's `size`\n  parameter. Shrinks to zero.\"\n  (fmap #(Math/abs (long %)) int))\n\n(def pos-int\n  \"Generate positive integers bounded by the generator's `size` parameter.\"\n  nat)\n\n(def neg-int\n  \"Generate negative integers bounded by the generator's `size` parameter.\"\n  (fmap #(* -1 %) nat))\n\n(def s-pos-int\n  \"Generate strictly positive integers bounded by the generator's `size` + 1\"\n  (fmap inc nat))\n\n(def s-neg-int\n  \"Generate strictly negative integers bounded by the generator's `size` + 1\"\n  (fmap dec neg-int))\n\n(defn vector\n  \"Create a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter.\"\n  ([generator]\n   (assert (generator? generator) \"Arg to vector must be a generator\")\n   (gen-bind\n    (sized #(choose 0 %))\n    (fn [num-elements-rose]\n      (gen-fmap (fn [roses]\n                  (rose/shrink-vector core/vector\n                                      roses))\n                (gen-tuple (repeat (rose/root num-elements-rose)\n                                   generator))))))\n  ([generator num-elements]\n   (assert (generator? generator) \"First arg to vector must be a generator\")\n   (apply tuple (repeat num-elements generator)))\n  ([generator min-elements max-elements]\n   (assert (generator? generator) \"First arg to vector must be a generator\")\n   (gen-bind\n    (choose min-elements max-elements)\n    (fn [num-elements-rose]\n      (gen-fmap (fn [roses]\n                  (rose/filter\n                   (fn [v] (and (>= (count v) min-elements)\n                                (<= (count v) max-elements)))\n                   (rose/shrink-vector core/vector\n                                       roses)))\n                (gen-tuple (repeat (rose/root num-elements-rose)\n                                   generator)))))))\n\n(defn list\n  \"Like `vector`, but generates lists.\"\n  [generator]\n  (assert (generator? generator) \"First arg to list must be a generator\")\n  (gen-bind (sized #(choose 0 %))\n            (fn [num-elements-rose]\n              (gen-fmap (fn [roses]\n                          (rose/shrink-vector core/list\n                                              roses))\n                        (gen-tuple (repeat (rose/root num-elements-rose)\n                                           generator))))))\n\n(defn- swap\n  [coll [i1 i2]]\n  (assoc coll i2 (coll i1) i1 (coll i2)))\n\n(defn\n  ^{:added \"0.6.0\"}\n  shuffle\n  \"Create a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector.\"\n  [coll]\n  (core/let [coll (if (vector? coll) coll (vec coll))\n             index-gen (choose 0 (dec (count coll)))]\n    (fmap #(reduce swap coll %)\n          ;; a vector of swap instructions, with count between\n          ;; zero and 2 * count. This means that the average number\n          ;; of instructions is count, which should provide sufficient\n          ;; (though perhaps not 'perfect') shuffling. This still gives us\n          ;; nice, relatively quick shrinks.\n          (vector (tuple index-gen index-gen) 0 (* 2 (count coll))))))\n\n;; NOTE cljs: Comment out for now - David\n\n#?(:clj\n   (def byte\n     \"Generates `java.lang.Byte`s, using the full byte-range.\"\n     (fmap core/byte (choose Byte/MIN_VALUE Byte/MAX_VALUE))))\n\n#?(:clj\n   (def bytes\n     \"Generates byte-arrays.\"\n     (fmap core/byte-array (vector byte))))\n\n(defn hash-map\n  \"Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       => ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})\"\n  [& kvs]\n  (assert (even? (count kvs)))\n  (core/let [ks (take-nth 2 kvs)\n             vs (take-nth 2 (rest kvs))]\n    (assert (every? generator? vs)\n            \"Value args to hash-map must be generators\")\n    (fmap #(zipmap ks %)\n          (apply tuple vs))))\n\n;; Collections of distinct elements\n;; (has to be done in a low-level way (instead of with combinators)\n;;  and is subject to the same kind of failure as such-that)\n;; ---------------------------------------------------------------------------\n\n(defn ^:private transient-set-contains?\n  [s k]\n  #? (:clj\n      (.contains ^clojure.lang.ITransientSet s k)\n      :cljs\n      (some? (-lookup s k))))\n\n(defn ^:private coll-distinct-by*\n  \"Returns a rose tree.\"\n  [empty-coll key-fn shuffle-fn gen rng size num-elements min-elements max-tries ex-fn]\n  {:pre [gen (:gen gen)]}\n  (loop [rose-trees (transient [])\n         s (transient #{})\n         rng rng\n         size size\n         tries 0]\n    (cond (and (= max-tries tries)\n               (< (count rose-trees) min-elements))\n          (throw (ex-fn {:gen gen\n                         :max-tries max-tries\n                         :num-elements num-elements}))\n\n          (or (= max-tries tries)\n              (= (count rose-trees) num-elements))\n          (->> (persistent! rose-trees)\n               ;; we shuffle the rose trees so that we aren't biased\n               ;; toward generating \"smaller\" elements earlier in the\n               ;; collection (only applies to ordered collections)\n               ;;\n               ;; shuffling the rose trees is more efficient than\n               ;; (bind ... shuffle) because we only perform the\n               ;; shuffling once and we have no need to shrink the\n               ;; shufling.\n               (shuffle-fn rng)\n               (rose/shrink-vector #(into empty-coll %&)))\n\n          :else\n          (core/let [[rng1 rng2] (random/split rng)\n                     rose (call-gen gen rng1 size)\n                     root (rose/root rose)\n                     k (key-fn root)]\n            (if (transient-set-contains? s k)\n              (recur rose-trees s rng2 (inc size) (inc tries))\n              (recur (conj! rose-trees rose)\n                     (conj! s k)\n                     rng2\n                     size\n                     0))))))\n\n(defn ^:private distinct-by?\n  \"Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections.\"\n  [f coll]\n  (or (empty? coll)\n      (apply distinct? (core/map f coll))))\n\n(defn ^:private the-shuffle-fn\n  \"Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function.\"\n  [rng coll]\n  (core/let [empty-coll (empty coll)\n             v (vec coll)\n             card (count coll)\n             dec-card (dec card)]\n    (into empty-coll\n          (first\n           (reduce (fn [[v rng] idx]\n                     (core/let [[rng1 rng2] (random/split rng)\n                                swap-idx (rand-range rng1 idx dec-card)]\n                       [(swap v [idx swap-idx]) rng2]))\n                   [v rng]\n                   (range card))))))\n\n(defn ^:private coll-distinct-by\n  [empty-coll key-fn allows-dupes? ordered? gen\n   {:keys [num-elements min-elements max-elements max-tries ex-fn]\n    :or {max-tries 10\n         ex-fn #(ex-info \"Couldn't generate enough distinct elements!\" %)}}]\n  (core/let [shuffle-fn (if ordered?\n                          the-shuffle-fn\n                          (fn [_rng coll] coll))\n             hard-min-elements (or num-elements min-elements 1)]\n    (if num-elements\n      (core/let [size-pred #(= num-elements (count %))]\n        (assert (and (nil? min-elements) (nil? max-elements)))\n        (make-gen\n         (fn [rng gen-size]\n           (rose/filter\n            (if allows-dupes?\n              ;; is there a smarter way to do the shrinking than checking\n              ;; the distinctness of the entire collection at each\n              ;; step?\n              (every-pred size-pred #(distinct-by? key-fn %))\n              size-pred)\n            (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                               num-elements hard-min-elements max-tries ex-fn)))))\n      (core/let [min-elements (or min-elements 0)\n                 size-pred (if max-elements\n                             #(<= min-elements (count %) max-elements)\n                             #(<= min-elements (count %)))]\n        (gen-bind\n         (if max-elements\n           (choose min-elements max-elements)\n           (sized #(choose min-elements (+ min-elements %))))\n         (fn [num-elements-rose]\n           (core/let [num-elements (rose/root num-elements-rose)]\n             (make-gen\n              (fn [rng gen-size]\n                (rose/filter\n                 (if allows-dupes?\n                   ;; same comment as above\n                   (every-pred size-pred #(distinct-by? key-fn %))\n                   size-pred)\n                 (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                                    num-elements hard-min-elements max-tries ex-fn)))))))))))\n\n;; I tried to reduce the duplication in these docstrings with a macro,\n;; but couldn't make it work in cljs.\n\n(defn vector-distinct\n  \"Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (vector-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to vector-distinct must be a generator!\")\n   (coll-distinct-by [] identity true true gen opts)))\n\n(defn list-distinct\n  \"Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (list-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to list-distinct must be a generator!\")\n   (coll-distinct-by () identity true true gen opts)))\n\n(defn vector-distinct-by\n  \"Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([key-fn gen] (vector-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) \"Second arg to vector-distinct-by must be a generator!\")\n   (coll-distinct-by [] key-fn true true gen opts)))\n\n(defn list-distinct-by\n  \"Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([key-fn gen] (list-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) \"Second arg to list-distinct-by must be a generator!\")\n   (coll-distinct-by () key-fn true true gen opts)))\n\n(defn set\n  \"Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (set gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to set must be a generator!\")\n   (coll-distinct-by #{} identity false false gen opts)))\n\n(defn sorted-set\n  \"Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (sorted-set gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to sorted-set must be a generator!\")\n   (coll-distinct-by (core/sorted-set) identity false false gen opts)))\n\n(defn map\n  \"Create a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception\"\n  ([key-gen val-gen] (map key-gen val-gen {}))\n  ([key-gen val-gen opts]\n   (coll-distinct-by {} first false false (tuple key-gen val-gen) opts)))\n\n;; large integers\n;; ---------------------------------------------------------------------------\n\n;; This approach has a few distribution edge cases, but is pretty good\n;; for expected uses and is way better than nothing.\n\n(def ^:private gen-raw-long\n  \"Generates a single uniformly random long, does not shrink.\"\n  (make-gen (fn [rnd _size]\n              (rose/pure (random/rand-long rnd)))))\n\n(def ^:private MAX_INTEGER\n  #?(:clj Long/MAX_VALUE :cljs (dec (apply * (repeat 53 2)))))\n(def ^:private MIN_INTEGER\n  #?(:clj Long/MIN_VALUE :cljs (- MAX_INTEGER)))\n\n(defn ^:private abs\n  [x]\n  #?(:clj (Math/abs (long x)) :cljs (Math/abs x)))\n\n(defn ^:private long->large-integer\n  [bit-count x min max]\n  (loop [res (-> x\n                 (#?(:clj bit-shift-right :cljs .shiftRight)\n                  (- 64 bit-count))\n                 #?(:cljs .toNumber)\n                 ;; so we don't get into an infinite loop bit-shifting\n                 ;; -1\n                 (cond-> (zero? min) (abs)))]\n    (if (<= min res max)\n      res\n      (core/let [res' (- res)]\n        (if (<= min res' max)\n          res'\n          (recur #?(:clj (bit-shift-right res 1)\n                    ;; emulating bit-shift-right\n                    :cljs (-> res\n                              (cond-> (odd? res)\n                                ((if (neg? res) inc dec)))\n                              (/ 2)))))))))\n\n(defn ^:private large-integer**\n  \"Like large-integer*, but assumes range includes zero.\"\n  [min max]\n  (sized (fn [size]\n           (core/let [size (core/max size 1) ;; no need to worry about size=0\n                      max-bit-count (core/min size #?(:clj 64 :cljs 54))]\n             (gen-fmap (fn [rose]\n                         (core/let [[bit-count x] (rose/root rose)]\n                           (int-rose-tree (long->large-integer bit-count x min max))))\n                       (tuple (choose 1 max-bit-count)\n                              gen-raw-long))))))\n\n(defn large-integer*\n  \"Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)\"\n  {:added \"0.9.0\"}\n  [{:keys [min max]}]\n  (core/let [min (or min MIN_INTEGER)\n             max (or max MAX_INTEGER)]\n    (assert (<= min max))\n    (such-that #(<= min % max)\n               (if (<= min 0 max)\n                 (large-integer** min max)\n                 (if (< max 0)\n                   (fmap #(+ max %) (large-integer** (- min max) 0))\n                   (fmap #(+ min %) (large-integer** 0 (- max min))))))))\n\n(def ^{:added \"0.9.0\"} large-integer\n  \"Generates a platform-native integer from the full available range\n  (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n  (2^53 - 1)).\n\n  Use large-integer* for more control.\"\n  (large-integer* {}))\n\n;; doubles\n;; ---------------------------------------------------------------------------\n\n\n;; This code is a lot more complex than any reasonable person would\n;; expect, for two reasons:\n;;\n;; 1) I wanted the generator to start with simple values and grow with\n;; the size parameter, as well as shrink back to simple values. I\n;; decided to define \"simple\" as numbers with simpler (closer to 0)\n;; exponents, with simpler fractional parts (fewer lower-level bits\n;; set), and with positive being simpler than negative. I also wanted\n;; to take optional min/max parameters, which complicates the hell out\n;; of things.\n;;\n;; 2) It works in CLJS as well, which has fewer utility functions for\n;; doubles, and I wanted it to work exactly the same way in CLJS just\n;; to validate the whole cross-platform situation. It should generate\n;; the exact same numbers on both platforms.\n;;\n;; Some of the lower level stuff could probably be less messy and\n;; faster, especially for CLJS.\n\n(def ^:private POS_INFINITY #?(:clj Double/POSITIVE_INFINITY, :cljs (.-POSITIVE_INFINITY js/Number)))\n(def ^:private NEG_INFINITY #?(:clj Double/NEGATIVE_INFINITY, :cljs (.-NEGATIVE_INFINITY js/Number)))\n(def ^:private MAX_POS_VALUE #?(:clj Double/MAX_VALUE, :cljs (.-MAX_VALUE js/Number)))\n(def ^:private MIN_NEG_VALUE (- MAX_POS_VALUE))\n(def ^:private NAN #?(:clj Double/NaN, :cljs (.-NaN js/Number)))\n\n(defn ^:private uniform-integer\n  \"Generates an integer uniformly in the range 0..(2^bit-count-1).\"\n  [bit-count]\n  {:assert [(<= 0 bit-count 52)]}\n  (if (<= bit-count 32)\n    ;; the case here is just for cljs\n    (choose 0 (case (long bit-count)\n                32 0xffffffff\n                31 0x7fffffff\n                (-> 1 (bit-shift-left bit-count) dec)))\n    (fmap (fn [[upper lower]]\n            #? (:clj\n                (-> upper (bit-shift-left 32) (+ lower))\n\n                :cljs\n                (-> upper (* 0x100000000) (+ lower))))\n          (tuple (uniform-integer (- bit-count 32))\n                 (uniform-integer 32)))))\n\n(defn ^:private scalb\n  [x exp]\n  #?(:clj (Math/scalb ^double x ^int exp)\n     :cljs (* x (.pow js/Math 2 exp))))\n\n(defn ^:private fifty-two-bit-reverse\n  \"Bit-reverses an integer in the range [0, 2^52).\"\n  [n]\n  #? (:clj\n      (-> n (Long/reverse) (unsigned-bit-shift-right 12))\n\n      :cljs\n      (loop [out 0\n             n n\n             out-shifter (Math/pow 2 52)]\n        (if (< n 1)\n          (* out out-shifter)\n          (recur (-> out (* 2) (+ (bit-and n 1)))\n                 (/ n 2)\n                 (/ out-shifter 2))))))\n\n(def ^:private backwards-shrinking-significand\n  \"Generates a 52-bit non-negative integer that shrinks toward having\n  fewer lower-order bits (and shrinks to 0 if possible).\"\n  (fmap fifty-two-bit-reverse\n        (sized (fn [size]\n                 (gen-bind (choose 0 (min size 52))\n                           (fn [rose]\n                             (uniform-integer (rose/root rose))))))))\n\n(defn ^:private get-exponent\n  [x]\n  #? (:clj\n      (Math/getExponent ^Double x)\n\n      :cljs\n      (if (zero? x)\n        -1023\n        (core/let [x (Math/abs x)\n\n                   res\n                   (Math/floor (* (Math/log x) (.-LOG2E js/Math)))\n\n                   t (scalb x (- res))]\n          (cond (< t 1) (dec res)\n                (<= 2 t) (inc res)\n                :else res)))))\n\n(defn ^:private double-exp-and-sign\n  \"Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds.\"\n  [lower-bound upper-bound]\n  (letfn [(gen-exp [lb ub]\n            (sized (fn [size]\n                     (core/let [qs8 (bit-shift-left 1 (quot (min 200 size) 8))]\n                       (cond (<= lb 0 ub)\n                             (choose (max lb (- qs8)) (min ub qs8))\n\n                             (< ub 0)\n                             (choose (max lb (- ub qs8)) ub)\n\n                             :else\n                             (choose lb (min ub (+ lb qs8))))))))]\n    (if (and (nil? lower-bound)\n             (nil? upper-bound))\n      (tuple (gen-exp -1023 1023)\n             (elements [1.0 -1.0]))\n      (core/let [lower-bound (or lower-bound MIN_NEG_VALUE)\n                 upper-bound (or upper-bound MAX_POS_VALUE)\n                 lbexp (max -1023 (get-exponent lower-bound))\n                 ubexp (max -1023 (get-exponent upper-bound))]\n        (cond (<= 0.0 lower-bound)\n              (tuple (gen-exp lbexp ubexp)\n                     (return 1.0))\n\n              (<= upper-bound 0.0)\n              (tuple (gen-exp ubexp lbexp)\n                     (return -1.0))\n\n              :else\n              (fmap (fn [[exp sign :as pair]]\n                      (if (or (and (neg? sign) (< lbexp exp))\n                              (and (pos? sign) (< ubexp exp)))\n                        [exp (- sign)]\n                        pair))\n                    (tuple\n                     (gen-exp -1023 (max ubexp lbexp))\n                     (elements [1.0 -1.0]))))))))\n\n(defn ^:private block-bounds\n  \"Returns [low high], the smallest and largest numbers in the given\n  range.\"\n  [exp sign]\n  (if (neg? sign)\n    (core/let [[low high] (block-bounds exp (- sign))]\n      [(- high) (- low)])\n    (if (= -1023 exp)\n      [0.0 (-> 1.0 (scalb 52) dec (scalb -1074))]\n      [(scalb 1.0 exp)\n       (-> 1.0 (scalb 52) dec (scalb (- exp 51)))])))\n\n(defn ^:private double-finite\n  [lower-bound upper-bound]\n  {:pre [(or (nil? lower-bound)\n             (nil? upper-bound)\n             (<= lower-bound upper-bound))]}\n  (core/let [pred (if lower-bound\n                    (if upper-bound\n                      #(<= lower-bound % upper-bound)\n                      #(<= lower-bound %))\n                    (if upper-bound\n                      #(<= % upper-bound)))\n\n             gen\n             (fmap (fn [[[exp sign] significand]]\n                     (core/let [;; 1.0 <= base < 2.0\n                                base (inc (/ significand (Math/pow 2 52)))\n                                x (-> base (scalb exp) (* sign))]\n                       (if (or (nil? pred) (pred x))\n                         x\n                         ;; Scale things a bit when we have a partial range\n                         ;; to deal with. It won't be great for generating\n                         ;; simple numbers, but oh well.\n                         (core/let [[low high] (block-bounds exp sign)\n\n                                    block-lb (cond-> low  lower-bound (max lower-bound))\n                                    block-ub (cond-> high upper-bound (min upper-bound))\n                                    x (+ block-lb (* (- block-ub block-lb) (- base 1)))]\n                           (-> x (min block-ub) (max block-lb))))))\n                   (tuple (double-exp-and-sign lower-bound upper-bound)\n                          backwards-shrinking-significand))]\n    ;; wrapping in the such-that is necessary for staying in bounds\n    ;; during shrinking\n    (cond->> gen pred (such-that pred))))\n\n(defn double*\n  \"Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity.\"\n  {:added \"0.9.0\"}\n  [{:keys [infinite? NaN? min max]\n    :or {infinite? true, NaN? true}}]\n  (core/let [frequency-arg (cond-> [[95 (double-finite min max)]]\n\n                             (if (nil? min)\n                               (or (nil? max) (<= 0.0 max))\n                               (if (nil? max)\n                                 (<= min 0.0)\n                                 (<= min 0.0 max)))\n                             (conj\n                              ;; Add zeros here as a special case, since\n                              ;; the `finite` code considers zeros rather\n                              ;; complex (as they have a -1023 exponent)\n                              ;;\n                              ;; I think most uses can't distinguish 0.0\n                              ;; from -0.0, but seems worth throwing both\n                              ;; in just in case.\n                              [1 (return 0.0)]\n                              [1 (return -0.0)])\n\n                             (and infinite? (nil? max))\n                             (conj [1 (return POS_INFINITY)])\n\n                             (and infinite? (nil? min))\n                             (conj [1 (return NEG_INFINITY)])\n\n                             NaN? (conj [1 (return NAN)]))]\n    (if (= 1 (count frequency-arg))\n      (-> frequency-arg first second)\n      (frequency frequency-arg))))\n\n(def ^{:added \"0.9.0\"} double\n  \"Generates 64-bit floating point numbers from the entire range,\n  including +/- infinity and NaN. Use double* for more control.\"\n  (double* {}))\n\n;; Characters & Strings\n;; ---------------------------------------------------------------------------\n\n(def char\n  \"Generates character from 0-255.\"\n  (fmap core/char (choose 0 255)))\n\n(def char-ascii\n  \"Generate only ascii character.\"\n  (fmap core/char (choose 32 126)))\n\n(def char-alphanumeric\n  \"Generate alphanumeric characters.\"\n  (fmap core/char\n        (one-of [(choose 48 57)\n                 (choose 65 90)\n                 (choose 97 122)])))\n\n(def ^{:deprecated \"0.6.0\"}\n  char-alpha-numeric\n  \"Deprecated - use char-alphanumeric instead.\n\n  Generate alphanumeric characters.\"\n  char-alphanumeric)\n\n(def char-alpha\n  \"Generate alpha characters.\"\n  (fmap core/char\n        (one-of [(choose 65 90)\n                 (choose 97 122)])))\n\n(def ^:private char-symbol-special\n  \"Generate non-alphanumeric characters that can be in a symbol.\"\n  (elements [\\* \\+ \\! \\- \\_ \\? \\.]))\n\n(def ^:private char-symbol-noninitial\n  \"Generate characters that can be the char following first of a keyword or symbol.\"\n  (frequency [[14 char-alphanumeric]\n              [7 char-symbol-special]\n              [1 (return \\:)]]))\n\n(def ^:private char-symbol-initial\n  \"Generate characters that can be the first char of a keyword or symbol.\"\n  (frequency [[2 char-alpha]\n              [1 char-symbol-special]]))\n\n(def string\n  \"Generate strings. May generate unprintable characters.\"\n  (fmap clojure.string/join (vector char)))\n\n(def string-ascii\n  \"Generate ascii strings.\"\n  (fmap clojure.string/join (vector char-ascii)))\n\n(def string-alphanumeric\n  \"Generate alphanumeric strings.\"\n  (fmap clojure.string/join (vector char-alphanumeric)))\n\n(def ^{:deprecated \"0.6.0\"}\n  string-alpha-numeric\n  \"Deprecated - use string-alphanumeric instead.\n\n  Generate alphanumeric strings.\"\n  string-alphanumeric)\n\n(defn- digit?\n  [d]\n  #?(:clj  (Character/isDigit ^Character d)\n     :cljs (gstring/isNumeric d)))\n\n(defn- +-or---digit?\n  \"Returns true if c is \\\\+ or \\\\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers.\"\n  [c d]\n  (core/boolean (and d\n                     (or (#?(:clj = :cljs identical?) \\+ c)\n                         (#?(:clj = :cljs identical?) \\- c))\n                     (digit? d))))\n\n(def ^:private symbol-name-or-namespace\n  \"Generates a namespace string for a symbol/keyword.\"\n  (->> (tuple char-symbol-initial (vector char-symbol-noninitial))\n       (such-that (fn [[c [d]]] (not (+-or---digit? c d))))\n       (fmap (fn [[c cs]]\n               (core/let [s (clojure.string/join (cons c cs))]\n                 (-> s\n                     (string/replace #\":{2,}\" \":\")\n                     (string/replace #\":$\" \"\")))))))\n\n(defn ^:private resize-symbolish-generator\n  \"Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable.\"\n  [g]\n  ;; function chosen by ad-hoc experimentation\n  (scale #(long (Math/pow % 0.60)) g))\n\n(def keyword\n  \"Generate keywords without namespaces.\"\n  (frequency [[100\n               (->> symbol-name-or-namespace\n                    (fmap core/keyword)\n                    (resize-symbolish-generator))]\n              [1 (return :/)]]))\n\n(def\n  ^{:added \"0.5.9\"}\n  keyword-ns\n  \"Generate keywords with namespaces.\"\n  (->> (tuple symbol-name-or-namespace symbol-name-or-namespace)\n       (fmap (fn [[ns name]] (core/keyword ns name)))\n       (resize-symbolish-generator)))\n\n(def symbol\n  \"Generate symbols without namespaces.\"\n  (frequency [[100\n               (->> symbol-name-or-namespace\n                    (fmap core/symbol)\n                    (resize-symbolish-generator))]\n              [1 (return '/)]]))\n\n(def\n  ^{:added \"0.5.9\"}\n  symbol-ns\n  \"Generate symbols with namespaces.\"\n  (->> (tuple symbol-name-or-namespace symbol-name-or-namespace)\n       (fmap (fn [[ns name]] (core/symbol ns name)))\n       (resize-symbolish-generator)))\n\n(def ratio\n  \"Generates a `clojure.lang.Ratio`. Shrinks toward 0. Not all values generated\n  will be ratios, as many values returned by `/` are not ratios.\"\n  (fmap\n   (fn [[a b]] (/ a b))\n   (tuple int\n          (such-that (complement zero?) int))))\n\n(def ^{:added \"0.9.0\"} uuid\n  \"Generates a random type-4 UUID. Does not shrink.\"\n  (no-shrink\n   #?(:clj\n      ;; this could be done with combinators, but doing it low-level\n      ;; seems to be 10x faster\n      (make-gen\n       (fn [rng _size]\n         (core/let [[r1 r2] (random/split rng)\n                    x1 (-> (random/rand-long r1)\n                           (bit-and -45057)\n                           (bit-or 0x4000))\n                    x2 (-> (random/rand-long r2)\n                           (bit-or -9223372036854775808)\n                           (bit-and -4611686018427387905))]\n           (rose/make-rose\n            (java.util.UUID. x1 x2)\n            []))))\n\n      :cljs\n      ;; this could definitely be optimized so that it doesn't require\n      ;; generating 31 numbers\n      (fmap (fn [nibbles]\n              (letfn [(hex [idx] (.toString (nibbles idx) 16))]\n                (core/let [rhex (-> (nibbles 15) (bit-and 3) (+ 8) (.toString 16))]\n                  (core/uuid (str (hex 0)  (hex 1)  (hex 2)  (hex 3)\n                                  (hex 4)  (hex 5)  (hex 6)  (hex 7)  \"-\"\n                                  (hex 8)  (hex 9)  (hex 10) (hex 11) \"-\"\n                                  \"4\"      (hex 12) (hex 13) (hex 14) \"-\"\n                                  rhex     (hex 16) (hex 17) (hex 18) \"-\"\n                                  (hex 19) (hex 20) (hex 21) (hex 22)\n                                  (hex 23) (hex 24) (hex 25) (hex 26)\n                                  (hex 27) (hex 28) (hex 29) (hex 30))))))\n            (vector (choose 0 15) 31)))))\n\n(def simple-type\n  (one-of [int large-integer double char string ratio boolean keyword\n           keyword-ns symbol symbol-ns uuid]))\n\n(def simple-type-printable\n  (one-of [int large-integer double char-ascii string-ascii ratio boolean\n           keyword keyword-ns symbol symbol-ns uuid]))\n\n#?(:cljs\n;; http://dev.clojure.org/jira/browse/CLJS-1594\n   (defn ^:private hashable?\n     [x]\n     (if (number? x)\n       (not (or (js/isNaN x)\n                (= NEG_INFINITY x)\n                (= POS_INFINITY x)))\n       true)))\n\n(defn container-type\n  [inner-type]\n  (one-of [(vector inner-type)\n           (list inner-type)\n           (set #?(:clj inner-type\n                   :cljs (such-that hashable? inner-type)))\n           ;; scaling this by half since it naturally generates twice\n           ;; as many elements\n           (scale #(quot % 2)\n                  (map #?(:clj inner-type\n                          :cljs (such-that hashable? inner-type))\n                       inner-type))]))\n\n;; A few helpers for recursive-gen\n\n(defn ^:private size->max-leaf-count\n  [size]\n  ;; chosen so that recursive-gen (with the assumptions mentioned in\n  ;; the comment below) will generate structures with leaf-node-counts\n  ;; not greater than the `size` ~99% of the time.\n  (long (Math/pow size 1.1)))\n\n(core/let [log2 (Math/log 2)]\n  (defn ^:private random-pseudofactoring\n    \"Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (<= (apply * xs) n).\"\n    [n rng]\n    (if (<= n 2)\n      [n]\n      (core/let [log (Math/log n)\n                 [r1 r2] (random/split rng)\n                 n1 (-> (random/rand-double r1)\n                        (* (- log log2))\n                        (+ log2)\n                        (Math/exp)\n                        (long))\n                 n2 (quot n n1)]\n        (if (and (< 1 n1) (< 1 n2))\n          (cons n1 (random-pseudofactoring n2 r2))\n          [n])))))\n\n(defn ^:private randomized\n  \"Like sized, but passes an rng instead of a size.\"\n  [func]\n  (make-gen (fn [rng size]\n              (core/let [[r1 r2] (random/split rng)]\n                (call-gen\n                 (func r1)\n                 r2\n                 size)))))\n\n(defn\n  ^{:added \"0.5.9\"}\n  recursive-gen\n  \"This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/int]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))\"\n  [container-gen-fn scalar-gen]\n  (assert (generator? scalar-gen)\n          \"Second arg to recursive-gen must be a generator\")\n  ;; The trickiest part about this is sizing. The strategy here is to\n  ;; assume that the container generators will (like the normal\n  ;; collection generators in this namespace) have a size bounded by\n  ;; the `size` parameter, and with that assumption we can give an\n  ;; upper bound to the total number of leaf nodes in the generated\n  ;; structure.\n  ;;\n  ;; So we first pick an upper bound, and pick it to be somewhat\n  ;; larger than the real `size` since on average they will be rather\n  ;; smaller. Then we factor that upper bound into integers to give us\n  ;; the size to use at each depth, assuming that the total size\n  ;; should sort of be the product of the factored sizes.\n  ;;\n  ;; This is all a bit weird and hard to explain precisely but I think\n  ;; it works reasonably and definitely better than the old code.\n  (sized (fn [size]\n           (bind (choose 0 (size->max-leaf-count size))\n                 (fn [max-leaf-count]\n                   (randomized\n                    (fn [rng]\n                      (core/let [sizes (random-pseudofactoring max-leaf-count rng)\n                                 sized-scalar-gen (resize size scalar-gen)]\n                        (reduce (fn [g size]\n                                  (bind (choose 0 10)\n                                        (fn [x]\n                                          (if (zero? x)\n                                            sized-scalar-gen\n                                            (resize size\n                                                    (container-gen-fn g))))))\n                                sized-scalar-gen\n                                sizes)))))))))\n\n(def any\n  \"A recursive generator that will generate many different, often nested, values\"\n  (recursive-gen container-type simple-type))\n\n(def any-printable\n  \"Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command)\"\n  (recursive-gen container-type simple-type-printable))\n\n;; Macros\n;; ---------------------------------------------------------------------------\n\n(defmacro let\n  \"Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \\\"users\\\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))\"\n  {:added \"0.9.0\"}\n  [bindings & body]\n  (assert (vector? bindings)\n          \"First arg to gen/let must be a vector of bindings.\")\n  (assert (even? (count bindings))\n          \"gen/let requires an even number of forms in binding vector\")\n  (if (empty? bindings)\n    `(core/let [val# (do ~@body)]\n       (if (clojure.test.check.generators/generator? val#)\n         val#\n         (return val#)))\n    (core/let [[binding gen & more] bindings]\n      `(clojure.test.check.generators/bind ~gen (fn [~binding] (let [~@more] ~@body))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/data.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.data",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns \n  ^{:author \"Stuart Halloway\",\n    :doc \"Non-core data functions.\"}\n  clojure.data\n  (:require [clojure.set :as set]))\n\n(declare ^{:arglists '([a b])} diff)\n\n(defn- atom-diff\n  \"Internal helper for diff.\"\n  [a b]\n  (if (= a b) [nil nil a] [a b nil]))\n\n;; for big things a sparse vector class would be better\n(defn- vectorize\n  \"Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys\"\n  [m]\n  (when (seq m)\n    (reduce\n     (fn [result [k v]] (assoc result k v))\n     (vec (repeat (apply max (keys m))  nil))\n     m)))\n\n(defn- diff-associative-key\n  \"Diff associative things a and b, comparing only the key k.\"\n  [a b k]\n  (let [va (get a k)\n        vb (get b k)\n        [a* b* ab] (diff va vb)\n        in-a (contains? a k)\n        in-b (contains? b k)\n        same (and in-a in-b\n                  (or (not (nil? ab))\n                      (and (nil? va) (nil? vb))))]\n    [(when (and in-a (or (not (nil? a*)) (not same))) {k a*})\n     (when (and in-b (or (not (nil? b*)) (not same))) {k b*})\n     (when same {k ab})\n     ]))\n\n(defn- diff-associative\n  \"Diff associative things a and b, comparing only keys in ks (if supplied).\"\n  ([a b]\n     (diff-associative a b (set/union (keys a) (keys b))))\n  ([a b ks]\n     (reduce\n      (fn [diff1 diff2]\n        (doall (map merge diff1 diff2)))\n      [nil nil nil]\n      (map\n       (partial diff-associative-key a b)\n       ks))))\n\n(defn- diff-sequential\n  [a b]\n  (vec (map vectorize (diff-associative\n                       (if (vector? a) a (vec a))\n                       (if (vector? b) b (vec b))\n                       (range (max (count a) (count b)))))))\n\n(defn- diff-set\n  [a b]\n  [(not-empty (set/difference a b))\n   (not-empty (set/difference b a))\n   (not-empty (set/intersection a b))])\n\n(defprotocol EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))\n\n(defprotocol Diff\n  \"Implementation detail. Subject to change.\"\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))\n\n(extend-protocol EqualityPartition\n  nil\n  (equality-partition [x] :atom)\n\n  string\n  (equality-partition [x] :atom)\n\n  number\n  (equality-partition [x] :atom)\n\n  array\n  (equality-partition [x] :sequential)\n\n  function\n  (equality-partition [x] :atom)\n\n  boolean\n  (equality-partition [x] :atom)\n\n  default\n  (equality-partition [x]\n    (cond\n     (satisfies? IMap x) :map\n     (satisfies? ISet x) :set\n     (satisfies? ISequential x) :sequential\n     :default :atom)))\n\n(extend-protocol Diff\n  nil\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  string\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  number\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  array\n  (diff-similar [a b]\n    (diff-sequential a b))\n\n  function\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  boolean\n  (diff-similar [a b]\n    (atom-diff a b))\n\n  default\n  (diff-similar [a b]\n    ((case (equality-partition a)\n       :atom atom-diff\n       :set diff-set\n       :sequential diff-sequential\n       :map diff-associative)\n     a b)))\n\n(defn diff\n  \"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.\"\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))\n  \n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/env/macros.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.env.macros",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.env.macros\n  (:refer-clojure :exclude [binding ensure]))\n\n(defmacro with-compiler-env\n   \"Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n this namespace.\"\n  [env & body]\n   `(let [env# ~env\n          env# (cond\n                 (map? env#) (atom env#)\n                 (and (instance? cljs.core/Atom env#) (map? @env#)) env#\n                 :default\n                 (throw\n                   (js/Error.\n                     (str \"Compiler environment must be a map or atom containing a map, not \"\n                       (type env#)))))]\n      (cljs.core/binding [cljs.env/*compiler* env#]\n        ~@body)))\n\n(defmacro ensure\n  [& body]\n  `(let [val# cljs.env/*compiler*]\n     (when (nil? val#)\n       (set! cljs.env/*compiler* (cljs.env/default-compiler-env)))\n     (try\n       ~@body\n       (finally\n         (when (nil? val#)\n           (set! cljs.env/*compiler* nil))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/core/reducers.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.core.reducers",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc\n      \"A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.\"\n      :author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [cljs.core :as core]))\n\n;;;;;;;;;;;;;; some fj stuff ;;;;;;;;;;\n(defn- fjtask [f]\n  f)\n\n(defn- fjinvoke [f]\n  (f))\n\n(defn- fjfork [task]\n  task)\n\n(defn- fjjoin [task]\n  (task))\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn reduce\n  \"Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv\"\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (#'array-reduce coll f init)\n         :else (-reduce coll f init)))))\n\n(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))\n\n(defn fold\n  \"Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented.\"\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))\n\n(defn reducer\n  \"Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))\n\n(defn folder\n  \"Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))\n\n(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))\n\n(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))\n\n(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))\n\n(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))\n\n(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))\n\n(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))\n\n(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))\n\n(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))\n\n;;do not construct this directly, use cat\n(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))\n\n(defn cat\n  \"A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.\"\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))\n\n(defn append!\n  \".adds x to acc and returns acc\"\n  [acc x]\n  (doto acc (.push x)))\n\n(defn foldcat\n  \"Equivalent to (fold cat append! coll)\"\n  [coll]\n  (fold cat append! coll))\n\n(defn monoid\n  \"Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.\"\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(comment\n(require '[clojure.core.reduce :as r])\n(def v (take 1000000 (range)))\n(reduce + 0 (r/map inc [1 2 3 4]))\n(into [] (r/take 12 (range 100)))\n(into [] (r/drop 12 (range 100)))\n(reduce + 0 (r/filter even? [1 2 3 4]))\n(into [] (r/filter even? [1 2 3 4]))\n(reduce + (filter even? [1 2 3 4]))\n(dotimes [_ 10] (time (reduce + 0 (r/map inc v))))\n(dotimes [_ 10] (time (reduce + 0 (map inc v))))\n(dotimes [_ 100] (time (reduce + 0 v)))\n(dotimes [_ 100] (time (reduce + 0 v)))\n(dotimes [_ 20] (time (reduce + 0 (r/map inc (r/filter even? v)))))\n(dotimes [_ 20] (time (reduce + 0 (map inc (filter even? v)))))\n(reduce + 0 (r/take-while even? [2 4 3]))\n(into [] (r/filter even? (r/flatten (r/remove #{4} [[1 2 3] 4 [5 [6 7 8]] [9] 10]))))\n(into [] (r/flatten nil))\n)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fold impls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- foldvec\n  [v n combinef reducef]\n  (cond\n   (empty? v) (combinef)\n   (<= (count v) n) (reduce reducef (combinef) v)\n   :else\n   (let [split (quot (count v) 2)\n         v1 (subvec v 0 split)\n         v2 (subvec v split (count v))\n         fc (fn [child] #(foldvec child n combinef reducef))]\n     (fjinvoke\n      #(let [f1 (fc v1)\n             t2 (fjtask (fc v2))]\n         (fjfork t2)\n         (combinef (f1) (fjjoin t2)))))))\n\n(extend-protocol CollFold\n nil\n (coll-fold\n  [coll n combinef reducef]\n  (combinef))\n\n object\n (coll-fold\n  [coll n combinef reducef]\n  ;;can't fold, single reduce\n  (reduce reducef (combinef) coll))\n\n cljs.core/PersistentVector\n (coll-fold\n  [v n combinef reducef]\n  (foldvec v n combinef reducef))\n\n #_\n cljs.core/PersistentHashMap\n #_\n (coll-fold\n  [m n combinef reducef]\n  (.fold m n combinef reducef fjinvoke fjtask fjfork fjjoin)))\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader/reader_types.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader.reader-types",new cljs.core.Keyword(null,"source","source",-433931539),";;   Copyright (c) Nicola Mometto, Rich Hickey & contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"Protocols and default Reader types implementation\"\n      :author \"Bronsa\"}\n  cljs.tools.reader.reader-types\n  (:refer-clojure :exclude [char read-line])\n  (:require [cljs.tools.reader.impl.utils :refer [char whitespace? newline?]]\n            [goog.string])\n  (:import goog.string.StringBuffer))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; reader protocols\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defprotocol Reader\n  (read-char [reader]\n    \"Returns the next char from the Reader, nil if the end of stream has been reached\")\n  (peek-char [reader]\n    \"Returns the next char from the Reader without removing it from the reader stream\"))\n\n(defprotocol IPushbackReader\n  (unread [reader ch]\n    \"Pushes back a single character on to the stream\"))\n\n(defprotocol IndexingReader\n  (get-line-number [reader]\n    \"Returns the line number of the next character to be read from the stream\")\n  (get-column-number [reader]\n    \"Returns the column number of the next character to be read from the stream\")\n  (get-file-name [reader]\n    \"Returns the file name the reader is reading from, or nil\"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; reader deftypes\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(deftype StringReader\n    [s s-len ^:mutable s-pos]\n  Reader\n  (read-char [reader]\n    (when (> s-len s-pos)\n      (let [r (.charAt s s-pos)]\n        (set! s-pos (inc s-pos))\n        r)))\n  (peek-char [reader]\n    (when (> s-len s-pos)\n      (.charAt s s-pos))))\n\n(deftype NodeReadableReader [readable ^:mutable buf]\n  Reader\n  (read-char [reader]\n    (if buf\n      (let [c (aget buf 0)]\n        (set! buf nil)\n        (char c))\n      (let [c (str (.read readable 1))]\n        (when c\n          (char c)))))\n  (peek-char [reader]\n    (when-not buf\n      (set! buf (str (.read readable 1))))\n    (when buf\n      (char (aget buf 0)))))\n\n(deftype PushbackReader\n  [^not-native rdr buf buf-len ^:mutable buf-pos]\n  Reader\n  (read-char [reader]\n    (let [c (if (< buf-pos buf-len)\n              (aget buf buf-pos)\n              (read-char rdr))]\n      (when (< buf-pos buf-len)\n        (set! buf-pos (inc buf-pos)))\n      (char c)))\n  (peek-char [reader]\n    (let [c (if (< buf-pos buf-len)\n              (aget buf buf-pos)\n              (peek-char rdr))]\n      (char c)))\n  IPushbackReader\n  (unread [reader ch]\n    (when ch\n      (if (zero? buf-pos) (throw (js/Error. \"Pushback buffer is full\")))\n      (set! buf-pos (dec buf-pos))\n      (aset buf buf-pos ch))))\n\n(defn- normalize-newline [^not-native rdr ch]\n  (if (identical? \\return ch)\n    (let [c (peek-char rdr)]\n      (when (or (identical? \\formfeed c)\n                (identical? \\newline c))\n        (read-char rdr))\n      \\newline)\n    ch))\n\n(deftype IndexingPushbackReader\n    [^not-native rdr ^:mutable line ^:mutable column\n     ^:mutable line-start? ^:mutable prev\n     ^:mutable prev-column file-name]\n  Reader\n  (read-char [reader]\n    (when-let [ch (read-char rdr)]\n      (let [ch (normalize-newline rdr ch)]\n        (set! prev line-start?)\n        (set! line-start? (newline? ch))\n        (when line-start?\n          (set! prev-column column)\n          (set! column 0)\n          (set! line (inc line)))\n        (set! column (inc column))\n        ch)))\n\n  (peek-char [reader]\n    (peek-char rdr))\n\n  IPushbackReader\n  (unread [reader ch]\n    (if line-start?\n      (do (set! line (dec line))\n          (set! column prev-column))\n      (set! column (dec column)))\n    (set! line-start? prev)\n    (unread rdr ch))\n\n  IndexingReader\n  (get-line-number [reader] (int line))\n  (get-column-number [reader] (int column))\n  (get-file-name [reader] file-name))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Source Logging support\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn merge-meta\n  \"Returns an object of the same type and value as `obj`, with its\nmetadata merged over `m`.\"\n  [obj m]\n  (let [orig-meta (meta obj)]\n    (with-meta obj (merge m (dissoc orig-meta :source)))))\n\n(defn- peek-source-log\n  \"Returns a string containing the contents of the top most source\nlogging frame.\"\n  [frames]\n  (subs (str (:buffer frames)) (first (:offset frames))))\n\n(defn- log-source-char\n  \"Logs `char` to all currently active source logging frames.\"\n  [frames char]\n  (when-let [buffer (:buffer frames)]\n    (.append buffer char)))\n\n(defn- drop-last-logged-char\n  \"Removes the last logged character from all currently active source\nlogging frames. Called when pushing a character back.\"\n  [frames]\n  (when-let [buffer (:buffer frames)]\n    (.set buffer (subs (str buffer) 0 (dec (.getLength buffer))))))\n\n(deftype SourceLoggingPushbackReader\n    [^not-native rdr ^:mutable line ^:mutable column\n     ^:mutable line-start? ^:mutable prev\n     ^:mutable prev-column file-name frames]\n  Reader\n  (read-char [reader]\n    (when-let [ch (read-char rdr)]\n      (let [ch (normalize-newline rdr ch)]\n        (set! prev line-start?)\n        (set! line-start? (newline? ch))\n        (when line-start?\n          (set! prev-column column)\n          (set! column 0)\n          (set! line (inc line)))\n        (set! column (inc column))\n        (log-source-char @frames ch)\n        ch)))\n\n  (peek-char [reader]\n    (peek-char rdr))\n\n  IPushbackReader\n  (unread [reader ch]\n    (if line-start?\n      (do (set! line (dec line))\n          (set! column prev-column))\n      (set! column (dec column)))\n    (set! line-start? prev)\n    (when ch\n      (drop-last-logged-char @frames))\n    (unread rdr ch))\n\n  IndexingReader\n  (get-line-number [reader] (int line))\n  (get-column-number [reader] (int column))\n  (get-file-name [reader] file-name))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Public API\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n;; fast check for provided implementations\n(defn indexing-reader?\n  \"Returns true if the reader satisfies IndexingReader\"\n  [rdr]\n  (implements? IndexingReader rdr))\n\n(defn string-reader\n  \"Creates a StringReader from a given string\"\n  ([s]\n     (StringReader. s (count s) 0)))\n\n(defn string-push-back-reader\n  \"Creates a PushbackReader from a given string\"\n  ([s]\n     (string-push-back-reader s 1))\n  ([s buf-len]\n     (PushbackReader. (string-reader s) (object-array buf-len) buf-len buf-len)))\n\n(defn node-readable-push-back-reader [readable]\n  (PushbackReader. (NodeReadableReader. readable nil) (object-array 1) 1 1))\n\n(defn indexing-push-back-reader\n  \"Creates an IndexingPushbackReader from a given string or PushbackReader\"\n  ([s-or-rdr]\n     (indexing-push-back-reader s-or-rdr 1))\n  ([s-or-rdr buf-len]\n     (indexing-push-back-reader s-or-rdr buf-len nil))\n  ([s-or-rdr buf-len file-name]\n     (IndexingPushbackReader.\n      (if (string? s-or-rdr) (string-push-back-reader s-or-rdr buf-len) s-or-rdr) 1 1 true nil 0 file-name)))\n\n(defn source-logging-push-back-reader\n  \"Creates a SourceLoggingPushbackReader from a given string or PushbackReader\"\n  ([s-or-rdr]\n     (source-logging-push-back-reader s-or-rdr 1))\n  ([s-or-rdr buf-len]\n     (source-logging-push-back-reader s-or-rdr buf-len nil))\n  ([s-or-rdr buf-len file-name]\n     (SourceLoggingPushbackReader.\n      (if (string? s-or-rdr) (string-push-back-reader s-or-rdr buf-len) s-or-rdr)\n      1\n      1\n      true\n      nil\n      0\n      file-name\n      (atom {:buffer (StringBuffer.) :offset '(0)}))))\n\n(defn read-line\n  \"Reads a line from the reader or from *in* if no reader is specified\"\n  ([^not-native rdr]\n     (loop [c (read-char rdr) s (StringBuffer.)]\n       (if (newline? c)\n         (str s)\n         (recur (read-char rdr) (.append s c))))))\n\n(defn ^boolean source-logging-reader?\n  [rdr]\n  (instance? SourceLoggingPushbackReader rdr))\n\n(defn ^boolean line-start?\n  \"Returns true if rdr is an IndexingReader and the current char starts a new line\"\n  [^not-native rdr]\n  (when (indexing-reader? rdr)\n    (== 1 (get-column-number rdr))))\n\n(defn log-source*\n  [reader f]\n  (let [buffer (:buffer @(.-frames reader))]\n    (try\n      (swap! (.-frames reader) update-in [:offset] conj (.getLength buffer))\n      (let [ret (f)]\n        (if (implements? IMeta ret)\n          (merge-meta ret {:source (peek-source-log @ (.-frames reader))})\n          ret))\n      (finally\n        (swap! (.-frames reader) update-in [:offset] rest)))))\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/analyzer/api.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.analyzer.api",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.analyzer.api\n  \"This is intended to be a stable api for those who need programmatic access\n  to the analyzer.\"\n  (:refer-clojure :exclude [all-ns ns-interns ns-resolve resolve find-ns\n                            ns-publics remove-ns])\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]))\n\n;; =============================================================================\n;; Useful Utilities\n\n(defn empty-state\n  \"Creates an empty compilation state Atom<Map>.\"\n  []\n  (env/default-compiler-env))\n\n(defmacro with-state\n  \"Run the body with the given compilation state Atom<Map>.\"\n  [state body]\n  `(env/with-compiler-env ~state\n     ~@body))\n\n(defn empty-env\n  \"Creates an empty analysis environment.\"\n  []\n  (ana/empty-env))\n\n(defmacro no-warn\n  \"Disable analyzer warnings for any analysis executed in body.\"\n  [& body]\n  (let [no-warnings (zipmap (keys ana/*cljs-warnings*) (repeat false))]\n    `(binding [ana/*cljs-warnings* ~no-warnings]\n       ~@body)))\n\n(defn warning-enabled?\n  \"Test if the given warning-type is enabled.\"\n  [warning-type]\n  (ana/*cljs-warnings* warning-type))\n\n(defn default-warning-handler\n  \"The default warning handler.\n\n   Outputs the warning messages to *err*.\"\n  [warning-type env extra]\n  (ana/default-warning-handler warning-type env extra))\n\n(defn get-options\n  \"Return the compiler options from compiler state.\"\n  ([] (get-options env/*compiler*))\n  ([state]\n   (get @state :options)))\n\n(defn get-js-index\n  \"Return the currently computed Google Closure js dependency index from the\n  compiler state.\"\n  ([] (get-options env/*compiler*))\n  ([state]\n   (get @state :js-dependency-index)))\n\n#?(:clj\n   (defn analyze\n     \"Given an environment, a map containing {:locals (mapping of names to bindings), :context\n     (one of :statement, :expr, :return), :ns (a symbol naming the\n     compilation ns)}, and form, returns an expression object (a map\n     containing at least :form, :op and :env keys). If expr has any (immediately)\n     nested exprs, must have :children entry. This must be a vector of keywords naming\n     the immediately nested fields mapped to an expr or vector of exprs. This will\n     facilitate code walking without knowing the details of the op set.\"\n     ([env form] (analyze env form nil))\n     ([env form name] (analyze env form name nil))\n     ([env form name opts]\n      (analyze\n        (if-not (nil? env/*compiler*)\n          env/*compiler*\n          (env/default-compiler-env opts))\n        env form name opts))\n     ([state env form name opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/analyze env form name opts))))))\n\n#?(:clj\n   (defn forms-seq\n     \"Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors.\"\n     ([rdr] (ana/forms-seq* rdr nil))\n     ([rdr filename] (ana/forms-seq* rdr filename))))\n\n#?(:clj\n   (defn parse-ns\n     \"Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n   \n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false.\"\n     ([src] (parse-ns src nil nil))\n     ([src opts] (parse-ns src nil opts))\n     ([src dest opts]\n      (parse-ns\n        (if-not (nil? env/*compiler*)\n          env/*compiler*\n          (env/default-compiler-env opts))\n        src dest opts))\n     ([state src dest opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/parse-ns src dest opts))))))\n#?(:clj\n   (defn analyze-file\n     \"Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n   \n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \\\":output-dir/some/ns/foo.cljs.cache.edn\\\". This function does not return a\n      meaningful value.\"\n     ([f] (analyze-file f nil))\n     ([f opts]\n      (analyze-file\n        (if-not (nil? env/*compiler*)\n          env/*compiler*\n          (env/default-compiler-env opts))\n        f opts))\n     ([state f opts]\n      (env/with-compiler-env state\n        (binding [ana/*cljs-warning-handlers* (:warning-handlers opts ana/*cljs-warning-handlers*)]\n          (ana/analyze-file f opts))))))\n\n;; =============================================================================\n;; Main API\n\n(defn resolve\n  \"Given an analysis environment resolve a var. Analogous to\n   clojure.core/resolve\"\n  [env sym]\n  {:pre [(map? env) (symbol? sym)]}\n  (try\n    (binding [ana/*private-var-access-nowarn* true]\n      (ana/resolve-var env sym\n        (ana/confirm-var-exists-throw)))\n    (catch #?(:clj Exception :cljs :default) e\n      (ana/resolve-macro-var env sym))))\n\n(defn all-ns\n  \"Return all namespaces. Analagous to clojure.core/all-ns but\n  returns symbols identifying namespaces not Namespace instances.\"\n  ([]\n   (all-ns env/*compiler*))\n  ([state]\n   (keys (get @state ::ana/namespaces))))\n\n(defn find-ns\n  \"Given a namespace return the corresponding namespace analysis map. Analagous\n  to clojure.core/find-ns.\"\n  ([sym]\n   (find-ns env/*compiler* sym))\n  ([state sym]\n   {:pre [(symbol? sym)]}\n   (get-in @state [::ana/namespaces sym])))\n\n(defn ns-interns\n  \"Given a namespace return all the var analysis maps. Analagous to\n  clojure.core/ns-interns but returns var analysis maps not vars.\"\n  ([ns]\n   (ns-interns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (merge\n     (get-in @state [::ana/namespaces ns :macros])\n     (get-in @state [::ana/namespaces ns :defs]))))\n\n(defn ns-publics\n  \"Given a namespace return all the public var analysis maps. Analagous to\n  clojure.core/ns-publics but returns var analysis maps not vars.\"\n  ([ns]\n   (ns-publics env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (->> (merge\n          (get-in @state [::ana/namespaces ns :macros])\n          (get-in @state [::ana/namespaces ns :defs]))\n        (remove (fn [[k v]] (:private v)))\n        (into {}))))\n\n(defn ns-resolve\n  \"Given a namespace and a symbol return the corresponding var analysis map.\n  Analagous to clojure.core/ns-resolve but returns var analysis map not Var.\"\n  ([ns sym]\n   (ns-resolve env/*compiler* ns sym))\n  ([state ns sym]\n   {:pre [(symbol? ns) (symbol? sym)]}\n   (get-in @state [::ana/namespaces ns :defs sym])))\n\n(defn remove-ns\n  \"Removes the namespace named by the symbol.\"\n  ([ns]\n   (remove-ns env/*compiler* ns))\n  ([state ns]\n   {:pre [(symbol? ns)]}\n   (swap! state update-in [::ana/namespaces] dissoc ns)))\n\n(defmacro in-cljs-user\n  \"Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\n  environment atom and runs body.\"\n  [env & body]\n  `(binding [cljs.analyzer/*cljs-ns* 'cljs.user]\n     (cljs.env/with-compiler-env ~env\n       ~@body)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/spec/test/alpha.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.spec.test.alpha",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.test.alpha\n  (:require\n    [cljs.analyzer :as ana]\n    [cljs.analyzer.api :as ana-api]\n    [clojure.string :as string]\n    [cljs.spec.alpha :as s]\n    [cljs.spec.gen.alpha :as gen]))\n\n(defonce ^:private instrumented-vars (atom #{}))\n\n(defn- collectionize\n  [x]\n  (if (symbol? x)\n    (list x)\n    x))\n\n(defn- enumerate-namespace* [sym-or-syms]\n  (into #{}\n    (mapcat\n      (fn [sym]\n        (->> (vals (ana-api/ns-interns sym))\n          (map :name)\n          (map\n            (fn [name-sym]\n              (symbol (name sym) (name name-sym)))))))\n    (collectionize sym-or-syms)))\n\n(defmacro enumerate-namespace\n  \"Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.\"\n  [ns-sym-or-syms]\n  `'~(enumerate-namespace* (eval ns-sym-or-syms)))\n\n(defn- fn-spec-name?\n  [s]\n  (symbol? s))\n\n(defmacro with-instrument-disabled\n  \"Disables instrument's checking of calls, within a scope.\"\n  [& body]\n  ;; Note: In order to read the value of this private var, we employ interop\n  ;; rather than derefing a var special. This eases specing core functions\n  ;; (and infinite recursion) by avoiding code generated by the var special,\n  ;; and also produces more compact / efficient code.\n  `(let [orig# (.-*instrument-enabled* js/cljs.spec.test.alpha)]\n     (set! *instrument-enabled* nil)\n     (try\n       ~@body\n       (finally\n         (set! *instrument-enabled* orig#)))))\n\n(defmacro instrument-1\n  [[quote s] opts]\n  (when-let [v (ana-api/resolve &env s)]\n    (let [var-name (:name v)]\n      (when (and (nil? (:const v))\n                 #?(:cljs (nil? (:macro v)))\n                 (contains? #?(:clj (s/speced-vars)\n                               :cljs (cljs.spec.alpha$macros/speced-vars))\n                            var-name))\n        (swap! instrumented-vars conj var-name)\n        `(let [checked# (#'instrument-1* '~s (var ~s) ~opts)]\n           (when checked# (set! ~s checked#))\n           '~var-name)))))\n\n(defmacro unstrument-1\n  [[quote s]]\n  (when-let [v (ana-api/resolve &env s)]\n    (when (@instrumented-vars (:name v))\n      (swap! instrumented-vars disj (:name v))\n      `(let [raw# (#'unstrument-1* '~s (var ~s))]\n         (when raw# (set! ~s raw#))\n         '~(:name v)))))\n\n(defn- sym-or-syms->syms [sym-or-syms]\n  (into []\n    (mapcat\n      (fn [sym]\n        (if (and (string/includes? (str sym) \".\")\n                 (ana-api/find-ns sym))\n          (->> (vals (ana-api/ns-interns sym))\n            (filter #(not (:macro %)))\n            (map :name)\n            (map\n              (fn [name-sym]\n                (symbol (name sym) (name name-sym)))))\n          [sym])))\n    (collectionize sym-or-syms)))\n\n(defn- form->sym-or-syms\n  \"Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.\"\n  [sym-or-syms]\n  (if (::no-eval (meta sym-or-syms))\n    (second sym-or-syms)\n    (eval sym-or-syms)))\n\n(defmacro instrument\n  \"Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.\"\n  ([]\n   `(instrument ^::no-eval '[~@(#?(:clj  s/speced-vars\n                                   :cljs cljs.spec.alpha$macros/speced-vars))]))\n  ([xs]\n   `(instrument ~xs nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms->syms (form->sym-or-syms sym-or-syms))\n         opts-sym (gensym \"opts\")]\n     `(let [~opts-sym ~opts]\n        (reduce\n          (fn [ret# [_# f#]]\n            (let [sym# (f#)]\n              (cond-> ret# sym# (conj sym#))))\n          []\n          (->> (zipmap '~syms\n                 [~@(map\n                      (fn [sym]\n                        `(fn [] (instrument-1 '~sym ~opts-sym)))\n                      syms)])\n            (filter #((instrumentable-syms ~opts-sym) (first %)))\n            (distinct-by first)))))))\n\n(defmacro unstrument\n  \"Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.\"\n  ([]\n   `(unstrument ^::no-eval '[~@(deref instrumented-vars)]))\n  ([sym-or-syms]\n   (let [syms (sym-or-syms->syms (form->sym-or-syms sym-or-syms))]\n     `(reduce\n        (fn [ret# f#]\n          (let [sym# (f#)]\n            (cond-> ret# sym# (conj sym#))))\n        []\n        [~@(->> syms\n             (map\n               (fn [sym]\n                 (when (symbol? sym)\n                   `(fn []\n                      (unstrument-1 '~sym)))))\n             (remove nil?))]))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; testing  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defmacro check-1\n  [[quote s :as qs] f spec opts]\n  (let [{:keys [name] :as v} (when qs (ana-api/resolve &env s))]\n    `(let [s#        '~name\n           v#        ~(when v `(var ~name))\n           spec#     (or ~spec ~(when v `(s/get-spec (var ~name))))\n           re-inst?# (and v# (seq (unstrument '~name)) true)\n           f#        (or ~f (when v# @v#))\n           opts#     ~opts\n           old-tc-ns# \"clojure.test.check\"\n           old-tc-opts-key# (keyword old-tc-ns# \"opts\")\n           [tc-ns# opts#] (if-let [old-tc-opts# (get opts# old-tc-opts-key#)]\n                            [old-tc-ns# (assoc opts# :clojure.spec.test.check/opts\n                                               old-tc-opts#)]\n                            [\"clojure.spec.test.check\" opts#])]\n       (try\n         (cond\n           (nil? f#)\n           {:failure (ex-info \"No fn to spec\" {::s/failure :no-fn})\n            :sym     s# :spec spec#}\n\n           (:args spec#)\n           (let [tcret# (#'quick-check f# spec# opts#)]\n             (#'make-check-result s# spec# tcret#\n                                  (keyword tc-ns# \"ret\")))\n\n           :default\n           {:failure (ex-info \"No :args spec\" {::s/failure :no-args-spec})\n            :sym     s# :spec spec#})\n         (finally\n           (when re-inst?# (instrument '~name)))))))\n\n(defmacro check-fn\n  \"Runs generative tests for fn f using spec and opts. See\n'check' for options and return.\"\n  ([f spec]\n   `(check-fn ~f ~spec nil))\n  ([f spec opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (check-1 nil ~f ~spec opts#))))\n\n(defn- registry-ref []\n  #?(:clj  @#'s/registry-ref\n     :cljs cljs.spec.alpha$macros/registry-ref))\n\n(defn checkable-syms*\n  ([]\n    (checkable-syms* nil))\n  ([opts]\n   (reduce into #{}\n     [(filter fn-spec-name? (keys @(registry-ref)))\n      (keys (:spec opts))])))\n\n(defmacro checkable-syms\n  \"Given an opts map as per check, returns the set of syms that\ncan be checked.\"\n  ([]\n   `(checkable-syms nil))\n  ([opts]\n   `(let [opts# ~opts]\n      (validate-check-opts opts#)\n      (reduce conj #{}\n        '[~@(filter fn-spec-name? (keys @(registry-ref)))\n          ~@(keys (:spec opts))]))))\n\n(defmacro check\n  \"Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n\"\n  ([]\n   `(check ^::no-eval '~(checkable-syms*)))\n  ([sym-or-syms]\n   `(check ~sym-or-syms nil))\n  ([sym-or-syms opts]\n   (let [syms (sym-or-syms->syms (form->sym-or-syms sym-or-syms))\n         opts-sym (gensym \"opts\")]\n     `(if (and (cljs.core/exists? clojure.test.check)\n               (cljs.core/exists? clojure.test.check.properties))\n        (let [~opts-sym ~opts]\n          [~@(->> syms\n                  (filter (checkable-syms* opts))\n                  (map\n                   (fn [sym]\n                     (do `(check-1 '~sym nil nil ~opts-sym)))))])\n        (throw\n         (js/Error. (str \"Require clojure.test.check and \"\n                         \"clojure.test.check.properties before calling check.\")))))))\n\n(defmacro ^:private maybe-setup-static-dispatch [f ret conform! arity]\n  (let [arity-accessor (symbol (str \".-cljs$core$IFn$_invoke$arity$\" arity))\n        argv (mapv #(symbol (str \"arg\" %)) (range arity))]\n    `(when-some [ac# (~arity-accessor ~f)]\n       (set! (~arity-accessor ~ret)\n             (fn ~argv\n               (if *instrument-enabled*\n                 (with-instrument-disabled\n                   (~conform! ~argv)\n                   (binding [*instrument-enabled* true]\n                     (ac# ~@argv)))\n                 (ac# ~@argv)))))))\n\n(defmacro ^:private setup-static-dispatches [f ret conform! max-arity]\n  ;; ret is for when we don't have arity info\n  `(do\n     ~@(mapv (fn [arity]\n               `(maybe-setup-static-dispatch ~f ~ret ~conform! ~arity))\n         (range (inc max-arity)))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/core.js",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs/core.js",new cljs.core.Keyword(null,"source","source",-433931539),"// Compiled by ClojureScript 1.10.520 {:static-fns true}\ngoog.provide('cljs.core');\ngoog.require('goog.math.Long');\ngoog.require('goog.math.Integer');\ngoog.require('goog.string');\ngoog.require('goog.object');\ngoog.require('goog.array');\ngoog.require('goog.Uri');\ngoog.require('goog.string.StringBuffer');\ncljs.core._STAR_clojurescript_version_STAR_ = \"1.10.520\";\ncljs.core._STAR_unchecked_if_STAR_ = false;\ncljs.core._STAR_unchecked_arrays_STAR_ = false;\ncljs.core._STAR_warn_on_infer_STAR_ = false;\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core.PROTOCOL_SENTINEL !== 'undefined')){\n} else {\ncljs.core.PROTOCOL_SENTINEL = ({});\n}\ncljs.core.MODULE_URIS = null;\ncljs.core.MODULE_INFOS = null;\n\n/** @define {string} */\ngoog.define(\"cljs.core._STAR_target_STAR_\",\"default\");\n/**\n * Var bound to the current namespace. Only used for bootstrapping.\n * @type {*}\n */\ncljs.core._STAR_ns_STAR_ = null;\n/**\n * @type {*}\n */\ncljs.core._STAR_out_STAR_ = null;\ncljs.core._STAR_assert_STAR_ = true;\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core._STAR_print_fn_STAR_ !== 'undefined')){\n} else {\n/**\n * Each runtime environment provides a different way to print output.\n *   Whatever function *print-fn* is bound to will be passed any\n *   Strings which should be printed.\n */\ncljs.core._STAR_print_fn_STAR_ = null;\n}\n/**\n * Arranges to have tap functions executed via the supplied f, a\n *   function of no arguments. Returns true if successful, false otherwise.\n */\ncljs.core._STAR_exec_tap_fn_STAR_ = (function cljs$core$_STAR_exec_tap_fn_STAR_(f){\nvar and__4120__auto__ = (typeof setTimeout !== 'undefined');\nif(and__4120__auto__){\nvar and__4120__auto____$1 = setTimeout(f,(0));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core._STAR_print_err_fn_STAR_ !== 'undefined')){\n} else {\n/**\n * Each runtime environment provides a different way to print error output.\n *   Whatever function *print-err-fn* is bound to will be passed any\n *   Strings which should be printed.\n */\ncljs.core._STAR_print_err_fn_STAR_ = null;\n}\n/**\n * Set *print-fn* to f.\n */\ncljs.core.set_print_fn_BANG_ = (function cljs$core$set_print_fn_BANG_(f){\nreturn cljs.core._STAR_print_fn_STAR_ = f;\n});\n/**\n * Set *print-err-fn* to f.\n */\ncljs.core.set_print_err_fn_BANG_ = (function cljs$core$set_print_err_fn_BANG_(f){\nreturn cljs.core._STAR_print_err_fn_STAR_ = f;\n});\n/**\n * When set to true, output will be flushed whenever a newline is printed.\n * \n *   Defaults to true.\n */\ncljs.core._STAR_flush_on_newline_STAR_ = true;\n/**\n * When set to logical false will drop newlines from printing calls.\n *   This is to work around the implicit newlines emitted by standard JavaScript\n *   console objects.\n */\ncljs.core._STAR_print_newline_STAR_ = true;\n/**\n * When set to logical false, strings and characters will be printed with\n *   non-alphanumeric characters converted to the appropriate escape sequences.\n * \n *   Defaults to true\n */\ncljs.core._STAR_print_readably_STAR_ = true;\n/**\n * If set to logical true, when printing an object, its metadata will also\n *   be printed in a form that can be read back by the reader.\n * \n *   Defaults to false.\n */\ncljs.core._STAR_print_meta_STAR_ = false;\n/**\n * When set to logical true, objects will be printed in a way that preserves\n *   their type when read in later.\n * \n *   Defaults to false.\n */\ncljs.core._STAR_print_dup_STAR_ = false;\n/**\n * *print-namespace-maps* controls whether the printer will print\n *   namespace map literal syntax.\n * \n *   Defaults to false, but the REPL binds it to true.\n */\ncljs.core._STAR_print_namespace_maps_STAR_ = false;\n/**\n * *print-length* controls how many items of each collection the\n *   printer will print. If it is bound to logical false, there is no\n *   limit. Otherwise, it must be bound to an integer indicating the maximum\n *   number of items of each collection to print. If a collection contains\n *   more items, the printer will print items up to the limit followed by\n *   '...' to represent the remaining items. The root binding is nil\n *   indicating no limit.\n * @type {null|number}\n */\ncljs.core._STAR_print_length_STAR_ = null;\n/**\n * *print-level* controls how many levels deep the printer will\n *   print nested objects. If it is bound to logical false, there is no\n *   limit. Otherwise, it must be bound to an integer indicating the maximum\n *   level to print. Each argument to print is at level 0; if an argument is a\n *   collection, its items are at level 1; and so on. If an object is a\n *   collection and is at a level greater than or equal to the value bound to\n *   *print-level*, the printer prints '#' to represent it. The root binding\n *   is nil indicating no limit.\n * @type {null|number}\n */\ncljs.core._STAR_print_level_STAR_ = null;\n/**\n * *print-fns-bodies* controls whether functions print their source or\n *  only their names.\n */\ncljs.core._STAR_print_fn_bodies_STAR_ = false;\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core._STAR_loaded_libs_STAR_ !== 'undefined')){\n} else {\n/**\n * @type {*}\n */\ncljs.core._STAR_loaded_libs_STAR_ = null;\n}\ncljs.core.pr_opts = (function cljs$core$pr_opts(){\nreturn new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"flush-on-newline\",\"flush-on-newline\",-151457939),cljs.core._STAR_flush_on_newline_STAR_,new cljs.core.Keyword(null,\"readably\",\"readably\",1129599760),cljs.core._STAR_print_readably_STAR_,new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964),cljs.core._STAR_print_meta_STAR_,new cljs.core.Keyword(null,\"dup\",\"dup\",556298533),cljs.core._STAR_print_dup_STAR_,new cljs.core.Keyword(null,\"print-length\",\"print-length\",1931866356),cljs.core._STAR_print_length_STAR_], null);\n});\n/**\n * Set *print-fn* to console.log\n */\ncljs.core.enable_console_print_BANG_ = (function cljs$core$enable_console_print_BANG_(){\ncljs.core._STAR_print_newline_STAR_ = false;\n\ncljs.core.set_print_fn_BANG_((function (){\nvar xs = arguments;\nreturn console.log.apply(console,goog.array.clone(xs));\n}));\n\ncljs.core.set_print_err_fn_BANG_((function (){\nvar xs = arguments;\nreturn console.error.apply(console,goog.array.clone(xs));\n}));\n\nreturn null;\n});\n/**\n * Internal - do not use!\n */\ncljs.core.truth_ = (function cljs$core$truth_(x){\nreturn (x != null && x !== false);\n});\ncljs.core.not_native = null;\n\n/**\n * Tests if 2 arguments are the same object\n */\ncljs.core.identical_QMARK_ = (function cljs$core$identical_QMARK_(x,y){\nreturn (x === y);\n});\n/**\n * Returns true if x is nil, false otherwise.\n */\ncljs.core.nil_QMARK_ = (function cljs$core$nil_QMARK_(x){\nreturn (x == null);\n});\n/**\n * Returns true if x is a JavaScript array.\n */\ncljs.core.array_QMARK_ = (function cljs$core$array_QMARK_(x){\nif((cljs.core._STAR_target_STAR_ === \"nodejs\")){\nreturn Array.isArray(x);\n} else {\nreturn (x instanceof Array);\n}\n});\n/**\n * Returns true if x is a JavaScript number.\n */\ncljs.core.number_QMARK_ = (function cljs$core$number_QMARK_(x){\nreturn typeof x === 'number';\n});\n/**\n * Returns true if x is logical false, false otherwise.\n */\ncljs.core.not = (function cljs$core$not(x){\nif((x == null)){\nreturn true;\n} else {\nif(x === false){\nreturn true;\n} else {\nreturn false;\n\n}\n}\n});\n/**\n * Returns true if x is not nil, false otherwise.\n */\ncljs.core.some_QMARK_ = (function cljs$core$some_QMARK_(x){\nreturn (!((x == null)));\n});\n/**\n * Returns true if x's constructor is Object\n */\ncljs.core.object_QMARK_ = (function cljs$core$object_QMARK_(x){\nif((!((x == null)))){\nreturn (x.constructor === Object);\n} else {\nreturn false;\n}\n});\n/**\n * Returns true if x is a JavaScript string.\n */\ncljs.core.string_QMARK_ = (function cljs$core$string_QMARK_(x){\nreturn goog.isString(x);\n});\n/**\n * Returns true if x is a JavaScript string of length one.\n */\ncljs.core.char_QMARK_ = (function cljs$core$char_QMARK_(x){\nreturn ((typeof x === 'string') && (((1) === x.length)));\n});\n/**\n * Returns true if given any argument.\n */\ncljs.core.any_QMARK_ = (function cljs$core$any_QMARK_(x){\nreturn true;\n});\n/**\n * Internal - do not use!\n */\ncljs.core.native_satisfies_QMARK_ = (function cljs$core$native_satisfies_QMARK_(p,x){\nvar x__$1 = (((x == null))?null:x);\nif((p[goog.typeOf(x__$1)])){\nreturn true;\n} else {\nif((p[\"_\"])){\nreturn true;\n} else {\nreturn false;\n\n}\n}\n});\ncljs.core.is_proto_ = (function cljs$core$is_proto_(x){\nreturn (x.constructor.prototype === x);\n});\n/**\n * When compiled for a command-line target, whatever function\n *   *main-cli-fn* is set to will be called with the command-line\n *   argv as arguments\n */\ncljs.core._STAR_main_cli_fn_STAR_ = null;\n/**\n * A sequence of the supplied command line arguments, or nil if\n *   none were supplied\n */\ncljs.core._STAR_command_line_args_STAR_ = null;\n/**\n * Return x's constructor.\n */\ncljs.core.type = (function cljs$core$type(x){\nif((x == null)){\nreturn null;\n} else {\nreturn x.constructor;\n}\n});\ncljs.core.missing_protocol = (function cljs$core$missing_protocol(proto,obj){\nvar ty = cljs.core.type(obj);\nvar ty__$1 = (cljs.core.truth_((function (){var and__4120__auto__ = ty;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn ty.cljs$lang$type;\n} else {\nreturn and__4120__auto__;\n}\n})())?ty.cljs$lang$ctorStr:goog.typeOf(obj));\nreturn (new Error([\"No protocol method \",proto,\" defined for type \",ty__$1,\": \",obj].join(\"\")));\n});\ncljs.core.type__GT_str = (function cljs$core$type__GT_str(ty){\nvar temp__5718__auto__ = ty.cljs$lang$ctorStr;\nif(cljs.core.truth_(temp__5718__auto__)){\nvar s = temp__5718__auto__;\nreturn s;\n} else {\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(ty);\n}\n});\ncljs.core.load_file = (function cljs$core$load_file(file){\nif(cljs.core.truth_(COMPILED)){\nreturn null;\n} else {\nreturn goog.nodeGlobalRequire(file);\n}\n});\nif((((typeof Symbol !== 'undefined')) && ((goog.typeOf(Symbol) === \"function\")))){\ncljs.core.ITER_SYMBOL = Symbol.iterator;\n} else {\ncljs.core.ITER_SYMBOL = \"@@iterator\";\n}\n/**\n * @enum {string}\n */\ncljs.core.CHAR_MAP = ({\"]\": \"_RBRACK_\", \"'\": \"_SINGLEQUOTE_\", \"=\": \"_EQ_\", \"\\\"\": \"_DOUBLEQUOTE_\", \"!\": \"_BANG_\", \"*\": \"_STAR_\", \"%\": \"_PERCENT_\", \"|\": \"_BAR_\", \"~\": \"_TILDE_\", \"/\": \"_SLASH_\", \"\\\\\": \"_BSLASH_\", \"-\": \"_\", \"?\": \"_QMARK_\", \"&\": \"_AMPERSAND_\", \":\": \"_COLON_\", \"<\": \"_LT_\", \"{\": \"_LBRACE_\", \"}\": \"_RBRACE_\", \"[\": \"_LBRACK_\", \"#\": \"_SHARP_\", \"^\": \"_CARET_\", \"+\": \"_PLUS_\", \"@\": \"_CIRCA_\", \">\": \"_GT_\"});\n/**\n * @enum {string}\n */\ncljs.core.DEMUNGE_MAP = ({\"_RBRACE_\": \"}\", \"_COLON_\": \":\", \"_BANG_\": \"!\", \"_QMARK_\": \"?\", \"_BSLASH_\": \"\\\\\\\\\", \"_SLASH_\": \"/\", \"_PERCENT_\": \"%\", \"_PLUS_\": \"+\", \"_SHARP_\": \"#\", \"_LBRACE_\": \"{\", \"_BAR_\": \"|\", \"_LBRACK_\": \"[\", \"_EQ_\": \"=\", \"_\": \"-\", \"_TILDE_\": \"~\", \"_RBRACK_\": \"]\", \"_GT_\": \">\", \"_SINGLEQUOTE_\": \"'\", \"_CIRCA_\": \"@\", \"_AMPERSAND_\": \"&\", \"_DOUBLEQUOTE_\": \"\\\\\\\"\", \"_CARET_\": \"^\", \"_LT_\": \"<\", \"_STAR_\": \"*\"});\ncljs.core.DEMUNGE_PATTERN = null;\n/**\n * Returns highest resolution time offered by host in milliseconds.\n */\ncljs.core.system_time = (function cljs$core$system_time(){\nif((((typeof performance !== 'undefined')) && ((!((performance.now == null)))))){\nreturn performance.now();\n} else {\nif((((typeof process !== 'undefined')) && ((!((process.hrtime == null)))))){\nvar t = process.hrtime();\nreturn ((((t[(0)]) * 1.0E9) + (t[(1)])) / 1000000.0);\n} else {\nreturn (new Date()).getTime();\n\n}\n}\n});\n/**\n * Construct a JavaScript array of the specified dimensions. Accepts ignored\n *   type argument for compatibility with Clojure. Note that there is no efficient\n *   way to allocate multi-dimensional arrays in JavaScript; as such, this function\n *   will run in polynomial time when called with 3 or more arguments.\n */\ncljs.core.make_array = (function cljs$core$make_array(var_args){\nvar G__530 = arguments.length;\nswitch (G__530) {\ncase 1:\nreturn cljs.core.make_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.make_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___532 = arguments.length;\nvar i__4731__auto___533 = (0);\nwhile(true){\nif((i__4731__auto___533 < len__4730__auto___532)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___533]));\n\nvar G__534 = (i__4731__auto___533 + (1));\ni__4731__auto___533 = G__534;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.make_array.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.make_array.cljs$core$IFn$_invoke$arity$1 = (function (size){\nreturn (new Array(size));\n});\n\ncljs.core.make_array.cljs$core$IFn$_invoke$arity$2 = (function (type,size){\nreturn (new Array(size));\n});\n\ncljs.core.make_array.cljs$core$IFn$_invoke$arity$variadic = (function (type,size,more_sizes){\nvar dims = more_sizes;\nvar dimarray = (new Array(size));\nvar n__4607__auto___535 = dimarray.length;\nvar i_536 = (0);\nwhile(true){\nif((i_536 < n__4607__auto___535)){\n(dimarray[i_536] = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.make_array,null,dims));\n\nvar G__537 = (i_536 + (1));\ni_536 = G__537;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn dimarray;\n});\n\n/** @this {Function} */\ncljs.core.make_array.cljs$lang$applyTo = (function (seq527){\nvar G__528 = cljs.core.first(seq527);\nvar seq527__$1 = cljs.core.next(seq527);\nvar G__529 = cljs.core.first(seq527__$1);\nvar seq527__$2 = cljs.core.next(seq527__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__528,G__529,seq527__$2);\n});\n\ncljs.core.make_array.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a javascript array, cloned from the passed in array\n */\ncljs.core.aclone = (function cljs$core$aclone(arr){\nvar len = arr.length;\nvar new_arr = (new Array(len));\nvar n__4607__auto___538 = len;\nvar i_539 = (0);\nwhile(true){\nif((i_539 < n__4607__auto___538)){\n(new_arr[i_539] = (arr[i_539]));\n\nvar G__540 = (i_539 + (1));\ni_539 = G__540;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn new_arr;\n});\n/**\n * Creates a new javascript array.\n * @param {...*} var_args\n */\ncljs.core.array = (function cljs$core$array(var_args){\nvar a = (new Array(arguments.length));\nvar i = (0);\nwhile(true){\nif((i < a.length)){\n(a[i] = (arguments[i]));\n\nvar G__541 = (i + (1));\ni = G__541;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n});\ncljs.core.maybe_warn = (function cljs$core$maybe_warn(e){\nif(cljs.core.truth_(cljs.core._STAR_print_err_fn_STAR_)){\nreturn (cljs.core._STAR_print_err_fn_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_print_err_fn_STAR_.cljs$core$IFn$_invoke$arity$1(e) : cljs.core._STAR_print_err_fn_STAR_.call(null,e));\n} else {\nreturn null;\n}\n});\ncljs.core.checked_aget = (function cljs$core$checked_aget(var_args){\nvar G__546 = arguments.length;\nswitch (G__546) {\ncase 2:\nreturn cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___549 = arguments.length;\nvar i__4731__auto___550 = (0);\nwhile(true){\nif((i__4731__auto___550 < len__4730__auto___549)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___550]));\n\nvar G__551 = (i__4731__auto___550 + (1));\ni__4731__auto___550 = G__551;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2 = (function (array,idx){\ntry{if(cljs.core.truth_((function (){var or__4131__auto__ = cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error(\"Assert failed: (or (array? array) (goog/isArrayLike array))\"));\n}\n\nif(typeof idx === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? idx)\"));\n}\n\nif((!((idx < (0))))){\n} else {\nthrow (new Error(\"Assert failed: (not (neg? idx))\"));\n}\n\nif((idx < array.length)){\n} else {\nthrow (new Error(\"Assert failed: (< idx (alength array))\"));\n}\n}catch (e547){var e_552 = e547;\ncljs.core.maybe_warn(e_552);\n}\nreturn (array[idx]);\n});\n\ncljs.core.checked_aget.cljs$core$IFn$_invoke$arity$variadic = (function (array,idx,idxs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.checked_aget,cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2(array,idx),idxs);\n});\n\n/** @this {Function} */\ncljs.core.checked_aget.cljs$lang$applyTo = (function (seq543){\nvar G__544 = cljs.core.first(seq543);\nvar seq543__$1 = cljs.core.next(seq543);\nvar G__545 = cljs.core.first(seq543__$1);\nvar seq543__$2 = cljs.core.next(seq543__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__544,G__545,seq543__$2);\n});\n\ncljs.core.checked_aget.cljs$lang$maxFixedArity = (2);\n\ncljs.core.checked_aset = (function cljs$core$checked_aset(var_args){\nvar G__558 = arguments.length;\nswitch (G__558) {\ncase 3:\nreturn cljs.core.checked_aset.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___561 = arguments.length;\nvar i__4731__auto___562 = (0);\nwhile(true){\nif((i__4731__auto___562 < len__4730__auto___561)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___562]));\n\nvar G__563 = (i__4731__auto___562 + (1));\ni__4731__auto___562 = G__563;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.checked_aset.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aset.cljs$core$IFn$_invoke$arity$3 = (function (array,idx,val){\ntry{if(cljs.core.truth_((function (){var or__4131__auto__ = cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error(\"Assert failed: (or (array? array) (goog/isArrayLike array))\"));\n}\n\nif(typeof idx === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? idx)\"));\n}\n\nif((!((idx < (0))))){\n} else {\nthrow (new Error(\"Assert failed: (not (neg? idx))\"));\n}\n\nif((idx < array.length)){\n} else {\nthrow (new Error(\"Assert failed: (< idx (alength array))\"));\n}\n}catch (e559){var e_564 = e559;\ncljs.core.maybe_warn(e_564);\n}\nreturn (array[idx] = val);\n});\n\ncljs.core.checked_aset.cljs$core$IFn$_invoke$arity$variadic = (function (array,idx,idx2,idxv){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.checked_aset,cljs.core.checked_aget.cljs$core$IFn$_invoke$arity$2(array,idx),idx2,idxv);\n});\n\n/** @this {Function} */\ncljs.core.checked_aset.cljs$lang$applyTo = (function (seq554){\nvar G__555 = cljs.core.first(seq554);\nvar seq554__$1 = cljs.core.next(seq554);\nvar G__556 = cljs.core.first(seq554__$1);\nvar seq554__$2 = cljs.core.next(seq554__$1);\nvar G__557 = cljs.core.first(seq554__$2);\nvar seq554__$3 = cljs.core.next(seq554__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__555,G__556,G__557,seq554__$3);\n});\n\ncljs.core.checked_aset.cljs$lang$maxFixedArity = (3);\n\ncljs.core.checked_aget_SINGLEQUOTE_ = (function cljs$core$checked_aget_SINGLEQUOTE_(var_args){\nvar G__569 = arguments.length;\nswitch (G__569) {\ncase 2:\nreturn cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___571 = arguments.length;\nvar i__4731__auto___572 = (0);\nwhile(true){\nif((i__4731__auto___572 < len__4730__auto___571)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___572]));\n\nvar G__573 = (i__4731__auto___572 + (1));\ni__4731__auto___572 = G__573;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (array,idx){\nif(cljs.core.truth_((function (){var or__4131__auto__ = cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error(\"Assert failed: (or (array? array) (goog/isArrayLike array))\"));\n}\n\nif(typeof idx === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? idx)\"));\n}\n\nif((!((idx < (0))))){\n} else {\nthrow (new Error(\"Assert failed: (not (neg? idx))\"));\n}\n\nif((idx < array.length)){\n} else {\nthrow (new Error(\"Assert failed: (< idx (alength array))\"));\n}\n\nreturn (array[idx]);\n});\n\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic = (function (array,idx,idxs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.checked_aget_SINGLEQUOTE_,cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(array,idx),idxs);\n});\n\n/** @this {Function} */\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$lang$applyTo = (function (seq566){\nvar G__567 = cljs.core.first(seq566);\nvar seq566__$1 = cljs.core.next(seq566);\nvar G__568 = cljs.core.first(seq566__$1);\nvar seq566__$2 = cljs.core.next(seq566__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__567,G__568,seq566__$2);\n});\n\ncljs.core.checked_aget_SINGLEQUOTE_.cljs$lang$maxFixedArity = (2);\n\ncljs.core.checked_aset_SINGLEQUOTE_ = (function cljs$core$checked_aset_SINGLEQUOTE_(var_args){\nvar G__579 = arguments.length;\nswitch (G__579) {\ncase 3:\nreturn cljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___581 = arguments.length;\nvar i__4731__auto___582 = (0);\nwhile(true){\nif((i__4731__auto___582 < len__4730__auto___581)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___582]));\n\nvar G__583 = (i__4731__auto___582 + (1));\ni__4731__auto___582 = G__583;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3 = (function (array,idx,val){\nif(cljs.core.truth_((function (){var or__4131__auto__ = cljs.core.array_QMARK_(array);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.isArrayLike(array);\n}\n})())){\n} else {\nthrow (new Error(\"Assert failed: (or (array? array) (goog/isArrayLike array))\"));\n}\n\nif(typeof idx === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? idx)\"));\n}\n\nif((!((idx < (0))))){\n} else {\nthrow (new Error(\"Assert failed: (not (neg? idx))\"));\n}\n\nif((idx < array.length)){\n} else {\nthrow (new Error(\"Assert failed: (< idx (alength array))\"));\n}\n\nreturn (array[idx] = val);\n});\n\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic = (function (array,idx,idx2,idxv){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.checked_aset_SINGLEQUOTE_,cljs.core.checked_aget_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(array,idx),idx2,idxv);\n});\n\n/** @this {Function} */\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$lang$applyTo = (function (seq575){\nvar G__576 = cljs.core.first(seq575);\nvar seq575__$1 = cljs.core.next(seq575);\nvar G__577 = cljs.core.first(seq575__$1);\nvar seq575__$2 = cljs.core.next(seq575__$1);\nvar G__578 = cljs.core.first(seq575__$2);\nvar seq575__$3 = cljs.core.next(seq575__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__576,G__577,G__578,seq575__$3);\n});\n\ncljs.core.checked_aset_SINGLEQUOTE_.cljs$lang$maxFixedArity = (3);\n\n/**\n * Returns the value at the index/indices. Works on JavaScript arrays.\n */\ncljs.core.aget = (function cljs$core$aget(var_args){\nvar G__588 = arguments.length;\nswitch (G__588) {\ncase 2:\nreturn cljs.core.aget.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___590 = arguments.length;\nvar i__4731__auto___591 = (0);\nwhile(true){\nif((i__4731__auto___591 < len__4730__auto___590)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___591]));\n\nvar G__592 = (i__4731__auto___591 + (1));\ni__4731__auto___591 = G__592;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.aget.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.aget.cljs$core$IFn$_invoke$arity$2 = (function (array,idx){\nreturn (array[idx]);\n});\n\ncljs.core.aget.cljs$core$IFn$_invoke$arity$variadic = (function (array,idx,idxs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.aget,(array[idx]),idxs);\n});\n\n/** @this {Function} */\ncljs.core.aget.cljs$lang$applyTo = (function (seq585){\nvar G__586 = cljs.core.first(seq585);\nvar seq585__$1 = cljs.core.next(seq585);\nvar G__587 = cljs.core.first(seq585__$1);\nvar seq585__$2 = cljs.core.next(seq585__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__586,G__587,seq585__$2);\n});\n\ncljs.core.aget.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the value at the index/indices. Works on JavaScript arrays.\n *   Returns val.\n */\ncljs.core.aset = (function cljs$core$aset(var_args){\nvar G__598 = arguments.length;\nswitch (G__598) {\ncase 3:\nreturn cljs.core.aset.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___600 = arguments.length;\nvar i__4731__auto___601 = (0);\nwhile(true){\nif((i__4731__auto___601 < len__4730__auto___600)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___601]));\n\nvar G__602 = (i__4731__auto___601 + (1));\ni__4731__auto___601 = G__602;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.aset.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.aset.cljs$core$IFn$_invoke$arity$3 = (function (array,idx,val){\nreturn (array[idx] = val);\n});\n\ncljs.core.aset.cljs$core$IFn$_invoke$arity$variadic = (function (array,idx,idx2,idxv){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.aset,(array[idx]),idx2,idxv);\n});\n\n/** @this {Function} */\ncljs.core.aset.cljs$lang$applyTo = (function (seq594){\nvar G__595 = cljs.core.first(seq594);\nvar seq594__$1 = cljs.core.next(seq594);\nvar G__596 = cljs.core.first(seq594__$1);\nvar seq594__$2 = cljs.core.next(seq594__$1);\nvar G__597 = cljs.core.first(seq594__$2);\nvar seq594__$3 = cljs.core.next(seq594__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__595,G__596,G__597,seq594__$3);\n});\n\ncljs.core.aset.cljs$lang$maxFixedArity = (3);\n\n/**\n * Returns the length of the array. Works on arrays of all types.\n */\ncljs.core.alength = (function cljs$core$alength(array){\nreturn array.length;\n});\n/**\n * Returns an array with components set to the values in aseq. Optional type\n *   argument accepted for compatibility with Clojure.\n */\ncljs.core.into_array = (function cljs$core$into_array(var_args){\nvar G__604 = arguments.length;\nswitch (G__604) {\ncase 1:\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.into_array.cljs$core$IFn$_invoke$arity$1 = (function (aseq){\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$2(null,aseq);\n});\n\ncljs.core.into_array.cljs$core$IFn$_invoke$arity$2 = (function (type,aseq){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (a,x){\na.push(x);\n\nreturn a;\n}),[],aseq);\n});\n\ncljs.core.into_array.cljs$lang$maxFixedArity = 2;\n\n/**\n * Invoke JavaScript object method via string. Needed when the\n *   string is not a valid unquoted property name.\n */\ncljs.core.js_invoke = (function cljs$core$js_invoke(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___609 = arguments.length;\nvar i__4731__auto___610 = (0);\nwhile(true){\nif((i__4731__auto___610 < len__4730__auto___609)){\nargs__4736__auto__.push((arguments[i__4731__auto___610]));\n\nvar G__611 = (i__4731__auto___610 + (1));\ni__4731__auto___610 = G__611;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((2) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((2)),(0),null)):null);\nreturn cljs.core.js_invoke.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4737__auto__);\n});\n\ncljs.core.js_invoke.cljs$core$IFn$_invoke$arity$variadic = (function (obj,s,args){\nreturn (obj[s]).apply(obj,cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(args));\n});\n\ncljs.core.js_invoke.cljs$lang$maxFixedArity = (2);\n\n/** @this {Function} */\ncljs.core.js_invoke.cljs$lang$applyTo = (function (seq606){\nvar G__607 = cljs.core.first(seq606);\nvar seq606__$1 = cljs.core.next(seq606);\nvar G__608 = cljs.core.first(seq606__$1);\nvar seq606__$2 = cljs.core.next(seq606__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__607,G__608,seq606__$2);\n});\n\n\n/**\n * Marker protocol\n * @interface\n */\ncljs.core.Fn = function(){};\n\n\n/**\n * Protocol for adding the ability to invoke an object as a function.\n *   For example, a vector can also be used to look up a value:\n *   ([1 2 3 4] 1) => 2\n * @interface\n */\ncljs.core.IFn = function(){};\n\ncljs.core._invoke = (function cljs$core$_invoke(var_args){\nvar G__613 = arguments.length;\nswitch (G__613) {\ncase 1:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase 7:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ncase 8:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase 9:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase 10:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$10((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]));\n\nbreak;\ncase 11:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ncase 12:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ncase 13:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$13((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]));\n\nbreak;\ncase 14:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$14((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]));\n\nbreak;\ncase 15:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$15((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]));\n\nbreak;\ncase 16:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$16((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]));\n\nbreak;\ncase 17:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$17((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]));\n\nbreak;\ncase 18:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$18((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]));\n\nbreak;\ncase 19:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$19((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]));\n\nbreak;\ncase 20:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$20((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]),(arguments[(19)]));\n\nbreak;\ncase 21:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$21((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]),(arguments[(19)]),(arguments[(20)]));\n\nbreak;\ncase 22:\nreturn cljs.core._invoke.cljs$core$IFn$_invoke$arity$22((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]),(arguments[(12)]),(arguments[(13)]),(arguments[(14)]),(arguments[(15)]),(arguments[(16)]),(arguments[(17)]),(arguments[(18)]),(arguments[(19)]),(arguments[(20)]),(arguments[(21)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$1 = (function (this$){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$1 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$1(this$);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__4434__auto__.call(null,this$));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(this$) : m__4431__auto__.call(null,this$));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$2 = (function (this$,a){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$2 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$2(this$,a);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(this$,a) : m__4434__auto__.call(null,this$,a));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(this$,a) : m__4431__auto__.call(null,this$,a));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$3 = (function (this$,a,b){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$3 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$3(this$,a,b);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(this$,a,b) : m__4434__auto__.call(null,this$,a,b));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(this$,a,b) : m__4431__auto__.call(null,this$,a,b));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$4 = (function (this$,a,b,c){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$4 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$4(this$,a,b,c);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(this$,a,b,c) : m__4434__auto__.call(null,this$,a,b,c));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(this$,a,b,c) : m__4431__auto__.call(null,this$,a,b,c));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$5 = (function (this$,a,b,c,d){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$5 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$5(this$,a,b,c,d);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$5(this$,a,b,c,d) : m__4434__auto__.call(null,this$,a,b,c,d));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$5(this$,a,b,c,d) : m__4431__auto__.call(null,this$,a,b,c,d));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$6 = (function (this$,a,b,c,d,e){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$6 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$6(this$,a,b,c,d,e);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$6 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$6(this$,a,b,c,d,e) : m__4434__auto__.call(null,this$,a,b,c,d,e));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$6 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$6(this$,a,b,c,d,e) : m__4431__auto__.call(null,this$,a,b,c,d,e));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$7 = (function (this$,a,b,c,d,e,f){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$7 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$7(this$,a,b,c,d,e,f);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$7 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$7(this$,a,b,c,d,e,f) : m__4434__auto__.call(null,this$,a,b,c,d,e,f));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$7 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$7(this$,a,b,c,d,e,f) : m__4431__auto__.call(null,this$,a,b,c,d,e,f));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$8 = (function (this$,a,b,c,d,e,f,g){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$8 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$8(this$,a,b,c,d,e,f,g);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$8 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$8(this$,a,b,c,d,e,f,g) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$8 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$8(this$,a,b,c,d,e,f,g) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$9 = (function (this$,a,b,c,d,e,f,g,h){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$9 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$9(this$,a,b,c,d,e,f,g,h);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$9 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$9(this$,a,b,c,d,e,f,g,h) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$9 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$9(this$,a,b,c,d,e,f,g,h) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$10 = (function (this$,a,b,c,d,e,f,g,h,i){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$10 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$10(this$,a,b,c,d,e,f,g,h,i);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$10 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$10(this$,a,b,c,d,e,f,g,h,i) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$10 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$10(this$,a,b,c,d,e,f,g,h,i) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$11 = (function (this$,a,b,c,d,e,f,g,h,i,j){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$11 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$11(this$,a,b,c,d,e,f,g,h,i,j);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$11 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$11(this$,a,b,c,d,e,f,g,h,i,j) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$11 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$11(this$,a,b,c,d,e,f,g,h,i,j) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$12 = (function (this$,a,b,c,d,e,f,g,h,i,j,k){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$12 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$12(this$,a,b,c,d,e,f,g,h,i,j,k);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$12 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$12(this$,a,b,c,d,e,f,g,h,i,j,k) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$12 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$12(this$,a,b,c,d,e,f,g,h,i,j,k) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$13 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$13 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$13(this$,a,b,c,d,e,f,g,h,i,j,k,l);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$13 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$13(this$,a,b,c,d,e,f,g,h,i,j,k,l) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$13 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$13(this$,a,b,c,d,e,f,g,h,i,j,k,l) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$14 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$14 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$14(this$,a,b,c,d,e,f,g,h,i,j,k,l,m);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$14 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$14(this$,a,b,c,d,e,f,g,h,i,j,k,l,m) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$14 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$14(this$,a,b,c,d,e,f,g,h,i,j,k,l,m) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$15 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$15 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$15(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$15 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$15(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$15 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$15(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$16 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$16 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$16(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$16 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$16(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$16 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$16(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$17 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$17 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$17(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$17 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$17(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$17 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$17(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$18 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$18 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$18(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$18 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$18(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$18 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$18(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$19 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$19 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$19(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$19 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$19(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$19 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$19(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$20 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$20 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$20(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$20 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$20(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$20 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$20(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$21 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$21 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$21(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$21 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$21(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$21 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$21(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$core$IFn$_invoke$arity$22 = (function (this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IFn$_invoke$arity$22 == null)))))){\nreturn this$.cljs$core$IFn$_invoke$arity$22(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._invoke[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$22 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$22(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest) : m__4434__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest));\n} else {\nvar m__4431__auto__ = (cljs.core._invoke[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$22 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$22(this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest) : m__4431__auto__.call(null,this$,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest));\n} else {\nthrow cljs.core.missing_protocol(\"IFn.-invoke\",this$);\n}\n}\n}\n});\n\ncljs.core._invoke.cljs$lang$maxFixedArity = 22;\n\n\n\n/**\n * Protocol for cloning a value.\n * @interface\n */\ncljs.core.ICloneable = function(){};\n\n/**\n * Creates a clone of value.\n */\ncljs.core._clone = (function cljs$core$_clone(value){\nif((((!((value == null)))) && ((!((value.cljs$core$ICloneable$_clone$arity$1 == null)))))){\nreturn value.cljs$core$ICloneable$_clone$arity$1(value);\n} else {\nvar x__4433__auto__ = (((value == null))?null:value);\nvar m__4434__auto__ = (cljs.core._clone[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(value) : m__4434__auto__.call(null,value));\n} else {\nvar m__4431__auto__ = (cljs.core._clone[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(value) : m__4431__auto__.call(null,value));\n} else {\nthrow cljs.core.missing_protocol(\"ICloneable.-clone\",value);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding the ability to count a collection in constant time.\n * @interface\n */\ncljs.core.ICounted = function(){};\n\n/**\n * Calculates the count of coll in constant time. Used by cljs.core/count.\n */\ncljs.core._count = (function cljs$core$_count(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ICounted$_count$arity$1 == null)))))){\nreturn coll.cljs$core$ICounted$_count$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._count[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._count[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"ICounted.-count\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for creating an empty collection.\n * @interface\n */\ncljs.core.IEmptyableCollection = function(){};\n\n/**\n * Returns an empty collection of the same category as coll. Used\n *   by cljs.core/empty.\n */\ncljs.core._empty = (function cljs$core$_empty(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IEmptyableCollection$_empty$arity$1 == null)))))){\nreturn coll.cljs$core$IEmptyableCollection$_empty$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._empty[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._empty[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IEmptyableCollection.-empty\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding to a collection.\n * @interface\n */\ncljs.core.ICollection = function(){};\n\n/**\n * Returns a new collection of coll with o added to it. The new item\n *   should be added to the most efficient place, e.g.\n *   (conj [1 2 3 4] 5) => [1 2 3 4 5]\n *   (conj '(2 3 4 5) 1) => '(1 2 3 4 5)\n */\ncljs.core._conj = (function cljs$core$_conj(coll,o){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ICollection$_conj$arity$2 == null)))))){\nreturn coll.cljs$core$ICollection$_conj$arity$2(coll,o);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._conj[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,o) : m__4434__auto__.call(null,coll,o));\n} else {\nvar m__4431__auto__ = (cljs.core._conj[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,o) : m__4431__auto__.call(null,coll,o));\n} else {\nthrow cljs.core.missing_protocol(\"ICollection.-conj\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for collections to provide indexed-based access to their items.\n * @interface\n */\ncljs.core.IIndexed = function(){};\n\n/**\n * Returns the value at the index n in the collection coll.\n *   Returns not-found if index n is out of bounds and not-found is supplied.\n */\ncljs.core._nth = (function cljs$core$_nth(var_args){\nvar G__616 = arguments.length;\nswitch (G__616) {\ncase 2:\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._nth.cljs$core$IFn$_invoke$arity$2 = (function (coll,n){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IIndexed$_nth$arity$2 == null)))))){\nreturn coll.cljs$core$IIndexed$_nth$arity$2(coll,n);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._nth[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,n) : m__4434__auto__.call(null,coll,n));\n} else {\nvar m__4431__auto__ = (cljs.core._nth[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,n) : m__4431__auto__.call(null,coll,n));\n} else {\nthrow cljs.core.missing_protocol(\"IIndexed.-nth\",coll);\n}\n}\n}\n});\n\ncljs.core._nth.cljs$core$IFn$_invoke$arity$3 = (function (coll,n,not_found){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IIndexed$_nth$arity$3 == null)))))){\nreturn coll.cljs$core$IIndexed$_nth$arity$3(coll,n,not_found);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._nth[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,not_found) : m__4434__auto__.call(null,coll,n,not_found));\n} else {\nvar m__4431__auto__ = (cljs.core._nth[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,not_found) : m__4431__auto__.call(null,coll,n,not_found));\n} else {\nthrow cljs.core.missing_protocol(\"IIndexed.-nth\",coll);\n}\n}\n}\n});\n\ncljs.core._nth.cljs$lang$maxFixedArity = 3;\n\n\n\n/**\n * Marker protocol indicating an array sequence.\n * @interface\n */\ncljs.core.ASeq = function(){};\n\n\n/**\n * Protocol for collections to provide access to their items as sequences.\n * @interface\n */\ncljs.core.ISeq = function(){};\n\n/**\n * Returns the first item in the collection coll. Used by cljs.core/first.\n */\ncljs.core._first = (function cljs$core$_first(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISeq$_first$arity$1 == null)))))){\nreturn coll.cljs$core$ISeq$_first$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._first[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._first[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"ISeq.-first\",coll);\n}\n}\n}\n});\n\n/**\n * Returns a new collection of coll without the first item. It should\n *   always return a seq, e.g.\n *   (rest []) => ()\n *   (rest nil) => ()\n */\ncljs.core._rest = (function cljs$core$_rest(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISeq$_rest$arity$1 == null)))))){\nreturn coll.cljs$core$ISeq$_rest$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._rest[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._rest[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"ISeq.-rest\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the next items of a collection.\n * @interface\n */\ncljs.core.INext = function(){};\n\n/**\n * Returns a new collection of coll without the first item. In contrast to\n *   rest, it should return nil if there are no more items, e.g.\n *   (next []) => nil\n *   (next nil) => nil\n */\ncljs.core._next = (function cljs$core$_next(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$INext$_next$arity$1 == null)))))){\nreturn coll.cljs$core$INext$_next$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._next[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._next[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"INext.-next\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for looking up a value in a data structure.\n * @interface\n */\ncljs.core.ILookup = function(){};\n\n/**\n * Use k to look up a value in o. If not-found is supplied and k is not\n *   a valid value that can be used for look up, not-found is returned.\n */\ncljs.core._lookup = (function cljs$core$_lookup(var_args){\nvar G__619 = arguments.length;\nswitch (G__619) {\ncase 2:\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._lookup.cljs$core$IFn$_invoke$arity$2 = (function (o,k){\nif((((!((o == null)))) && ((!((o.cljs$core$ILookup$_lookup$arity$2 == null)))))){\nreturn o.cljs$core$ILookup$_lookup$arity$2(o,k);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._lookup[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,k) : m__4434__auto__.call(null,o,k));\n} else {\nvar m__4431__auto__ = (cljs.core._lookup[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,k) : m__4431__auto__.call(null,o,k));\n} else {\nthrow cljs.core.missing_protocol(\"ILookup.-lookup\",o);\n}\n}\n}\n});\n\ncljs.core._lookup.cljs$core$IFn$_invoke$arity$3 = (function (o,k,not_found){\nif((((!((o == null)))) && ((!((o.cljs$core$ILookup$_lookup$arity$3 == null)))))){\nreturn o.cljs$core$ILookup$_lookup$arity$3(o,k,not_found);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._lookup[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,k,not_found) : m__4434__auto__.call(null,o,k,not_found));\n} else {\nvar m__4431__auto__ = (cljs.core._lookup[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,k,not_found) : m__4431__auto__.call(null,o,k,not_found));\n} else {\nthrow cljs.core.missing_protocol(\"ILookup.-lookup\",o);\n}\n}\n}\n});\n\ncljs.core._lookup.cljs$lang$maxFixedArity = 3;\n\n\n\n/**\n * Protocol for adding associativity to collections.\n * @interface\n */\ncljs.core.IAssociative = function(){};\n\n/**\n * Returns true if k is a key in coll.\n */\ncljs.core._contains_key_QMARK_ = (function cljs$core$_contains_key_QMARK_(coll,k){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 == null)))))){\nreturn coll.cljs$core$IAssociative$_contains_key_QMARK_$arity$2(coll,k);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._contains_key_QMARK_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4434__auto__.call(null,coll,k));\n} else {\nvar m__4431__auto__ = (cljs.core._contains_key_QMARK_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4431__auto__.call(null,coll,k));\n} else {\nthrow cljs.core.missing_protocol(\"IAssociative.-contains-key?\",coll);\n}\n}\n}\n});\n\n/**\n * Returns a new collection of coll with a mapping from key k to\n *   value v added to it.\n */\ncljs.core._assoc = (function cljs$core$_assoc(coll,k,v){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IAssociative$_assoc$arity$3 == null)))))){\nreturn coll.cljs$core$IAssociative$_assoc$arity$3(coll,k,v);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._assoc[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,v) : m__4434__auto__.call(null,coll,k,v));\n} else {\nvar m__4431__auto__ = (cljs.core._assoc[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,v) : m__4431__auto__.call(null,coll,k,v));\n} else {\nthrow cljs.core.missing_protocol(\"IAssociative.-assoc\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for implementing entry finding in collections.\n * @interface\n */\ncljs.core.IFind = function(){};\n\n/**\n * Returns the map entry for key, or nil if key not present.\n */\ncljs.core._find = (function cljs$core$_find(coll,k){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IFind$_find$arity$2 == null)))))){\nreturn coll.cljs$core$IFind$_find$arity$2(coll,k);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._find[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4434__auto__.call(null,coll,k));\n} else {\nvar m__4431__auto__ = (cljs.core._find[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4431__auto__.call(null,coll,k));\n} else {\nthrow cljs.core.missing_protocol(\"IFind.-find\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding mapping functionality to collections.\n * @interface\n */\ncljs.core.IMap = function(){};\n\n/**\n * Returns a new collection of coll without the mapping for key k.\n */\ncljs.core._dissoc = (function cljs$core$_dissoc(coll,k){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IMap$_dissoc$arity$2 == null)))))){\nreturn coll.cljs$core$IMap$_dissoc$arity$2(coll,k);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._dissoc[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4434__auto__.call(null,coll,k));\n} else {\nvar m__4431__auto__ = (cljs.core._dissoc[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,k) : m__4431__auto__.call(null,coll,k));\n} else {\nthrow cljs.core.missing_protocol(\"IMap.-dissoc\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for examining a map entry.\n * @interface\n */\ncljs.core.IMapEntry = function(){};\n\n/**\n * Returns the key of the map entry.\n */\ncljs.core._key = (function cljs$core$_key(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IMapEntry$_key$arity$1 == null)))))){\nreturn coll.cljs$core$IMapEntry$_key$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._key[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._key[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IMapEntry.-key\",coll);\n}\n}\n}\n});\n\n/**\n * Returns the value of the map entry.\n */\ncljs.core._val = (function cljs$core$_val(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IMapEntry$_val$arity$1 == null)))))){\nreturn coll.cljs$core$IMapEntry$_val$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._val[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._val[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IMapEntry.-val\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding set functionality to a collection.\n * @interface\n */\ncljs.core.ISet = function(){};\n\n/**\n * Returns a new collection of coll that does not contain v.\n */\ncljs.core._disjoin = (function cljs$core$_disjoin(coll,v){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISet$_disjoin$arity$2 == null)))))){\nreturn coll.cljs$core$ISet$_disjoin$arity$2(coll,v);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._disjoin[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,v) : m__4434__auto__.call(null,coll,v));\n} else {\nvar m__4431__auto__ = (cljs.core._disjoin[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,v) : m__4431__auto__.call(null,coll,v));\n} else {\nthrow cljs.core.missing_protocol(\"ISet.-disjoin\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for collections to provide access to their items as stacks. The top\n *   of the stack should be accessed in the most efficient way for the different\n *   data structures.\n * @interface\n */\ncljs.core.IStack = function(){};\n\n/**\n * Returns the item from the top of the stack. Is used by cljs.core/peek.\n */\ncljs.core._peek = (function cljs$core$_peek(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IStack$_peek$arity$1 == null)))))){\nreturn coll.cljs$core$IStack$_peek$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._peek[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._peek[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IStack.-peek\",coll);\n}\n}\n}\n});\n\n/**\n * Returns a new stack without the item on top of the stack. Is used\n *   by cljs.core/pop.\n */\ncljs.core._pop = (function cljs$core$_pop(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IStack$_pop$arity$1 == null)))))){\nreturn coll.cljs$core$IStack$_pop$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._pop[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._pop[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IStack.-pop\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding vector functionality to collections.\n * @interface\n */\ncljs.core.IVector = function(){};\n\n/**\n * Returns a new vector with value val added at position n.\n */\ncljs.core._assoc_n = (function cljs$core$_assoc_n(coll,n,val){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IVector$_assoc_n$arity$3 == null)))))){\nreturn coll.cljs$core$IVector$_assoc_n$arity$3(coll,n,val);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._assoc_n[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,val) : m__4434__auto__.call(null,coll,n,val));\n} else {\nvar m__4431__auto__ = (cljs.core._assoc_n[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,n,val) : m__4431__auto__.call(null,coll,n,val));\n} else {\nthrow cljs.core.missing_protocol(\"IVector.-assoc-n\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding dereference functionality to a reference.\n * @interface\n */\ncljs.core.IDeref = function(){};\n\n/**\n * Returns the value of the reference o.\n */\ncljs.core._deref = (function cljs$core$_deref(o){\nif((((!((o == null)))) && ((!((o.cljs$core$IDeref$_deref$arity$1 == null)))))){\nreturn o.cljs$core$IDeref$_deref$arity$1(o);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._deref[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ = (cljs.core._deref[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol(\"IDeref.-deref\",o);\n}\n}\n}\n});\n\n\n/**\n * @interface\n */\ncljs.core.IDerefWithTimeout = function(){};\n\ncljs.core._deref_with_timeout = (function cljs$core$_deref_with_timeout(o,msec,timeout_val){\nif((((!((o == null)))) && ((!((o.cljs$core$IDerefWithTimeout$_deref_with_timeout$arity$3 == null)))))){\nreturn o.cljs$core$IDerefWithTimeout$_deref_with_timeout$arity$3(o,msec,timeout_val);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._deref_with_timeout[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,msec,timeout_val) : m__4434__auto__.call(null,o,msec,timeout_val));\n} else {\nvar m__4431__auto__ = (cljs.core._deref_with_timeout[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,msec,timeout_val) : m__4431__auto__.call(null,o,msec,timeout_val));\n} else {\nthrow cljs.core.missing_protocol(\"IDerefWithTimeout.-deref-with-timeout\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the metadata of an object.\n * @interface\n */\ncljs.core.IMeta = function(){};\n\n/**\n * Returns the metadata of object o.\n */\ncljs.core._meta = (function cljs$core$_meta(o){\nif((((!((o == null)))) && ((!((o.cljs$core$IMeta$_meta$arity$1 == null)))))){\nreturn o.cljs$core$IMeta$_meta$arity$1(o);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._meta[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ = (cljs.core._meta[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol(\"IMeta.-meta\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding metadata to an object.\n * @interface\n */\ncljs.core.IWithMeta = function(){};\n\n/**\n * Returns a new object with value of o and metadata meta added to it.\n */\ncljs.core._with_meta = (function cljs$core$_with_meta(o,meta){\nif((((!((o == null)))) && ((!((o.cljs$core$IWithMeta$_with_meta$arity$2 == null)))))){\nreturn o.cljs$core$IWithMeta$_with_meta$arity$2(o,meta);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._with_meta[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,meta) : m__4434__auto__.call(null,o,meta));\n} else {\nvar m__4431__auto__ = (cljs.core._with_meta[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,meta) : m__4431__auto__.call(null,o,meta));\n} else {\nthrow cljs.core.missing_protocol(\"IWithMeta.-with-meta\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for seq types that can reduce themselves.\n *   Called by cljs.core/reduce.\n * @interface\n */\ncljs.core.IReduce = function(){};\n\n/**\n * f should be a function of 2 arguments. If start is not supplied,\n *   returns the result of applying f to the first 2 items in coll, then\n *   applying f to that result and the 3rd item, etc.\n */\ncljs.core._reduce = (function cljs$core$_reduce(var_args){\nvar G__622 = arguments.length;\nswitch (G__622) {\ncase 2:\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._reduce.cljs$core$IFn$_invoke$arity$2 = (function (coll,f){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IReduce$_reduce$arity$2 == null)))))){\nreturn coll.cljs$core$IReduce$_reduce$arity$2(coll,f);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._reduce[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,f) : m__4434__auto__.call(null,coll,f));\n} else {\nvar m__4431__auto__ = (cljs.core._reduce[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,f) : m__4431__auto__.call(null,coll,f));\n} else {\nthrow cljs.core.missing_protocol(\"IReduce.-reduce\",coll);\n}\n}\n}\n});\n\ncljs.core._reduce.cljs$core$IFn$_invoke$arity$3 = (function (coll,f,start){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IReduce$_reduce$arity$3 == null)))))){\nreturn coll.cljs$core$IReduce$_reduce$arity$3(coll,f,start);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._reduce[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,start) : m__4434__auto__.call(null,coll,f,start));\n} else {\nvar m__4431__auto__ = (cljs.core._reduce[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,start) : m__4431__auto__.call(null,coll,f,start));\n} else {\nthrow cljs.core.missing_protocol(\"IReduce.-reduce\",coll);\n}\n}\n}\n});\n\ncljs.core._reduce.cljs$lang$maxFixedArity = 3;\n\n\n\n/**\n * Protocol for associative types that can reduce themselves\n *   via a function of key and val. Called by cljs.core/reduce-kv.\n * @interface\n */\ncljs.core.IKVReduce = function(){};\n\n/**\n * Reduces an associative collection and returns the result. f should be\n *   a function that takes three arguments.\n */\ncljs.core._kv_reduce = (function cljs$core$_kv_reduce(coll,f,init){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IKVReduce$_kv_reduce$arity$3 == null)))))){\nreturn coll.cljs$core$IKVReduce$_kv_reduce$arity$3(coll,f,init);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._kv_reduce[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,init) : m__4434__auto__.call(null,coll,f,init));\n} else {\nvar m__4431__auto__ = (cljs.core._kv_reduce[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,f,init) : m__4431__auto__.call(null,coll,f,init));\n} else {\nthrow cljs.core.missing_protocol(\"IKVReduce.-kv-reduce\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding value comparison functionality to a type.\n * @interface\n */\ncljs.core.IEquiv = function(){};\n\n/**\n * Returns true if o and other are equal, false otherwise.\n */\ncljs.core._equiv = (function cljs$core$_equiv(o,other){\nif((((!((o == null)))) && ((!((o.cljs$core$IEquiv$_equiv$arity$2 == null)))))){\nreturn o.cljs$core$IEquiv$_equiv$arity$2(o,other);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._equiv[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,other) : m__4434__auto__.call(null,o,other));\n} else {\nvar m__4431__auto__ = (cljs.core._equiv[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,other) : m__4431__auto__.call(null,o,other));\n} else {\nthrow cljs.core.missing_protocol(\"IEquiv.-equiv\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding hashing functionality to a type.\n * @interface\n */\ncljs.core.IHash = function(){};\n\n/**\n * Returns the hash code of o.\n */\ncljs.core._hash = (function cljs$core$_hash(o){\nif((((!((o == null)))) && ((!((o.cljs$core$IHash$_hash$arity$1 == null)))))){\nreturn o.cljs$core$IHash$_hash$arity$1(o);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._hash[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ = (cljs.core._hash[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol(\"IHash.-hash\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding the ability to a type to be transformed into a sequence.\n * @interface\n */\ncljs.core.ISeqable = function(){};\n\n/**\n * Returns a seq of o, or nil if o is empty.\n */\ncljs.core._seq = (function cljs$core$_seq(o){\nif((((!((o == null)))) && ((!((o.cljs$core$ISeqable$_seq$arity$1 == null)))))){\nreturn o.cljs$core$ISeqable$_seq$arity$1(o);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._seq[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4434__auto__.call(null,o));\n} else {\nvar m__4431__auto__ = (cljs.core._seq[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(o) : m__4431__auto__.call(null,o));\n} else {\nthrow cljs.core.missing_protocol(\"ISeqable.-seq\",o);\n}\n}\n}\n});\n\n\n/**\n * Marker interface indicating a persistent collection of sequential items\n * @interface\n */\ncljs.core.ISequential = function(){};\n\n\n/**\n * Marker interface indicating a persistent list\n * @interface\n */\ncljs.core.IList = function(){};\n\n\n/**\n * Marker interface indicating a record object\n * @interface\n */\ncljs.core.IRecord = function(){};\n\n\n/**\n * Protocol for reversing a seq.\n * @interface\n */\ncljs.core.IReversible = function(){};\n\n/**\n * Returns a seq of the items in coll in reversed order.\n */\ncljs.core._rseq = (function cljs$core$_rseq(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IReversible$_rseq$arity$1 == null)))))){\nreturn coll.cljs$core$IReversible$_rseq$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._rseq[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._rseq[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IReversible.-rseq\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for a collection which can represent their items\n *   in a sorted manner. \n * @interface\n */\ncljs.core.ISorted = function(){};\n\n/**\n * Returns a sorted seq from coll in either ascending or descending order.\n */\ncljs.core._sorted_seq = (function cljs$core$_sorted_seq(coll,ascending_QMARK_){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISorted$_sorted_seq$arity$2 == null)))))){\nreturn coll.cljs$core$ISorted$_sorted_seq$arity$2(coll,ascending_QMARK_);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._sorted_seq[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,ascending_QMARK_) : m__4434__auto__.call(null,coll,ascending_QMARK_));\n} else {\nvar m__4431__auto__ = (cljs.core._sorted_seq[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,ascending_QMARK_) : m__4431__auto__.call(null,coll,ascending_QMARK_));\n} else {\nthrow cljs.core.missing_protocol(\"ISorted.-sorted-seq\",coll);\n}\n}\n}\n});\n\n/**\n * Returns a sorted seq from coll in either ascending or descending order.\n *   If ascending is true, the result should contain all items which are > or >=\n *   than k. If ascending is false, the result should contain all items which\n *   are < or <= than k, e.g.\n *   (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n *   (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)\n */\ncljs.core._sorted_seq_from = (function cljs$core$_sorted_seq_from(coll,k,ascending_QMARK_){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISorted$_sorted_seq_from$arity$3 == null)))))){\nreturn coll.cljs$core$ISorted$_sorted_seq_from$arity$3(coll,k,ascending_QMARK_);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._sorted_seq_from[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,ascending_QMARK_) : m__4434__auto__.call(null,coll,k,ascending_QMARK_));\n} else {\nvar m__4431__auto__ = (cljs.core._sorted_seq_from[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(coll,k,ascending_QMARK_) : m__4431__auto__.call(null,coll,k,ascending_QMARK_));\n} else {\nthrow cljs.core.missing_protocol(\"ISorted.-sorted-seq-from\",coll);\n}\n}\n}\n});\n\n/**\n * Returns the key for entry.\n */\ncljs.core._entry_key = (function cljs$core$_entry_key(coll,entry){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISorted$_entry_key$arity$2 == null)))))){\nreturn coll.cljs$core$ISorted$_entry_key$arity$2(coll,entry);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._entry_key[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(coll,entry) : m__4434__auto__.call(null,coll,entry));\n} else {\nvar m__4431__auto__ = (cljs.core._entry_key[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(coll,entry) : m__4431__auto__.call(null,coll,entry));\n} else {\nthrow cljs.core.missing_protocol(\"ISorted.-entry-key\",coll);\n}\n}\n}\n});\n\n/**\n * Returns the comparator for coll.\n */\ncljs.core._comparator = (function cljs$core$_comparator(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$ISorted$_comparator$arity$1 == null)))))){\nreturn coll.cljs$core$ISorted$_comparator$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._comparator[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._comparator[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"ISorted.-comparator\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for writing. Currently only implemented by StringBufferWriter.\n * @interface\n */\ncljs.core.IWriter = function(){};\n\n/**\n * Writes s with writer and returns the result.\n */\ncljs.core._write = (function cljs$core$_write(writer,s){\nif((((!((writer == null)))) && ((!((writer.cljs$core$IWriter$_write$arity$2 == null)))))){\nreturn writer.cljs$core$IWriter$_write$arity$2(writer,s);\n} else {\nvar x__4433__auto__ = (((writer == null))?null:writer);\nvar m__4434__auto__ = (cljs.core._write[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(writer,s) : m__4434__auto__.call(null,writer,s));\n} else {\nvar m__4431__auto__ = (cljs.core._write[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(writer,s) : m__4431__auto__.call(null,writer,s));\n} else {\nthrow cljs.core.missing_protocol(\"IWriter.-write\",writer);\n}\n}\n}\n});\n\n/**\n * Flush writer.\n */\ncljs.core._flush = (function cljs$core$_flush(writer){\nif((((!((writer == null)))) && ((!((writer.cljs$core$IWriter$_flush$arity$1 == null)))))){\nreturn writer.cljs$core$IWriter$_flush$arity$1(writer);\n} else {\nvar x__4433__auto__ = (((writer == null))?null:writer);\nvar m__4434__auto__ = (cljs.core._flush[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(writer) : m__4434__auto__.call(null,writer));\n} else {\nvar m__4431__auto__ = (cljs.core._flush[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(writer) : m__4431__auto__.call(null,writer));\n} else {\nthrow cljs.core.missing_protocol(\"IWriter.-flush\",writer);\n}\n}\n}\n});\n\n\n/**\n * The old IPrintable protocol's implementation consisted of building a giant\n * list of strings to concatenate.  This involved lots of concat calls,\n * intermediate vectors, and lazy-seqs, and was very slow in some older JS\n * engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n * be implemented efficiently in terms of e.g. a StringBuffer append.\n * @interface\n */\ncljs.core.IPrintWithWriter = function(){};\n\ncljs.core._pr_writer = (function cljs$core$_pr_writer(o,writer,opts){\nif((((!((o == null)))) && ((!((o.cljs$core$IPrintWithWriter$_pr_writer$arity$3 == null)))))){\nreturn o.cljs$core$IPrintWithWriter$_pr_writer$arity$3(o,writer,opts);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._pr_writer[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,writer,opts) : m__4434__auto__.call(null,o,writer,opts));\n} else {\nvar m__4431__auto__ = (cljs.core._pr_writer[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,writer,opts) : m__4431__auto__.call(null,o,writer,opts));\n} else {\nthrow cljs.core.missing_protocol(\"IPrintWithWriter.-pr-writer\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for types which can have a deferred realization. Currently only\n *   implemented by Delay and LazySeq.\n * @interface\n */\ncljs.core.IPending = function(){};\n\n/**\n * Returns true if a value for x has been produced, false otherwise.\n */\ncljs.core._realized_QMARK_ = (function cljs$core$_realized_QMARK_(x){\nif((((!((x == null)))) && ((!((x.cljs$core$IPending$_realized_QMARK_$arity$1 == null)))))){\nreturn x.cljs$core$IPending$_realized_QMARK_$arity$1(x);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._realized_QMARK_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ = (cljs.core._realized_QMARK_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol(\"IPending.-realized?\",x);\n}\n}\n}\n});\n\n\n/**\n * Protocol for types that can be watched. Currently only implemented by Atom.\n * @interface\n */\ncljs.core.IWatchable = function(){};\n\n/**\n * Calls all watchers with this, oldval and newval.\n */\ncljs.core._notify_watches = (function cljs$core$_notify_watches(this$,oldval,newval){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IWatchable$_notify_watches$arity$3 == null)))))){\nreturn this$.cljs$core$IWatchable$_notify_watches$arity$3(this$,oldval,newval);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._notify_watches[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(this$,oldval,newval) : m__4434__auto__.call(null,this$,oldval,newval));\n} else {\nvar m__4431__auto__ = (cljs.core._notify_watches[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(this$,oldval,newval) : m__4431__auto__.call(null,this$,oldval,newval));\n} else {\nthrow cljs.core.missing_protocol(\"IWatchable.-notify-watches\",this$);\n}\n}\n}\n});\n\n/**\n * Adds a watcher function f to this. Keys must be unique per reference,\n *   and can be used to remove the watch with -remove-watch.\n */\ncljs.core._add_watch = (function cljs$core$_add_watch(this$,key,f){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IWatchable$_add_watch$arity$3 == null)))))){\nreturn this$.cljs$core$IWatchable$_add_watch$arity$3(this$,key,f);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._add_watch[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(this$,key,f) : m__4434__auto__.call(null,this$,key,f));\n} else {\nvar m__4431__auto__ = (cljs.core._add_watch[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(this$,key,f) : m__4431__auto__.call(null,this$,key,f));\n} else {\nthrow cljs.core.missing_protocol(\"IWatchable.-add-watch\",this$);\n}\n}\n}\n});\n\n/**\n * Removes watcher that corresponds to key from this.\n */\ncljs.core._remove_watch = (function cljs$core$_remove_watch(this$,key){\nif((((!((this$ == null)))) && ((!((this$.cljs$core$IWatchable$_remove_watch$arity$2 == null)))))){\nreturn this$.cljs$core$IWatchable$_remove_watch$arity$2(this$,key);\n} else {\nvar x__4433__auto__ = (((this$ == null))?null:this$);\nvar m__4434__auto__ = (cljs.core._remove_watch[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(this$,key) : m__4434__auto__.call(null,this$,key));\n} else {\nvar m__4431__auto__ = (cljs.core._remove_watch[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(this$,key) : m__4431__auto__.call(null,this$,key));\n} else {\nthrow cljs.core.missing_protocol(\"IWatchable.-remove-watch\",this$);\n}\n}\n}\n});\n\n\n/**\n * Protocol for collections which can transformed to transients.\n * @interface\n */\ncljs.core.IEditableCollection = function(){};\n\n/**\n * Returns a new, transient version of the collection, in constant time.\n */\ncljs.core._as_transient = (function cljs$core$_as_transient(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IEditableCollection$_as_transient$arity$1 == null)))))){\nreturn coll.cljs$core$IEditableCollection$_as_transient$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._as_transient[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._as_transient[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IEditableCollection.-as-transient\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding basic functionality to transient collections.\n * @interface\n */\ncljs.core.ITransientCollection = function(){};\n\n/**\n * Adds value val to tcoll and returns tcoll.\n */\ncljs.core._conj_BANG_ = (function cljs$core$_conj_BANG_(tcoll,val){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientCollection$_conj_BANG_$arity$2 == null)))))){\nreturn tcoll.cljs$core$ITransientCollection$_conj_BANG_$arity$2(tcoll,val);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._conj_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,val) : m__4434__auto__.call(null,tcoll,val));\n} else {\nvar m__4431__auto__ = (cljs.core._conj_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,val) : m__4431__auto__.call(null,tcoll,val));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientCollection.-conj!\",tcoll);\n}\n}\n}\n});\n\n/**\n * Creates a persistent data structure from tcoll and returns it.\n */\ncljs.core._persistent_BANG_ = (function cljs$core$_persistent_BANG_(tcoll){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 == null)))))){\nreturn tcoll.cljs$core$ITransientCollection$_persistent_BANG_$arity$1(tcoll);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._persistent_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4434__auto__.call(null,tcoll));\n} else {\nvar m__4431__auto__ = (cljs.core._persistent_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4431__auto__.call(null,tcoll));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientCollection.-persistent!\",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding associativity to transient collections.\n * @interface\n */\ncljs.core.ITransientAssociative = function(){};\n\n/**\n * Returns a new transient collection of tcoll with a mapping from key to\n *   val added to it.\n */\ncljs.core._assoc_BANG_ = (function cljs$core$_assoc_BANG_(tcoll,key,val){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 == null)))))){\nreturn tcoll.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3(tcoll,key,val);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._assoc_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,key,val) : m__4434__auto__.call(null,tcoll,key,val));\n} else {\nvar m__4431__auto__ = (cljs.core._assoc_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,key,val) : m__4431__auto__.call(null,tcoll,key,val));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientAssociative.-assoc!\",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding mapping functionality to transient collections.\n * @interface\n */\ncljs.core.ITransientMap = function(){};\n\n/**\n * Returns a new transient collection of tcoll without the mapping for key.\n */\ncljs.core._dissoc_BANG_ = (function cljs$core$_dissoc_BANG_(tcoll,key){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientMap$_dissoc_BANG_$arity$2 == null)))))){\nreturn tcoll.cljs$core$ITransientMap$_dissoc_BANG_$arity$2(tcoll,key);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._dissoc_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,key) : m__4434__auto__.call(null,tcoll,key));\n} else {\nvar m__4431__auto__ = (cljs.core._dissoc_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,key) : m__4431__auto__.call(null,tcoll,key));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientMap.-dissoc!\",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding vector functionality to transient collections.\n * @interface\n */\ncljs.core.ITransientVector = function(){};\n\n/**\n * Returns tcoll with value val added at position n.\n */\ncljs.core._assoc_n_BANG_ = (function cljs$core$_assoc_n_BANG_(tcoll,n,val){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3 == null)))))){\nreturn tcoll.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3(tcoll,n,val);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._assoc_n_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,n,val) : m__4434__auto__.call(null,tcoll,n,val));\n} else {\nvar m__4431__auto__ = (cljs.core._assoc_n_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(tcoll,n,val) : m__4431__auto__.call(null,tcoll,n,val));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientVector.-assoc-n!\",tcoll);\n}\n}\n}\n});\n\n/**\n * Returns tcoll with the last item removed from it.\n */\ncljs.core._pop_BANG_ = (function cljs$core$_pop_BANG_(tcoll){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientVector$_pop_BANG_$arity$1 == null)))))){\nreturn tcoll.cljs$core$ITransientVector$_pop_BANG_$arity$1(tcoll);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._pop_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4434__auto__.call(null,tcoll));\n} else {\nvar m__4431__auto__ = (cljs.core._pop_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(tcoll) : m__4431__auto__.call(null,tcoll));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientVector.-pop!\",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding set functionality to a transient collection.\n * @interface\n */\ncljs.core.ITransientSet = function(){};\n\n/**\n * Returns tcoll without v.\n */\ncljs.core._disjoin_BANG_ = (function cljs$core$_disjoin_BANG_(tcoll,v){\nif((((!((tcoll == null)))) && ((!((tcoll.cljs$core$ITransientSet$_disjoin_BANG_$arity$2 == null)))))){\nreturn tcoll.cljs$core$ITransientSet$_disjoin_BANG_$arity$2(tcoll,v);\n} else {\nvar x__4433__auto__ = (((tcoll == null))?null:tcoll);\nvar m__4434__auto__ = (cljs.core._disjoin_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,v) : m__4434__auto__.call(null,tcoll,v));\n} else {\nvar m__4431__auto__ = (cljs.core._disjoin_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(tcoll,v) : m__4431__auto__.call(null,tcoll,v));\n} else {\nthrow cljs.core.missing_protocol(\"ITransientSet.-disjoin!\",tcoll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for values that can be compared.\n * @interface\n */\ncljs.core.IComparable = function(){};\n\n/**\n * Returns a negative number, zero, or a positive number when x is logically\n *   'less than', 'equal to', or 'greater than' y.\n */\ncljs.core._compare = (function cljs$core$_compare(x,y){\nif((((!((x == null)))) && ((!((x.cljs$core$IComparable$_compare$arity$2 == null)))))){\nreturn x.cljs$core$IComparable$_compare$arity$2(x,y);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._compare[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(x,y) : m__4434__auto__.call(null,x,y));\n} else {\nvar m__4431__auto__ = (cljs.core._compare[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(x,y) : m__4431__auto__.call(null,x,y));\n} else {\nthrow cljs.core.missing_protocol(\"IComparable.-compare\",x);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the items of a chunk.\n * @interface\n */\ncljs.core.IChunk = function(){};\n\n/**\n * Return a new chunk of coll with the first item removed.\n */\ncljs.core._drop_first = (function cljs$core$_drop_first(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IChunk$_drop_first$arity$1 == null)))))){\nreturn coll.cljs$core$IChunk$_drop_first$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._drop_first[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._drop_first[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IChunk.-drop-first\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing a collection as sequential chunks.\n * @interface\n */\ncljs.core.IChunkedSeq = function(){};\n\n/**\n * Returns the first chunk in coll.\n */\ncljs.core._chunked_first = (function cljs$core$_chunked_first(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IChunkedSeq$_chunked_first$arity$1 == null)))))){\nreturn coll.cljs$core$IChunkedSeq$_chunked_first$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._chunked_first[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._chunked_first[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IChunkedSeq.-chunked-first\",coll);\n}\n}\n}\n});\n\n/**\n * Return a new collection of coll with the first chunk removed.\n */\ncljs.core._chunked_rest = (function cljs$core$_chunked_rest(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IChunkedSeq$_chunked_rest$arity$1 == null)))))){\nreturn coll.cljs$core$IChunkedSeq$_chunked_rest$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._chunked_rest[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._chunked_rest[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IChunkedSeq.-chunked-rest\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for accessing the chunks of a collection.\n * @interface\n */\ncljs.core.IChunkedNext = function(){};\n\n/**\n * Returns a new collection of coll without the first chunk.\n */\ncljs.core._chunked_next = (function cljs$core$_chunked_next(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IChunkedNext$_chunked_next$arity$1 == null)))))){\nreturn coll.cljs$core$IChunkedNext$_chunked_next$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._chunked_next[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._chunked_next[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IChunkedNext.-chunked-next\",coll);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding a name.\n * @interface\n */\ncljs.core.INamed = function(){};\n\n/**\n * Returns the name String of x.\n */\ncljs.core._name = (function cljs$core$_name(x){\nif((((!((x == null)))) && ((!((x.cljs$core$INamed$_name$arity$1 == null)))))){\nreturn x.cljs$core$INamed$_name$arity$1(x);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._name[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ = (cljs.core._name[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol(\"INamed.-name\",x);\n}\n}\n}\n});\n\n/**\n * Returns the namespace String of x.\n */\ncljs.core._namespace = (function cljs$core$_namespace(x){\nif((((!((x == null)))) && ((!((x.cljs$core$INamed$_namespace$arity$1 == null)))))){\nreturn x.cljs$core$INamed$_namespace$arity$1(x);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._namespace[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ = (cljs.core._namespace[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol(\"INamed.-namespace\",x);\n}\n}\n}\n});\n\n\n/**\n * Marker protocol indicating an atom.\n * @interface\n */\ncljs.core.IAtom = function(){};\n\n\n/**\n * Protocol for adding resetting functionality.\n * @interface\n */\ncljs.core.IReset = function(){};\n\n/**\n * Sets the value of o to new-value.\n */\ncljs.core._reset_BANG_ = (function cljs$core$_reset_BANG_(o,new_value){\nif((((!((o == null)))) && ((!((o.cljs$core$IReset$_reset_BANG_$arity$2 == null)))))){\nreturn o.cljs$core$IReset$_reset_BANG_$arity$2(o,new_value);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._reset_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4434__auto__.call(null,o,new_value));\n} else {\nvar m__4431__auto__ = (cljs.core._reset_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4431__auto__.call(null,o,new_value));\n} else {\nthrow cljs.core.missing_protocol(\"IReset.-reset!\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for adding swapping functionality.\n * @interface\n */\ncljs.core.ISwap = function(){};\n\n/**\n * Swaps the value of o to be (apply f current-value-of-atom args).\n */\ncljs.core._swap_BANG_ = (function cljs$core$_swap_BANG_(var_args){\nvar G__625 = arguments.length;\nswitch (G__625) {\ncase 2:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (o,f){\nif((((!((o == null)))) && ((!((o.cljs$core$ISwap$_swap_BANG_$arity$2 == null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$2(o,f);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,f) : m__4434__auto__.call(null,o,f));\n} else {\nvar m__4431__auto__ = (cljs.core._swap_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,f) : m__4431__auto__.call(null,o,f));\n} else {\nthrow cljs.core.missing_protocol(\"ISwap.-swap!\",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (o,f,a){\nif((((!((o == null)))) && ((!((o.cljs$core$ISwap$_swap_BANG_$arity$3 == null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$3(o,f,a);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(o,f,a) : m__4434__auto__.call(null,o,f,a));\n} else {\nvar m__4431__auto__ = (cljs.core._swap_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(o,f,a) : m__4431__auto__.call(null,o,f,a));\n} else {\nthrow cljs.core.missing_protocol(\"ISwap.-swap!\",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$4 = (function (o,f,a,b){\nif((((!((o == null)))) && ((!((o.cljs$core$ISwap$_swap_BANG_$arity$4 == null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$4(o,f,a,b);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(o,f,a,b) : m__4434__auto__.call(null,o,f,a,b));\n} else {\nvar m__4431__auto__ = (cljs.core._swap_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(o,f,a,b) : m__4431__auto__.call(null,o,f,a,b));\n} else {\nthrow cljs.core.missing_protocol(\"ISwap.-swap!\",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$5 = (function (o,f,a,b,xs){\nif((((!((o == null)))) && ((!((o.cljs$core$ISwap$_swap_BANG_$arity$5 == null)))))){\nreturn o.cljs$core$ISwap$_swap_BANG_$arity$5(o,f,a,b,xs);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._swap_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$5(o,f,a,b,xs) : m__4434__auto__.call(null,o,f,a,b,xs));\n} else {\nvar m__4431__auto__ = (cljs.core._swap_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$5 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$5(o,f,a,b,xs) : m__4431__auto__.call(null,o,f,a,b,xs));\n} else {\nthrow cljs.core.missing_protocol(\"ISwap.-swap!\",o);\n}\n}\n}\n});\n\ncljs.core._swap_BANG_.cljs$lang$maxFixedArity = 5;\n\n\n\n/**\n * Protocol for adding volatile functionality.\n * @interface\n */\ncljs.core.IVolatile = function(){};\n\n/**\n * Sets the value of volatile o to new-value without regard for the\n *   current value. Returns new-value.\n */\ncljs.core._vreset_BANG_ = (function cljs$core$_vreset_BANG_(o,new_value){\nif((((!((o == null)))) && ((!((o.cljs$core$IVolatile$_vreset_BANG_$arity$2 == null)))))){\nreturn o.cljs$core$IVolatile$_vreset_BANG_$arity$2(o,new_value);\n} else {\nvar x__4433__auto__ = (((o == null))?null:o);\nvar m__4434__auto__ = (cljs.core._vreset_BANG_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4434__auto__.call(null,o,new_value));\n} else {\nvar m__4431__auto__ = (cljs.core._vreset_BANG_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(o,new_value) : m__4431__auto__.call(null,o,new_value));\n} else {\nthrow cljs.core.missing_protocol(\"IVolatile.-vreset!\",o);\n}\n}\n}\n});\n\n\n/**\n * Protocol for iterating over a collection.\n * @interface\n */\ncljs.core.IIterable = function(){};\n\n/**\n * Returns an iterator for coll.\n */\ncljs.core._iterator = (function cljs$core$_iterator(coll){\nif((((!((coll == null)))) && ((!((coll.cljs$core$IIterable$_iterator$arity$1 == null)))))){\nreturn coll.cljs$core$IIterable$_iterator$arity$1(coll);\n} else {\nvar x__4433__auto__ = (((coll == null))?null:coll);\nvar m__4434__auto__ = (cljs.core._iterator[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4434__auto__.call(null,coll));\n} else {\nvar m__4431__auto__ = (cljs.core._iterator[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(coll) : m__4431__auto__.call(null,coll));\n} else {\nthrow cljs.core.missing_protocol(\"IIterable.-iterator\",coll);\n}\n}\n}\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IWriter}\n*/\ncljs.core.StringBufferWriter = (function (sb){\nthis.sb = sb;\nthis.cljs$lang$protocol_mask$partition0$ = 1073741824;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.StringBufferWriter.prototype.cljs$core$IWriter$_write$arity$2 = (function (_,s){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.sb.append(s);\n});\n\ncljs.core.StringBufferWriter.prototype.cljs$core$IWriter$_flush$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn null;\n});\n\ncljs.core.StringBufferWriter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"sb\",\"sb\",-1249746442,null)], null);\n});\n\ncljs.core.StringBufferWriter.cljs$lang$type = true;\n\ncljs.core.StringBufferWriter.cljs$lang$ctorStr = \"cljs.core/StringBufferWriter\";\n\ncljs.core.StringBufferWriter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/StringBufferWriter\");\n});\n\n/**\n * Positional factory function for cljs.core/StringBufferWriter.\n */\ncljs.core.__GT_StringBufferWriter = (function cljs$core$__GT_StringBufferWriter(sb){\nreturn (new cljs.core.StringBufferWriter(sb));\n});\n\n/**\n * Support so that collections can implement toString without\n * loading all the printing machinery.\n */\ncljs.core.pr_str_STAR_ = (function cljs$core$pr_str_STAR_(obj){\nvar sb = (new goog.string.StringBuffer());\nvar writer = (new cljs.core.StringBufferWriter(sb));\nobj.cljs$core$IPrintWithWriter$_pr_writer$arity$3(null,writer,cljs.core.pr_opts());\n\nwriter.cljs$core$IWriter$_flush$arity$1(null);\n\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(sb);\n});\ncljs.core.int_rotate_left = (function cljs$core$int_rotate_left(x,n){\nreturn ((x << n) | (x >>> (- n)));\n});\nif((((typeof Math !== 'undefined') && (typeof Math.imul !== 'undefined')) && ((!((Math.imul((4294967295),(5)) === (0))))))){\ncljs.core.imul = (function cljs$core$imul(a,b){\nreturn Math.imul(a,b);\n});\n} else {\ncljs.core.imul = (function cljs$core$imul(a,b){\nvar ah = ((a >>> (16)) & (65535));\nvar al = (a & (65535));\nvar bh = ((b >>> (16)) & (65535));\nvar bl = (b & (65535));\nreturn (((al * bl) + ((((ah * bl) + (al * bh)) << (16)) >>> (0))) | (0));\n});\n}\ncljs.core.m3_seed = (0);\ncljs.core.m3_C1 = ((3432918353) | (0));\ncljs.core.m3_C2 = ((461845907) | (0));\ncljs.core.m3_mix_K1 = (function cljs$core$m3_mix_K1(k1){\nreturn cljs.core.imul(cljs.core.int_rotate_left(cljs.core.imul((k1 | (0)),cljs.core.m3_C1),(15)),cljs.core.m3_C2);\n});\ncljs.core.m3_mix_H1 = (function cljs$core$m3_mix_H1(h1,k1){\nreturn ((cljs.core.imul(cljs.core.int_rotate_left(((h1 | (0)) ^ (k1 | (0))),(13)),(5)) + ((3864292196) | (0))) | (0));\n});\ncljs.core.m3_fmix = (function cljs$core$m3_fmix(h1,len){\nvar h1__$1 = (h1 | (0));\nvar h1__$2 = (h1__$1 ^ len);\nvar h1__$3 = (h1__$2 ^ (h1__$2 >>> (16)));\nvar h1__$4 = cljs.core.imul(h1__$3,((2246822507) | (0)));\nvar h1__$5 = (h1__$4 ^ (h1__$4 >>> (13)));\nvar h1__$6 = cljs.core.imul(h1__$5,((3266489909) | (0)));\nreturn (h1__$6 ^ (h1__$6 >>> (16)));\n});\ncljs.core.m3_hash_int = (function cljs$core$m3_hash_int(in$){\nif((in$ === (0))){\nreturn in$;\n} else {\nvar k1 = cljs.core.m3_mix_K1(in$);\nvar h1 = cljs.core.m3_mix_H1(cljs.core.m3_seed,k1);\nreturn cljs.core.m3_fmix(h1,(4));\n}\n});\ncljs.core.m3_hash_unencoded_chars = (function cljs$core$m3_hash_unencoded_chars(in$){\nvar h1 = (function (){var i = (1);\nvar h1 = cljs.core.m3_seed;\nwhile(true){\nif((i < in$.length)){\nvar G__627 = (i + (2));\nvar G__628 = cljs.core.m3_mix_H1(h1,cljs.core.m3_mix_K1((in$.charCodeAt((i - (1))) | (in$.charCodeAt(i) << (16)))));\ni = G__627;\nh1 = G__628;\ncontinue;\n} else {\nreturn h1;\n}\nbreak;\n}\n})();\nvar h1__$1 = ((((in$.length & (1)) === (1)))?(h1 ^ cljs.core.m3_mix_K1(in$.charCodeAt((in$.length - (1))))):h1);\nreturn cljs.core.m3_fmix(h1__$1,cljs.core.imul((2),in$.length));\n});\n\n\n\ncljs.core.string_hash_cache = ({});\ncljs.core.string_hash_cache_count = (0);\ncljs.core.hash_string_STAR_ = (function cljs$core$hash_string_STAR_(s){\nif((!((s == null)))){\nvar len = s.length;\nif((len > (0))){\nvar i = (0);\nvar hash = (0);\nwhile(true){\nif((i < len)){\nvar G__631 = (i + (1));\nvar G__632 = (cljs.core.imul((31),hash) + s.charCodeAt(i));\ni = G__631;\nhash = G__632;\ncontinue;\n} else {\nreturn hash;\n}\nbreak;\n}\n} else {\nreturn (0);\n}\n} else {\nreturn (0);\n}\n});\ncljs.core.add_to_string_hash_cache = (function cljs$core$add_to_string_hash_cache(k){\nvar h = cljs.core.hash_string_STAR_(k);\ngoog.object.set(cljs.core.string_hash_cache,k,h);\n\ncljs.core.string_hash_cache_count = (cljs.core.string_hash_cache_count + (1));\n\nreturn h;\n});\ncljs.core.hash_string = (function cljs$core$hash_string(k){\nif((cljs.core.string_hash_cache_count > (255))){\ncljs.core.string_hash_cache = ({});\n\ncljs.core.string_hash_cache_count = (0);\n} else {\n}\n\nif((k == null)){\nreturn (0);\n} else {\nvar h = (cljs.core.string_hash_cache[k]);\nif(typeof h === 'number'){\nreturn h;\n} else {\nreturn cljs.core.add_to_string_hash_cache(k);\n}\n}\n});\n/**\n * Returns the hash code of its argument. Note this is the hash code\n * consistent with =.\n */\ncljs.core.hash = (function cljs$core$hash(o){\nif((((!((o == null))))?(((((o.cljs$lang$protocol_mask$partition0$ & (4194304))) || ((cljs.core.PROTOCOL_SENTINEL === o.cljs$core$IHash$))))?true:false):false)){\nreturn (cljs.core._hash(o) ^ (0));\n} else {\nif(typeof o === 'number'){\nif(cljs.core.truth_(isFinite(o))){\nreturn (Math.floor(o) % (2147483647));\n} else {\nvar G__636 = o;\nswitch (G__636) {\ncase Infinity:\nreturn (2146435072);\n\nbreak;\ncase -Infinity:\nreturn (-1048576);\n\nbreak;\ndefault:\nreturn (2146959360);\n\n}\n}\n} else {\nif(o === true){\nreturn (1231);\n} else {\nif(o === false){\nreturn (1237);\n} else {\nif(typeof o === 'string'){\nreturn cljs.core.m3_hash_int(cljs.core.hash_string(o));\n} else {\nif((o instanceof Date)){\nreturn (o.valueOf() ^ (0));\n} else {\nif((o == null)){\nreturn (0);\n} else {\nreturn (cljs.core._hash(o) ^ (0));\n\n}\n}\n}\n}\n}\n}\n}\n});\ncljs.core.hash_combine = (function cljs$core$hash_combine(seed,hash){\nreturn (seed ^ (((hash + (2654435769)) + (seed << (6))) + (seed >> (2))));\n});\n/**\n * Evaluates x and tests if it is an instance of the type\n *   c. Returns true or false\n */\ncljs.core.instance_QMARK_ = (function cljs$core$instance_QMARK_(c,x){\nreturn (x instanceof c);\n});\n/**\n * Return true if x is a Symbol\n */\ncljs.core.symbol_QMARK_ = (function cljs$core$symbol_QMARK_(x){\nreturn (x instanceof cljs.core.Symbol);\n});\ncljs.core.hash_symbol = (function cljs$core$hash_symbol(sym){\nreturn cljs.core.hash_combine(cljs.core.m3_hash_unencoded_chars(sym.name),cljs.core.hash_string(sym.ns));\n});\ncljs.core.compare_symbols = (function cljs$core$compare_symbols(a,b){\nif((a.str === b.str)){\nreturn (0);\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.not(a.ns);\nif(and__4120__auto__){\nreturn b.ns;\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (-1);\n} else {\nif(cljs.core.truth_(a.ns)){\nif(cljs.core.not(b.ns)){\nreturn (1);\n} else {\nvar nsc = (function (){var G__638 = a.ns;\nvar G__639 = b.ns;\nreturn goog.array.defaultCompare(G__638,G__639);\n})();\nif(((0) === nsc)){\nvar G__640 = a.name;\nvar G__641 = b.name;\nreturn goog.array.defaultCompare(G__640,G__641);\n} else {\nreturn nsc;\n}\n}\n} else {\nvar G__642 = a.name;\nvar G__643 = b.name;\nreturn goog.array.defaultCompare(G__642,G__643);\n\n}\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.INamed}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.Symbol = (function (ns,name,str,_hash,_meta){\nthis.ns = ns;\nthis.name = name;\nthis.str = str;\nthis._hash = _hash;\nthis._meta = _meta;\nthis.cljs$lang$protocol_mask$partition0$ = 2154168321;\nthis.cljs$lang$protocol_mask$partition1$ = 4096;\n});\ncljs.core.Symbol.prototype.toString = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.str;\n});\n\ncljs.core.Symbol.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Symbol.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (_,other){\nvar self__ = this;\nvar ___$1 = this;\nif((other instanceof cljs.core.Symbol)){\nreturn (self__.str === other.str);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Symbol.prototype.call = (function() {\nvar G__645 = null;\nvar G__645__2 = (function (self__,coll){\nvar self__ = this;\nvar self____$1 = this;\nvar sym = self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,sym);\n});\nvar G__645__3 = (function (self__,coll,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar sym = self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,sym,not_found);\n});\nG__645 = function(self__,coll,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__645__2.call(this,self__,coll);\ncase 3:\nreturn G__645__3.call(this,self__,coll,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__645.cljs$core$IFn$_invoke$arity$2 = G__645__2;\nG__645.cljs$core$IFn$_invoke$arity$3 = G__645__3;\nreturn G__645;\n})()\n;\n\ncljs.core.Symbol.prototype.apply = (function (self__,args644){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args644)));\n});\n\ncljs.core.Symbol.prototype.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nvar self__ = this;\nvar sym = this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,sym);\n});\n\ncljs.core.Symbol.prototype.cljs$core$IFn$_invoke$arity$2 = (function (coll,not_found){\nvar self__ = this;\nvar sym = this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,sym,not_found);\n});\n\ncljs.core.Symbol.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__._meta;\n});\n\ncljs.core.Symbol.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_,new_meta){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.Symbol(self__.ns,self__.name,self__.str,self__._hash,new_meta));\n});\n\ncljs.core.Symbol.prototype.cljs$core$IHash$_hash$arity$1 = (function (sym){\nvar self__ = this;\nvar sym__$1 = this;\nvar h__4243__auto__ = self__._hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_symbol(sym__$1);\nself__._hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Symbol.prototype.cljs$core$INamed$_name$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.name;\n});\n\ncljs.core.Symbol.prototype.cljs$core$INamed$_namespace$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.ns;\n});\n\ncljs.core.Symbol.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (o,writer,_){\nvar self__ = this;\nvar o__$1 = this;\nreturn cljs.core._write(writer,self__.str);\n});\n\ncljs.core.Symbol.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"ns\",\"ns\",2082130287,null),new cljs.core.Symbol(null,\"name\",\"name\",-810760592,null),new cljs.core.Symbol(null,\"str\",\"str\",-1564826950,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"_hash\",\"_hash\",-2130838312,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"_meta\",\"_meta\",-1716892533,null)], null);\n});\n\ncljs.core.Symbol.cljs$lang$type = true;\n\ncljs.core.Symbol.cljs$lang$ctorStr = \"cljs.core/Symbol\";\n\ncljs.core.Symbol.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Symbol\");\n});\n\n/**\n * Positional factory function for cljs.core/Symbol.\n */\ncljs.core.__GT_Symbol = (function cljs$core$__GT_Symbol(ns,name,str,_hash,_meta){\nreturn (new cljs.core.Symbol(ns,name,str,_hash,_meta));\n});\n\n/**\n * Returns true if v is of type cljs.core.Var\n */\ncljs.core.var_QMARK_ = (function cljs$core$var_QMARK_(v){\nreturn (v instanceof cljs.core.Var);\n});\n/**\n * Returns a Symbol with the given namespace and name. Arity-1 works\n *   on strings, keywords, and vars.\n */\ncljs.core.symbol = (function cljs$core$symbol(var_args){\nvar G__647 = arguments.length;\nswitch (G__647) {\ncase 1:\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.symbol.cljs$core$IFn$_invoke$arity$1 = (function (name){\nwhile(true){\nif((name instanceof cljs.core.Symbol)){\nreturn name;\n} else {\nif(typeof name === 'string'){\nvar idx = name.indexOf(\"/\");\nif((idx < (1))){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(null,name);\n} else {\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(name.substring((0),idx),name.substring((idx + (1)),name.length));\n}\n} else {\nif(cljs.core.var_QMARK_(name)){\nreturn name.sym;\n} else {\nif((name instanceof cljs.core.Keyword)){\nvar G__649 = name.fqn;\nname = G__649;\ncontinue;\n} else {\nthrow (new Error(\"no conversion to symbol\"));\n\n}\n}\n}\n}\nbreak;\n}\n});\n\ncljs.core.symbol.cljs$core$IFn$_invoke$arity$2 = (function (ns,name){\nvar sym_str = (((!((ns == null))))?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns),\"/\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(name)].join(''):name);\nreturn (new cljs.core.Symbol(ns,name,sym_str,null,null));\n});\n\ncljs.core.symbol.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.Fn}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.Var = (function (val,sym,_meta){\nthis.val = val;\nthis.sym = sym;\nthis._meta = _meta;\nthis.cljs$lang$protocol_mask$partition0$ = 6717441;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.Var.prototype.isMacro = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null)).cljs$lang$macro;\n});\n\ncljs.core.Var.prototype.toString = (function (){\nvar self__ = this;\nvar _ = this;\nreturn [\"#'\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.sym)].join('');\n});\n\ncljs.core.Var.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\n});\n\ncljs.core.Var.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__._meta;\n});\n\ncljs.core.Var.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_,new_meta){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.Var(self__.val,self__.sym,new_meta));\n});\n\ncljs.core.Var.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this$,other){\nvar self__ = this;\nvar this$__$1 = this;\nif((other instanceof cljs.core.Var)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this$__$1.sym,other.sym);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Var.prototype.cljs$core$IHash$_hash$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.hash_symbol(self__.sym);\n});\n\ncljs.core.Var.prototype.cljs$core$Fn$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Var.prototype.call = (function() {\nvar G__693 = null;\nvar G__693__1 = (function (self__){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__651 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__651.cljs$core$IFn$_invoke$arity$0 ? fexpr__651.cljs$core$IFn$_invoke$arity$0() : fexpr__651.call(null));\n});\nvar G__693__2 = (function (self__,a){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__652 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__652.cljs$core$IFn$_invoke$arity$1 ? fexpr__652.cljs$core$IFn$_invoke$arity$1(a) : fexpr__652.call(null,a));\n});\nvar G__693__3 = (function (self__,a,b){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__653 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__653.cljs$core$IFn$_invoke$arity$2 ? fexpr__653.cljs$core$IFn$_invoke$arity$2(a,b) : fexpr__653.call(null,a,b));\n});\nvar G__693__4 = (function (self__,a,b,c){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__654 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__654.cljs$core$IFn$_invoke$arity$3 ? fexpr__654.cljs$core$IFn$_invoke$arity$3(a,b,c) : fexpr__654.call(null,a,b,c));\n});\nvar G__693__5 = (function (self__,a,b,c,d){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__655 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__655.cljs$core$IFn$_invoke$arity$4 ? fexpr__655.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : fexpr__655.call(null,a,b,c,d));\n});\nvar G__693__6 = (function (self__,a,b,c,d,e){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__656 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__656.cljs$core$IFn$_invoke$arity$5 ? fexpr__656.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : fexpr__656.call(null,a,b,c,d,e));\n});\nvar G__693__7 = (function (self__,a,b,c,d,e,f){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__657 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__657.cljs$core$IFn$_invoke$arity$6 ? fexpr__657.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : fexpr__657.call(null,a,b,c,d,e,f));\n});\nvar G__693__8 = (function (self__,a,b,c,d,e,f,g){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__658 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__658.cljs$core$IFn$_invoke$arity$7 ? fexpr__658.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : fexpr__658.call(null,a,b,c,d,e,f,g));\n});\nvar G__693__9 = (function (self__,a,b,c,d,e,f,g,h){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__659 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__659.cljs$core$IFn$_invoke$arity$8 ? fexpr__659.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : fexpr__659.call(null,a,b,c,d,e,f,g,h));\n});\nvar G__693__10 = (function (self__,a,b,c,d,e,f,g,h,i){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__660 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__660.cljs$core$IFn$_invoke$arity$9 ? fexpr__660.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : fexpr__660.call(null,a,b,c,d,e,f,g,h,i));\n});\nvar G__693__11 = (function (self__,a,b,c,d,e,f,g,h,i,j){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__661 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__661.cljs$core$IFn$_invoke$arity$10 ? fexpr__661.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : fexpr__661.call(null,a,b,c,d,e,f,g,h,i,j));\n});\nvar G__693__12 = (function (self__,a,b,c,d,e,f,g,h,i,j,k){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__662 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__662.cljs$core$IFn$_invoke$arity$11 ? fexpr__662.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : fexpr__662.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\nvar G__693__13 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__663 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__663.cljs$core$IFn$_invoke$arity$12 ? fexpr__663.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : fexpr__663.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\nvar G__693__14 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__664 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__664.cljs$core$IFn$_invoke$arity$13 ? fexpr__664.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : fexpr__664.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\nvar G__693__15 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__665 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__665.cljs$core$IFn$_invoke$arity$14 ? fexpr__665.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : fexpr__665.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\nvar G__693__16 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__666 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__666.cljs$core$IFn$_invoke$arity$15 ? fexpr__666.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : fexpr__666.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\nvar G__693__17 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__667 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__667.cljs$core$IFn$_invoke$arity$16 ? fexpr__667.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : fexpr__667.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\nvar G__693__18 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__668 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__668.cljs$core$IFn$_invoke$arity$17 ? fexpr__668.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : fexpr__668.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\nvar G__693__19 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__669 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__669.cljs$core$IFn$_invoke$arity$18 ? fexpr__669.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : fexpr__669.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\nvar G__693__20 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__670 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__670.cljs$core$IFn$_invoke$arity$19 ? fexpr__670.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : fexpr__670.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\nvar G__693__21 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nvar fexpr__671 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__671.cljs$core$IFn$_invoke$arity$20 ? fexpr__671.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : fexpr__671.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\nvar G__693__22 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic((self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null)),a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\nG__693 = function(self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nswitch(arguments.length){\ncase 1:\nreturn G__693__1.call(this,self__);\ncase 2:\nreturn G__693__2.call(this,self__,a);\ncase 3:\nreturn G__693__3.call(this,self__,a,b);\ncase 4:\nreturn G__693__4.call(this,self__,a,b,c);\ncase 5:\nreturn G__693__5.call(this,self__,a,b,c,d);\ncase 6:\nreturn G__693__6.call(this,self__,a,b,c,d,e);\ncase 7:\nreturn G__693__7.call(this,self__,a,b,c,d,e,f);\ncase 8:\nreturn G__693__8.call(this,self__,a,b,c,d,e,f,g);\ncase 9:\nreturn G__693__9.call(this,self__,a,b,c,d,e,f,g,h);\ncase 10:\nreturn G__693__10.call(this,self__,a,b,c,d,e,f,g,h,i);\ncase 11:\nreturn G__693__11.call(this,self__,a,b,c,d,e,f,g,h,i,j);\ncase 12:\nreturn G__693__12.call(this,self__,a,b,c,d,e,f,g,h,i,j,k);\ncase 13:\nreturn G__693__13.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l);\ncase 14:\nreturn G__693__14.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m);\ncase 15:\nreturn G__693__15.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\ncase 16:\nreturn G__693__16.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\ncase 17:\nreturn G__693__17.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\ncase 18:\nreturn G__693__18.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\ncase 19:\nreturn G__693__19.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\ncase 20:\nreturn G__693__20.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\ncase 21:\nreturn G__693__21.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\ncase 22:\nreturn G__693__22.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__693.cljs$core$IFn$_invoke$arity$1 = G__693__1;\nG__693.cljs$core$IFn$_invoke$arity$2 = G__693__2;\nG__693.cljs$core$IFn$_invoke$arity$3 = G__693__3;\nG__693.cljs$core$IFn$_invoke$arity$4 = G__693__4;\nG__693.cljs$core$IFn$_invoke$arity$5 = G__693__5;\nG__693.cljs$core$IFn$_invoke$arity$6 = G__693__6;\nG__693.cljs$core$IFn$_invoke$arity$7 = G__693__7;\nG__693.cljs$core$IFn$_invoke$arity$8 = G__693__8;\nG__693.cljs$core$IFn$_invoke$arity$9 = G__693__9;\nG__693.cljs$core$IFn$_invoke$arity$10 = G__693__10;\nG__693.cljs$core$IFn$_invoke$arity$11 = G__693__11;\nG__693.cljs$core$IFn$_invoke$arity$12 = G__693__12;\nG__693.cljs$core$IFn$_invoke$arity$13 = G__693__13;\nG__693.cljs$core$IFn$_invoke$arity$14 = G__693__14;\nG__693.cljs$core$IFn$_invoke$arity$15 = G__693__15;\nG__693.cljs$core$IFn$_invoke$arity$16 = G__693__16;\nG__693.cljs$core$IFn$_invoke$arity$17 = G__693__17;\nG__693.cljs$core$IFn$_invoke$arity$18 = G__693__18;\nG__693.cljs$core$IFn$_invoke$arity$19 = G__693__19;\nG__693.cljs$core$IFn$_invoke$arity$20 = G__693__20;\nG__693.cljs$core$IFn$_invoke$arity$21 = G__693__21;\nG__693.cljs$core$IFn$_invoke$arity$22 = G__693__22;\nreturn G__693;\n})()\n;\n\ncljs.core.Var.prototype.apply = (function (self__,args650){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args650)));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$0 = (function (){\nvar self__ = this;\nvar _ = this;\nvar fexpr__672 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__672.cljs$core$IFn$_invoke$arity$0 ? fexpr__672.cljs$core$IFn$_invoke$arity$0() : fexpr__672.call(null));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$1 = (function (a){\nvar self__ = this;\nvar _ = this;\nvar fexpr__673 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__673.cljs$core$IFn$_invoke$arity$1 ? fexpr__673.cljs$core$IFn$_invoke$arity$1(a) : fexpr__673.call(null,a));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nvar self__ = this;\nvar _ = this;\nvar fexpr__674 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__674.cljs$core$IFn$_invoke$arity$2 ? fexpr__674.cljs$core$IFn$_invoke$arity$2(a,b) : fexpr__674.call(null,a,b));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nvar self__ = this;\nvar _ = this;\nvar fexpr__675 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__675.cljs$core$IFn$_invoke$arity$3 ? fexpr__675.cljs$core$IFn$_invoke$arity$3(a,b,c) : fexpr__675.call(null,a,b,c));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$4 = (function (a,b,c,d){\nvar self__ = this;\nvar _ = this;\nvar fexpr__676 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__676.cljs$core$IFn$_invoke$arity$4 ? fexpr__676.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : fexpr__676.call(null,a,b,c,d));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$5 = (function (a,b,c,d,e){\nvar self__ = this;\nvar _ = this;\nvar fexpr__677 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__677.cljs$core$IFn$_invoke$arity$5 ? fexpr__677.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : fexpr__677.call(null,a,b,c,d,e));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$6 = (function (a,b,c,d,e,f){\nvar self__ = this;\nvar _ = this;\nvar fexpr__678 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__678.cljs$core$IFn$_invoke$arity$6 ? fexpr__678.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : fexpr__678.call(null,a,b,c,d,e,f));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$7 = (function (a,b,c,d,e,f,g){\nvar self__ = this;\nvar _ = this;\nvar fexpr__679 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__679.cljs$core$IFn$_invoke$arity$7 ? fexpr__679.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : fexpr__679.call(null,a,b,c,d,e,f,g));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$8 = (function (a,b,c,d,e,f,g,h){\nvar self__ = this;\nvar _ = this;\nvar fexpr__680 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__680.cljs$core$IFn$_invoke$arity$8 ? fexpr__680.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : fexpr__680.call(null,a,b,c,d,e,f,g,h));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$9 = (function (a,b,c,d,e,f,g,h,i){\nvar self__ = this;\nvar _ = this;\nvar fexpr__681 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__681.cljs$core$IFn$_invoke$arity$9 ? fexpr__681.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : fexpr__681.call(null,a,b,c,d,e,f,g,h,i));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$10 = (function (a,b,c,d,e,f,g,h,i,j){\nvar self__ = this;\nvar _ = this;\nvar fexpr__682 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__682.cljs$core$IFn$_invoke$arity$10 ? fexpr__682.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : fexpr__682.call(null,a,b,c,d,e,f,g,h,i,j));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$11 = (function (a,b,c,d,e,f,g,h,i,j,k){\nvar self__ = this;\nvar _ = this;\nvar fexpr__683 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__683.cljs$core$IFn$_invoke$arity$11 ? fexpr__683.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : fexpr__683.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$12 = (function (a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ = this;\nvar _ = this;\nvar fexpr__684 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__684.cljs$core$IFn$_invoke$arity$12 ? fexpr__684.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : fexpr__684.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$13 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ = this;\nvar _ = this;\nvar fexpr__685 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__685.cljs$core$IFn$_invoke$arity$13 ? fexpr__685.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : fexpr__685.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$14 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ = this;\nvar _ = this;\nvar fexpr__686 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__686.cljs$core$IFn$_invoke$arity$14 ? fexpr__686.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : fexpr__686.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$15 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ = this;\nvar _ = this;\nvar fexpr__687 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__687.cljs$core$IFn$_invoke$arity$15 ? fexpr__687.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : fexpr__687.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$16 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ = this;\nvar _ = this;\nvar fexpr__688 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__688.cljs$core$IFn$_invoke$arity$16 ? fexpr__688.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : fexpr__688.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$17 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ = this;\nvar _ = this;\nvar fexpr__689 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__689.cljs$core$IFn$_invoke$arity$17 ? fexpr__689.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : fexpr__689.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$18 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ = this;\nvar _ = this;\nvar fexpr__690 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__690.cljs$core$IFn$_invoke$arity$18 ? fexpr__690.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : fexpr__690.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$19 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ = this;\nvar _ = this;\nvar fexpr__691 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__691.cljs$core$IFn$_invoke$arity$19 ? fexpr__691.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : fexpr__691.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$20 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ = this;\nvar _ = this;\nvar fexpr__692 = (self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null));\nreturn (fexpr__692.cljs$core$IFn$_invoke$arity$20 ? fexpr__692.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : fexpr__692.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\n\ncljs.core.Var.prototype.cljs$core$IFn$_invoke$arity$21 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ = this;\nvar _ = this;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic((self__.val.cljs$core$IFn$_invoke$arity$0 ? self__.val.cljs$core$IFn$_invoke$arity$0() : self__.val.call(null)),a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\n\ncljs.core.Var.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.Symbol(null,\"sym\",\"sym\",195671222,null),new cljs.core.Symbol(null,\"_meta\",\"_meta\",-1716892533,null)], null);\n});\n\ncljs.core.Var.cljs$lang$type = true;\n\ncljs.core.Var.cljs$lang$ctorStr = \"cljs.core/Var\";\n\ncljs.core.Var.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Var\");\n});\n\n/**\n * Positional factory function for cljs.core/Var.\n */\ncljs.core.__GT_Var = (function cljs$core$__GT_Var(val,sym,_meta){\nreturn (new cljs.core.Var(val,sym,_meta));\n});\n\n\n\n/**\n * Return true if x implements IIterable protocol.\n */\ncljs.core.iterable_QMARK_ = (function cljs$core$iterable_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition1$ & (131072))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IIterable$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition1$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIterable,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIterable,x);\n}\n});\n/**\n * Clone the supplied value which must implement ICloneable.\n */\ncljs.core.clone = (function cljs$core$clone(value){\nreturn cljs.core._clone(value);\n});\n/**\n * Return true if x implements ICloneable protocol.\n */\ncljs.core.cloneable_QMARK_ = (function cljs$core$cloneable_QMARK_(value){\nif((!((value == null)))){\nif((((value.cljs$lang$protocol_mask$partition1$ & (8192))) || ((cljs.core.PROTOCOL_SENTINEL === value.cljs$core$ICloneable$)))){\nreturn true;\n} else {\nif((!value.cljs$lang$protocol_mask$partition1$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICloneable,value);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICloneable,value);\n}\n});\n/**\n * Returns a seq on the collection. If the collection is\n *   empty, returns nil.  (seq nil) returns nil. seq also works on\n *   Strings.\n */\ncljs.core.seq = (function cljs$core$seq(coll){\nif((coll == null)){\nreturn null;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (8388608))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeqable$))))?true:false):false)){\nreturn cljs.core._seq(coll);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nif((coll.length === (0))){\nreturn null;\n} else {\nreturn (new cljs.core.IndexedSeq(coll,(0),null));\n}\n} else {\nif(typeof coll === 'string'){\nif((coll.length === (0))){\nreturn null;\n} else {\nreturn (new cljs.core.IndexedSeq(coll,(0),null));\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.ISeqable,coll)){\nreturn cljs.core._seq(coll);\n} else {\nthrow (new Error([cljs.core.str.cljs$core$IFn$_invoke$arity$1(coll),\" is not ISeqable\"].join('')));\n\n}\n}\n}\n}\n}\n});\n/**\n * Returns the first item in the collection. Calls seq on its\n *   argument. If coll is nil, returns nil.\n */\ncljs.core.first = (function cljs$core$first(coll){\nif((coll == null)){\nreturn null;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeq$))))?true:false):false)){\nreturn cljs.core._first(coll);\n} else {\nvar s = cljs.core.seq(coll);\nif((s == null)){\nreturn null;\n} else {\nreturn cljs.core._first(s);\n}\n}\n}\n});\n/**\n * Returns a possibly empty seq of the items after the first. Calls seq on its\n *   argument.\n */\ncljs.core.rest = (function cljs$core$rest(coll){\nif((!((coll == null)))){\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeq$))))?true:false):false)){\nreturn cljs.core._rest(coll);\n} else {\nvar s = cljs.core.seq(coll);\nif(s){\nreturn s.cljs$core$ISeq$_rest$arity$1(null);\n} else {\nreturn cljs.core.List.EMPTY;\n}\n}\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n/**\n * Returns a seq of the items after the first. Calls seq on its\n *   argument.  If there are no more items, returns nil\n */\ncljs.core.next = (function cljs$core$next(coll){\nif((coll == null)){\nreturn null;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (128))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$INext$))))?true:false):false)){\nreturn cljs.core._next(coll);\n} else {\nreturn cljs.core.seq(cljs.core.rest(coll));\n}\n}\n});\n/**\n * Equality. Returns true if x equals y, false if not. Compares\n *   numbers and collections in a type-independent manner.  Clojure's immutable data\n *   structures define -equiv (and thus =) as a value, not an identity,\n *   comparison.\n */\ncljs.core._EQ_ = (function cljs$core$_EQ_(var_args){\nvar G__704 = arguments.length;\nswitch (G__704) {\ncase 1:\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___706 = arguments.length;\nvar i__4731__auto___707 = (0);\nwhile(true){\nif((i__4731__auto___707 < len__4730__auto___706)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___707]));\n\nvar G__708 = (i__4731__auto___707 + (1));\ni__4731__auto___707 = G__708;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._EQ_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core._EQ_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nif((x == null)){\nreturn (y == null);\n} else {\nreturn (((x === y)) || (cljs.core._equiv(x,y)));\n}\n});\n\ncljs.core._EQ_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nwhile(true){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)){\nif(cljs.core.next(more)){\nvar G__709 = y;\nvar G__710 = cljs.core.first(more);\nvar G__711 = cljs.core.next(more);\nx = G__709;\ny = G__710;\nmore = G__711;\ncontinue;\n} else {\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(y,cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._EQ_.cljs$lang$applyTo = (function (seq701){\nvar G__702 = cljs.core.first(seq701);\nvar seq701__$1 = cljs.core.next(seq701);\nvar G__703 = cljs.core.first(seq701__$1);\nvar seq701__$2 = cljs.core.next(seq701__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__702,G__703,seq701__$2);\n});\n\ncljs.core._EQ_.cljs$lang$maxFixedArity = (2);\n\n\n/**\n* @constructor\n*/\ncljs.core.ES6Iterator = (function (s){\nthis.s = s;\n});\ncljs.core.ES6Iterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif((!((self__.s == null)))){\nvar x = cljs.core.first(self__.s);\nself__.s = cljs.core.next(self__.s);\n\nreturn ({\"value\": x, \"done\": false});\n} else {\nreturn ({\"value\": null, \"done\": true});\n}\n});\n\ncljs.core.ES6Iterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ES6Iterator.cljs$lang$type = true;\n\ncljs.core.ES6Iterator.cljs$lang$ctorStr = \"cljs.core/ES6Iterator\";\n\ncljs.core.ES6Iterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ES6Iterator\");\n});\n\n/**\n * Positional factory function for cljs.core/ES6Iterator.\n */\ncljs.core.__GT_ES6Iterator = (function cljs$core$__GT_ES6Iterator(s){\nreturn (new cljs.core.ES6Iterator(s));\n});\n\n/**\n * EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\n */\ncljs.core.es6_iterator = (function cljs$core$es6_iterator(coll){\nreturn (new cljs.core.ES6Iterator(cljs.core.seq(coll)));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.ISeqable}\n*/\ncljs.core.ES6IteratorSeq = (function (value,iter,_rest){\nthis.value = value;\nthis.iter = iter;\nthis._rest = _rest;\nthis.cljs$lang$protocol_mask$partition0$ = 8388672;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.ES6IteratorSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1;\n});\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.value;\n});\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nif((self__._rest == null)){\nself__._rest = cljs.core.es6_iterator_seq(self__.iter);\n} else {\n}\n\nreturn self__._rest;\n});\n\ncljs.core.ES6IteratorSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"value\",\"value\",1946509744,null),new cljs.core.Symbol(null,\"iter\",\"iter\",-1346195486,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"_rest\",\"_rest\",-2100466189,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ES6IteratorSeq.cljs$lang$type = true;\n\ncljs.core.ES6IteratorSeq.cljs$lang$ctorStr = \"cljs.core/ES6IteratorSeq\";\n\ncljs.core.ES6IteratorSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ES6IteratorSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/ES6IteratorSeq.\n */\ncljs.core.__GT_ES6IteratorSeq = (function cljs$core$__GT_ES6IteratorSeq(value,iter,_rest){\nreturn (new cljs.core.ES6IteratorSeq(value,iter,_rest));\n});\n\n/**\n * EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\n */\ncljs.core.es6_iterator_seq = (function cljs$core$es6_iterator_seq(iter){\nvar v = iter.next();\nif(cljs.core.truth_(v.done)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn (new cljs.core.ES6IteratorSeq(v.value,iter,null));\n}\n});\n/**\n * Mix final collection hash for ordered or unordered collections.\n * hash-basis is the combined collection hash, count is the number\n * of elements included in the basis. Note this is the hash code\n * consistent with =, different from .hashCode.\n * See http://clojure.org/data_structures#hash for full algorithms.\n */\ncljs.core.mix_collection_hash = (function cljs$core$mix_collection_hash(hash_basis,count){\nvar h1 = cljs.core.m3_seed;\nvar k1 = cljs.core.m3_mix_K1(hash_basis);\nvar h1__$1 = cljs.core.m3_mix_H1(h1,k1);\nreturn cljs.core.m3_fmix(h1__$1,count);\n});\n/**\n * Returns the hash code, consistent with =, for an external ordered\n * collection implementing Iterable.\n * See http://clojure.org/data_structures#hash for full algorithms.\n */\ncljs.core.hash_ordered_coll = (function cljs$core$hash_ordered_coll(coll){\nvar n = (0);\nvar hash_code = (1);\nvar coll__$1 = cljs.core.seq(coll);\nwhile(true){\nif((!((coll__$1 == null)))){\nvar G__712 = (n + (1));\nvar G__713 = ((cljs.core.imul((31),hash_code) + cljs.core.hash(cljs.core.first(coll__$1))) | (0));\nvar G__714 = cljs.core.next(coll__$1);\nn = G__712;\nhash_code = G__713;\ncoll__$1 = G__714;\ncontinue;\n} else {\nreturn cljs.core.mix_collection_hash(hash_code,n);\n}\nbreak;\n}\n});\ncljs.core.empty_ordered_hash = cljs.core.mix_collection_hash((1),(0));\n/**\n * Returns the hash code, consistent with =, for an external unordered\n * collection implementing Iterable. For maps, the iterator should\n * return map entries whose hash is computed as\n *   (hash-ordered-coll [k v]).\n * See http://clojure.org/data_structures#hash for full algorithms.\n */\ncljs.core.hash_unordered_coll = (function cljs$core$hash_unordered_coll(coll){\nvar n = (0);\nvar hash_code = (0);\nvar coll__$1 = cljs.core.seq(coll);\nwhile(true){\nif((!((coll__$1 == null)))){\nvar G__715 = (n + (1));\nvar G__716 = ((hash_code + cljs.core.hash(cljs.core.first(coll__$1))) | (0));\nvar G__717 = cljs.core.next(coll__$1);\nn = G__715;\nhash_code = G__716;\ncoll__$1 = G__717;\ncontinue;\n} else {\nreturn cljs.core.mix_collection_hash(hash_code,n);\n}\nbreak;\n}\n});\ncljs.core.empty_unordered_hash = cljs.core.mix_collection_hash((0),(0));\n\n\ngoog.object.set(cljs.core.ICounted,\"null\",true);\n\nvar G__718_721 = cljs.core._count;\nvar G__719_722 = \"null\";\nvar G__720_723 = ((function (G__718_721,G__719_722){\nreturn (function (_){\nreturn (0);\n});})(G__718_721,G__719_722))\n;\ngoog.object.set(G__718_721,G__719_722,G__720_723);\nDate.prototype.cljs$core$IEquiv$ = cljs.core.PROTOCOL_SENTINEL;\n\nDate.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (o,other){\nvar o__$1 = this;\nreturn (((other instanceof Date)) && ((o__$1.valueOf() === other.valueOf())));\n});\n\nDate.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\nDate.prototype.cljs$core$IComparable$_compare$arity$2 = (function (this$,other){\nvar this$__$1 = this;\nif((other instanceof Date)){\nvar G__724 = this$__$1.valueOf();\nvar G__725 = other.valueOf();\nreturn goog.array.defaultCompare(G__724,G__725);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(this$__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(other)].join('')));\n}\n});\n\n/**\n * @interface\n */\ncljs.core.Inst = function(){};\n\ncljs.core.inst_ms_STAR_ = (function cljs$core$inst_ms_STAR_(inst){\nif((((!((inst == null)))) && ((!((inst.cljs$core$Inst$inst_ms_STAR_$arity$1 == null)))))){\nreturn inst.cljs$core$Inst$inst_ms_STAR_$arity$1(inst);\n} else {\nvar x__4433__auto__ = (((inst == null))?null:inst);\nvar m__4434__auto__ = (cljs.core.inst_ms_STAR_[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(inst) : m__4434__auto__.call(null,inst));\n} else {\nvar m__4431__auto__ = (cljs.core.inst_ms_STAR_[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(inst) : m__4431__auto__.call(null,inst));\n} else {\nthrow cljs.core.missing_protocol(\"Inst.inst-ms*\",inst);\n}\n}\n}\n});\n\nDate.prototype.cljs$core$Inst$ = cljs.core.PROTOCOL_SENTINEL;\n\nDate.prototype.cljs$core$Inst$inst_ms_STAR_$arity$1 = (function (inst){\nvar inst__$1 = this;\nreturn inst__$1.getTime();\n});\n/**\n * Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\n */\ncljs.core.inst_ms = (function cljs$core$inst_ms(inst){\nreturn cljs.core.inst_ms_STAR_(inst);\n});\n/**\n * Return true if x satisfies Inst\n */\ncljs.core.inst_QMARK_ = (function cljs$core$inst_QMARK_(x){\nif((!((x == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$Inst$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Inst,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Inst,x);\n}\n});\ngoog.object.set(cljs.core.IEquiv,\"number\",true);\n\nvar G__727_730 = cljs.core._equiv;\nvar G__728_731 = \"number\";\nvar G__729_732 = ((function (G__727_730,G__728_731){\nreturn (function (x,o){\nreturn (x === o);\n});})(G__727_730,G__728_731))\n;\ngoog.object.set(G__727_730,G__728_731,G__729_732);\ngoog.object.set(cljs.core.Fn,\"function\",true);\n\ngoog.object.set(cljs.core.IMeta,\"function\",true);\n\nvar G__733_736 = cljs.core._meta;\nvar G__734_737 = \"function\";\nvar G__735_738 = ((function (G__733_736,G__734_737){\nreturn (function (_){\nreturn null;\n});})(G__733_736,G__734_737))\n;\ngoog.object.set(G__733_736,G__734_737,G__735_738);\ngoog.object.set(cljs.core.IHash,\"_\",true);\n\nvar G__739_742 = cljs.core._hash;\nvar G__740_743 = \"_\";\nvar G__741_744 = ((function (G__739_742,G__740_743){\nreturn (function (o){\nreturn goog.getUid(o);\n});})(G__739_742,G__740_743))\n;\ngoog.object.set(G__739_742,G__740_743,G__741_744);\n/**\n * Returns a number one greater than num.\n */\ncljs.core.inc = (function cljs$core$inc(x){\nreturn (x + (1));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IDeref}\n*/\ncljs.core.Reduced = (function (val){\nthis.val = val;\nthis.cljs$lang$protocol_mask$partition0$ = 32768;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.Reduced.prototype.cljs$core$IDeref$_deref$arity$1 = (function (o){\nvar self__ = this;\nvar o__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.Reduced.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null)], null);\n});\n\ncljs.core.Reduced.cljs$lang$type = true;\n\ncljs.core.Reduced.cljs$lang$ctorStr = \"cljs.core/Reduced\";\n\ncljs.core.Reduced.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Reduced\");\n});\n\n/**\n * Positional factory function for cljs.core/Reduced.\n */\ncljs.core.__GT_Reduced = (function cljs$core$__GT_Reduced(val){\nreturn (new cljs.core.Reduced(val));\n});\n\n/**\n * Wraps x in a way such that a reduce will terminate with the value x\n */\ncljs.core.reduced = (function cljs$core$reduced(x){\nreturn (new cljs.core.Reduced(x));\n});\n/**\n * Returns true if x is the result of a call to reduced\n */\ncljs.core.reduced_QMARK_ = (function cljs$core$reduced_QMARK_(r){\nreturn (r instanceof cljs.core.Reduced);\n});\n/**\n * If x is already reduced?, returns it, else returns (reduced x)\n */\ncljs.core.ensure_reduced = (function cljs$core$ensure_reduced(x){\nif(cljs.core.reduced_QMARK_(x)){\nreturn x;\n} else {\nreturn cljs.core.reduced(x);\n}\n});\n/**\n * If x is reduced?, returns (deref x), else returns x\n */\ncljs.core.unreduced = (function cljs$core$unreduced(x){\nif(cljs.core.reduced_QMARK_(x)){\nreturn cljs.core.deref(x);\n} else {\nreturn x;\n}\n});\n/**\n * Also reader macro: @var/@atom/@delay. Returns the\n * most-recently-committed value of ref. When applied to a var\n * or atom, returns its current state. When applied to a delay, forces\n * it if not already forced. See also - realized?.\n */\ncljs.core.deref = (function cljs$core$deref(o){\nreturn cljs.core._deref(o);\n});\n/**\n * Accepts any collection which satisfies the ICount and IIndexed protocols and\n * reduces them without incurring seq initialization\n */\ncljs.core.ci_reduce = (function cljs$core$ci_reduce(var_args){\nvar G__746 = arguments.length;\nswitch (G__746) {\ncase 2:\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2 = (function (cicoll,f){\nvar cnt = cljs.core._count(cicoll);\nif((cnt === (0))){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n} else {\nvar val = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,(0));\nvar n = (1);\nwhile(true){\nif((n < cnt)){\nvar nval = (function (){var G__747 = val;\nvar G__748 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,n);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__747,G__748) : f.call(null,G__747,G__748));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__754 = nval;\nvar G__755 = (n + (1));\nval = G__754;\nn = G__755;\ncontinue;\n}\n} else {\nreturn val;\n}\nbreak;\n}\n}\n});\n\ncljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3 = (function (cicoll,f,val){\nvar cnt = cljs.core._count(cicoll);\nvar val__$1 = val;\nvar n = (0);\nwhile(true){\nif((n < cnt)){\nvar nval = (function (){var G__749 = val__$1;\nvar G__750 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,n);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__749,G__750) : f.call(null,G__749,G__750));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__756 = nval;\nvar G__757 = (n + (1));\nval__$1 = G__756;\nn = G__757;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$4 = (function (cicoll,f,val,idx){\nvar cnt = cljs.core._count(cicoll);\nvar val__$1 = val;\nvar n = idx;\nwhile(true){\nif((n < cnt)){\nvar nval = (function (){var G__751 = val__$1;\nvar G__752 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(cicoll,n);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__751,G__752) : f.call(null,G__751,G__752));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__758 = nval;\nvar G__759 = (n + (1));\nval__$1 = G__758;\nn = G__759;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ci_reduce.cljs$lang$maxFixedArity = 4;\n\ncljs.core.array_reduce = (function cljs$core$array_reduce(var_args){\nvar G__761 = arguments.length;\nswitch (G__761) {\ncase 2:\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2 = (function (arr,f){\nvar cnt = arr.length;\nif((arr.length === (0))){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n} else {\nvar val = (arr[(0)]);\nvar n = (1);\nwhile(true){\nif((n < cnt)){\nvar nval = (function (){var G__762 = val;\nvar G__763 = (arr[n]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__762,G__763) : f.call(null,G__762,G__763));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__769 = nval;\nvar G__770 = (n + (1));\nval = G__769;\nn = G__770;\ncontinue;\n}\n} else {\nreturn val;\n}\nbreak;\n}\n}\n});\n\ncljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3 = (function (arr,f,val){\nvar cnt = arr.length;\nvar val__$1 = val;\nvar n = (0);\nwhile(true){\nif((n < cnt)){\nvar nval = (function (){var G__764 = val__$1;\nvar G__765 = (arr[n]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__764,G__765) : f.call(null,G__764,G__765));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__771 = nval;\nvar G__772 = (n + (1));\nval__$1 = G__771;\nn = G__772;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4 = (function (arr,f,val,idx){\nvar cnt = arr.length;\nvar val__$1 = val;\nvar n = idx;\nwhile(true){\nif((n < cnt)){\nvar nval = (function (){var G__766 = val__$1;\nvar G__767 = (arr[n]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__766,G__767) : f.call(null,G__766,G__767));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__773 = nval;\nvar G__774 = (n + (1));\nval__$1 = G__773;\nn = G__774;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.array_reduce.cljs$lang$maxFixedArity = 4;\n\n\n\n\n\n\n\n/**\n * Returns true if coll implements count in constant time\n */\ncljs.core.counted_QMARK_ = (function cljs$core$counted_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (2))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$ICounted$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICounted,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICounted,x);\n}\n});\n/**\n * Returns true if coll implements nth in constant time\n */\ncljs.core.indexed_QMARK_ = (function cljs$core$indexed_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (16))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IIndexed$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,x);\n}\n});\ncljs.core._indexOf = (function cljs$core$_indexOf(var_args){\nvar G__778 = arguments.length;\nswitch (G__778) {\ncase 2:\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._indexOf.cljs$core$IFn$_invoke$arity$2 = (function (coll,x){\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\n\ncljs.core._indexOf.cljs$core$IFn$_invoke$arity$3 = (function (coll,x,start){\nvar len = cljs.core.count(coll);\nif((start >= len)){\nreturn (-1);\n} else {\nvar idx = (((start > (0)))?start:(((start < (0)))?(function (){var x__4219__auto__ = (0);\nvar y__4220__auto__ = (start + len);\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})():start\n));\nwhile(true){\nif((idx < len)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(coll,idx),x)){\nreturn idx;\n} else {\nvar G__780 = (idx + (1));\nidx = G__780;\ncontinue;\n}\n} else {\nreturn (-1);\n}\nbreak;\n}\n}\n});\n\ncljs.core._indexOf.cljs$lang$maxFixedArity = 3;\n\ncljs.core._lastIndexOf = (function cljs$core$_lastIndexOf(var_args){\nvar G__782 = arguments.length;\nswitch (G__782) {\ncase 2:\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$2 = (function (coll,x){\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\n\ncljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3 = (function (coll,x,start){\nvar len = cljs.core.count(coll);\nif((len === (0))){\nreturn (-1);\n} else {\nvar idx = (((start > (0)))?(function (){var x__4222__auto__ = (len - (1));\nvar y__4223__auto__ = start;\nreturn ((x__4222__auto__ < y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})():(((start < (0)))?(len + start):start\n));\nwhile(true){\nif((idx >= (0))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(coll,idx),x)){\nreturn idx;\n} else {\nvar G__784 = (idx - (1));\nidx = G__784;\ncontinue;\n}\n} else {\nreturn (-1);\n}\nbreak;\n}\n}\n});\n\ncljs.core._lastIndexOf.cljs$lang$maxFixedArity = 3;\n\n\n/**\n* @constructor\n*/\ncljs.core.IndexedSeqIterator = (function (arr,i){\nthis.arr = arr;\nthis.i = i;\n});\ncljs.core.IndexedSeqIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.i < self__.arr.length);\n});\n\ncljs.core.IndexedSeqIterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nvar ret = (self__.arr[self__.i]);\nself__.i = (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.IndexedSeqIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.IndexedSeqIterator.cljs$lang$type = true;\n\ncljs.core.IndexedSeqIterator.cljs$lang$ctorStr = \"cljs.core/IndexedSeqIterator\";\n\ncljs.core.IndexedSeqIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/IndexedSeqIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/IndexedSeqIterator.\n */\ncljs.core.__GT_IndexedSeqIterator = (function cljs$core$__GT_IndexedSeqIterator(arr,i){\nreturn (new cljs.core.IndexedSeqIterator(arr,i));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.IndexedSeq = (function (arr,i,meta){\nthis.arr = arr;\nthis.i = i;\nthis.meta = meta;\nthis.cljs$lang$protocol_mask$partition0$ = 166592766;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\n});\ncljs.core.IndexedSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.IndexedSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.IndexedSeq.prototype.indexOf = (function() {\nvar G__785 = null;\nvar G__785__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__785__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__785 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__785__1.call(this,x);\ncase 2:\nreturn G__785__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__785.cljs$core$IFn$_invoke$arity$1 = G__785__1;\nG__785.cljs$core$IFn$_invoke$arity$2 = G__785__2;\nreturn G__785;\n})()\n;\n\ncljs.core.IndexedSeq.prototype.lastIndexOf = (function() {\nvar G__786 = null;\nvar G__786__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__786__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__786 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__786__1.call(this,x);\ncase 2:\nreturn G__786__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__786.cljs$core$IFn$_invoke$arity$1 = G__786__1;\nG__786.cljs$core$IFn$_invoke$arity$2 = G__786__2;\nreturn G__786;\n})()\n;\n\ncljs.core.IndexedSeq.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (coll,n){\nvar self__ = this;\nvar coll__$1 = this;\nvar i__$1 = (n + self__.i);\nif(((((0) <= i__$1)) && ((i__$1 < self__.arr.length)))){\nreturn (self__.arr[i__$1]);\n} else {\nthrow (new Error(\"Index out of bounds\"));\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (coll,n,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nvar i__$1 = (n + self__.i);\nif(((((0) <= i__$1)) && ((i__$1 < self__.arr.length)))){\nreturn (self__.arr[i__$1]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.IndexedSeqIterator(self__.arr,self__.i));\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.IndexedSeq(self__.arr,self__.i,self__.meta));\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$INext$_next$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nif(((self__.i + (1)) < self__.arr.length)){\nreturn (new cljs.core.IndexedSeq(self__.arr,(self__.i + (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ICounted$_count$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nvar x__4219__auto__ = (0);\nvar y__4220__auto__ = (self__.arr.length - self__.i);\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar c = coll__$1.cljs$core$ICounted$_count$arity$1(null);\nif((c > (0))){\nreturn (new cljs.core.RSeq(coll__$1,(c - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,(self__.arr[self__.i]),(self__.i + (1)));\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,start,self__.i);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (self__.arr[self__.i]);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nif(((self__.i + (1)) < self__.arr.length)){\nreturn (new cljs.core.IndexedSeq(self__.arr,(self__.i + (1)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.i < self__.arr.length)){\nreturn this$__$1;\n} else {\nreturn null;\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.IndexedSeq(self__.arr,self__.i,new_meta));\n}\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.IndexedSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null)], null);\n});\n\ncljs.core.IndexedSeq.cljs$lang$type = true;\n\ncljs.core.IndexedSeq.cljs$lang$ctorStr = \"cljs.core/IndexedSeq\";\n\ncljs.core.IndexedSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/IndexedSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/IndexedSeq.\n */\ncljs.core.__GT_IndexedSeq = (function cljs$core$__GT_IndexedSeq(arr,i,meta){\nreturn (new cljs.core.IndexedSeq(arr,i,meta));\n});\n\nvar G__787_790 = cljs.core.IndexedSeq.prototype;\nvar G__788_791 = cljs.core.ITER_SYMBOL;\nvar G__789_792 = ((function (G__787_790,G__788_791){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__787_790,G__788_791))\n;\ngoog.object.set(G__787_790,G__788_791,G__789_792);\n/**\n * Create seq from a primitive JavaScript Array-like.\n */\ncljs.core.prim_seq = (function cljs$core$prim_seq(var_args){\nvar G__794 = arguments.length;\nswitch (G__794) {\ncase 1:\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.prim_seq.cljs$core$IFn$_invoke$arity$1 = (function (prim){\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(prim,(0));\n});\n\ncljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2 = (function (prim,i){\nif((i < prim.length)){\nreturn (new cljs.core.IndexedSeq(prim,i,null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.prim_seq.cljs$lang$maxFixedArity = 2;\n\n/**\n * Create a seq from a JavaScript array.\n */\ncljs.core.array_seq = (function cljs$core$array_seq(var_args){\nvar G__797 = arguments.length;\nswitch (G__797) {\ncase 1:\nreturn cljs.core.array_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.array_seq.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.array_seq.cljs$core$IFn$_invoke$arity$1 = (function (array){\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(array,(0));\n});\n\ncljs.core.array_seq.cljs$core$IFn$_invoke$arity$2 = (function (array,i){\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(array,i);\n});\n\ncljs.core.array_seq.cljs$lang$maxFixedArity = 2;\n\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.RSeq = (function (ci,i,meta){\nthis.ci = ci;\nthis.i = i;\nthis.meta = meta;\nthis.cljs$lang$protocol_mask$partition0$ = 32374990;\nthis.cljs$lang$protocol_mask$partition1$ = 8192;\n});\ncljs.core.RSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.RSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.RSeq.prototype.indexOf = (function() {\nvar G__799 = null;\nvar G__799__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__799__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__799 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__799__1.call(this,x);\ncase 2:\nreturn G__799__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__799.cljs$core$IFn$_invoke$arity$1 = G__799__1;\nG__799.cljs$core$IFn$_invoke$arity$2 = G__799__2;\nreturn G__799;\n})()\n;\n\ncljs.core.RSeq.prototype.lastIndexOf = (function() {\nvar G__800 = null;\nvar G__800__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__800__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__800 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__800__1.call(this,x);\ncase 2:\nreturn G__800__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__800.cljs$core$IFn$_invoke$arity$1 = G__800__1;\nG__800.cljs$core$IFn$_invoke$arity$2 = G__800__2;\nreturn G__800;\n})()\n;\n\ncljs.core.RSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.RSeq.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.RSeq(self__.ci,self__.i,self__.meta));\n});\n\ncljs.core.RSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.i > (0))){\nreturn (new cljs.core.RSeq(self__.ci,(self__.i - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.RSeq.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (self__.i + (1));\n});\n\ncljs.core.RSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.RSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (col,f){\nvar self__ = this;\nvar col__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,col__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (col,f,start){\nvar self__ = this;\nvar col__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,col__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.ci,self__.i);\n});\n\ncljs.core.RSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.i > (0))){\nreturn (new cljs.core.RSeq(self__.ci,(self__.i - (1)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.RSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.RSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.RSeq(self__.ci,self__.i,new_meta));\n}\n});\n\ncljs.core.RSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.RSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"ci\",\"ci\",2049808339,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null)], null);\n});\n\ncljs.core.RSeq.cljs$lang$type = true;\n\ncljs.core.RSeq.cljs$lang$ctorStr = \"cljs.core/RSeq\";\n\ncljs.core.RSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/RSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/RSeq.\n */\ncljs.core.__GT_RSeq = (function cljs$core$__GT_RSeq(ci,i,meta){\nreturn (new cljs.core.RSeq(ci,i,meta));\n});\n\nvar G__801_804 = cljs.core.RSeq.prototype;\nvar G__802_805 = cljs.core.ITER_SYMBOL;\nvar G__803_806 = ((function (G__801_804,G__802_805){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__801_804,G__802_805))\n;\ngoog.object.set(G__801_804,G__802_805,G__803_806);\n/**\n * Same as (first (next x))\n */\ncljs.core.second = (function cljs$core$second(coll){\nreturn cljs.core.first(cljs.core.next(coll));\n});\n/**\n * Same as (first (first x))\n */\ncljs.core.ffirst = (function cljs$core$ffirst(coll){\nreturn cljs.core.first(cljs.core.first(coll));\n});\n/**\n * Same as (next (first x))\n */\ncljs.core.nfirst = (function cljs$core$nfirst(coll){\nreturn cljs.core.next(cljs.core.first(coll));\n});\n/**\n * Same as (first (next x))\n */\ncljs.core.fnext = (function cljs$core$fnext(coll){\nreturn cljs.core.first(cljs.core.next(coll));\n});\n/**\n * Same as (next (next x))\n */\ncljs.core.nnext = (function cljs$core$nnext(coll){\nreturn cljs.core.next(cljs.core.next(coll));\n});\n/**\n * Return the last item in coll, in linear time\n */\ncljs.core.last = (function cljs$core$last(s){\nwhile(true){\nvar sn = cljs.core.next(s);\nif((!((sn == null)))){\nvar G__807 = sn;\ns = G__807;\ncontinue;\n} else {\nreturn cljs.core.first(s);\n}\nbreak;\n}\n});\ngoog.object.set(cljs.core.IEquiv,\"_\",true);\n\nvar G__808_811 = cljs.core._equiv;\nvar G__809_812 = \"_\";\nvar G__810_813 = ((function (G__808_811,G__809_812){\nreturn (function (x,o){\nreturn (x === o);\n});})(G__808_811,G__809_812))\n;\ngoog.object.set(G__808_811,G__809_812,G__810_813);\n/**\n * conj[oin]. Returns a new collection with the xs\n *   'added'. (conj nil item) returns (item).  The 'addition' may\n *   happen at different 'places' depending on the concrete type.\n */\ncljs.core.conj = (function cljs$core$conj(var_args){\nvar G__818 = arguments.length;\nswitch (G__818) {\ncase 0:\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___820 = arguments.length;\nvar i__4731__auto___821 = (0);\nwhile(true){\nif((i__4731__auto___821 < len__4730__auto___820)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___821]));\n\nvar G__822 = (i__4731__auto___821 + (1));\ni__4731__auto___821 = G__822;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nreturn coll;\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$2 = (function (coll,x){\nif((!((coll == null)))){\nreturn cljs.core._conj(coll,x);\n} else {\nreturn (new cljs.core.List(null,x,null,(1),null));\n}\n});\n\ncljs.core.conj.cljs$core$IFn$_invoke$arity$variadic = (function (coll,x,xs){\nwhile(true){\nif(cljs.core.truth_(xs)){\nvar G__823 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(coll,x);\nvar G__824 = cljs.core.first(xs);\nvar G__825 = cljs.core.next(xs);\ncoll = G__823;\nx = G__824;\nxs = G__825;\ncontinue;\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(coll,x);\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.conj.cljs$lang$applyTo = (function (seq815){\nvar G__816 = cljs.core.first(seq815);\nvar seq815__$1 = cljs.core.next(seq815);\nvar G__817 = cljs.core.first(seq815__$1);\nvar seq815__$2 = cljs.core.next(seq815__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__816,G__817,seq815__$2);\n});\n\ncljs.core.conj.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns an empty collection of the same category as coll, or nil\n */\ncljs.core.empty = (function cljs$core$empty(coll){\nif((coll == null)){\nreturn null;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (4))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IEmptyableCollection$))))?true:false):false)){\nreturn cljs.core._empty(coll);\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (4))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IEmptyableCollection$))))?true:(((!coll.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEmptyableCollection,coll):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEmptyableCollection,coll))){\nreturn cljs.core._empty(coll);\n} else {\nreturn null;\n\n}\n}\n}\n});\ncljs.core.accumulating_seq_count = (function cljs$core$accumulating_seq_count(coll){\nvar s = cljs.core.seq(coll);\nvar acc = (0);\nwhile(true){\nif(cljs.core.counted_QMARK_(s)){\nreturn (acc + cljs.core._count(s));\n} else {\nvar G__828 = cljs.core.next(s);\nvar G__829 = (acc + (1));\ns = G__828;\nacc = G__829;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Returns the number of items in the collection. (count nil) returns\n *   0.  Also works on strings, arrays, and Maps\n */\ncljs.core.count = (function cljs$core$count(coll){\nif((!((coll == null)))){\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (2))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ICounted$))))?true:false):false)){\nreturn cljs.core._count(coll);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn coll.length;\n} else {\nif(typeof coll === 'string'){\nreturn coll.length;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (8388608))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeqable$))))?true:false):false)){\nreturn cljs.core.accumulating_seq_count(coll);\n} else {\nreturn cljs.core._count(coll);\n\n}\n}\n}\n}\n} else {\nreturn (0);\n}\n});\ncljs.core.linear_traversal_nth = (function cljs$core$linear_traversal_nth(var_args){\nvar G__833 = arguments.length;\nswitch (G__833) {\ncase 2:\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$2 = (function (coll,n){\nwhile(true){\nif((coll == null)){\nthrow (new Error(\"Index out of bounds\"));\n} else {\nif((n === (0))){\nif(cljs.core.seq(coll)){\nreturn cljs.core.first(coll);\n} else {\nthrow (new Error(\"Index out of bounds\"));\n}\n} else {\nif(cljs.core.indexed_QMARK_(coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n} else {\nif(cljs.core.seq(coll)){\nvar G__835 = cljs.core.next(coll);\nvar G__836 = (n - (1));\ncoll = G__835;\nn = G__836;\ncontinue;\n} else {\nthrow (new Error(\"Index out of bounds\"));\n\n}\n}\n}\n}\nbreak;\n}\n});\n\ncljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$3 = (function (coll,n,not_found){\nwhile(true){\nif((coll == null)){\nreturn not_found;\n} else {\nif((n === (0))){\nif(cljs.core.seq(coll)){\nreturn cljs.core.first(coll);\n} else {\nreturn not_found;\n}\n} else {\nif(cljs.core.indexed_QMARK_(coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n} else {\nif(cljs.core.seq(coll)){\nvar G__837 = cljs.core.next(coll);\nvar G__838 = (n - (1));\nvar G__839 = not_found;\ncoll = G__837;\nn = G__838;\nnot_found = G__839;\ncontinue;\n} else {\nreturn not_found;\n\n}\n}\n}\n}\nbreak;\n}\n});\n\ncljs.core.linear_traversal_nth.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns the value at the index. get returns nil if index out of\n *   bounds, nth throws an exception unless not-found is supplied.  nth\n *   also works for strings, arrays, regex Matchers and Lists, and,\n *   in O(n) time, for sequences.\n */\ncljs.core.nth = (function cljs$core$nth(var_args){\nvar G__841 = arguments.length;\nswitch (G__841) {\ncase 2:\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.nth.cljs$core$IFn$_invoke$arity$2 = (function (coll,n){\nif((!(typeof n === 'number'))){\nthrow (new Error(\"Index argument to nth must be a number\"));\n} else {\nif((coll == null)){\nreturn coll;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (16))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IIndexed$))))?true:false):false)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nif(((((-1) < n)) && ((n < coll.length)))){\nreturn (coll[(n | (0))]);\n} else {\nthrow (new Error(\"Index out of bounds\"));\n}\n} else {\nif(typeof coll === 'string'){\nif(((((-1) < n)) && ((n < coll.length)))){\nreturn coll.charAt((n | (0)));\n} else {\nthrow (new Error(\"Index out of bounds\"));\n}\n} else {\nif((function (){var or__4131__auto__ = (((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeq$))))?true:false):false);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((coll == null)))){\nif((((coll.cljs$lang$protocol_mask$partition0$ & (16777216))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISequential$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n}\n})()){\nif((n < (0))){\nthrow (new Error(\"Index out of bounds\"));\n} else {\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(coll,n);\n} else {\nthrow (new Error([\"nth not supported on this type \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.type__GT_str(cljs.core.type(coll)))].join('')));\n\n}\n}\n}\n}\n}\n}\n}\n});\n\ncljs.core.nth.cljs$core$IFn$_invoke$arity$3 = (function (coll,n,not_found){\nif((!(typeof n === 'number'))){\nthrow (new Error(\"Index argument to nth must be a number.\"));\n} else {\nif((coll == null)){\nreturn not_found;\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (16))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IIndexed$))))?true:false):false)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nif(((((-1) < n)) && ((n < coll.length)))){\nreturn (coll[(n | (0))]);\n} else {\nreturn not_found;\n}\n} else {\nif(typeof coll === 'string'){\nif(((((-1) < n)) && ((n < coll.length)))){\nreturn coll.charAt((n | (0)));\n} else {\nreturn not_found;\n}\n} else {\nif((function (){var or__4131__auto__ = (((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeq$))))?true:false):false);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((coll == null)))){\nif((((coll.cljs$lang$protocol_mask$partition0$ & (16777216))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISequential$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n}\n})()){\nif((n < (0))){\nreturn not_found;\n} else {\nreturn cljs.core.linear_traversal_nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IIndexed,coll)){\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(coll,n,not_found);\n} else {\nthrow (new Error([\"nth not supported on this type \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.type__GT_str(cljs.core.type(coll)))].join('')));\n\n}\n}\n}\n}\n}\n}\n}\n});\n\ncljs.core.nth.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns the nth rest of coll, coll when n is 0.\n */\ncljs.core.nthrest = (function cljs$core$nthrest(coll,n){\nvar n__$1 = n;\nvar xs = coll;\nwhile(true){\nvar temp__5718__auto__ = (((n__$1 > (0))) && (cljs.core.seq(xs)));\nif(temp__5718__auto__){\nvar xs__$1 = temp__5718__auto__;\nvar G__851 = (n__$1 - (1));\nvar G__852 = cljs.core.rest(xs__$1);\nn__$1 = G__851;\nxs = G__852;\ncontinue;\n} else {\nreturn xs;\n}\nbreak;\n}\n});\n/**\n * Returns the value mapped to key, not-found or nil if key not present.\n */\ncljs.core.get = (function cljs$core$get(var_args){\nvar G__854 = arguments.length;\nswitch (G__854) {\ncase 2:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.get.cljs$core$IFn$_invoke$arity$2 = (function (o,k){\nif((o == null)){\nreturn null;\n} else {\nif((((!((o == null))))?(((((o.cljs$lang$protocol_mask$partition0$ & (256))) || ((cljs.core.PROTOCOL_SENTINEL === o.cljs$core$ILookup$))))?true:false):false)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(o,k);\n} else {\nif(cljs.core.array_QMARK_(o)){\nif((((!((k == null)))) && ((k < o.length)))){\nreturn (o[(k | (0))]);\n} else {\nreturn null;\n}\n} else {\nif(typeof o === 'string'){\nif((((!((k == null)))) && ((k < o.length)))){\nreturn o.charAt((k | (0)));\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.ILookup,o)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(o,k);\n} else {\nreturn null;\n\n}\n}\n}\n}\n}\n});\n\ncljs.core.get.cljs$core$IFn$_invoke$arity$3 = (function (o,k,not_found){\nif((!((o == null)))){\nif((((!((o == null))))?(((((o.cljs$lang$protocol_mask$partition0$ & (256))) || ((cljs.core.PROTOCOL_SENTINEL === o.cljs$core$ILookup$))))?true:false):false)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(o,k,not_found);\n} else {\nif(cljs.core.array_QMARK_(o)){\nif((((!((k == null)))) && (((((-1) < k)) && ((k < o.length)))))){\nreturn (o[(k | (0))]);\n} else {\nreturn not_found;\n}\n} else {\nif(typeof o === 'string'){\nif((((!((k == null)))) && (((((-1) < k)) && ((k < o.length)))))){\nreturn o.charAt((k | (0)));\n} else {\nreturn not_found;\n}\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.ILookup,o)){\nreturn cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(o,k,not_found);\n} else {\nreturn not_found;\n\n}\n}\n}\n}\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.get.cljs$lang$maxFixedArity = 3;\n\n\n\n/**\n * assoc[iate]. When applied to a map, returns a new map of the\n * same (hashed/sorted) type, that contains the mapping of key(s) to\n * val(s). When applied to a vector, returns a new vector that\n * contains val at index.\n */\ncljs.core.assoc = (function cljs$core$assoc(var_args){\nvar G__863 = arguments.length;\nswitch (G__863) {\ncase 3:\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___865 = arguments.length;\nvar i__4731__auto___866 = (0);\nwhile(true){\nif((i__4731__auto___866 < len__4730__auto___865)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___866]));\n\nvar G__867 = (i__4731__auto___866 + (1));\ni__4731__auto___866 = G__867;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.assoc.cljs$core$IFn$_invoke$arity$3 = (function (coll,k,v){\nif((!((coll == null)))){\nreturn cljs.core._assoc(coll,k,v);\n} else {\nreturn cljs.core.PersistentArrayMap.createAsIfByAssoc([k,v]);\n}\n});\n\ncljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic = (function (coll,k,v,kvs){\nwhile(true){\nvar ret = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(coll,k,v);\nif(cljs.core.truth_(kvs)){\nvar G__868 = ret;\nvar G__869 = cljs.core.first(kvs);\nvar G__870 = cljs.core.second(kvs);\nvar G__871 = cljs.core.nnext(kvs);\ncoll = G__868;\nk = G__869;\nv = G__870;\nkvs = G__871;\ncontinue;\n} else {\nreturn ret;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.assoc.cljs$lang$applyTo = (function (seq859){\nvar G__860 = cljs.core.first(seq859);\nvar seq859__$1 = cljs.core.next(seq859);\nvar G__861 = cljs.core.first(seq859__$1);\nvar seq859__$2 = cljs.core.next(seq859__$1);\nvar G__862 = cljs.core.first(seq859__$2);\nvar seq859__$3 = cljs.core.next(seq859__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__860,G__861,G__862,seq859__$3);\n});\n\ncljs.core.assoc.cljs$lang$maxFixedArity = (3);\n\n/**\n * dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n *   that does not contain a mapping for key(s).\n */\ncljs.core.dissoc = (function cljs$core$dissoc(var_args){\nvar G__876 = arguments.length;\nswitch (G__876) {\ncase 1:\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___878 = arguments.length;\nvar i__4731__auto___879 = (0);\nwhile(true){\nif((i__4731__auto___879 < len__4730__auto___878)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___879]));\n\nvar G__880 = (i__4731__auto___879 + (1));\ni__4731__auto___879 = G__880;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.dissoc.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nreturn coll;\n});\n\ncljs.core.dissoc.cljs$core$IFn$_invoke$arity$2 = (function (coll,k){\nif((coll == null)){\nreturn null;\n} else {\nreturn cljs.core._dissoc(coll,k);\n}\n});\n\ncljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic = (function (coll,k,ks){\nwhile(true){\nif((coll == null)){\nreturn null;\n} else {\nvar ret = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(coll,k);\nif(cljs.core.truth_(ks)){\nvar G__881 = ret;\nvar G__882 = cljs.core.first(ks);\nvar G__883 = cljs.core.next(ks);\ncoll = G__881;\nk = G__882;\nks = G__883;\ncontinue;\n} else {\nreturn ret;\n}\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.dissoc.cljs$lang$applyTo = (function (seq873){\nvar G__874 = cljs.core.first(seq873);\nvar seq873__$1 = cljs.core.next(seq873);\nvar G__875 = cljs.core.first(seq873__$1);\nvar seq873__$2 = cljs.core.next(seq873__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__874,G__875,seq873__$2);\n});\n\ncljs.core.dissoc.cljs$lang$maxFixedArity = (2);\n\n/**\n * Return true if f is a JavaScript function or satisfies the Fn protocol.\n */\ncljs.core.fn_QMARK_ = (function cljs$core$fn_QMARK_(f){\nvar or__4131__auto__ = goog.isFunction(f);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((f == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === f.cljs$core$Fn$)))){\nreturn true;\n} else {\nif((!f.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Fn,f);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.Fn,f);\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.Fn}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.MetaFn = (function (afn,meta){\nthis.afn = afn;\nthis.meta = meta;\nthis.cljs$lang$protocol_mask$partition0$ = 393217;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.MetaFn.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_,new_meta){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.MetaFn(self__.afn,new_meta));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$Fn$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MetaFn.prototype.call = (function() {\nvar G__887 = null;\nvar G__887__1 = (function (self__){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$0 ? self__.afn.cljs$core$IFn$_invoke$arity$0() : self__.afn.call(null));\n});\nvar G__887__2 = (function (self__,a){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$1 ? self__.afn.cljs$core$IFn$_invoke$arity$1(a) : self__.afn.call(null,a));\n});\nvar G__887__3 = (function (self__,a,b){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$2 ? self__.afn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.afn.call(null,a,b));\n});\nvar G__887__4 = (function (self__,a,b,c){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$3 ? self__.afn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.afn.call(null,a,b,c));\n});\nvar G__887__5 = (function (self__,a,b,c,d){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$4 ? self__.afn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.afn.call(null,a,b,c,d));\n});\nvar G__887__6 = (function (self__,a,b,c,d,e){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$5 ? self__.afn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.afn.call(null,a,b,c,d,e));\n});\nvar G__887__7 = (function (self__,a,b,c,d,e,f){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$6 ? self__.afn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.afn.call(null,a,b,c,d,e,f));\n});\nvar G__887__8 = (function (self__,a,b,c,d,e,f,g){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$7 ? self__.afn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.afn.call(null,a,b,c,d,e,f,g));\n});\nvar G__887__9 = (function (self__,a,b,c,d,e,f,g,h){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$8 ? self__.afn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.afn.call(null,a,b,c,d,e,f,g,h));\n});\nvar G__887__10 = (function (self__,a,b,c,d,e,f,g,h,i){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$9 ? self__.afn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.afn.call(null,a,b,c,d,e,f,g,h,i));\n});\nvar G__887__11 = (function (self__,a,b,c,d,e,f,g,h,i,j){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$10 ? self__.afn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\nvar G__887__12 = (function (self__,a,b,c,d,e,f,g,h,i,j,k){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$11 ? self__.afn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\nvar G__887__13 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$12 ? self__.afn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\nvar G__887__14 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$13 ? self__.afn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\nvar G__887__15 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$14 ? self__.afn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\nvar G__887__16 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$15 ? self__.afn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\nvar G__887__17 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$16 ? self__.afn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\nvar G__887__18 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$17 ? self__.afn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\nvar G__887__19 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$18 ? self__.afn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\nvar G__887__20 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$19 ? self__.afn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\nvar G__887__21 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$20 ? self__.afn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\nvar G__887__22 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ = this;\nvar self____$1 = this;\nvar _ = self____$1;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.afn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\nG__887 = function(self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nswitch(arguments.length){\ncase 1:\nreturn G__887__1.call(this,self__);\ncase 2:\nreturn G__887__2.call(this,self__,a);\ncase 3:\nreturn G__887__3.call(this,self__,a,b);\ncase 4:\nreturn G__887__4.call(this,self__,a,b,c);\ncase 5:\nreturn G__887__5.call(this,self__,a,b,c,d);\ncase 6:\nreturn G__887__6.call(this,self__,a,b,c,d,e);\ncase 7:\nreturn G__887__7.call(this,self__,a,b,c,d,e,f);\ncase 8:\nreturn G__887__8.call(this,self__,a,b,c,d,e,f,g);\ncase 9:\nreturn G__887__9.call(this,self__,a,b,c,d,e,f,g,h);\ncase 10:\nreturn G__887__10.call(this,self__,a,b,c,d,e,f,g,h,i);\ncase 11:\nreturn G__887__11.call(this,self__,a,b,c,d,e,f,g,h,i,j);\ncase 12:\nreturn G__887__12.call(this,self__,a,b,c,d,e,f,g,h,i,j,k);\ncase 13:\nreturn G__887__13.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l);\ncase 14:\nreturn G__887__14.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m);\ncase 15:\nreturn G__887__15.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\ncase 16:\nreturn G__887__16.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\ncase 17:\nreturn G__887__17.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\ncase 18:\nreturn G__887__18.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\ncase 19:\nreturn G__887__19.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\ncase 20:\nreturn G__887__20.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\ncase 21:\nreturn G__887__21.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\ncase 22:\nreturn G__887__22.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__887.cljs$core$IFn$_invoke$arity$1 = G__887__1;\nG__887.cljs$core$IFn$_invoke$arity$2 = G__887__2;\nG__887.cljs$core$IFn$_invoke$arity$3 = G__887__3;\nG__887.cljs$core$IFn$_invoke$arity$4 = G__887__4;\nG__887.cljs$core$IFn$_invoke$arity$5 = G__887__5;\nG__887.cljs$core$IFn$_invoke$arity$6 = G__887__6;\nG__887.cljs$core$IFn$_invoke$arity$7 = G__887__7;\nG__887.cljs$core$IFn$_invoke$arity$8 = G__887__8;\nG__887.cljs$core$IFn$_invoke$arity$9 = G__887__9;\nG__887.cljs$core$IFn$_invoke$arity$10 = G__887__10;\nG__887.cljs$core$IFn$_invoke$arity$11 = G__887__11;\nG__887.cljs$core$IFn$_invoke$arity$12 = G__887__12;\nG__887.cljs$core$IFn$_invoke$arity$13 = G__887__13;\nG__887.cljs$core$IFn$_invoke$arity$14 = G__887__14;\nG__887.cljs$core$IFn$_invoke$arity$15 = G__887__15;\nG__887.cljs$core$IFn$_invoke$arity$16 = G__887__16;\nG__887.cljs$core$IFn$_invoke$arity$17 = G__887__17;\nG__887.cljs$core$IFn$_invoke$arity$18 = G__887__18;\nG__887.cljs$core$IFn$_invoke$arity$19 = G__887__19;\nG__887.cljs$core$IFn$_invoke$arity$20 = G__887__20;\nG__887.cljs$core$IFn$_invoke$arity$21 = G__887__21;\nG__887.cljs$core$IFn$_invoke$arity$22 = G__887__22;\nreturn G__887;\n})()\n;\n\ncljs.core.MetaFn.prototype.apply = (function (self__,args886){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args886)));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$0 = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$0 ? self__.afn.cljs$core$IFn$_invoke$arity$0() : self__.afn.call(null));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$1 = (function (a){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$1 ? self__.afn.cljs$core$IFn$_invoke$arity$1(a) : self__.afn.call(null,a));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$2 ? self__.afn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.afn.call(null,a,b));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$3 ? self__.afn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.afn.call(null,a,b,c));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$4 = (function (a,b,c,d){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$4 ? self__.afn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.afn.call(null,a,b,c,d));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$5 = (function (a,b,c,d,e){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$5 ? self__.afn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.afn.call(null,a,b,c,d,e));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$6 = (function (a,b,c,d,e,f){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$6 ? self__.afn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.afn.call(null,a,b,c,d,e,f));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$7 = (function (a,b,c,d,e,f,g){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$7 ? self__.afn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.afn.call(null,a,b,c,d,e,f,g));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$8 = (function (a,b,c,d,e,f,g,h){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$8 ? self__.afn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.afn.call(null,a,b,c,d,e,f,g,h));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$9 = (function (a,b,c,d,e,f,g,h,i){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$9 ? self__.afn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.afn.call(null,a,b,c,d,e,f,g,h,i));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$10 = (function (a,b,c,d,e,f,g,h,i,j){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$10 ? self__.afn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$11 = (function (a,b,c,d,e,f,g,h,i,j,k){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$11 ? self__.afn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$12 = (function (a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$12 ? self__.afn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$13 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$13 ? self__.afn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$14 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$14 ? self__.afn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$15 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$15 ? self__.afn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$16 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$16 ? self__.afn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$17 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$17 ? self__.afn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$18 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$18 ? self__.afn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$19 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$19 ? self__.afn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$20 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ = this;\nvar _ = this;\nreturn (self__.afn.cljs$core$IFn$_invoke$arity$20 ? self__.afn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.afn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\n\ncljs.core.MetaFn.prototype.cljs$core$IFn$_invoke$arity$21 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ = this;\nvar _ = this;\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.afn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\n\ncljs.core.MetaFn.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"afn\",\"afn\",216963467,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null)], null);\n});\n\ncljs.core.MetaFn.cljs$lang$type = true;\n\ncljs.core.MetaFn.cljs$lang$ctorStr = \"cljs.core/MetaFn\";\n\ncljs.core.MetaFn.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/MetaFn\");\n});\n\n/**\n * Positional factory function for cljs.core/MetaFn.\n */\ncljs.core.__GT_MetaFn = (function cljs$core$__GT_MetaFn(afn,meta){\nreturn (new cljs.core.MetaFn(afn,meta));\n});\n\n/**\n * Returns an object of the same type and value as obj, with\n *   map m as its metadata.\n */\ncljs.core.with_meta = (function cljs$core$with_meta(o,meta){\nif(goog.isFunction(o)){\nreturn (new cljs.core.MetaFn(o,meta));\n} else {\nif((o == null)){\nreturn null;\n} else {\nreturn cljs.core._with_meta(o,meta);\n}\n}\n});\n/**\n * Returns the metadata of obj, returns nil if there is no metadata.\n */\ncljs.core.meta = (function cljs$core$meta(o){\nif((function (){var and__4120__auto__ = (!((o == null)));\nif(and__4120__auto__){\nif((!((o == null)))){\nif((((o.cljs$lang$protocol_mask$partition0$ & (131072))) || ((cljs.core.PROTOCOL_SENTINEL === o.cljs$core$IMeta$)))){\nreturn true;\n} else {\nif((!o.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMeta,o);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMeta,o);\n}\n} else {\nreturn and__4120__auto__;\n}\n})()){\nreturn cljs.core._meta(o);\n} else {\nreturn null;\n}\n});\n/**\n * For a list or queue, same as first, for a vector, same as, but much\n *   more efficient than, last. If the collection is empty, returns nil.\n */\ncljs.core.peek = (function cljs$core$peek(coll){\nif((coll == null)){\nreturn null;\n} else {\nreturn cljs.core._peek(coll);\n}\n});\n/**\n * For a list or queue, returns a new list/queue without the first\n *   item, for a vector, returns a new vector without the last item.\n *   Note - not the same as next/butlast.\n */\ncljs.core.pop = (function cljs$core$pop(coll){\nif((coll == null)){\nreturn null;\n} else {\nreturn cljs.core._pop(coll);\n}\n});\n/**\n * disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n *   does not contain key(s).\n */\ncljs.core.disj = (function cljs$core$disj(var_args){\nvar G__894 = arguments.length;\nswitch (G__894) {\ncase 1:\nreturn cljs.core.disj.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.disj.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___896 = arguments.length;\nvar i__4731__auto___897 = (0);\nwhile(true){\nif((i__4731__auto___897 < len__4730__auto___896)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___897]));\n\nvar G__898 = (i__4731__auto___897 + (1));\ni__4731__auto___897 = G__898;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.disj.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.disj.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nreturn coll;\n});\n\ncljs.core.disj.cljs$core$IFn$_invoke$arity$2 = (function (coll,k){\nif((coll == null)){\nreturn null;\n} else {\nreturn cljs.core._disjoin(coll,k);\n}\n});\n\ncljs.core.disj.cljs$core$IFn$_invoke$arity$variadic = (function (coll,k,ks){\nwhile(true){\nif((coll == null)){\nreturn null;\n} else {\nvar ret = cljs.core.disj.cljs$core$IFn$_invoke$arity$2(coll,k);\nif(cljs.core.truth_(ks)){\nvar G__899 = ret;\nvar G__900 = cljs.core.first(ks);\nvar G__901 = cljs.core.next(ks);\ncoll = G__899;\nk = G__900;\nks = G__901;\ncontinue;\n} else {\nreturn ret;\n}\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.disj.cljs$lang$applyTo = (function (seq891){\nvar G__892 = cljs.core.first(seq891);\nvar seq891__$1 = cljs.core.next(seq891);\nvar G__893 = cljs.core.first(seq891__$1);\nvar seq891__$2 = cljs.core.next(seq891__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__892,G__893,seq891__$2);\n});\n\ncljs.core.disj.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns true if coll has no items - same as (not (seq coll)).\n *   Please use the idiom (seq x) rather than (not (empty? x))\n */\ncljs.core.empty_QMARK_ = (function cljs$core$empty_QMARK_(coll){\nreturn (((coll == null)) || (cljs.core.not(cljs.core.seq(coll))));\n});\n/**\n * Returns true if x satisfies ICollection\n */\ncljs.core.coll_QMARK_ = (function cljs$core$coll_QMARK_(x){\nif((x == null)){\nreturn false;\n} else {\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (8))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$ICollection$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICollection,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ICollection,x);\n}\n}\n});\n/**\n * Returns true if x satisfies ISet\n */\ncljs.core.set_QMARK_ = (function cljs$core$set_QMARK_(x){\nif((x == null)){\nreturn false;\n} else {\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (4096))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$ISet$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISet,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISet,x);\n}\n}\n});\n/**\n * Returns true if coll implements IAssociative\n */\ncljs.core.associative_QMARK_ = (function cljs$core$associative_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (512))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IAssociative$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IAssociative,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IAssociative,x);\n}\n});\n/**\n * Returns true if coll implements IFind\n */\ncljs.core.ifind_QMARK_ = (function cljs$core$ifind_QMARK_(x){\nif((!((x == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IFind$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFind,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFind,x);\n}\n});\n/**\n * Returns true if coll satisfies ISequential\n */\ncljs.core.sequential_QMARK_ = (function cljs$core$sequential_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (16777216))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$ISequential$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISequential,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISequential,x);\n}\n});\n/**\n * Returns true if coll satisfies ISorted\n */\ncljs.core.sorted_QMARK_ = (function cljs$core$sorted_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (268435456))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$ISorted$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISorted,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISorted,x);\n}\n});\n/**\n * Returns true if coll satisfies IReduce\n */\ncljs.core.reduceable_QMARK_ = (function cljs$core$reduceable_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (524288))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IReduce$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,x);\n}\n});\n/**\n * Return true if x satisfies IMap\n */\ncljs.core.map_QMARK_ = (function cljs$core$map_QMARK_(x){\nif((x == null)){\nreturn false;\n} else {\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (1024))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IMap$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMap,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IMap,x);\n}\n}\n});\n/**\n * Return true if x satisfies IRecord\n */\ncljs.core.record_QMARK_ = (function cljs$core$record_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (67108864))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IRecord$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IRecord,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IRecord,x);\n}\n});\n/**\n * Return true if x satisfies IVector\n */\ncljs.core.vector_QMARK_ = (function cljs$core$vector_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (16384))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IVector$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IVector,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IVector,x);\n}\n});\n\n/**\n * Return true if x is satisfies IChunkedSeq.\n */\ncljs.core.chunked_seq_QMARK_ = (function cljs$core$chunked_seq_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition1$ & (512))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IChunkedSeq$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\n/**\n * Create JavaSript object from an even number arguments representing\n *   interleaved keys and values.\n */\ncljs.core.js_obj = (function cljs$core$js_obj(var_args){\nvar G__915 = arguments.length;\nswitch (G__915) {\ncase 0:\nreturn cljs.core.js_obj.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___919 = arguments.length;\nvar i__4731__auto___920 = (0);\nwhile(true){\nif((i__4731__auto___920 < len__4730__auto___919)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___920]));\n\nvar G__921 = (i__4731__auto___920 + (1));\ni__4731__auto___920 = G__921;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((0)),(0),null));\nreturn cljs.core.js_obj.cljs$core$IFn$_invoke$arity$variadic(argseq__4752__auto__);\n\n}\n});\n\ncljs.core.js_obj.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn ({});\n});\n\ncljs.core.js_obj.cljs$core$IFn$_invoke$arity$variadic = (function (keyvals){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(goog.object.create,keyvals);\n});\n\n/** @this {Function} */\ncljs.core.js_obj.cljs$lang$applyTo = (function (seq914){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq914));\n});\n\ncljs.core.js_obj.cljs$lang$maxFixedArity = (0);\n\n/**\n * Return the JavaScript keys for an object.\n */\ncljs.core.js_keys = (function cljs$core$js_keys(obj){\nreturn goog.object.getKeys(obj);\n});\n/**\n * Delete a property from a JavaScript object.\n *   Returns true upon success, false otherwise.\n */\ncljs.core.js_delete = (function cljs$core$js_delete(obj,key){\nreturn delete obj[key];\n});\ncljs.core.array_copy = (function cljs$core$array_copy(from,i,to,j,len){\nvar i__$1 = i;\nvar j__$1 = j;\nvar len__$1 = len;\nwhile(true){\nif((len__$1 === (0))){\nreturn to;\n} else {\n(to[j__$1] = (from[i__$1]));\n\nvar G__922 = (i__$1 + (1));\nvar G__923 = (j__$1 + (1));\nvar G__924 = (len__$1 - (1));\ni__$1 = G__922;\nj__$1 = G__923;\nlen__$1 = G__924;\ncontinue;\n}\nbreak;\n}\n});\ncljs.core.array_copy_downward = (function cljs$core$array_copy_downward(from,i,to,j,len){\nvar i__$1 = (i + (len - (1)));\nvar j__$1 = (j + (len - (1)));\nvar len__$1 = len;\nwhile(true){\nif((len__$1 === (0))){\nreturn to;\n} else {\n(to[j__$1] = (from[i__$1]));\n\nvar G__925 = (i__$1 - (1));\nvar G__926 = (j__$1 - (1));\nvar G__927 = (len__$1 - (1));\ni__$1 = G__925;\nj__$1 = G__926;\nlen__$1 = G__927;\ncontinue;\n}\nbreak;\n}\n});\ncljs.core.lookup_sentinel = ({});\n/**\n * Returns true if x is the value false, false otherwise.\n */\ncljs.core.false_QMARK_ = (function cljs$core$false_QMARK_(x){\nreturn x === false;\n});\n/**\n * Returns true if x is the value true, false otherwise.\n */\ncljs.core.true_QMARK_ = (function cljs$core$true_QMARK_(x){\nreturn x === true;\n});\n/**\n * Return true if x is a Boolean\n */\ncljs.core.boolean_QMARK_ = (function cljs$core$boolean_QMARK_(x){\nreturn ((x === true) || (x === false));\n});\n/**\n * Returns true if x identical to the JavaScript undefined value.\n */\ncljs.core.undefined_QMARK_ = (function cljs$core$undefined_QMARK_(x){\nreturn (void 0 === x);\n});\n/**\n * Return true if s satisfies ISeq\n */\ncljs.core.seq_QMARK_ = (function cljs$core$seq_QMARK_(s){\nif((s == null)){\nreturn false;\n} else {\nif((!((s == null)))){\nif((((s.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === s.cljs$core$ISeq$)))){\nreturn true;\n} else {\nif((!s.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISeq,s);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.ISeq,s);\n}\n}\n});\n/**\n * Return true if the seq function is supported for s\n */\ncljs.core.seqable_QMARK_ = (function cljs$core$seqable_QMARK_(s){\nvar or__4131__auto__ = (s == null);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (((!((s == null))))?(((((s.cljs$lang$protocol_mask$partition0$ & (8388608))) || ((cljs.core.PROTOCOL_SENTINEL === s.cljs$core$ISeqable$))))?true:(((!s.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.ISeqable,s):false)):cljs.core.native_satisfies_QMARK_(cljs.core.ISeqable,s));\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nreturn ((cljs.core.array_QMARK_(s)) || (typeof s === 'string'));\n}\n}\n});\n/**\n * Coerce to boolean\n */\ncljs.core.boolean$ = (function cljs$core$boolean(x){\nif((x == null)){\nreturn false;\n} else {\nif(x === false){\nreturn false;\n} else {\nreturn true;\n\n}\n}\n});\n/**\n * Returns true if f returns true for fn? or satisfies IFn.\n */\ncljs.core.ifn_QMARK_ = (function cljs$core$ifn_QMARK_(f){\nvar or__4131__auto__ = cljs.core.fn_QMARK_(f);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nif((!((f == null)))){\nif((((f.cljs$lang$protocol_mask$partition0$ & (1))) || ((cljs.core.PROTOCOL_SENTINEL === f.cljs$core$IFn$)))){\nreturn true;\n} else {\nif((!f.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFn,f);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IFn,f);\n}\n}\n});\n/**\n * Returns true if n is a JavaScript number with no decimal part.\n */\ncljs.core.integer_QMARK_ = (function cljs$core$integer_QMARK_(n){\nreturn ((typeof n === 'number') && ((!(isNaN(n)))) && ((!((n === Infinity)))) && ((parseFloat(n) === parseInt(n,(10)))));\n});\n/**\n * Return true if x satisfies integer? or is an instance of goog.math.Integer\n * or goog.math.Long.\n */\ncljs.core.int_QMARK_ = (function cljs$core$int_QMARK_(x){\nreturn ((cljs.core.integer_QMARK_(x)) || ((x instanceof goog.math.Integer)) || ((x instanceof goog.math.Long)));\n});\n/**\n * Return true if x satisfies int? and is positive.\n */\ncljs.core.pos_int_QMARK_ = (function cljs$core$pos_int_QMARK_(x){\nif(cljs.core.integer_QMARK_(x)){\nreturn (x > (0));\n} else {\nif((x instanceof goog.math.Integer)){\nreturn ((cljs.core.not(x.isNegative())) && (cljs.core.not(x.isZero())));\n} else {\nif((x instanceof goog.math.Long)){\nreturn ((cljs.core.not(x.isNegative())) && (cljs.core.not(x.isZero())));\n} else {\nreturn false;\n\n}\n}\n}\n});\n/**\n * Return true if x satisfies int? and is negative.\n */\ncljs.core.neg_int_QMARK_ = (function cljs$core$neg_int_QMARK_(x){\nif(cljs.core.integer_QMARK_(x)){\nreturn (x < (0));\n} else {\nif((x instanceof goog.math.Integer)){\nreturn x.isNegative();\n} else {\nif((x instanceof goog.math.Long)){\nreturn x.isNegative();\n} else {\nreturn false;\n\n}\n}\n}\n});\n/**\n * Return true if x satisfies int? and is a natural integer value.\n */\ncljs.core.nat_int_QMARK_ = (function cljs$core$nat_int_QMARK_(x){\nif(cljs.core.integer_QMARK_(x)){\nreturn (!((x < (0))));\n} else {\nif((x instanceof goog.math.Integer)){\nreturn cljs.core.not(x.isNegative());\n} else {\nif((x instanceof goog.math.Long)){\nreturn cljs.core.not(x.isNegative());\n} else {\nreturn false;\n\n}\n}\n}\n});\n/**\n * Returns true for JavaScript numbers, false otherwise.\n */\ncljs.core.float_QMARK_ = (function cljs$core$float_QMARK_(x){\nreturn typeof x === 'number';\n});\n/**\n * Returns true for JavaScript numbers, false otherwise.\n */\ncljs.core.double_QMARK_ = (function cljs$core$double_QMARK_(x){\nreturn typeof x === 'number';\n});\n/**\n * Returns true for Infinity and -Infinity values.\n */\ncljs.core.infinite_QMARK_ = (function cljs$core$infinite_QMARK_(x){\nreturn (((x === Number.POSITIVE_INFINITY)) || ((x === Number.NEGATIVE_INFINITY)));\n});\n/**\n * Returns true if key is present in the given collection, otherwise\n *   returns false.  Note that for numerically indexed collections like\n *   vectors and arrays, this tests if the numeric key is within the\n *   range of indexes. 'contains?' operates constant or logarithmic time;\n *   it will not perform a linear search for a value.  See also 'some'.\n */\ncljs.core.contains_QMARK_ = (function cljs$core$contains_QMARK_(coll,v){\nif((cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,v,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)){\nreturn false;\n} else {\nreturn true;\n}\n});\n/**\n * Returns the map entry for key, or nil if key not present.\n */\ncljs.core.find = (function cljs$core$find(coll,k){\nif(cljs.core.ifind_QMARK_(coll)){\nreturn cljs.core._find(coll,k);\n} else {\nif((((!((coll == null)))) && (cljs.core.associative_QMARK_(coll)) && (cljs.core.contains_QMARK_(coll,k)))){\nreturn (new cljs.core.MapEntry(k,cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,k),null));\n} else {\nreturn null;\n}\n}\n});\n/**\n * Returns true if no two of the arguments are =\n */\ncljs.core.distinct_QMARK_ = (function cljs$core$distinct_QMARK_(var_args){\nvar G__940 = arguments.length;\nswitch (G__940) {\ncase 1:\nreturn cljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___942 = arguments.length;\nvar i__4731__auto___943 = (0);\nwhile(true){\nif((i__4731__auto___943 < len__4730__auto___942)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___943]));\n\nvar G__944 = (i__4731__auto___943 + (1));\ni__4731__auto___943 = G__944;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)));\n});\n\ncljs.core.distinct_QMARK_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nif((!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)))){\nvar s = cljs.core.PersistentHashSet.createAsIfByAssoc([x,y]);\nvar xs = more;\nwhile(true){\nvar x__$1 = cljs.core.first(xs);\nvar etc = cljs.core.next(xs);\nif(cljs.core.truth_(xs)){\nif(cljs.core.contains_QMARK_(s,x__$1)){\nreturn false;\n} else {\nvar G__945 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(s,x__$1);\nvar G__946 = etc;\ns = G__945;\nxs = G__946;\ncontinue;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n} else {\nreturn false;\n}\n});\n\n/** @this {Function} */\ncljs.core.distinct_QMARK_.cljs$lang$applyTo = (function (seq937){\nvar G__938 = cljs.core.first(seq937);\nvar seq937__$1 = cljs.core.next(seq937);\nvar G__939 = cljs.core.first(seq937__$1);\nvar seq937__$2 = cljs.core.next(seq937__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__938,G__939,seq937__$2);\n});\n\ncljs.core.distinct_QMARK_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Comparator. Returns a negative number, zero, or a positive number\n *   when x is logically 'less than', 'equal to', or 'greater than'\n *   y. Uses IComparable if available and google.array.defaultCompare for objects\n *  of the same type and special-cases nil to be less than any other object.\n */\ncljs.core.compare = (function cljs$core$compare(x,y){\nif((x === y)){\nreturn (0);\n} else {\nif((x == null)){\nreturn (-1);\n} else {\nif((y == null)){\nreturn (1);\n} else {\nif(typeof x === 'number'){\nif(typeof y === 'number'){\nreturn goog.array.defaultCompare(x,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n} else {\nif((((!((x == null))))?(((((x.cljs$lang$protocol_mask$partition1$ & (2048))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IComparable$))))?true:(((!x.cljs$lang$protocol_mask$partition1$))?cljs.core.native_satisfies_QMARK_(cljs.core.IComparable,x):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IComparable,x))){\nreturn cljs.core._compare(x,y);\n} else {\nif(((((typeof x === 'string') || (cljs.core.array_QMARK_(x)) || (x === true) || (x === false))) && ((cljs.core.type(x) === cljs.core.type(y))))){\nreturn goog.array.defaultCompare(x,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n\n}\n}\n}\n}\n}\n});\n/**\n * Compare indexed collection.\n */\ncljs.core.compare_indexed = (function cljs$core$compare_indexed(var_args){\nvar G__949 = arguments.length;\nswitch (G__949) {\ncase 2:\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 4:\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2 = (function (xs,ys){\nvar xl = cljs.core.count(xs);\nvar yl = cljs.core.count(ys);\nif((xl < yl)){\nreturn (-1);\n} else {\nif((xl > yl)){\nreturn (1);\n} else {\nif((xl === (0))){\nreturn (0);\n} else {\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$4(xs,ys,xl,(0));\n\n}\n}\n}\n});\n\ncljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$4 = (function (xs,ys,len,n){\nwhile(true){\nvar d = cljs.core.compare(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(xs,n),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(ys,n));\nif((((d === (0))) && (((n + (1)) < len)))){\nvar G__951 = xs;\nvar G__952 = ys;\nvar G__953 = len;\nvar G__954 = (n + (1));\nxs = G__951;\nys = G__952;\nlen = G__953;\nn = G__954;\ncontinue;\n} else {\nreturn d;\n}\nbreak;\n}\n});\n\ncljs.core.compare_indexed.cljs$lang$maxFixedArity = 4;\n\n/**\n * Given a fn that might be boolean valued or a comparator,\n * return a fn that is a comparator.\n */\ncljs.core.fn__GT_comparator = (function cljs$core$fn__GT_comparator(f){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(f,cljs.core.compare)){\nreturn cljs.core.compare;\n} else {\nreturn (function (x,y){\nvar r = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y));\nif(typeof r === 'number'){\nreturn r;\n} else {\nif(cljs.core.truth_(r)){\nreturn (-1);\n} else {\nif(cljs.core.truth_((f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(y,x) : f.call(null,y,x)))){\nreturn (1);\n} else {\nreturn (0);\n}\n}\n}\n});\n}\n});\n/**\n * Returns a sorted sequence of the items in coll. Comp can be\n * boolean-valued comparison function, or a -/0/+ valued comparator.\n * Comp defaults to compare.\n */\ncljs.core.sort = (function cljs$core$sort(var_args){\nvar G__956 = arguments.length;\nswitch (G__956) {\ncase 1:\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.sort.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2(cljs.core.compare,coll);\n});\n\ncljs.core.sort.cljs$core$IFn$_invoke$arity$2 = (function (comp,coll){\nif(cljs.core.seq(coll)){\nvar a = cljs.core.to_array(coll);\nvar G__957_960 = a;\nvar G__958_961 = cljs.core.fn__GT_comparator(comp);\ngoog.array.stableSort(G__957_960,G__958_961);\n\nreturn cljs.core.seq(a);\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.sort.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a sorted sequence of the items in coll, where the sort\n * order is determined by comparing (keyfn item).  Comp can be\n * boolean-valued comparison function, or a -/0/+ valued comparator.\n * Comp defaults to compare.\n */\ncljs.core.sort_by = (function cljs$core$sort_by(var_args){\nvar G__963 = arguments.length;\nswitch (G__963) {\ncase 2:\nreturn cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.sort_by.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.sort_by.cljs$core$IFn$_invoke$arity$2 = (function (keyfn,coll){\nreturn cljs.core.sort_by.cljs$core$IFn$_invoke$arity$3(keyfn,cljs.core.compare,coll);\n});\n\ncljs.core.sort_by.cljs$core$IFn$_invoke$arity$3 = (function (keyfn,comp,coll){\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2((function (x,y){\nvar G__965 = (keyfn.cljs$core$IFn$_invoke$arity$1 ? keyfn.cljs$core$IFn$_invoke$arity$1(x) : keyfn.call(null,x));\nvar G__966 = (keyfn.cljs$core$IFn$_invoke$arity$1 ? keyfn.cljs$core$IFn$_invoke$arity$1(y) : keyfn.call(null,y));\nvar fexpr__964 = cljs.core.fn__GT_comparator(comp);\nreturn (fexpr__964.cljs$core$IFn$_invoke$arity$2 ? fexpr__964.cljs$core$IFn$_invoke$arity$2(G__965,G__966) : fexpr__964.call(null,G__965,G__966));\n}),coll);\n});\n\ncljs.core.sort_by.cljs$lang$maxFixedArity = 3;\n\ncljs.core.seq_reduce = (function cljs$core$seq_reduce(var_args){\nvar G__969 = arguments.length;\nswitch (G__969) {\ncase 2:\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nvar temp__5718__auto__ = cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar s = temp__5718__auto__;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(f,cljs.core.first(s),cljs.core.next(s));\n} else {\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n}\n});\n\ncljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3 = (function (f,val,coll){\nvar val__$1 = val;\nvar coll__$1 = cljs.core.seq(coll);\nwhile(true){\nif(coll__$1){\nvar nval = (function (){var G__970 = val__$1;\nvar G__971 = cljs.core.first(coll__$1);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__970,G__971) : f.call(null,G__970,G__971));\n})();\nif(cljs.core.reduced_QMARK_(nval)){\nreturn cljs.core.deref(nval);\n} else {\nvar G__973 = nval;\nvar G__974 = cljs.core.next(coll__$1);\nval__$1 = G__973;\ncoll__$1 = G__974;\ncontinue;\n}\n} else {\nreturn val__$1;\n}\nbreak;\n}\n});\n\ncljs.core.seq_reduce.cljs$lang$maxFixedArity = 3;\n\n/**\n * Return a random permutation of coll\n */\ncljs.core.shuffle = (function cljs$core$shuffle(coll){\nvar a = cljs.core.to_array(coll);\ngoog.array.shuffle(a);\n\nreturn cljs.core.vec(a);\n});\ncljs.core.iter_reduce = (function cljs$core$iter_reduce(var_args){\nvar G__976 = arguments.length;\nswitch (G__976) {\ncase 2:\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2 = (function (coll,f){\nvar iter = cljs.core._iterator(coll);\nif(cljs.core.truth_(iter.hasNext())){\nvar init = iter.next();\nvar acc = init;\nwhile(true){\nif(iter.hasNext()){\nvar nacc = (function (){var G__977 = acc;\nvar G__978 = iter.next();\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__977,G__978) : f.call(null,G__977,G__978));\n})();\nif(cljs.core.reduced_QMARK_(nacc)){\nreturn cljs.core.deref(nacc);\n} else {\nvar G__982 = nacc;\nacc = G__982;\ncontinue;\n}\n} else {\nreturn acc;\n}\nbreak;\n}\n} else {\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n}\n});\n\ncljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3 = (function (coll,f,init){\nvar iter = cljs.core._iterator(coll);\nvar acc = init;\nwhile(true){\nif(iter.hasNext()){\nvar nacc = (function (){var G__979 = acc;\nvar G__980 = iter.next();\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__979,G__980) : f.call(null,G__979,G__980));\n})();\nif(cljs.core.reduced_QMARK_(nacc)){\nreturn cljs.core.deref(nacc);\n} else {\nvar G__983 = nacc;\nacc = G__983;\ncontinue;\n}\n} else {\nreturn acc;\n}\nbreak;\n}\n});\n\ncljs.core.iter_reduce.cljs$lang$maxFixedArity = 3;\n\n/**\n * f should be a function of 2 arguments. If val is not supplied,\n *   returns the result of applying f to the first 2 items in coll, then\n *   applying f to that result and the 3rd item, etc. If coll contains no\n *   items, f must accept no arguments as well, and reduce returns the\n *   result of calling f with no arguments.  If coll has only 1 item, it\n *   is returned and f is not called.  If val is supplied, returns the\n *   result of applying f to val and the first item in coll, then\n *   applying f to that result and the 2nd item, etc. If coll contains no\n *   items, returns val and f is not called.\n */\ncljs.core.reduce = (function cljs$core$reduce(var_args){\nvar G__985 = arguments.length;\nswitch (G__985) {\ncase 2:\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (524288))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IReduce$))))?true:false):false)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(typeof coll === 'string'){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,coll)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nif(cljs.core.iterable_QMARK_(coll)){\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2(coll,f);\n} else {\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll);\n\n}\n}\n}\n}\n}\n});\n\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$3 = (function (f,val,coll){\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (524288))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IReduce$))))?true:false):false)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(typeof coll === 'string'){\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(cljs.core.native_satisfies_QMARK_(cljs.core.IReduce,coll)){\nreturn cljs.core._reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nif(cljs.core.iterable_QMARK_(coll)){\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3(coll,f,val);\n} else {\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,val,coll);\n\n}\n}\n}\n}\n}\n});\n\ncljs.core.reduce.cljs$lang$maxFixedArity = 3;\n\n/**\n * Reduces an associative collection. f should be a function of 3\n *   arguments. Returns the result of applying f to init, the first key\n *   and the first value in coll, then applying f to that result and the\n *   2nd key and value, etc. If coll contains no entries, returns init\n *   and f is not called. Note that reduce-kv is supported on vectors,\n *   where the keys will be the ordinals.\n */\ncljs.core.reduce_kv = (function cljs$core$reduce_kv(f,init,coll){\nif((!((coll == null)))){\nreturn cljs.core._kv_reduce(coll,f,init);\n} else {\nreturn init;\n}\n});\n/**\n * Returns its argument.\n */\ncljs.core.identity = (function cljs$core$identity(x){\nreturn x;\n});\n/**\n * Takes a reducing function f of 2 args and returns a fn suitable for\n *   transduce by adding an arity-1 signature that calls cf (default -\n *   identity) on the result argument.\n */\ncljs.core.completing = (function cljs$core$completing(var_args){\nvar G__990 = arguments.length;\nswitch (G__990) {\ncase 1:\nreturn cljs.core.completing.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.completing.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.completing.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn cljs.core.completing.cljs$core$IFn$_invoke$arity$2(f,cljs.core.identity);\n});\n\ncljs.core.completing.cljs$core$IFn$_invoke$arity$2 = (function (f,cf){\nreturn (function() {\nvar G__992 = null;\nvar G__992__0 = (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n});\nvar G__992__1 = (function (x){\nreturn (cf.cljs$core$IFn$_invoke$arity$1 ? cf.cljs$core$IFn$_invoke$arity$1(x) : cf.call(null,x));\n});\nvar G__992__2 = (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y));\n});\nG__992 = function(x,y){\nswitch(arguments.length){\ncase 0:\nreturn G__992__0.call(this);\ncase 1:\nreturn G__992__1.call(this,x);\ncase 2:\nreturn G__992__2.call(this,x,y);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__992.cljs$core$IFn$_invoke$arity$0 = G__992__0;\nG__992.cljs$core$IFn$_invoke$arity$1 = G__992__1;\nG__992.cljs$core$IFn$_invoke$arity$2 = G__992__2;\nreturn G__992;\n})()\n});\n\ncljs.core.completing.cljs$lang$maxFixedArity = 2;\n\n/**\n * reduce with a transformation of f (xf). If init is not\n *   supplied, (f) will be called to produce it. f should be a reducing\n *   step function that accepts both 1 and 2 arguments, if it accepts\n *   only 2 you can add the arity-1 with 'completing'. Returns the result\n *   of applying (the transformed) xf to init and the first item in coll,\n *   then applying xf to that result and the 2nd item, etc. If coll\n *   contains no items, returns init and f is not called. Note that\n *   certain transforms may inject or skip items.\n */\ncljs.core.transduce = (function cljs$core$transduce(var_args){\nvar G__994 = arguments.length;\nswitch (G__994) {\ncase 3:\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.transduce.cljs$core$IFn$_invoke$arity$3 = (function (xform,f,coll){\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(xform,f,(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),coll);\n});\n\ncljs.core.transduce.cljs$core$IFn$_invoke$arity$4 = (function (xform,f,init,coll){\nvar f__$1 = (xform.cljs$core$IFn$_invoke$arity$1 ? xform.cljs$core$IFn$_invoke$arity$1(f) : xform.call(null,f));\nvar ret = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(f__$1,init,coll);\nreturn (f__$1.cljs$core$IFn$_invoke$arity$1 ? f__$1.cljs$core$IFn$_invoke$arity$1(ret) : f__$1.call(null,ret));\n});\n\ncljs.core.transduce.cljs$lang$maxFixedArity = 4;\n\n/**\n * Returns the sum of nums. (+) returns 0.\n */\ncljs.core._PLUS_ = (function cljs$core$_PLUS_(var_args){\nvar G__1000 = arguments.length;\nswitch (G__1000) {\ncase 0:\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1002 = arguments.length;\nvar i__4731__auto___1003 = (0);\nwhile(true){\nif((i__4731__auto___1003 < len__4730__auto___1002)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1003]));\n\nvar G__1004 = (i__4731__auto___1003 + (1));\ni__4731__auto___1003 = G__1004;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._PLUS_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (0);\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x + y);\n});\n\ncljs.core._PLUS_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._PLUS_,(x + y),more);\n});\n\n/** @this {Function} */\ncljs.core._PLUS_.cljs$lang$applyTo = (function (seq997){\nvar G__998 = cljs.core.first(seq997);\nvar seq997__$1 = cljs.core.next(seq997);\nvar G__999 = cljs.core.first(seq997__$1);\nvar seq997__$2 = cljs.core.next(seq997__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__998,G__999,seq997__$2);\n});\n\ncljs.core._PLUS_.cljs$lang$maxFixedArity = (2);\n\n/**\n * If no ys are supplied, returns the negation of x, else subtracts\n *   the ys from x and returns the result.\n */\ncljs.core._ = (function cljs$core$_(var_args){\nvar G__1009 = arguments.length;\nswitch (G__1009) {\ncase 1:\nreturn cljs.core._.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1011 = arguments.length;\nvar i__4731__auto___1012 = (0);\nwhile(true){\nif((i__4731__auto___1012 < len__4730__auto___1011)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1012]));\n\nvar G__1013 = (i__4731__auto___1012 + (1));\ni__4731__auto___1012 = G__1013;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn (- x);\n});\n\ncljs.core._.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x - y);\n});\n\ncljs.core._.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._,(x - y),more);\n});\n\n/** @this {Function} */\ncljs.core._.cljs$lang$applyTo = (function (seq1006){\nvar G__1007 = cljs.core.first(seq1006);\nvar seq1006__$1 = cljs.core.next(seq1006);\nvar G__1008 = cljs.core.first(seq1006__$1);\nvar seq1006__$2 = cljs.core.next(seq1006__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1007,G__1008,seq1006__$2);\n});\n\ncljs.core._.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns the product of nums. (*) returns 1.\n */\ncljs.core._STAR_ = (function cljs$core$_STAR_(var_args){\nvar G__1018 = arguments.length;\nswitch (G__1018) {\ncase 0:\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1020 = arguments.length;\nvar i__4731__auto___1021 = (0);\nwhile(true){\nif((i__4731__auto___1021 < len__4730__auto___1020)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1021]));\n\nvar G__1022 = (i__4731__auto___1021 + (1));\ni__4731__auto___1021 = G__1022;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._STAR_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (1);\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x * y);\n});\n\ncljs.core._STAR_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._STAR_,(x * y),more);\n});\n\n/** @this {Function} */\ncljs.core._STAR_.cljs$lang$applyTo = (function (seq1015){\nvar G__1016 = cljs.core.first(seq1015);\nvar seq1015__$1 = cljs.core.next(seq1015);\nvar G__1017 = cljs.core.first(seq1015__$1);\nvar seq1015__$2 = cljs.core.next(seq1015__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1016,G__1017,seq1015__$2);\n});\n\ncljs.core._STAR_.cljs$lang$maxFixedArity = (2);\n\n/**\n * If no denominators are supplied, returns 1/numerator,\n *   else returns numerator divided by all of the denominators.\n */\ncljs.core._SLASH_ = (function cljs$core$_SLASH_(var_args){\nvar G__1027 = arguments.length;\nswitch (G__1027) {\ncase 1:\nreturn cljs.core._SLASH_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._SLASH_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1029 = arguments.length;\nvar i__4731__auto___1030 = (0);\nwhile(true){\nif((i__4731__auto___1030 < len__4730__auto___1029)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1030]));\n\nvar G__1031 = (i__4731__auto___1030 + (1));\ni__4731__auto___1030 = G__1031;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._SLASH_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._SLASH_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn ((1) / x);\n});\n\ncljs.core._SLASH_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x / y);\n});\n\ncljs.core._SLASH_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._SLASH_,(x / y),more);\n});\n\n/** @this {Function} */\ncljs.core._SLASH_.cljs$lang$applyTo = (function (seq1024){\nvar G__1025 = cljs.core.first(seq1024);\nvar seq1024__$1 = cljs.core.next(seq1024);\nvar G__1026 = cljs.core.first(seq1024__$1);\nvar seq1024__$2 = cljs.core.next(seq1024__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1025,G__1026,seq1024__$2);\n});\n\ncljs.core._SLASH_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns non-nil if nums are in monotonically increasing order,\n *   otherwise false.\n */\ncljs.core._LT_ = (function cljs$core$_LT_(var_args){\nvar G__1036 = arguments.length;\nswitch (G__1036) {\ncase 1:\nreturn cljs.core._LT_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._LT_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1038 = arguments.length;\nvar i__4731__auto___1039 = (0);\nwhile(true){\nif((i__4731__auto___1039 < len__4730__auto___1038)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1039]));\n\nvar G__1040 = (i__4731__auto___1039 + (1));\ni__4731__auto___1039 = G__1040;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._LT_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._LT_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core._LT_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x < y);\n});\n\ncljs.core._LT_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nwhile(true){\nif((x < y)){\nif(cljs.core.next(more)){\nvar G__1041 = y;\nvar G__1042 = cljs.core.first(more);\nvar G__1043 = cljs.core.next(more);\nx = G__1041;\ny = G__1042;\nmore = G__1043;\ncontinue;\n} else {\nreturn (y < cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._LT_.cljs$lang$applyTo = (function (seq1033){\nvar G__1034 = cljs.core.first(seq1033);\nvar seq1033__$1 = cljs.core.next(seq1033);\nvar G__1035 = cljs.core.first(seq1033__$1);\nvar seq1033__$2 = cljs.core.next(seq1033__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1034,G__1035,seq1033__$2);\n});\n\ncljs.core._LT_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns non-nil if nums are in monotonically non-decreasing order,\n *   otherwise false.\n */\ncljs.core._LT__EQ_ = (function cljs$core$_LT__EQ_(var_args){\nvar G__1048 = arguments.length;\nswitch (G__1048) {\ncase 1:\nreturn cljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1050 = arguments.length;\nvar i__4731__auto___1051 = (0);\nwhile(true){\nif((i__4731__auto___1051 < len__4730__auto___1050)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1051]));\n\nvar G__1052 = (i__4731__auto___1051 + (1));\ni__4731__auto___1051 = G__1052;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x <= y);\n});\n\ncljs.core._LT__EQ_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nwhile(true){\nif((x <= y)){\nif(cljs.core.next(more)){\nvar G__1053 = y;\nvar G__1054 = cljs.core.first(more);\nvar G__1055 = cljs.core.next(more);\nx = G__1053;\ny = G__1054;\nmore = G__1055;\ncontinue;\n} else {\nreturn (y <= cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._LT__EQ_.cljs$lang$applyTo = (function (seq1045){\nvar G__1046 = cljs.core.first(seq1045);\nvar seq1045__$1 = cljs.core.next(seq1045);\nvar G__1047 = cljs.core.first(seq1045__$1);\nvar seq1045__$2 = cljs.core.next(seq1045__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1046,G__1047,seq1045__$2);\n});\n\ncljs.core._LT__EQ_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns non-nil if nums are in monotonically decreasing order,\n *   otherwise false.\n */\ncljs.core._GT_ = (function cljs$core$_GT_(var_args){\nvar G__1060 = arguments.length;\nswitch (G__1060) {\ncase 1:\nreturn cljs.core._GT_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._GT_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1062 = arguments.length;\nvar i__4731__auto___1063 = (0);\nwhile(true){\nif((i__4731__auto___1063 < len__4730__auto___1062)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1063]));\n\nvar G__1064 = (i__4731__auto___1063 + (1));\ni__4731__auto___1063 = G__1064;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._GT_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._GT_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core._GT_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x > y);\n});\n\ncljs.core._GT_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nwhile(true){\nif((x > y)){\nif(cljs.core.next(more)){\nvar G__1065 = y;\nvar G__1066 = cljs.core.first(more);\nvar G__1067 = cljs.core.next(more);\nx = G__1065;\ny = G__1066;\nmore = G__1067;\ncontinue;\n} else {\nreturn (y > cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._GT_.cljs$lang$applyTo = (function (seq1057){\nvar G__1058 = cljs.core.first(seq1057);\nvar seq1057__$1 = cljs.core.next(seq1057);\nvar G__1059 = cljs.core.first(seq1057__$1);\nvar seq1057__$2 = cljs.core.next(seq1057__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1058,G__1059,seq1057__$2);\n});\n\ncljs.core._GT_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns non-nil if nums are in monotonically non-increasing order,\n *   otherwise false.\n */\ncljs.core._GT__EQ_ = (function cljs$core$_GT__EQ_(var_args){\nvar G__1072 = arguments.length;\nswitch (G__1072) {\ncase 1:\nreturn cljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1074 = arguments.length;\nvar i__4731__auto___1075 = (0);\nwhile(true){\nif((i__4731__auto___1075 < len__4730__auto___1074)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1075]));\n\nvar G__1076 = (i__4731__auto___1075 + (1));\ni__4731__auto___1075 = G__1076;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x >= y);\n});\n\ncljs.core._GT__EQ_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nwhile(true){\nif((x >= y)){\nif(cljs.core.next(more)){\nvar G__1077 = y;\nvar G__1078 = cljs.core.first(more);\nvar G__1079 = cljs.core.next(more);\nx = G__1077;\ny = G__1078;\nmore = G__1079;\ncontinue;\n} else {\nreturn (y >= cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._GT__EQ_.cljs$lang$applyTo = (function (seq1069){\nvar G__1070 = cljs.core.first(seq1069);\nvar seq1069__$1 = cljs.core.next(seq1069);\nvar G__1071 = cljs.core.first(seq1069__$1);\nvar seq1069__$2 = cljs.core.next(seq1069__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1070,G__1071,seq1069__$2);\n});\n\ncljs.core._GT__EQ_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a number one less than num.\n */\ncljs.core.dec = (function cljs$core$dec(x){\nreturn (x - (1));\n});\n/**\n * Returns the greatest of the nums.\n */\ncljs.core.max = (function cljs$core$max(var_args){\nvar G__1084 = arguments.length;\nswitch (G__1084) {\ncase 1:\nreturn cljs.core.max.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.max.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1086 = arguments.length;\nvar i__4731__auto___1087 = (0);\nwhile(true){\nif((i__4731__auto___1087 < len__4730__auto___1086)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1087]));\n\nvar G__1088 = (i__4731__auto___1087 + (1));\ni__4731__auto___1087 = G__1088;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.max.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.max.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core.max.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nvar x__4219__auto__ = x;\nvar y__4220__auto__ = y;\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n});\n\ncljs.core.max.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.max,(function (){var x__4219__auto__ = x;\nvar y__4220__auto__ = y;\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})(),more);\n});\n\n/** @this {Function} */\ncljs.core.max.cljs$lang$applyTo = (function (seq1081){\nvar G__1082 = cljs.core.first(seq1081);\nvar seq1081__$1 = cljs.core.next(seq1081);\nvar G__1083 = cljs.core.first(seq1081__$1);\nvar seq1081__$2 = cljs.core.next(seq1081__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1082,G__1083,seq1081__$2);\n});\n\ncljs.core.max.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns the least of the nums.\n */\ncljs.core.min = (function cljs$core$min(var_args){\nvar G__1093 = arguments.length;\nswitch (G__1093) {\ncase 1:\nreturn cljs.core.min.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.min.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1095 = arguments.length;\nvar i__4731__auto___1096 = (0);\nwhile(true){\nif((i__4731__auto___1096 < len__4730__auto___1095)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1096]));\n\nvar G__1097 = (i__4731__auto___1096 + (1));\ni__4731__auto___1096 = G__1097;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.min.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.min.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core.min.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nvar x__4222__auto__ = x;\nvar y__4223__auto__ = y;\nreturn ((x__4222__auto__ < y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n});\n\ncljs.core.min.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.min,(function (){var x__4222__auto__ = x;\nvar y__4223__auto__ = y;\nreturn ((x__4222__auto__ < y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})(),more);\n});\n\n/** @this {Function} */\ncljs.core.min.cljs$lang$applyTo = (function (seq1090){\nvar G__1091 = cljs.core.first(seq1090);\nvar seq1090__$1 = cljs.core.next(seq1090);\nvar G__1092 = cljs.core.first(seq1090__$1);\nvar seq1090__$2 = cljs.core.next(seq1090__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1091,G__1092,seq1090__$2);\n});\n\ncljs.core.min.cljs$lang$maxFixedArity = (2);\n\ncljs.core.byte$ = (function cljs$core$byte(x){\nreturn x;\n});\n/**\n * Coerce to char\n */\ncljs.core.char$ = (function cljs$core$char(x){\nif(typeof x === 'number'){\nreturn String.fromCharCode(x);\n} else {\nif(((typeof x === 'string') && ((x.length === (1))))){\nreturn x;\n} else {\nthrow (new Error(\"Argument to char must be a character or number\"));\n\n}\n}\n});\ncljs.core.short$ = (function cljs$core$short(x){\nreturn x;\n});\ncljs.core.float$ = (function cljs$core$float(x){\nreturn x;\n});\ncljs.core.double$ = (function cljs$core$double(x){\nreturn x;\n});\ncljs.core.unchecked_byte = (function cljs$core$unchecked_byte(x){\nreturn x;\n});\ncljs.core.unchecked_char = (function cljs$core$unchecked_char(x){\nreturn x;\n});\ncljs.core.unchecked_short = (function cljs$core$unchecked_short(x){\nreturn x;\n});\ncljs.core.unchecked_float = (function cljs$core$unchecked_float(x){\nreturn x;\n});\ncljs.core.unchecked_double = (function cljs$core$unchecked_double(x){\nreturn x;\n});\n/**\n * Returns the sum of nums. (+) returns 0.\n */\ncljs.core.unchecked_add = (function cljs$core$unchecked_add(var_args){\nvar G__1102 = arguments.length;\nswitch (G__1102) {\ncase 0:\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1104 = arguments.length;\nvar i__4731__auto___1105 = (0);\nwhile(true){\nif((i__4731__auto___1105 < len__4730__auto___1104)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1105]));\n\nvar G__1106 = (i__4731__auto___1105 + (1));\ni__4731__auto___1105 = G__1106;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (0);\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x + y);\n});\n\ncljs.core.unchecked_add.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_add,(x + y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_add.cljs$lang$applyTo = (function (seq1099){\nvar G__1100 = cljs.core.first(seq1099);\nvar seq1099__$1 = cljs.core.next(seq1099);\nvar G__1101 = cljs.core.first(seq1099__$1);\nvar seq1099__$2 = cljs.core.next(seq1099__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1100,G__1101,seq1099__$2);\n});\n\ncljs.core.unchecked_add.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns the sum of nums. (+) returns 0.\n */\ncljs.core.unchecked_add_int = (function cljs$core$unchecked_add_int(var_args){\nvar G__1111 = arguments.length;\nswitch (G__1111) {\ncase 0:\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1113 = arguments.length;\nvar i__4731__auto___1114 = (0);\nwhile(true){\nif((i__4731__auto___1114 < len__4730__auto___1113)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1114]));\n\nvar G__1115 = (i__4731__auto___1114 + (1));\ni__4731__auto___1114 = G__1115;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (0);\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x + y);\n});\n\ncljs.core.unchecked_add_int.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_add_int,(x + y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_add_int.cljs$lang$applyTo = (function (seq1108){\nvar G__1109 = cljs.core.first(seq1108);\nvar seq1108__$1 = cljs.core.next(seq1108);\nvar G__1110 = cljs.core.first(seq1108__$1);\nvar seq1108__$2 = cljs.core.next(seq1108__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1109,G__1110,seq1108__$2);\n});\n\ncljs.core.unchecked_add_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a number one less than x, an int.\n */\ncljs.core.unchecked_dec = (function cljs$core$unchecked_dec(x){\nreturn (x - (1));\n});\n/**\n * Returns a number one less than x, an int.\n */\ncljs.core.unchecked_dec_int = (function cljs$core$unchecked_dec_int(x){\nreturn (x - (1));\n});\n/**\n * If no denominators are supplied, returns 1/numerator,\n *   else returns numerator divided by all of the denominators.\n */\ncljs.core.unchecked_divide_int = (function cljs$core$unchecked_divide_int(var_args){\nvar G__1120 = arguments.length;\nswitch (G__1120) {\ncase 1:\nreturn cljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1122 = arguments.length;\nvar i__4731__auto___1123 = (0);\nwhile(true){\nif((i__4731__auto___1123 < len__4730__auto___1122)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1123]));\n\nvar G__1124 = (i__4731__auto___1123 + (1));\ni__4731__auto___1123 = G__1124;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn ((1) / x);\n});\n\ncljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x / y);\n});\n\ncljs.core.unchecked_divide_int.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_divide_int,(x / y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_divide_int.cljs$lang$applyTo = (function (seq1117){\nvar G__1118 = cljs.core.first(seq1117);\nvar seq1117__$1 = cljs.core.next(seq1117);\nvar G__1119 = cljs.core.first(seq1117__$1);\nvar seq1117__$2 = cljs.core.next(seq1117__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1118,G__1119,seq1117__$2);\n});\n\ncljs.core.unchecked_divide_int.cljs$lang$maxFixedArity = (2);\n\ncljs.core.unchecked_inc = (function cljs$core$unchecked_inc(x){\nreturn (x + (1));\n});\ncljs.core.unchecked_inc_int = (function cljs$core$unchecked_inc_int(x){\nreturn (x + (1));\n});\n/**\n * Returns the product of nums. (*) returns 1.\n */\ncljs.core.unchecked_multiply = (function cljs$core$unchecked_multiply(var_args){\nvar G__1129 = arguments.length;\nswitch (G__1129) {\ncase 0:\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1131 = arguments.length;\nvar i__4731__auto___1132 = (0);\nwhile(true){\nif((i__4731__auto___1132 < len__4730__auto___1131)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1132]));\n\nvar G__1133 = (i__4731__auto___1132 + (1));\ni__4731__auto___1132 = G__1133;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (1);\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x * y);\n});\n\ncljs.core.unchecked_multiply.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_multiply,(x * y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_multiply.cljs$lang$applyTo = (function (seq1126){\nvar G__1127 = cljs.core.first(seq1126);\nvar seq1126__$1 = cljs.core.next(seq1126);\nvar G__1128 = cljs.core.first(seq1126__$1);\nvar seq1126__$2 = cljs.core.next(seq1126__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1127,G__1128,seq1126__$2);\n});\n\ncljs.core.unchecked_multiply.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns the product of nums. (*) returns 1.\n */\ncljs.core.unchecked_multiply_int = (function cljs$core$unchecked_multiply_int(var_args){\nvar G__1138 = arguments.length;\nswitch (G__1138) {\ncase 0:\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1140 = arguments.length;\nvar i__4731__auto___1141 = (0);\nwhile(true){\nif((i__4731__auto___1141 < len__4730__auto___1140)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1141]));\n\nvar G__1142 = (i__4731__auto___1141 + (1));\ni__4731__auto___1141 = G__1142;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (1);\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn x;\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x * y);\n});\n\ncljs.core.unchecked_multiply_int.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_multiply_int,(x * y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_multiply_int.cljs$lang$applyTo = (function (seq1135){\nvar G__1136 = cljs.core.first(seq1135);\nvar seq1135__$1 = cljs.core.next(seq1135);\nvar G__1137 = cljs.core.first(seq1135__$1);\nvar seq1135__$2 = cljs.core.next(seq1135__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1136,G__1137,seq1135__$2);\n});\n\ncljs.core.unchecked_multiply_int.cljs$lang$maxFixedArity = (2);\n\ncljs.core.unchecked_negate = (function cljs$core$unchecked_negate(x){\nreturn (- x);\n});\ncljs.core.unchecked_negate_int = (function cljs$core$unchecked_negate_int(x){\nreturn (- x);\n});\ncljs.core.unchecked_remainder_int = (function cljs$core$unchecked_remainder_int(x,n){\nreturn cljs.core.mod(x,n);\n});\n/**\n * If no ys are supplied, returns the negation of x, else subtracts\n *   the ys from x and returns the result.\n */\ncljs.core.unchecked_subtract = (function cljs$core$unchecked_subtract(var_args){\nvar G__1147 = arguments.length;\nswitch (G__1147) {\ncase 1:\nreturn cljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1149 = arguments.length;\nvar i__4731__auto___1150 = (0);\nwhile(true){\nif((i__4731__auto___1150 < len__4730__auto___1149)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1150]));\n\nvar G__1151 = (i__4731__auto___1150 + (1));\ni__4731__auto___1150 = G__1151;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn (- x);\n});\n\ncljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x - y);\n});\n\ncljs.core.unchecked_subtract.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_subtract,(x - y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_subtract.cljs$lang$applyTo = (function (seq1144){\nvar G__1145 = cljs.core.first(seq1144);\nvar seq1144__$1 = cljs.core.next(seq1144);\nvar G__1146 = cljs.core.first(seq1144__$1);\nvar seq1144__$2 = cljs.core.next(seq1144__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1145,G__1146,seq1144__$2);\n});\n\ncljs.core.unchecked_subtract.cljs$lang$maxFixedArity = (2);\n\n/**\n * If no ys are supplied, returns the negation of x, else subtracts\n *   the ys from x and returns the result.\n */\ncljs.core.unchecked_subtract_int = (function cljs$core$unchecked_subtract_int(var_args){\nvar G__1156 = arguments.length;\nswitch (G__1156) {\ncase 1:\nreturn cljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1158 = arguments.length;\nvar i__4731__auto___1159 = (0);\nwhile(true){\nif((i__4731__auto___1159 < len__4730__auto___1158)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1159]));\n\nvar G__1160 = (i__4731__auto___1159 + (1));\ni__4731__auto___1159 = G__1160;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn (- x);\n});\n\ncljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x - y);\n});\n\ncljs.core.unchecked_subtract_int.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.unchecked_subtract_int,(x - y),more);\n});\n\n/** @this {Function} */\ncljs.core.unchecked_subtract_int.cljs$lang$applyTo = (function (seq1153){\nvar G__1154 = cljs.core.first(seq1153);\nvar seq1153__$1 = cljs.core.next(seq1153);\nvar G__1155 = cljs.core.first(seq1153__$1);\nvar seq1153__$2 = cljs.core.next(seq1153__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1154,G__1155,seq1153__$2);\n});\n\ncljs.core.unchecked_subtract_int.cljs$lang$maxFixedArity = (2);\n\ncljs.core.fix = (function cljs$core$fix(q){\nif((q >= (0))){\nreturn Math.floor(q);\n} else {\nreturn Math.ceil(q);\n}\n});\n/**\n * Coerce to int by stripping decimal places.\n */\ncljs.core.int$ = (function cljs$core$int(x){\nreturn (x | (0));\n});\n/**\n * Coerce to int by stripping decimal places.\n */\ncljs.core.unchecked_int = (function cljs$core$unchecked_int(x){\nreturn cljs.core.fix(x);\n});\n/**\n * Coerce to long by stripping decimal places. Identical to `int'.\n */\ncljs.core.long$ = (function cljs$core$long(x){\nreturn cljs.core.fix(x);\n});\n/**\n * Coerce to long by stripping decimal places. Identical to `int'.\n */\ncljs.core.unchecked_long = (function cljs$core$unchecked_long(x){\nreturn cljs.core.fix(x);\n});\ncljs.core.booleans = (function cljs$core$booleans(x){\nreturn x;\n});\ncljs.core.bytes = (function cljs$core$bytes(x){\nreturn x;\n});\ncljs.core.chars = (function cljs$core$chars(x){\nreturn x;\n});\ncljs.core.shorts = (function cljs$core$shorts(x){\nreturn x;\n});\ncljs.core.ints = (function cljs$core$ints(x){\nreturn x;\n});\ncljs.core.floats = (function cljs$core$floats(x){\nreturn x;\n});\ncljs.core.doubles = (function cljs$core$doubles(x){\nreturn x;\n});\ncljs.core.longs = (function cljs$core$longs(x){\nreturn x;\n});\n/**\n * Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\n */\ncljs.core.js_mod = (function cljs$core$js_mod(n,d){\nreturn (n % d);\n});\n/**\n * Modulus of num and div. Truncates toward negative infinity.\n */\ncljs.core.mod = (function cljs$core$mod(n,d){\nreturn (((n % d) + d) % d);\n});\n/**\n * quot[ient] of dividing numerator by denominator.\n */\ncljs.core.quot = (function cljs$core$quot(n,d){\nvar rem = (n % d);\nreturn cljs.core.fix(((n - rem) / d));\n});\n/**\n * remainder of dividing numerator by denominator.\n */\ncljs.core.rem = (function cljs$core$rem(n,d){\nvar q = cljs.core.quot(n,d);\nreturn (n - (d * q));\n});\n/**\n * Bitwise exclusive or\n */\ncljs.core.bit_xor = (function cljs$core$bit_xor(var_args){\nvar G__1165 = arguments.length;\nswitch (G__1165) {\ncase 2:\nreturn cljs.core.bit_xor.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1167 = arguments.length;\nvar i__4731__auto___1168 = (0);\nwhile(true){\nif((i__4731__auto___1168 < len__4730__auto___1167)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1168]));\n\nvar G__1169 = (i__4731__auto___1168 + (1));\ni__4731__auto___1168 = G__1169;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_xor.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_xor.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x ^ y);\n});\n\ncljs.core.bit_xor.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_xor,(x ^ y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_xor.cljs$lang$applyTo = (function (seq1162){\nvar G__1163 = cljs.core.first(seq1162);\nvar seq1162__$1 = cljs.core.next(seq1162);\nvar G__1164 = cljs.core.first(seq1162__$1);\nvar seq1162__$2 = cljs.core.next(seq1162__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1163,G__1164,seq1162__$2);\n});\n\ncljs.core.bit_xor.cljs$lang$maxFixedArity = (2);\n\n/**\n * Bitwise and\n */\ncljs.core.bit_and = (function cljs$core$bit_and(var_args){\nvar G__1174 = arguments.length;\nswitch (G__1174) {\ncase 2:\nreturn cljs.core.bit_and.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1176 = arguments.length;\nvar i__4731__auto___1177 = (0);\nwhile(true){\nif((i__4731__auto___1177 < len__4730__auto___1176)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1177]));\n\nvar G__1178 = (i__4731__auto___1177 + (1));\ni__4731__auto___1177 = G__1178;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_and.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_and.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x & y);\n});\n\ncljs.core.bit_and.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_and,(x & y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_and.cljs$lang$applyTo = (function (seq1171){\nvar G__1172 = cljs.core.first(seq1171);\nvar seq1171__$1 = cljs.core.next(seq1171);\nvar G__1173 = cljs.core.first(seq1171__$1);\nvar seq1171__$2 = cljs.core.next(seq1171__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1172,G__1173,seq1171__$2);\n});\n\ncljs.core.bit_and.cljs$lang$maxFixedArity = (2);\n\n/**\n * Bitwise or\n */\ncljs.core.bit_or = (function cljs$core$bit_or(var_args){\nvar G__1183 = arguments.length;\nswitch (G__1183) {\ncase 2:\nreturn cljs.core.bit_or.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1185 = arguments.length;\nvar i__4731__auto___1186 = (0);\nwhile(true){\nif((i__4731__auto___1186 < len__4730__auto___1185)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1186]));\n\nvar G__1187 = (i__4731__auto___1186 + (1));\ni__4731__auto___1186 = G__1187;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_or.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_or.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x | y);\n});\n\ncljs.core.bit_or.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_or,(x | y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_or.cljs$lang$applyTo = (function (seq1180){\nvar G__1181 = cljs.core.first(seq1180);\nvar seq1180__$1 = cljs.core.next(seq1180);\nvar G__1182 = cljs.core.first(seq1180__$1);\nvar seq1180__$2 = cljs.core.next(seq1180__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1181,G__1182,seq1180__$2);\n});\n\ncljs.core.bit_or.cljs$lang$maxFixedArity = (2);\n\n/**\n * Bitwise and with complement\n */\ncljs.core.bit_and_not = (function cljs$core$bit_and_not(var_args){\nvar G__1192 = arguments.length;\nswitch (G__1192) {\ncase 2:\nreturn cljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1194 = arguments.length;\nvar i__4731__auto___1195 = (0);\nwhile(true){\nif((i__4731__auto___1195 < len__4730__auto___1194)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1195]));\n\nvar G__1196 = (i__4731__auto___1195 + (1));\ni__4731__auto___1195 = G__1196;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (x & ~y);\n});\n\ncljs.core.bit_and_not.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.bit_and_not,(x & ~y),more);\n});\n\n/** @this {Function} */\ncljs.core.bit_and_not.cljs$lang$applyTo = (function (seq1189){\nvar G__1190 = cljs.core.first(seq1189);\nvar seq1189__$1 = cljs.core.next(seq1189);\nvar G__1191 = cljs.core.first(seq1189__$1);\nvar seq1189__$2 = cljs.core.next(seq1189__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1190,G__1191,seq1189__$2);\n});\n\ncljs.core.bit_and_not.cljs$lang$maxFixedArity = (2);\n\n/**\n * Clear bit at index n\n */\ncljs.core.bit_clear = (function cljs$core$bit_clear(x,n){\nreturn (x & ~(1 << n));\n});\n/**\n * Flip bit at index n\n */\ncljs.core.bit_flip = (function cljs$core$bit_flip(x,n){\nreturn (x ^ (1 << n));\n});\n/**\n * Bitwise complement\n */\ncljs.core.bit_not = (function cljs$core$bit_not(x){\nreturn (~ x);\n});\n/**\n * Set bit at index n\n */\ncljs.core.bit_set = (function cljs$core$bit_set(x,n){\nreturn (x | (1 << n));\n});\n/**\n * Test bit at index n\n */\ncljs.core.bit_test = (function cljs$core$bit_test(x,n){\nreturn ((x & (1 << n)) != 0);\n});\n/**\n * Bitwise shift left\n */\ncljs.core.bit_shift_left = (function cljs$core$bit_shift_left(x,n){\nreturn (x << n);\n});\n/**\n * Bitwise shift right\n */\ncljs.core.bit_shift_right = (function cljs$core$bit_shift_right(x,n){\nreturn (x >> n);\n});\n/**\n * DEPRECATED: Bitwise shift right with zero fill\n */\ncljs.core.bit_shift_right_zero_fill = (function cljs$core$bit_shift_right_zero_fill(x,n){\nreturn (x >>> n);\n});\n/**\n * Bitwise shift right with zero fill\n */\ncljs.core.unsigned_bit_shift_right = (function cljs$core$unsigned_bit_shift_right(x,n){\nreturn (x >>> n);\n});\n/**\n * Counts the number of bits set in n\n */\ncljs.core.bit_count = (function cljs$core$bit_count(v){\nvar v__$1 = (v - ((v >> (1)) & (1431655765)));\nvar v__$2 = ((v__$1 & (858993459)) + ((v__$1 >> (2)) & (858993459)));\nreturn ((((v__$2 + (v__$2 >> (4))) & (252645135)) * (16843009)) >> (24));\n});\n/**\n * Returns non-nil if nums all have the equivalent\n *   value, otherwise false. Behavior on non nums is\n *   undefined.\n */\ncljs.core._EQ__EQ_ = (function cljs$core$_EQ__EQ_(var_args){\nvar G__1201 = arguments.length;\nswitch (G__1201) {\ncase 1:\nreturn cljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1203 = arguments.length;\nvar i__4731__auto___1204 = (0);\nwhile(true){\nif((i__4731__auto___1204 < len__4730__auto___1203)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1204]));\n\nvar G__1205 = (i__4731__auto___1204 + (1));\ni__4731__auto___1204 = G__1205;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn true;\n});\n\ncljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn cljs.core._equiv(x,y);\n});\n\ncljs.core._EQ__EQ_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nwhile(true){\nif((x === y)){\nif(cljs.core.next(more)){\nvar G__1206 = y;\nvar G__1207 = cljs.core.first(more);\nvar G__1208 = cljs.core.next(more);\nx = G__1206;\ny = G__1207;\nmore = G__1208;\ncontinue;\n} else {\nreturn (y === cljs.core.first(more));\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core._EQ__EQ_.cljs$lang$applyTo = (function (seq1198){\nvar G__1199 = cljs.core.first(seq1198);\nvar seq1198__$1 = cljs.core.next(seq1198);\nvar G__1200 = cljs.core.first(seq1198__$1);\nvar seq1198__$2 = cljs.core.next(seq1198__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1199,G__1200,seq1198__$2);\n});\n\ncljs.core._EQ__EQ_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns true if num is greater than zero, else false\n */\ncljs.core.pos_QMARK_ = (function cljs$core$pos_QMARK_(x){\nreturn (x > (0));\n});\n/**\n * Returns true if num is zero, else false\n */\ncljs.core.zero_QMARK_ = (function cljs$core$zero_QMARK_(x){\nreturn (x === (0));\n});\n/**\n * Returns true if num is less than zero, else false\n */\ncljs.core.neg_QMARK_ = (function cljs$core$neg_QMARK_(x){\nreturn (x < (0));\n});\n/**\n * Returns the nth next of coll, (seq coll) when n is 0.\n */\ncljs.core.nthnext = (function cljs$core$nthnext(coll,n){\nvar n__$1 = n;\nvar xs = cljs.core.seq(coll);\nwhile(true){\nif(((xs) && ((n__$1 > (0))))){\nvar G__1209 = (n__$1 - (1));\nvar G__1210 = cljs.core.next(xs);\nn__$1 = G__1209;\nxs = G__1210;\ncontinue;\n} else {\nreturn xs;\n}\nbreak;\n}\n});\n/**\n * With no args, returns the empty string. With one arg x, returns\n *   x.toString().  (str nil) returns the empty string. With more than\n *   one arg, returns the concatenation of the str values of the args.\n */\ncljs.core.str = (function cljs$core$str(var_args){\nvar G__1214 = arguments.length;\nswitch (G__1214) {\ncase 0:\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1216 = arguments.length;\nvar i__4731__auto___1217 = (0);\nwhile(true){\nif((i__4731__auto___1217 < len__4730__auto___1216)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1217]));\n\nvar G__1218 = (i__4731__auto___1217 + (1));\ni__4731__auto___1217 = G__1218;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.str.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn \"\";\n});\n\ncljs.core.str.cljs$core$IFn$_invoke$arity$1 = (function (x){\nif((x == null)){\nreturn \"\";\n} else {\nreturn [x].join(\"\");\n}\n});\n\ncljs.core.str.cljs$core$IFn$_invoke$arity$variadic = (function (x,ys){\nvar sb = (new goog.string.StringBuffer(cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)));\nvar more = ys;\nwhile(true){\nif(cljs.core.truth_(more)){\nvar G__1219 = sb.append(cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(more)));\nvar G__1220 = cljs.core.next(more);\nsb = G__1219;\nmore = G__1220;\ncontinue;\n} else {\nreturn sb.toString();\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.str.cljs$lang$applyTo = (function (seq1212){\nvar G__1213 = cljs.core.first(seq1212);\nvar seq1212__$1 = cljs.core.next(seq1212);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1213,seq1212__$1);\n});\n\ncljs.core.str.cljs$lang$maxFixedArity = (1);\n\n/**\n * Returns the substring of s beginning at start inclusive, and ending\n *   at end (defaults to length of string), exclusive.\n */\ncljs.core.subs = (function cljs$core$subs(var_args){\nvar G__1222 = arguments.length;\nswitch (G__1222) {\ncase 2:\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.subs.cljs$core$IFn$_invoke$arity$2 = (function (s,start){\nreturn s.substring(start);\n});\n\ncljs.core.subs.cljs$core$IFn$_invoke$arity$3 = (function (s,start,end){\nreturn s.substring(start,end);\n});\n\ncljs.core.subs.cljs$lang$maxFixedArity = 3;\n\n\n/**\n * Assumes x is sequential. Returns true if x equals y, otherwise\n *   returns false.\n */\ncljs.core.equiv_sequential = (function cljs$core$equiv_sequential(x,y){\nreturn cljs.core.boolean$(((cljs.core.sequential_QMARK_(y))?((((cljs.core.counted_QMARK_(x)) && (cljs.core.counted_QMARK_(y)) && ((!((cljs.core.count(x) === cljs.core.count(y)))))))?false:(function (){var xs = cljs.core.seq(x);\nvar ys = cljs.core.seq(y);\nwhile(true){\nif((xs == null)){\nreturn (ys == null);\n} else {\nif((ys == null)){\nreturn false;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(xs),cljs.core.first(ys))){\nvar G__1224 = cljs.core.next(xs);\nvar G__1225 = cljs.core.next(ys);\nxs = G__1224;\nys = G__1225;\ncontinue;\n} else {\nreturn false;\n\n}\n}\n}\nbreak;\n}\n})()):null));\n});\ncljs.core.hash_coll = (function cljs$core$hash_coll(coll){\nif(cljs.core.seq(coll)){\nvar res = cljs.core.hash(cljs.core.first(coll));\nvar s = cljs.core.next(coll);\nwhile(true){\nif((s == null)){\nreturn res;\n} else {\nvar G__1226 = cljs.core.hash_combine(res,cljs.core.hash(cljs.core.first(s)));\nvar G__1227 = cljs.core.next(s);\nres = G__1226;\ns = G__1227;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn (0);\n}\n});\n\ncljs.core.hash_imap = (function cljs$core$hash_imap(m){\nvar h = (0);\nvar s = cljs.core.seq(m);\nwhile(true){\nif(s){\nvar e = cljs.core.first(s);\nvar G__1228 = ((h + (cljs.core.hash(cljs.core.key(e)) ^ cljs.core.hash(cljs.core.val(e)))) % (4503599627370496));\nvar G__1229 = cljs.core.next(s);\nh = G__1228;\ns = G__1229;\ncontinue;\n} else {\nreturn h;\n}\nbreak;\n}\n});\ncljs.core.hash_iset = (function cljs$core$hash_iset(s){\nvar h = (0);\nvar s__$1 = cljs.core.seq(s);\nwhile(true){\nif(s__$1){\nvar e = cljs.core.first(s__$1);\nvar G__1230 = ((h + cljs.core.hash(e)) % (4503599627370496));\nvar G__1231 = cljs.core.next(s__$1);\nh = G__1230;\ns__$1 = G__1231;\ncontinue;\n} else {\nreturn h;\n}\nbreak;\n}\n});\n\n\n/**\n * Takes a JavaScript object and a map of names to functions and\n *   attaches said functions as methods on the object.  Any references to\n *   JavaScript's implicit this (via the this-as macro) will resolve to the\n *   object that the function is attached.\n */\ncljs.core.extend_object_BANG_ = (function cljs$core$extend_object_BANG_(obj,fn_map){\nvar seq__1232_1248 = cljs.core.seq(fn_map);\nvar chunk__1233_1249 = null;\nvar count__1234_1250 = (0);\nvar i__1235_1251 = (0);\nwhile(true){\nif((i__1235_1251 < count__1234_1250)){\nvar vec__1242_1252 = chunk__1233_1249.cljs$core$IIndexed$_nth$arity$2(null,i__1235_1251);\nvar key_name_1253 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1242_1252,(0),null);\nvar f_1254 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1242_1252,(1),null);\nvar str_name_1255 = cljs.core.name(key_name_1253);\ngoog.object.set(obj,str_name_1255,f_1254);\n\n\nvar G__1256 = seq__1232_1248;\nvar G__1257 = chunk__1233_1249;\nvar G__1258 = count__1234_1250;\nvar G__1259 = (i__1235_1251 + (1));\nseq__1232_1248 = G__1256;\nchunk__1233_1249 = G__1257;\ncount__1234_1250 = G__1258;\ni__1235_1251 = G__1259;\ncontinue;\n} else {\nvar temp__5720__auto___1260 = cljs.core.seq(seq__1232_1248);\nif(temp__5720__auto___1260){\nvar seq__1232_1261__$1 = temp__5720__auto___1260;\nif(cljs.core.chunked_seq_QMARK_(seq__1232_1261__$1)){\nvar c__4550__auto___1262 = cljs.core.chunk_first(seq__1232_1261__$1);\nvar G__1263 = cljs.core.chunk_rest(seq__1232_1261__$1);\nvar G__1264 = c__4550__auto___1262;\nvar G__1265 = cljs.core.count(c__4550__auto___1262);\nvar G__1266 = (0);\nseq__1232_1248 = G__1263;\nchunk__1233_1249 = G__1264;\ncount__1234_1250 = G__1265;\ni__1235_1251 = G__1266;\ncontinue;\n} else {\nvar vec__1245_1267 = cljs.core.first(seq__1232_1261__$1);\nvar key_name_1268 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1245_1267,(0),null);\nvar f_1269 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1245_1267,(1),null);\nvar str_name_1270 = cljs.core.name(key_name_1268);\ngoog.object.set(obj,str_name_1270,f_1269);\n\n\nvar G__1271 = cljs.core.next(seq__1232_1261__$1);\nvar G__1272 = null;\nvar G__1273 = (0);\nvar G__1274 = (0);\nseq__1232_1248 = G__1271;\nchunk__1233_1249 = G__1272;\ncount__1234_1250 = G__1273;\ni__1235_1251 = G__1274;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn obj;\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IList}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.List = (function (meta,first,rest,count,__hash){\nthis.meta = meta;\nthis.first = first;\nthis.rest = rest;\nthis.count = count;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 65937646;\nthis.cljs$lang$protocol_mask$partition1$ = 8192;\n});\ncljs.core.List.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.List.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.List.prototype.indexOf = (function() {\nvar G__1275 = null;\nvar G__1275__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__1275__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1275 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1275__1.call(this,x);\ncase 2:\nreturn G__1275__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1275.cljs$core$IFn$_invoke$arity$1 = G__1275__1;\nG__1275.cljs$core$IFn$_invoke$arity$2 = G__1275__2;\nreturn G__1275;\n})()\n;\n\ncljs.core.List.prototype.lastIndexOf = (function() {\nvar G__1276 = null;\nvar G__1276__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,self__.count);\n});\nvar G__1276__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1276 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1276__1.call(this,x);\ncase 2:\nreturn G__1276__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1276.cljs$core$IFn$_invoke$arity$1 = G__1276__1;\nG__1276.cljs$core$IFn$_invoke$arity$2 = G__1276__2;\nreturn G__1276;\n})()\n;\n\ncljs.core.List.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.List.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.List(self__.meta,self__.first,self__.rest,self__.count,self__.__hash));\n});\n\ncljs.core.List.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.count === (1))){\nreturn null;\n} else {\nreturn self__.rest;\n}\n});\n\ncljs.core.List.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.count;\n});\n\ncljs.core.List.prototype.cljs$core$IStack$_peek$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.first;\n});\n\ncljs.core.List.prototype.cljs$core$IStack$_pop$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ISeq$_rest$arity$1(null);\n});\n\ncljs.core.List.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.List.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.List.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.List.EMPTY,self__.meta);\n});\n\ncljs.core.List.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.List.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.List.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.first;\n});\n\ncljs.core.List.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.count === (1))){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.rest;\n}\n});\n\ncljs.core.List.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.List.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.List(new_meta,self__.first,self__.rest,self__.count,self__.__hash));\n}\n});\n\ncljs.core.List.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.List(self__.meta,o,coll__$1,(self__.count + (1)),null));\n});\n\ncljs.core.List.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"first\",\"first\",996428481,null),new cljs.core.Symbol(null,\"rest\",\"rest\",398835108,null),new cljs.core.Symbol(null,\"count\",\"count\",-514511684,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.List.cljs$lang$type = true;\n\ncljs.core.List.cljs$lang$ctorStr = \"cljs.core/List\";\n\ncljs.core.List.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/List\");\n});\n\n/**\n * Positional factory function for cljs.core/List.\n */\ncljs.core.__GT_List = (function cljs$core$__GT_List(meta,first,rest,count,__hash){\nreturn (new cljs.core.List(meta,first,rest,count,__hash));\n});\n\n/**\n * Returns true if x implements IList\n */\ncljs.core.list_QMARK_ = (function cljs$core$list_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (33554432))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IList$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IList,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IList,x);\n}\n});\nvar G__1278_1281 = cljs.core.List.prototype;\nvar G__1279_1282 = cljs.core.ITER_SYMBOL;\nvar G__1280_1283 = ((function (G__1278_1281,G__1279_1282){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__1278_1281,G__1279_1282))\n;\ngoog.object.set(G__1278_1281,G__1279_1282,G__1280_1283);\n\n/**\n* @constructor\n * @implements {cljs.core.IList}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.EmptyList = (function (meta){\nthis.meta = meta;\nthis.cljs$lang$protocol_mask$partition0$ = 65937614;\nthis.cljs$lang$protocol_mask$partition1$ = 8192;\n});\ncljs.core.EmptyList.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.EmptyList.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.EmptyList.prototype.indexOf = (function() {\nvar G__1284 = null;\nvar G__1284__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__1284__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1284 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1284__1.call(this,x);\ncase 2:\nreturn G__1284__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1284.cljs$core$IFn$_invoke$arity$1 = G__1284__1;\nG__1284.cljs$core$IFn$_invoke$arity$2 = G__1284__2;\nreturn G__1284;\n})()\n;\n\ncljs.core.EmptyList.prototype.lastIndexOf = (function() {\nvar G__1285 = null;\nvar G__1285__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__1285__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1285 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1285__1.call(this,x);\ncase 2:\nreturn G__1285__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1285.cljs$core$IFn$_invoke$arity$1 = G__1285__1;\nG__1285.cljs$core$IFn$_invoke$arity$2 = G__1285__2;\nreturn G__1285;\n})()\n;\n\ncljs.core.EmptyList.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.EmptyList(self__.meta));\n});\n\ncljs.core.EmptyList.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (0);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IStack$_peek$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IStack$_pop$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nthrow (new Error(\"Can't pop empty list\"));\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.empty_ordered_hash;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nif(((cljs.core.list_QMARK_(other)) || (cljs.core.sequential_QMARK_(other)))){\nreturn (cljs.core.seq(other) == null);\n} else {\nreturn false;\n}\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn null;\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.EmptyList(new_meta));\n}\n});\n\ncljs.core.EmptyList.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.List(self__.meta,o,null,(1),null));\n});\n\ncljs.core.EmptyList.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null)], null);\n});\n\ncljs.core.EmptyList.cljs$lang$type = true;\n\ncljs.core.EmptyList.cljs$lang$ctorStr = \"cljs.core/EmptyList\";\n\ncljs.core.EmptyList.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/EmptyList\");\n});\n\n/**\n * Positional factory function for cljs.core/EmptyList.\n */\ncljs.core.__GT_EmptyList = (function cljs$core$__GT_EmptyList(meta){\nreturn (new cljs.core.EmptyList(meta));\n});\n\ncljs.core.List.EMPTY = (new cljs.core.EmptyList(null));\nvar G__1286_1289 = cljs.core.EmptyList.prototype;\nvar G__1287_1290 = cljs.core.ITER_SYMBOL;\nvar G__1288_1291 = ((function (G__1286_1289,G__1287_1290){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__1286_1289,G__1287_1290))\n;\ngoog.object.set(G__1286_1289,G__1287_1290,G__1288_1291);\n/**\n * Returns true if coll satisfies? IReversible.\n */\ncljs.core.reversible_QMARK_ = (function cljs$core$reversible_QMARK_(coll){\nif((!((coll == null)))){\nif((((coll.cljs$lang$protocol_mask$partition0$ & (134217728))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$IReversible$)))){\nreturn true;\n} else {\nif((!coll.cljs$lang$protocol_mask$partition0$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReversible,coll);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.core.IReversible,coll);\n}\n});\n/**\n * Returns, in constant time, a seq of the items in rev (which\n *   can be a vector or sorted-map), in reverse order. If rev is empty returns nil\n */\ncljs.core.rseq = (function cljs$core$rseq(rev){\nreturn cljs.core._rseq(rev);\n});\n/**\n * Returns a seq of the items in coll in reverse order. Not lazy.\n */\ncljs.core.reverse = (function cljs$core$reverse(coll){\nif(cljs.core.reversible_QMARK_(coll)){\nvar or__4131__auto__ = cljs.core.rseq(coll);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.List.EMPTY,coll);\n}\n});\n/**\n * Creates a new list containing the items.\n */\ncljs.core.list = (function cljs$core$list(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___1294 = arguments.length;\nvar i__4731__auto___1295 = (0);\nwhile(true){\nif((i__4731__auto___1295 < len__4730__auto___1294)){\nargs__4736__auto__.push((arguments[i__4731__auto___1295]));\n\nvar G__1296 = (i__4731__auto___1295 + (1));\ni__4731__auto___1295 = G__1296;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.list.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.list.cljs$core$IFn$_invoke$arity$variadic = (function (xs){\nvar arr = (((((xs instanceof cljs.core.IndexedSeq)) && ((xs.i === (0)))))?xs.arr:(function (){var arr = [];\nvar xs__$1 = xs;\nwhile(true){\nif((!((xs__$1 == null)))){\narr.push(cljs.core._first(xs__$1));\n\nvar G__1297 = cljs.core._next(xs__$1);\nxs__$1 = G__1297;\ncontinue;\n} else {\nreturn arr;\n}\nbreak;\n}\n})());\nvar i = arr.length;\nvar r = cljs.core.List.EMPTY;\nwhile(true){\nif((i > (0))){\nvar G__1298 = (i - (1));\nvar G__1299 = cljs.core._conj(r,(arr[(i - (1))]));\ni = G__1298;\nr = G__1299;\ncontinue;\n} else {\nreturn r;\n}\nbreak;\n}\n});\n\ncljs.core.list.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.list.cljs$lang$applyTo = (function (seq1293){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq1293));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IList}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Cons = (function (meta,first,rest,__hash){\nthis.meta = meta;\nthis.first = first;\nthis.rest = rest;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 65929452;\nthis.cljs$lang$protocol_mask$partition1$ = 8192;\n});\ncljs.core.Cons.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Cons.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Cons.prototype.indexOf = (function() {\nvar G__1300 = null;\nvar G__1300__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__1300__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1300 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1300__1.call(this,x);\ncase 2:\nreturn G__1300__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1300.cljs$core$IFn$_invoke$arity$1 = G__1300__1;\nG__1300.cljs$core$IFn$_invoke$arity$2 = G__1300__2;\nreturn G__1300;\n})()\n;\n\ncljs.core.Cons.prototype.lastIndexOf = (function() {\nvar G__1301 = null;\nvar G__1301__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__1301__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1301 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1301__1.call(this,x);\ncase 2:\nreturn G__1301__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1301.cljs$core$IFn$_invoke$arity$1 = G__1301__1;\nG__1301.cljs$core$IFn$_invoke$arity$2 = G__1301__2;\nreturn G__1301;\n})()\n;\n\ncljs.core.Cons.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Cons.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.Cons(self__.meta,self__.first,self__.rest,self__.__hash));\n});\n\ncljs.core.Cons.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.rest == null)){\nreturn null;\n} else {\nreturn cljs.core.seq(self__.rest);\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.Cons.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Cons.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.Cons.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.Cons.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.first;\n});\n\ncljs.core.Cons.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.rest == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.rest;\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.Cons.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Cons(new_meta,self__.first,self__.rest,self__.__hash));\n}\n});\n\ncljs.core.Cons.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.Cons(null,o,coll__$1,null));\n});\n\ncljs.core.Cons.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"first\",\"first\",996428481,null),new cljs.core.Symbol(null,\"rest\",\"rest\",398835108,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Cons.cljs$lang$type = true;\n\ncljs.core.Cons.cljs$lang$ctorStr = \"cljs.core/Cons\";\n\ncljs.core.Cons.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Cons\");\n});\n\n/**\n * Positional factory function for cljs.core/Cons.\n */\ncljs.core.__GT_Cons = (function cljs$core$__GT_Cons(meta,first,rest,__hash){\nreturn (new cljs.core.Cons(meta,first,rest,__hash));\n});\n\nvar G__1302_1305 = cljs.core.Cons.prototype;\nvar G__1303_1306 = cljs.core.ITER_SYMBOL;\nvar G__1304_1307 = ((function (G__1302_1305,G__1303_1306){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__1302_1305,G__1303_1306))\n;\ngoog.object.set(G__1302_1305,G__1303_1306,G__1304_1307);\n/**\n * Returns a new seq where x is the first element and coll is the rest.\n */\ncljs.core.cons = (function cljs$core$cons(x,coll){\nif((coll == null)){\nreturn (new cljs.core.List(null,x,null,(1),null));\n} else {\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$ISeq$))))?true:false):false)){\nreturn (new cljs.core.Cons(null,x,coll,null));\n} else {\nreturn (new cljs.core.Cons(null,x,cljs.core.seq(coll),null));\n\n}\n}\n});\ncljs.core.hash_keyword = (function cljs$core$hash_keyword(k){\nreturn ((cljs.core.hash_symbol(k) + (2654435769)) | (0));\n});\ncljs.core.compare_keywords = (function cljs$core$compare_keywords(a,b){\nif((a.fqn === b.fqn)){\nreturn (0);\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.not(a.ns);\nif(and__4120__auto__){\nreturn b.ns;\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (-1);\n} else {\nif(cljs.core.truth_(a.ns)){\nif(cljs.core.not(b.ns)){\nreturn (1);\n} else {\nvar nsc = (function (){var G__1309 = a.ns;\nvar G__1310 = b.ns;\nreturn goog.array.defaultCompare(G__1309,G__1310);\n})();\nif(((0) === nsc)){\nvar G__1311 = a.name;\nvar G__1312 = b.name;\nreturn goog.array.defaultCompare(G__1311,G__1312);\n} else {\nreturn nsc;\n}\n}\n} else {\nvar G__1313 = a.name;\nvar G__1314 = b.name;\nreturn goog.array.defaultCompare(G__1313,G__1314);\n\n}\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.INamed}\n * @implements {cljs.core.IPrintWithWriter}\n*/\ncljs.core.Keyword = (function (ns,name,fqn,_hash){\nthis.ns = ns;\nthis.name = name;\nthis.fqn = fqn;\nthis._hash = _hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2153775105;\nthis.cljs$lang$protocol_mask$partition1$ = 4096;\n});\ncljs.core.Keyword.prototype.toString = (function (){\nvar self__ = this;\nvar _ = this;\nreturn [\":\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.fqn)].join('');\n});\n\ncljs.core.Keyword.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Keyword.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (_,other){\nvar self__ = this;\nvar ___$1 = this;\nif((other instanceof cljs.core.Keyword)){\nreturn (self__.fqn === other.fqn);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Keyword.prototype.call = (function() {\nvar G__1316 = null;\nvar G__1316__2 = (function (self__,coll){\nvar self__ = this;\nvar self____$1 = this;\nvar kw = self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,kw);\n});\nvar G__1316__3 = (function (self__,coll,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar kw = self____$1;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,kw,not_found);\n});\nG__1316 = function(self__,coll,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__1316__2.call(this,self__,coll);\ncase 3:\nreturn G__1316__3.call(this,self__,coll,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__1316.cljs$core$IFn$_invoke$arity$2 = G__1316__2;\nG__1316.cljs$core$IFn$_invoke$arity$3 = G__1316__3;\nreturn G__1316;\n})()\n;\n\ncljs.core.Keyword.prototype.apply = (function (self__,args1315){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args1315)));\n});\n\ncljs.core.Keyword.prototype.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nvar self__ = this;\nvar kw = this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coll,kw);\n});\n\ncljs.core.Keyword.prototype.cljs$core$IFn$_invoke$arity$2 = (function (coll,not_found){\nvar self__ = this;\nvar kw = this;\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(coll,kw,not_found);\n});\n\ncljs.core.Keyword.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nvar h__4243__auto__ = self__._hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_keyword(this$__$1);\nself__._hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Keyword.prototype.cljs$core$INamed$_name$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.name;\n});\n\ncljs.core.Keyword.prototype.cljs$core$INamed$_namespace$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.ns;\n});\n\ncljs.core.Keyword.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (o,writer,_){\nvar self__ = this;\nvar o__$1 = this;\nreturn cljs.core._write(writer,[\":\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.fqn)].join(''));\n});\n\ncljs.core.Keyword.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"ns\",\"ns\",2082130287,null),new cljs.core.Symbol(null,\"name\",\"name\",-810760592,null),new cljs.core.Symbol(null,\"fqn\",\"fqn\",-1749334463,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"_hash\",\"_hash\",-2130838312,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Keyword.cljs$lang$type = true;\n\ncljs.core.Keyword.cljs$lang$ctorStr = \"cljs.core/Keyword\";\n\ncljs.core.Keyword.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Keyword\");\n});\n\n/**\n * Positional factory function for cljs.core/Keyword.\n */\ncljs.core.__GT_Keyword = (function cljs$core$__GT_Keyword(ns,name,fqn,_hash){\nreturn (new cljs.core.Keyword(ns,name,fqn,_hash));\n});\n\n/**\n * Return true if x is a Keyword\n */\ncljs.core.keyword_QMARK_ = (function cljs$core$keyword_QMARK_(x){\nreturn (x instanceof cljs.core.Keyword);\n});\n/**\n * Efficient test to determine that two keywords are identical.\n */\ncljs.core.keyword_identical_QMARK_ = (function cljs$core$keyword_identical_QMARK_(x,y){\nif((x === y)){\nreturn true;\n} else {\nif((((x instanceof cljs.core.Keyword)) && ((y instanceof cljs.core.Keyword)))){\nreturn (x.fqn === y.fqn);\n} else {\nreturn false;\n}\n}\n});\n/**\n * Efficient test to determine that two symbols are identical.\n */\ncljs.core.symbol_identical_QMARK_ = (function cljs$core$symbol_identical_QMARK_(x,y){\nif((x === y)){\nreturn true;\n} else {\nif((((x instanceof cljs.core.Symbol)) && ((y instanceof cljs.core.Symbol)))){\nreturn (x.str === y.str);\n} else {\nreturn false;\n}\n}\n});\n/**\n * Returns the namespace String of a symbol or keyword, or nil if not present.\n */\ncljs.core.namespace = (function cljs$core$namespace(x){\nif((((!((x == null))))?(((((x.cljs$lang$protocol_mask$partition1$ & (4096))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$INamed$))))?true:false):false)){\nreturn cljs.core._namespace(x);\n} else {\nthrow (new Error([\"Doesn't support namespace: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)].join('')));\n}\n});\n/**\n * Return true if x is a symbol or keyword\n */\ncljs.core.ident_QMARK_ = (function cljs$core$ident_QMARK_(x){\nreturn (((x instanceof cljs.core.Keyword)) || ((x instanceof cljs.core.Symbol)));\n});\n/**\n * Return true if x is a symbol or keyword without a namespace\n */\ncljs.core.simple_ident_QMARK_ = (function cljs$core$simple_ident_QMARK_(x){\nreturn ((cljs.core.ident_QMARK_(x)) && ((cljs.core.namespace(x) == null)));\n});\n/**\n * Return true if x is a symbol or keyword with a namespace\n */\ncljs.core.qualified_ident_QMARK_ = (function cljs$core$qualified_ident_QMARK_(x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = cljs.core.ident_QMARK_(x);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = cljs.core.namespace(x);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\n/**\n * Return true if x is a symbol without a namespace\n */\ncljs.core.simple_symbol_QMARK_ = (function cljs$core$simple_symbol_QMARK_(x){\nreturn (((x instanceof cljs.core.Symbol)) && ((cljs.core.namespace(x) == null)));\n});\n/**\n * Return true if x is a symbol with a namespace\n */\ncljs.core.qualified_symbol_QMARK_ = (function cljs$core$qualified_symbol_QMARK_(x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (x instanceof cljs.core.Symbol);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = cljs.core.namespace(x);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\n/**\n * Return true if x is a keyword without a namespace\n */\ncljs.core.simple_keyword_QMARK_ = (function cljs$core$simple_keyword_QMARK_(x){\nreturn (((x instanceof cljs.core.Keyword)) && ((cljs.core.namespace(x) == null)));\n});\n/**\n * Return true if x is a keyword with a namespace\n */\ncljs.core.qualified_keyword_QMARK_ = (function cljs$core$qualified_keyword_QMARK_(x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (x instanceof cljs.core.Keyword);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = cljs.core.namespace(x);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn true;\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\n/**\n * Returns a Keyword with the given namespace and name.  Do not use :\n *   in the keyword strings, it will be added automatically.\n */\ncljs.core.keyword = (function cljs$core$keyword(var_args){\nvar G__1319 = arguments.length;\nswitch (G__1319) {\ncase 1:\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.keyword.cljs$core$IFn$_invoke$arity$1 = (function (name){\nif((name instanceof cljs.core.Keyword)){\nreturn name;\n} else {\nif((name instanceof cljs.core.Symbol)){\nreturn (new cljs.core.Keyword(cljs.core.namespace(name),cljs.core.name(name),name.str,null));\n} else {\nif(typeof name === 'string'){\nvar parts = name.split(\"/\");\nif((parts.length === (2))){\nreturn (new cljs.core.Keyword((parts[(0)]),(parts[(1)]),name,null));\n} else {\nreturn (new cljs.core.Keyword(null,(parts[(0)]),name,null));\n}\n} else {\nreturn null;\n}\n}\n}\n});\n\ncljs.core.keyword.cljs$core$IFn$_invoke$arity$2 = (function (ns,name){\nvar ns__$1 = (((ns instanceof cljs.core.Keyword))?cljs.core.name(ns):(((ns instanceof cljs.core.Symbol))?cljs.core.name(ns):ns\n));\nvar name__$1 = (((name instanceof cljs.core.Keyword))?cljs.core.name(name):(((name instanceof cljs.core.Symbol))?cljs.core.name(name):name\n));\nreturn (new cljs.core.Keyword(ns__$1,name__$1,[(cljs.core.truth_(ns__$1)?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns__$1),\"/\"].join(''):null),cljs.core.str.cljs$core$IFn$_invoke$arity$1(name__$1)].join(''),null));\n});\n\ncljs.core.keyword.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.LazySeq = (function (meta,fn,s,__hash){\nthis.meta = meta;\nthis.fn = fn;\nthis.s = s;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32374988;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\ncljs.core.LazySeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.LazySeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.LazySeq.prototype.sval = (function (){\nvar self__ = this;\nvar coll = this;\nif((self__.fn == null)){\nreturn self__.s;\n} else {\nself__.s = (self__.fn.cljs$core$IFn$_invoke$arity$0 ? self__.fn.cljs$core$IFn$_invoke$arity$0() : self__.fn.call(null));\n\nself__.fn = null;\n\nreturn self__.s;\n}\n});\n\ncljs.core.LazySeq.prototype.indexOf = (function() {\nvar G__1321 = null;\nvar G__1321__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__1321__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1321 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1321__1.call(this,x);\ncase 2:\nreturn G__1321__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1321.cljs$core$IFn$_invoke$arity$1 = G__1321__1;\nG__1321.cljs$core$IFn$_invoke$arity$2 = G__1321__2;\nreturn G__1321;\n})()\n;\n\ncljs.core.LazySeq.prototype.lastIndexOf = (function() {\nvar G__1322 = null;\nvar G__1322__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__1322__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1322 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1322__1.call(this,x);\ncase 2:\nreturn G__1322__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1322.cljs$core$IFn$_invoke$arity$1 = G__1322__1;\nG__1322.cljs$core$IFn$_invoke$arity$2 = G__1322__2;\nreturn G__1322;\n})()\n;\n\ncljs.core.LazySeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.LazySeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\ncoll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n\nif((self__.s == null)){\nreturn null;\n} else {\nreturn cljs.core.next(self__.s);\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.List.EMPTY,self__.meta);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.not(self__.fn);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\ncoll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n\nif((self__.s == null)){\nreturn null;\n} else {\nreturn cljs.core.first(self__.s);\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\ncoll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n\nif((!((self__.s == null)))){\nreturn cljs.core.rest(self__.s);\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\ncoll__$1.sval();\n\nif((self__.s == null)){\nreturn null;\n} else {\nvar ls = self__.s;\nwhile(true){\nif((ls instanceof cljs.core.LazySeq)){\nvar G__1323 = ls.sval();\nls = G__1323;\ncontinue;\n} else {\nself__.s = ls;\n\nreturn cljs.core.seq(self__.s);\n}\nbreak;\n}\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.LazySeq(new_meta,((function (coll__$1){\nreturn (function (){\nreturn coll__$1.cljs$core$ISeqable$_seq$arity$1(null);\n});})(coll__$1))\n,null,self__.__hash));\n}\n});\n\ncljs.core.LazySeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.LazySeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"fn\",\"fn\",465265323,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.LazySeq.cljs$lang$type = true;\n\ncljs.core.LazySeq.cljs$lang$ctorStr = \"cljs.core/LazySeq\";\n\ncljs.core.LazySeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/LazySeq\");\n});\n\n/**\n * Positional factory function for cljs.core/LazySeq.\n */\ncljs.core.__GT_LazySeq = (function cljs$core$__GT_LazySeq(meta,fn,s,__hash){\nreturn (new cljs.core.LazySeq(meta,fn,s,__hash));\n});\n\nvar G__1324_1327 = cljs.core.LazySeq.prototype;\nvar G__1325_1328 = cljs.core.ITER_SYMBOL;\nvar G__1326_1329 = ((function (G__1324_1327,G__1325_1328){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__1324_1327,G__1325_1328))\n;\ngoog.object.set(G__1324_1327,G__1325_1328,G__1326_1329);\n\n/**\n* @constructor\n * @implements {cljs.core.ICounted}\n*/\ncljs.core.ChunkBuffer = (function (buf,end){\nthis.buf = buf;\nthis.end = end;\nthis.cljs$lang$protocol_mask$partition0$ = 2;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.ChunkBuffer.prototype.add = (function (o){\nvar self__ = this;\nvar _ = this;\n(self__.buf[self__.end] = o);\n\nreturn self__.end = (self__.end + (1));\n});\n\ncljs.core.ChunkBuffer.prototype.chunk = (function (){\nvar self__ = this;\nvar _ = this;\nvar ret = (new cljs.core.ArrayChunk(self__.buf,(0),self__.end));\nself__.buf = null;\n\nreturn ret;\n});\n\ncljs.core.ChunkBuffer.prototype.cljs$core$ICounted$_count$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.end;\n});\n\ncljs.core.ChunkBuffer.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"buf\",\"buf\",1426618187,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"end\",\"end\",1372345569,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ChunkBuffer.cljs$lang$type = true;\n\ncljs.core.ChunkBuffer.cljs$lang$ctorStr = \"cljs.core/ChunkBuffer\";\n\ncljs.core.ChunkBuffer.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ChunkBuffer\");\n});\n\n/**\n * Positional factory function for cljs.core/ChunkBuffer.\n */\ncljs.core.__GT_ChunkBuffer = (function cljs$core$__GT_ChunkBuffer(buf,end){\nreturn (new cljs.core.ChunkBuffer(buf,end));\n});\n\ncljs.core.chunk_buffer = (function cljs$core$chunk_buffer(capacity){\nreturn (new cljs.core.ChunkBuffer((new Array(capacity)),(0)));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.IChunk}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ArrayChunk = (function (arr,off,end){\nthis.arr = arr;\nthis.off = off;\nthis.end = end;\nthis.cljs$lang$protocol_mask$partition0$ = 524306;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.ArrayChunk.prototype.cljs$core$ICounted$_count$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (self__.end - self__.off);\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (coll,i){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (self__.arr[(self__.off + i)]);\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (coll,i,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif((((i >= (0))) && ((i < (self__.end - self__.off))))){\nreturn (self__.arr[(self__.off + i)]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IChunk$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ArrayChunk.prototype.cljs$core$IChunk$_drop_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.off === self__.end)){\nthrow (new Error(\"-drop-first of empty chunk\"));\n} else {\nreturn (new cljs.core.ArrayChunk(self__.arr,(self__.off + (1)),self__.end));\n}\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,(self__.arr[self__.off]),(self__.off + (1)));\n});\n\ncljs.core.ArrayChunk.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.array_reduce.cljs$core$IFn$_invoke$arity$4(self__.arr,f,start,self__.off);\n});\n\ncljs.core.ArrayChunk.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"off\",\"off\",-2047994980,null),new cljs.core.Symbol(null,\"end\",\"end\",1372345569,null)], null);\n});\n\ncljs.core.ArrayChunk.cljs$lang$type = true;\n\ncljs.core.ArrayChunk.cljs$lang$ctorStr = \"cljs.core/ArrayChunk\";\n\ncljs.core.ArrayChunk.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ArrayChunk\");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayChunk.\n */\ncljs.core.__GT_ArrayChunk = (function cljs$core$__GT_ArrayChunk(arr,off,end){\nreturn (new cljs.core.ArrayChunk(arr,off,end));\n});\n\ncljs.core.array_chunk = (function cljs$core$array_chunk(var_args){\nvar G__1331 = arguments.length;\nswitch (G__1331) {\ncase 1:\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.array_chunk.cljs$core$IFn$_invoke$arity$1 = (function (arr){\nreturn (new cljs.core.ArrayChunk(arr,(0),arr.length));\n});\n\ncljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2 = (function (arr,off){\nreturn (new cljs.core.ArrayChunk(arr,off,arr.length));\n});\n\ncljs.core.array_chunk.cljs$core$IFn$_invoke$arity$3 = (function (arr,off,end){\nreturn (new cljs.core.ArrayChunk(arr,off,end));\n});\n\ncljs.core.array_chunk.cljs$lang$maxFixedArity = 3;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.ChunkedCons = (function (chunk,more,meta,__hash){\nthis.chunk = chunk;\nthis.more = more;\nthis.meta = meta;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 31850732;\nthis.cljs$lang$protocol_mask$partition1$ = 1536;\n});\ncljs.core.ChunkedCons.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ChunkedCons.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ChunkedCons.prototype.indexOf = (function() {\nvar G__1333 = null;\nvar G__1333__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__1333__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1333 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1333__1.call(this,x);\ncase 2:\nreturn G__1333__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1333.cljs$core$IFn$_invoke$arity$1 = G__1333__1;\nG__1333.cljs$core$IFn$_invoke$arity$2 = G__1333__2;\nreturn G__1333;\n})()\n;\n\ncljs.core.ChunkedCons.prototype.lastIndexOf = (function() {\nvar G__1334 = null;\nvar G__1334__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__1334__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1334 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1334__1.call(this,x);\ncase 2:\nreturn G__1334__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1334.cljs$core$IFn$_invoke$arity$1 = G__1334__1;\nG__1334.cljs$core$IFn$_invoke$arity$2 = G__1334__2;\nreturn G__1334;\n})()\n;\n\ncljs.core.ChunkedCons.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((cljs.core._count(self__.chunk) > (1))){\nreturn (new cljs.core.ChunkedCons(cljs.core._drop_first(self__.chunk),self__.more,null,null));\n} else {\nif((self__.more == null)){\nreturn null;\n} else {\nreturn cljs.core._seq(self__.more);\n}\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.chunk,(0));\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((cljs.core._count(self__.chunk) > (1))){\nreturn (new cljs.core.ChunkedCons(cljs.core._drop_first(self__.chunk),self__.more,null,null));\n} else {\nif((self__.more == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.more;\n}\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.chunk;\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.more == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.more;\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ChunkedCons(self__.chunk,self__.more,new_meta,self__.__hash));\n}\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this$,o){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.cons(o,this$__$1);\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.more == null)){\nreturn null;\n} else {\nreturn self__.more;\n}\n});\n\ncljs.core.ChunkedCons.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"chunk\",\"chunk\",449371907,null),new cljs.core.Symbol(null,\"more\",\"more\",-418290273,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ChunkedCons.cljs$lang$type = true;\n\ncljs.core.ChunkedCons.cljs$lang$ctorStr = \"cljs.core/ChunkedCons\";\n\ncljs.core.ChunkedCons.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ChunkedCons\");\n});\n\n/**\n * Positional factory function for cljs.core/ChunkedCons.\n */\ncljs.core.__GT_ChunkedCons = (function cljs$core$__GT_ChunkedCons(chunk,more,meta,__hash){\nreturn (new cljs.core.ChunkedCons(chunk,more,meta,__hash));\n});\n\nvar G__1335_1338 = cljs.core.ChunkedCons.prototype;\nvar G__1336_1339 = cljs.core.ITER_SYMBOL;\nvar G__1337_1340 = ((function (G__1335_1338,G__1336_1339){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__1335_1338,G__1336_1339))\n;\ngoog.object.set(G__1335_1338,G__1336_1339,G__1337_1340);\ncljs.core.chunk_cons = (function cljs$core$chunk_cons(chunk,rest){\nif((cljs.core._count(chunk) === (0))){\nreturn rest;\n} else {\nreturn (new cljs.core.ChunkedCons(chunk,rest,null,null));\n}\n});\ncljs.core.chunk_append = (function cljs$core$chunk_append(b,x){\nreturn b.add(x);\n});\ncljs.core.chunk = (function cljs$core$chunk(b){\nreturn b.chunk();\n});\ncljs.core.chunk_first = (function cljs$core$chunk_first(s){\nreturn cljs.core._chunked_first(s);\n});\ncljs.core.chunk_rest = (function cljs$core$chunk_rest(s){\nreturn cljs.core._chunked_rest(s);\n});\ncljs.core.chunk_next = (function cljs$core$chunk_next(s){\nif((((!((s == null))))?(((((s.cljs$lang$protocol_mask$partition1$ & (1024))) || ((cljs.core.PROTOCOL_SENTINEL === s.cljs$core$IChunkedNext$))))?true:false):false)){\nreturn cljs.core._chunked_next(s);\n} else {\nreturn cljs.core.seq(cljs.core._chunked_rest(s));\n}\n});\n/**\n * Returns an array containing the contents of coll.\n */\ncljs.core.to_array = (function cljs$core$to_array(coll){\nvar ary = [];\nvar s = cljs.core.seq(coll);\nwhile(true){\nif((!((s == null)))){\nary.push(cljs.core.first(s));\n\nvar G__1342 = cljs.core.next(s);\ns = G__1342;\ncontinue;\n} else {\nreturn ary;\n}\nbreak;\n}\n});\n/**\n * Returns a (potentially-ragged) 2-dimensional array\n *   containing the contents of coll.\n */\ncljs.core.to_array_2d = (function cljs$core$to_array_2d(coll){\nvar ret = (new Array(cljs.core.count(coll)));\nvar i_1343 = (0);\nvar xs_1344 = cljs.core.seq(coll);\nwhile(true){\nif((xs_1344 == null)){\n} else {\n(ret[i_1343] = cljs.core.to_array(cljs.core.first(xs_1344)));\n\nvar G__1345 = (i_1343 + (1));\nvar G__1346 = cljs.core.next(xs_1344);\ni_1343 = G__1345;\nxs_1344 = G__1346;\ncontinue;\n}\nbreak;\n}\n\nreturn ret;\n});\n/**\n * Creates an array of ints. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.int_array = (function cljs$core$int_array(var_args){\nvar G__1348 = arguments.length;\nswitch (G__1348) {\ncase 1:\nreturn cljs.core.int_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.int_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.int_array.cljs$core$IFn$_invoke$arity$1 = (function (size_or_seq){\nif(typeof size_or_seq === 'number'){\nreturn cljs.core.int_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.int_array.cljs$core$IFn$_invoke$arity$2 = (function (size,init_val_or_seq){\nvar a = (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s = cljs.core.seq(init_val_or_seq);\nvar i = (0);\nvar s__$1 = s;\nwhile(true){\nif(((s__$1) && ((i < size)))){\n(a[i] = cljs.core.first(s__$1));\n\nvar G__1350 = (i + (1));\nvar G__1351 = cljs.core.next(s__$1);\ni = G__1350;\ns__$1 = G__1351;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___1352 = size;\nvar i_1353 = (0);\nwhile(true){\nif((i_1353 < n__4607__auto___1352)){\n(a[i_1353] = init_val_or_seq);\n\nvar G__1354 = (i_1353 + (1));\ni_1353 = G__1354;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.int_array.cljs$lang$maxFixedArity = 2;\n\n/**\n * Creates an array of longs. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.long_array = (function cljs$core$long_array(var_args){\nvar G__1356 = arguments.length;\nswitch (G__1356) {\ncase 1:\nreturn cljs.core.long_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.long_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.long_array.cljs$core$IFn$_invoke$arity$1 = (function (size_or_seq){\nif(typeof size_or_seq === 'number'){\nreturn cljs.core.long_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.long_array.cljs$core$IFn$_invoke$arity$2 = (function (size,init_val_or_seq){\nvar a = (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s = cljs.core.seq(init_val_or_seq);\nvar i = (0);\nvar s__$1 = s;\nwhile(true){\nif(((s__$1) && ((i < size)))){\n(a[i] = cljs.core.first(s__$1));\n\nvar G__1358 = (i + (1));\nvar G__1359 = cljs.core.next(s__$1);\ni = G__1358;\ns__$1 = G__1359;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___1360 = size;\nvar i_1361 = (0);\nwhile(true){\nif((i_1361 < n__4607__auto___1360)){\n(a[i_1361] = init_val_or_seq);\n\nvar G__1362 = (i_1361 + (1));\ni_1361 = G__1362;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.long_array.cljs$lang$maxFixedArity = 2;\n\n/**\n * Creates an array of doubles. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.double_array = (function cljs$core$double_array(var_args){\nvar G__1364 = arguments.length;\nswitch (G__1364) {\ncase 1:\nreturn cljs.core.double_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.double_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.double_array.cljs$core$IFn$_invoke$arity$1 = (function (size_or_seq){\nif(typeof size_or_seq === 'number'){\nreturn cljs.core.double_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.double_array.cljs$core$IFn$_invoke$arity$2 = (function (size,init_val_or_seq){\nvar a = (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s = cljs.core.seq(init_val_or_seq);\nvar i = (0);\nvar s__$1 = s;\nwhile(true){\nif(((s__$1) && ((i < size)))){\n(a[i] = cljs.core.first(s__$1));\n\nvar G__1366 = (i + (1));\nvar G__1367 = cljs.core.next(s__$1);\ni = G__1366;\ns__$1 = G__1367;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___1368 = size;\nvar i_1369 = (0);\nwhile(true){\nif((i_1369 < n__4607__auto___1368)){\n(a[i_1369] = init_val_or_seq);\n\nvar G__1370 = (i_1369 + (1));\ni_1369 = G__1370;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.double_array.cljs$lang$maxFixedArity = 2;\n\n/**\n * Creates an array of objects. Does not coerce array, provided for compatibility\n *   with Clojure.\n */\ncljs.core.object_array = (function cljs$core$object_array(var_args){\nvar G__1372 = arguments.length;\nswitch (G__1372) {\ncase 1:\nreturn cljs.core.object_array.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.object_array.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.object_array.cljs$core$IFn$_invoke$arity$1 = (function (size_or_seq){\nif(typeof size_or_seq === 'number'){\nreturn cljs.core.object_array.cljs$core$IFn$_invoke$arity$2(size_or_seq,null);\n} else {\nreturn cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(size_or_seq);\n}\n});\n\ncljs.core.object_array.cljs$core$IFn$_invoke$arity$2 = (function (size,init_val_or_seq){\nvar a = (new Array(size));\nif(cljs.core.seq_QMARK_(init_val_or_seq)){\nvar s = cljs.core.seq(init_val_or_seq);\nvar i = (0);\nvar s__$1 = s;\nwhile(true){\nif(((s__$1) && ((i < size)))){\n(a[i] = cljs.core.first(s__$1));\n\nvar G__1374 = (i + (1));\nvar G__1375 = cljs.core.next(s__$1);\ni = G__1374;\ns__$1 = G__1375;\ncontinue;\n} else {\nreturn a;\n}\nbreak;\n}\n} else {\nvar n__4607__auto___1376 = size;\nvar i_1377 = (0);\nwhile(true){\nif((i_1377 < n__4607__auto___1376)){\n(a[i_1377] = init_val_or_seq);\n\nvar G__1378 = (i_1377 + (1));\ni_1377 = G__1378;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn a;\n}\n});\n\ncljs.core.object_array.cljs$lang$maxFixedArity = 2;\n\n/**\n * If coll is counted? returns its count, else will count at most the first n\n * elements of coll using its seq\n */\ncljs.core.bounded_count = (function cljs$core$bounded_count(n,coll){\nif(cljs.core.counted_QMARK_(coll)){\nreturn cljs.core.count(coll);\n} else {\nvar i = (0);\nvar s = cljs.core.seq(coll);\nwhile(true){\nif((((!((s == null)))) && ((i < n)))){\nvar G__1379 = (i + (1));\nvar G__1380 = cljs.core.next(s);\ni = G__1379;\ns = G__1380;\ncontinue;\n} else {\nreturn i;\n}\nbreak;\n}\n}\n});\ncljs.core.spread = (function cljs$core$spread(arglist){\nif((arglist == null)){\nreturn null;\n} else {\nvar n = cljs.core.next(arglist);\nif((n == null)){\nreturn cljs.core.seq(cljs.core.first(arglist));\n} else {\nreturn cljs.core.cons(cljs.core.first(arglist),(cljs.core.spread.cljs$core$IFn$_invoke$arity$1 ? cljs.core.spread.cljs$core$IFn$_invoke$arity$1(n) : cljs.core.spread.call(null,n)));\n}\n}\n});\n/**\n * Returns a lazy seq representing the concatenation of the elements in the supplied colls.\n */\ncljs.core.concat = (function cljs$core$concat(var_args){\nvar G__1385 = arguments.length;\nswitch (G__1385) {\ncase 0:\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1387 = arguments.length;\nvar i__4731__auto___1388 = (0);\nwhile(true){\nif((i__4731__auto___1388 < len__4730__auto___1387)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1388]));\n\nvar G__1389 = (i__4731__auto___1388 + (1));\ni__4731__auto___1388 = G__1389;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn null;\n}),null,null));\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn x;\n}),null,null));\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s = cljs.core.seq(x);\nif(s){\nif(cljs.core.chunked_seq_QMARK_(s)){\nreturn cljs.core.chunk_cons(cljs.core.chunk_first(s),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.chunk_rest(s),y));\n} else {\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.rest(s),y));\n}\n} else {\nreturn y;\n}\n}),null,null));\n});\n\ncljs.core.concat.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,zs){\nvar cat = (function cljs$core$cat(xys,zs__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar xys__$1 = cljs.core.seq(xys);\nif(xys__$1){\nif(cljs.core.chunked_seq_QMARK_(xys__$1)){\nreturn cljs.core.chunk_cons(cljs.core.chunk_first(xys__$1),cljs$core$cat(cljs.core.chunk_rest(xys__$1),zs__$1));\n} else {\nreturn cljs.core.cons(cljs.core.first(xys__$1),cljs$core$cat(cljs.core.rest(xys__$1),zs__$1));\n}\n} else {\nif(cljs.core.truth_(zs__$1)){\nreturn cljs$core$cat(cljs.core.first(zs__$1),cljs.core.next(zs__$1));\n} else {\nreturn null;\n}\n}\n}),null,null));\n});\nreturn cat(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(x,y),zs);\n});\n\n/** @this {Function} */\ncljs.core.concat.cljs$lang$applyTo = (function (seq1382){\nvar G__1383 = cljs.core.first(seq1382);\nvar seq1382__$1 = cljs.core.next(seq1382);\nvar G__1384 = cljs.core.first(seq1382__$1);\nvar seq1382__$2 = cljs.core.next(seq1382__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1383,G__1384,seq1382__$2);\n});\n\ncljs.core.concat.cljs$lang$maxFixedArity = (2);\n\n/**\n * Creates a new list containing the items prepended to the rest, the\n *   last of which will be treated as a sequence.\n */\ncljs.core.list_STAR_ = (function cljs$core$list_STAR_(var_args){\nvar G__1396 = arguments.length;\nswitch (G__1396) {\ncase 1:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1398 = arguments.length;\nvar i__4731__auto___1399 = (0);\nwhile(true){\nif((i__4731__auto___1399 < len__4730__auto___1398)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1399]));\n\nvar G__1400 = (i__4731__auto___1399 + (1));\ni__4731__auto___1399 = G__1400;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$1 = (function (args){\nreturn cljs.core.seq(args);\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2 = (function (a,args){\nreturn cljs.core.cons(a,args);\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$3 = (function (a,b,args){\nreturn cljs.core.cons(a,cljs.core.cons(b,args));\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4 = (function (a,b,c,args){\nreturn cljs.core.cons(a,cljs.core.cons(b,cljs.core.cons(c,args)));\n});\n\ncljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$variadic = (function (a,b,c,d,more){\nreturn cljs.core.cons(a,cljs.core.cons(b,cljs.core.cons(c,cljs.core.cons(d,cljs.core.spread(more)))));\n});\n\n/** @this {Function} */\ncljs.core.list_STAR_.cljs$lang$applyTo = (function (seq1391){\nvar G__1392 = cljs.core.first(seq1391);\nvar seq1391__$1 = cljs.core.next(seq1391);\nvar G__1393 = cljs.core.first(seq1391__$1);\nvar seq1391__$2 = cljs.core.next(seq1391__$1);\nvar G__1394 = cljs.core.first(seq1391__$2);\nvar seq1391__$3 = cljs.core.next(seq1391__$2);\nvar G__1395 = cljs.core.first(seq1391__$3);\nvar seq1391__$4 = cljs.core.next(seq1391__$3);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1392,G__1393,G__1394,G__1395,seq1391__$4);\n});\n\ncljs.core.list_STAR_.cljs$lang$maxFixedArity = (4);\n\n/**\n * Returns a new, transient version of the collection, in constant time.\n */\ncljs.core.transient$ = (function cljs$core$transient(coll){\nreturn cljs.core._as_transient(coll);\n});\n/**\n * Returns a new, persistent version of the transient collection, in\n *   constant time. The transient collection cannot be used after this\n *   call, any such use will throw an exception.\n */\ncljs.core.persistent_BANG_ = (function cljs$core$persistent_BANG_(tcoll){\nreturn cljs.core._persistent_BANG_(tcoll);\n});\n/**\n * Adds val to the transient collection, and return tcoll. The 'addition'\n *   may happen at different 'places' depending on the concrete type.\n */\ncljs.core.conj_BANG_ = (function cljs$core$conj_BANG_(var_args){\nvar G__1405 = arguments.length;\nswitch (G__1405) {\ncase 0:\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1407 = arguments.length;\nvar i__4731__auto___1408 = (0);\nwhile(true){\nif((i__4731__auto___1408 < len__4730__auto___1407)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1408]));\n\nvar G__1409 = (i__4731__auto___1408 + (1));\ni__4731__auto___1408 = G__1409;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$1 = (function (tcoll){\nreturn tcoll;\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (tcoll,val){\nreturn cljs.core._conj_BANG_(tcoll,val);\n});\n\ncljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (tcoll,val,vals){\nwhile(true){\nvar ntcoll = cljs.core._conj_BANG_(tcoll,val);\nif(cljs.core.truth_(vals)){\nvar G__1410 = ntcoll;\nvar G__1411 = cljs.core.first(vals);\nvar G__1412 = cljs.core.next(vals);\ntcoll = G__1410;\nval = G__1411;\nvals = G__1412;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.conj_BANG_.cljs$lang$applyTo = (function (seq1402){\nvar G__1403 = cljs.core.first(seq1402);\nvar seq1402__$1 = cljs.core.next(seq1402);\nvar G__1404 = cljs.core.first(seq1402__$1);\nvar seq1402__$2 = cljs.core.next(seq1402__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1403,G__1404,seq1402__$2);\n});\n\ncljs.core.conj_BANG_.cljs$lang$maxFixedArity = (2);\n\n/**\n * When applied to a transient map, adds mapping of key(s) to\n *   val(s). When applied to a transient vector, sets the val at index.\n *   Note - index must be <= (count vector). Returns coll.\n */\ncljs.core.assoc_BANG_ = (function cljs$core$assoc_BANG_(var_args){\nvar G__1418 = arguments.length;\nswitch (G__1418) {\ncase 3:\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1420 = arguments.length;\nvar i__4731__auto___1421 = (0);\nwhile(true){\nif((i__4731__auto___1421 < len__4730__auto___1420)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1421]));\n\nvar G__1422 = (i__4731__auto___1421 + (1));\ni__4731__auto___1421 = G__1422;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (tcoll,key,val){\nreturn cljs.core._assoc_BANG_(tcoll,key,val);\n});\n\ncljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (tcoll,key,val,kvs){\nwhile(true){\nvar ntcoll = cljs.core._assoc_BANG_(tcoll,key,val);\nif(cljs.core.truth_(kvs)){\nvar G__1423 = ntcoll;\nvar G__1424 = cljs.core.first(kvs);\nvar G__1425 = cljs.core.second(kvs);\nvar G__1426 = cljs.core.nnext(kvs);\ntcoll = G__1423;\nkey = G__1424;\nval = G__1425;\nkvs = G__1426;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.assoc_BANG_.cljs$lang$applyTo = (function (seq1414){\nvar G__1415 = cljs.core.first(seq1414);\nvar seq1414__$1 = cljs.core.next(seq1414);\nvar G__1416 = cljs.core.first(seq1414__$1);\nvar seq1414__$2 = cljs.core.next(seq1414__$1);\nvar G__1417 = cljs.core.first(seq1414__$2);\nvar seq1414__$3 = cljs.core.next(seq1414__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1415,G__1416,G__1417,seq1414__$3);\n});\n\ncljs.core.assoc_BANG_.cljs$lang$maxFixedArity = (3);\n\n/**\n * Returns a transient map that doesn't contain a mapping for key(s).\n */\ncljs.core.dissoc_BANG_ = (function cljs$core$dissoc_BANG_(var_args){\nvar G__1431 = arguments.length;\nswitch (G__1431) {\ncase 2:\nreturn cljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1433 = arguments.length;\nvar i__4731__auto___1434 = (0);\nwhile(true){\nif((i__4731__auto___1434 < len__4730__auto___1433)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1434]));\n\nvar G__1435 = (i__4731__auto___1434 + (1));\ni__4731__auto___1434 = G__1435;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (tcoll,key){\nreturn cljs.core._dissoc_BANG_(tcoll,key);\n});\n\ncljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (tcoll,key,ks){\nwhile(true){\nvar ntcoll = cljs.core._dissoc_BANG_(tcoll,key);\nif(cljs.core.truth_(ks)){\nvar G__1436 = ntcoll;\nvar G__1437 = cljs.core.first(ks);\nvar G__1438 = cljs.core.next(ks);\ntcoll = G__1436;\nkey = G__1437;\nks = G__1438;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.dissoc_BANG_.cljs$lang$applyTo = (function (seq1428){\nvar G__1429 = cljs.core.first(seq1428);\nvar seq1428__$1 = cljs.core.next(seq1428);\nvar G__1430 = cljs.core.first(seq1428__$1);\nvar seq1428__$2 = cljs.core.next(seq1428__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1429,G__1430,seq1428__$2);\n});\n\ncljs.core.dissoc_BANG_.cljs$lang$maxFixedArity = (2);\n\n/**\n * Removes the last item from a transient vector. If\n *   the collection is empty, throws an exception. Returns tcoll\n */\ncljs.core.pop_BANG_ = (function cljs$core$pop_BANG_(tcoll){\nreturn cljs.core._pop_BANG_(tcoll);\n});\n/**\n * disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n *   does not contain key(s).\n */\ncljs.core.disj_BANG_ = (function cljs$core$disj_BANG_(var_args){\nvar G__1443 = arguments.length;\nswitch (G__1443) {\ncase 2:\nreturn cljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1445 = arguments.length;\nvar i__4731__auto___1446 = (0);\nwhile(true){\nif((i__4731__auto___1446 < len__4730__auto___1445)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1446]));\n\nvar G__1447 = (i__4731__auto___1446 + (1));\ni__4731__auto___1446 = G__1447;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (tcoll,val){\nreturn cljs.core._disjoin_BANG_(tcoll,val);\n});\n\ncljs.core.disj_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (tcoll,val,vals){\nwhile(true){\nvar ntcoll = cljs.core._disjoin_BANG_(tcoll,val);\nif(cljs.core.truth_(vals)){\nvar G__1448 = ntcoll;\nvar G__1449 = cljs.core.first(vals);\nvar G__1450 = cljs.core.next(vals);\ntcoll = G__1448;\nval = G__1449;\nvals = G__1450;\ncontinue;\n} else {\nreturn ntcoll;\n}\nbreak;\n}\n});\n\n/** @this {Function} */\ncljs.core.disj_BANG_.cljs$lang$applyTo = (function (seq1440){\nvar G__1441 = cljs.core.first(seq1440);\nvar seq1440__$1 = cljs.core.next(seq1440);\nvar G__1442 = cljs.core.first(seq1440__$1);\nvar seq1440__$2 = cljs.core.next(seq1440__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1441,G__1442,seq1440__$2);\n});\n\ncljs.core.disj_BANG_.cljs$lang$maxFixedArity = (2);\n\n\ncljs.core.apply_to = (function cljs$core$apply_to(f,argc,args){\nvar args__$1 = cljs.core.seq(args);\nif((argc === (0))){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n} else {\nvar a142 = cljs.core._first(args__$1);\nvar args__$2 = cljs.core._rest(args__$1);\nif((argc === (1))){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(a142) : f.call(null,a142));\n} else {\nvar b143 = cljs.core._first(args__$2);\nvar args__$3 = cljs.core._rest(args__$2);\nif((argc === (2))){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(a142,b143) : f.call(null,a142,b143));\n} else {\nvar c144 = cljs.core._first(args__$3);\nvar args__$4 = cljs.core._rest(args__$3);\nif((argc === (3))){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(a142,b143,c144) : f.call(null,a142,b143,c144));\n} else {\nvar d145 = cljs.core._first(args__$4);\nvar args__$5 = cljs.core._rest(args__$4);\nif((argc === (4))){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(a142,b143,c144,d145) : f.call(null,a142,b143,c144,d145));\n} else {\nvar e146 = cljs.core._first(args__$5);\nvar args__$6 = cljs.core._rest(args__$5);\nif((argc === (5))){\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(a142,b143,c144,d145,e146) : f.call(null,a142,b143,c144,d145,e146));\n} else {\nvar f147 = cljs.core._first(args__$6);\nvar args__$7 = cljs.core._rest(args__$6);\nif((argc === (6))){\nreturn (f.cljs$core$IFn$_invoke$arity$6 ? f.cljs$core$IFn$_invoke$arity$6(a142,b143,c144,d145,e146,f147) : f.call(null,a142,b143,c144,d145,e146,f147));\n} else {\nvar g148 = cljs.core._first(args__$7);\nvar args__$8 = cljs.core._rest(args__$7);\nif((argc === (7))){\nreturn (f.cljs$core$IFn$_invoke$arity$7 ? f.cljs$core$IFn$_invoke$arity$7(a142,b143,c144,d145,e146,f147,g148) : f.call(null,a142,b143,c144,d145,e146,f147,g148));\n} else {\nvar h149 = cljs.core._first(args__$8);\nvar args__$9 = cljs.core._rest(args__$8);\nif((argc === (8))){\nreturn (f.cljs$core$IFn$_invoke$arity$8 ? f.cljs$core$IFn$_invoke$arity$8(a142,b143,c144,d145,e146,f147,g148,h149) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149));\n} else {\nvar i150 = cljs.core._first(args__$9);\nvar args__$10 = cljs.core._rest(args__$9);\nif((argc === (9))){\nreturn (f.cljs$core$IFn$_invoke$arity$9 ? f.cljs$core$IFn$_invoke$arity$9(a142,b143,c144,d145,e146,f147,g148,h149,i150) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150));\n} else {\nvar j151 = cljs.core._first(args__$10);\nvar args__$11 = cljs.core._rest(args__$10);\nif((argc === (10))){\nreturn (f.cljs$core$IFn$_invoke$arity$10 ? f.cljs$core$IFn$_invoke$arity$10(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151));\n} else {\nvar k152 = cljs.core._first(args__$11);\nvar args__$12 = cljs.core._rest(args__$11);\nif((argc === (11))){\nreturn (f.cljs$core$IFn$_invoke$arity$11 ? f.cljs$core$IFn$_invoke$arity$11(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152));\n} else {\nvar l153 = cljs.core._first(args__$12);\nvar args__$13 = cljs.core._rest(args__$12);\nif((argc === (12))){\nreturn (f.cljs$core$IFn$_invoke$arity$12 ? f.cljs$core$IFn$_invoke$arity$12(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153));\n} else {\nvar m154 = cljs.core._first(args__$13);\nvar args__$14 = cljs.core._rest(args__$13);\nif((argc === (13))){\nreturn (f.cljs$core$IFn$_invoke$arity$13 ? f.cljs$core$IFn$_invoke$arity$13(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154));\n} else {\nvar n155 = cljs.core._first(args__$14);\nvar args__$15 = cljs.core._rest(args__$14);\nif((argc === (14))){\nreturn (f.cljs$core$IFn$_invoke$arity$14 ? f.cljs$core$IFn$_invoke$arity$14(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155));\n} else {\nvar o156 = cljs.core._first(args__$15);\nvar args__$16 = cljs.core._rest(args__$15);\nif((argc === (15))){\nreturn (f.cljs$core$IFn$_invoke$arity$15 ? f.cljs$core$IFn$_invoke$arity$15(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156));\n} else {\nvar p157 = cljs.core._first(args__$16);\nvar args__$17 = cljs.core._rest(args__$16);\nif((argc === (16))){\nreturn (f.cljs$core$IFn$_invoke$arity$16 ? f.cljs$core$IFn$_invoke$arity$16(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157));\n} else {\nvar q158 = cljs.core._first(args__$17);\nvar args__$18 = cljs.core._rest(args__$17);\nif((argc === (17))){\nreturn (f.cljs$core$IFn$_invoke$arity$17 ? f.cljs$core$IFn$_invoke$arity$17(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158));\n} else {\nvar r159 = cljs.core._first(args__$18);\nvar args__$19 = cljs.core._rest(args__$18);\nif((argc === (18))){\nreturn (f.cljs$core$IFn$_invoke$arity$18 ? f.cljs$core$IFn$_invoke$arity$18(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159));\n} else {\nvar s160 = cljs.core._first(args__$19);\nvar args__$20 = cljs.core._rest(args__$19);\nif((argc === (19))){\nreturn (f.cljs$core$IFn$_invoke$arity$19 ? f.cljs$core$IFn$_invoke$arity$19(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160));\n} else {\nvar t161 = cljs.core._first(args__$20);\nvar args__$21 = cljs.core._rest(args__$20);\nif((argc === (20))){\nreturn (f.cljs$core$IFn$_invoke$arity$20 ? f.cljs$core$IFn$_invoke$arity$20(a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160,t161) : f.call(null,a142,b143,c144,d145,e146,f147,g148,h149,i150,j151,k152,l153,m154,n155,o156,p157,q158,r159,s160,t161));\n} else {\nthrow (new Error(\"Only up to 20 arguments supported on functions\"));\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n\n/**\n * Internal. DO NOT USE! Next without the nil? check.\n */\ncljs.core.next_STAR_ = (function cljs$core$next_STAR_(coll){\nif((((!((coll == null))))?(((((coll.cljs$lang$protocol_mask$partition0$ & (128))) || ((cljs.core.PROTOCOL_SENTINEL === coll.cljs$core$INext$))))?true:false):false)){\nreturn coll.cljs$core$INext$_next$arity$1(null);\n} else {\nreturn cljs.core.seq(cljs.core.rest(coll));\n}\n});\n/**\n * Internal. DO NOT USE!\n *   Assumes args was already called with seq beforehand!\n */\ncljs.core.apply_to_simple = (function cljs$core$apply_to_simple(var_args){\nvar G__1453 = arguments.length;\nswitch (G__1453) {\ncase 2:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2 = (function (f,args){\nif((args == null)){\nif(f.cljs$core$IFn$_invoke$arity$0){\nreturn f.cljs$core$IFn$_invoke$arity$0();\n} else {\nreturn f.call(f);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3(f,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3 = (function (f,a0,args){\nif((args == null)){\nif(f.cljs$core$IFn$_invoke$arity$1){\nreturn f.cljs$core$IFn$_invoke$arity$1(a0);\n} else {\nreturn f.call(f,a0);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4(f,a0,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4 = (function (f,a0,a1,args){\nif((args == null)){\nif(f.cljs$core$IFn$_invoke$arity$2){\nreturn f.cljs$core$IFn$_invoke$arity$2(a0,a1);\n} else {\nreturn f.call(f,a0,a1);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5(f,a0,a1,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5 = (function (f,a0,a1,a2,args){\nif((args == null)){\nif(f.cljs$core$IFn$_invoke$arity$3){\nreturn f.cljs$core$IFn$_invoke$arity$3(a0,a1,a2);\n} else {\nreturn f.call(f,a0,a1,a2);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6(f,a0,a1,a2,cljs.core._first(args),cljs.core.next_STAR_(args));\n}\n});\n\ncljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6 = (function (f,a0,a1,a2,a3,args){\nif((args == null)){\nif(f.cljs$core$IFn$_invoke$arity$4){\nreturn f.cljs$core$IFn$_invoke$arity$4(a0,a1,a2,a3);\n} else {\nreturn f.call(f,a0,a1,a2,a3);\n}\n} else {\nvar a4 = cljs.core._first(args);\nvar next_4 = cljs.core.next(args);\nif((next_4 == null)){\nif(f.cljs$core$IFn$_invoke$arity$5){\nreturn f.cljs$core$IFn$_invoke$arity$5(a0,a1,a2,a3,a4);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4);\n}\n} else {\nvar a5 = cljs.core._first(next_4);\nvar next_5 = cljs.core.next(next_4);\nif((next_5 == null)){\nif(f.cljs$core$IFn$_invoke$arity$6){\nreturn f.cljs$core$IFn$_invoke$arity$6(a0,a1,a2,a3,a4,a5);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5);\n}\n} else {\nvar a6 = cljs.core._first(next_5);\nvar next_6 = cljs.core.next(next_5);\nif((next_6 == null)){\nif(f.cljs$core$IFn$_invoke$arity$7){\nreturn f.cljs$core$IFn$_invoke$arity$7(a0,a1,a2,a3,a4,a5,a6);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6);\n}\n} else {\nvar a7 = cljs.core._first(next_6);\nvar next_7 = cljs.core.next(next_6);\nif((next_7 == null)){\nif(f.cljs$core$IFn$_invoke$arity$8){\nreturn f.cljs$core$IFn$_invoke$arity$8(a0,a1,a2,a3,a4,a5,a6,a7);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7);\n}\n} else {\nvar a8 = cljs.core._first(next_7);\nvar next_8 = cljs.core.next(next_7);\nif((next_8 == null)){\nif(f.cljs$core$IFn$_invoke$arity$9){\nreturn f.cljs$core$IFn$_invoke$arity$9(a0,a1,a2,a3,a4,a5,a6,a7,a8);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8);\n}\n} else {\nvar a9 = cljs.core._first(next_8);\nvar next_9 = cljs.core.next(next_8);\nif((next_9 == null)){\nif(f.cljs$core$IFn$_invoke$arity$10){\nreturn f.cljs$core$IFn$_invoke$arity$10(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9);\n}\n} else {\nvar a10 = cljs.core._first(next_9);\nvar next_10 = cljs.core.next(next_9);\nif((next_10 == null)){\nif(f.cljs$core$IFn$_invoke$arity$11){\nreturn f.cljs$core$IFn$_invoke$arity$11(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n}\n} else {\nvar a11 = cljs.core._first(next_10);\nvar next_11 = cljs.core.next(next_10);\nif((next_11 == null)){\nif(f.cljs$core$IFn$_invoke$arity$12){\nreturn f.cljs$core$IFn$_invoke$arity$12(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);\n}\n} else {\nvar a12 = cljs.core._first(next_11);\nvar next_12 = cljs.core.next(next_11);\nif((next_12 == null)){\nif(f.cljs$core$IFn$_invoke$arity$13){\nreturn f.cljs$core$IFn$_invoke$arity$13(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);\n}\n} else {\nvar a13 = cljs.core._first(next_12);\nvar next_13 = cljs.core.next(next_12);\nif((next_13 == null)){\nif(f.cljs$core$IFn$_invoke$arity$14){\nreturn f.cljs$core$IFn$_invoke$arity$14(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13);\n}\n} else {\nvar a14 = cljs.core._first(next_13);\nvar next_14 = cljs.core.next(next_13);\nif((next_14 == null)){\nif(f.cljs$core$IFn$_invoke$arity$15){\nreturn f.cljs$core$IFn$_invoke$arity$15(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14);\n}\n} else {\nvar a15 = cljs.core._first(next_14);\nvar next_15 = cljs.core.next(next_14);\nif((next_15 == null)){\nif(f.cljs$core$IFn$_invoke$arity$16){\nreturn f.cljs$core$IFn$_invoke$arity$16(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);\n}\n} else {\nvar a16 = cljs.core._first(next_15);\nvar next_16 = cljs.core.next(next_15);\nif((next_16 == null)){\nif(f.cljs$core$IFn$_invoke$arity$17){\nreturn f.cljs$core$IFn$_invoke$arity$17(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);\n}\n} else {\nvar a17 = cljs.core._first(next_16);\nvar next_17 = cljs.core.next(next_16);\nif((next_17 == null)){\nif(f.cljs$core$IFn$_invoke$arity$18){\nreturn f.cljs$core$IFn$_invoke$arity$18(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17);\n}\n} else {\nvar a18 = cljs.core._first(next_17);\nvar next_18 = cljs.core.next(next_17);\nif((next_18 == null)){\nif(f.cljs$core$IFn$_invoke$arity$19){\nreturn f.cljs$core$IFn$_invoke$arity$19(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18);\n}\n} else {\nvar a19 = cljs.core._first(next_18);\nvar next_19 = cljs.core.next(next_18);\nif((next_19 == null)){\nif(f.cljs$core$IFn$_invoke$arity$20){\nreturn f.cljs$core$IFn$_invoke$arity$20(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19);\n} else {\nreturn f.call(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19);\n}\n} else {\nvar arr__4655__auto__ = [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19];\nvar s__4656__auto___1455 = next_19;\nwhile(true){\nif(s__4656__auto___1455){\narr__4655__auto__.push(cljs.core._first(s__4656__auto___1455));\n\nvar G__1456 = cljs.core.next(s__4656__auto___1455);\ns__4656__auto___1455 = G__1456;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn f.apply(f,arr__4655__auto__);\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n});\n\ncljs.core.apply_to_simple.cljs$lang$maxFixedArity = 6;\n\n/**\n * Applies fn f to the argument list formed by prepending intervening arguments to args.\n */\ncljs.core.apply = (function cljs$core$apply(var_args){\nvar G__1464 = arguments.length;\nswitch (G__1464) {\ncase 2:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1466 = arguments.length;\nvar i__4731__auto___1467 = (0);\nwhile(true){\nif((i__4731__auto___1467 < len__4730__auto___1466)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1467]));\n\nvar G__1468 = (i__4731__auto___1467 + (1));\ni__4731__auto___1467 = G__1468;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((5)),(0),null));\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$2 = (function (f,args){\nif(f.cljs$lang$applyTo){\nvar fixed_arity = f.cljs$lang$maxFixedArity;\nvar bc = cljs.core.bounded_count((fixed_arity + (1)),args);\nif((bc <= fixed_arity)){\nreturn cljs.core.apply_to(f,bc,args);\n} else {\nreturn f.cljs$lang$applyTo(args);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$2(f,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$3 = (function (f,x,args){\nif(f.cljs$lang$applyTo){\nvar arglist = cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$2(x,args);\nvar fixed_arity = f.cljs$lang$maxFixedArity;\nvar bc = (cljs.core.bounded_count(fixed_arity,args) + (1));\nif((bc <= fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$3(f,x,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$4 = (function (f,x,y,args){\nif(f.cljs$lang$applyTo){\nvar arglist = cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$3(x,y,args);\nvar fixed_arity = f.cljs$lang$maxFixedArity;\nvar bc = ((2) + cljs.core.bounded_count((fixed_arity - (1)),args));\nif((bc <= fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$4(f,x,y,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$5 = (function (f,x,y,z,args){\nif(f.cljs$lang$applyTo){\nvar arglist = cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(x,y,z,args);\nvar fixed_arity = f.cljs$lang$maxFixedArity;\nvar bc = ((3) + cljs.core.bounded_count((fixed_arity - (2)),args));\nif((bc <= fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$5(f,x,y,z,cljs.core.seq(args));\n}\n});\n\ncljs.core.apply.cljs$core$IFn$_invoke$arity$variadic = (function (f,a,b,c,d,args){\nif(f.cljs$lang$applyTo){\nvar spread_args = cljs.core.spread(args);\nvar arglist = cljs.core.cons(a,cljs.core.cons(b,cljs.core.cons(c,cljs.core.cons(d,spread_args))));\nvar fixed_arity = f.cljs$lang$maxFixedArity;\nvar bc = ((4) + cljs.core.bounded_count((fixed_arity - (3)),spread_args));\nif((bc <= fixed_arity)){\nreturn cljs.core.apply_to(f,bc,arglist);\n} else {\nreturn f.cljs$lang$applyTo(arglist);\n}\n} else {\nreturn cljs.core.apply_to_simple.cljs$core$IFn$_invoke$arity$6(f,a,b,c,d,cljs.core.spread(args));\n}\n});\n\n/** @this {Function} */\ncljs.core.apply.cljs$lang$applyTo = (function (seq1458){\nvar G__1459 = cljs.core.first(seq1458);\nvar seq1458__$1 = cljs.core.next(seq1458);\nvar G__1460 = cljs.core.first(seq1458__$1);\nvar seq1458__$2 = cljs.core.next(seq1458__$1);\nvar G__1461 = cljs.core.first(seq1458__$2);\nvar seq1458__$3 = cljs.core.next(seq1458__$2);\nvar G__1462 = cljs.core.first(seq1458__$3);\nvar seq1458__$4 = cljs.core.next(seq1458__$3);\nvar G__1463 = cljs.core.first(seq1458__$4);\nvar seq1458__$5 = cljs.core.next(seq1458__$4);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1459,G__1460,G__1461,G__1462,G__1463,seq1458__$5);\n});\n\ncljs.core.apply.cljs$lang$maxFixedArity = (5);\n\n/**\n * Returns an object of the same type and value as obj, with\n *   (apply f (meta obj) args) as its metadata.\n */\ncljs.core.vary_meta = (function cljs$core$vary_meta(var_args){\nvar G__1477 = arguments.length;\nswitch (G__1477) {\ncase 2:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1494 = arguments.length;\nvar i__4731__auto___1495 = (0);\nwhile(true){\nif((i__4731__auto___1495 < len__4730__auto___1494)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1495]));\n\nvar G__1496 = (i__4731__auto___1495 + (1));\ni__4731__auto___1495 = G__1496;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((6)),(0),null));\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$2 = (function (obj,f){\nreturn cljs.core.with_meta(obj,(function (){var G__1478 = cljs.core.meta(obj);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1478) : f.call(null,G__1478));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$3 = (function (obj,f,a){\nreturn cljs.core.with_meta(obj,(function (){var G__1479 = cljs.core.meta(obj);\nvar G__1480 = a;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1479,G__1480) : f.call(null,G__1479,G__1480));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4 = (function (obj,f,a,b){\nreturn cljs.core.with_meta(obj,(function (){var G__1481 = cljs.core.meta(obj);\nvar G__1482 = a;\nvar G__1483 = b;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1481,G__1482,G__1483) : f.call(null,G__1481,G__1482,G__1483));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$5 = (function (obj,f,a,b,c){\nreturn cljs.core.with_meta(obj,(function (){var G__1484 = cljs.core.meta(obj);\nvar G__1485 = a;\nvar G__1486 = b;\nvar G__1487 = c;\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(G__1484,G__1485,G__1486,G__1487) : f.call(null,G__1484,G__1485,G__1486,G__1487));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$6 = (function (obj,f,a,b,c,d){\nreturn cljs.core.with_meta(obj,(function (){var G__1488 = cljs.core.meta(obj);\nvar G__1489 = a;\nvar G__1490 = b;\nvar G__1491 = c;\nvar G__1492 = d;\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(G__1488,G__1489,G__1490,G__1491,G__1492) : f.call(null,G__1488,G__1489,G__1490,G__1491,G__1492));\n})());\n});\n\ncljs.core.vary_meta.cljs$core$IFn$_invoke$arity$variadic = (function (obj,f,a,b,c,d,args){\nreturn cljs.core.with_meta(obj,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,cljs.core.meta(obj),a,b,c,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([d,args], 0)));\n});\n\n/** @this {Function} */\ncljs.core.vary_meta.cljs$lang$applyTo = (function (seq1470){\nvar G__1471 = cljs.core.first(seq1470);\nvar seq1470__$1 = cljs.core.next(seq1470);\nvar G__1472 = cljs.core.first(seq1470__$1);\nvar seq1470__$2 = cljs.core.next(seq1470__$1);\nvar G__1473 = cljs.core.first(seq1470__$2);\nvar seq1470__$3 = cljs.core.next(seq1470__$2);\nvar G__1474 = cljs.core.first(seq1470__$3);\nvar seq1470__$4 = cljs.core.next(seq1470__$3);\nvar G__1475 = cljs.core.first(seq1470__$4);\nvar seq1470__$5 = cljs.core.next(seq1470__$4);\nvar G__1476 = cljs.core.first(seq1470__$5);\nvar seq1470__$6 = cljs.core.next(seq1470__$5);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1471,G__1472,G__1473,G__1474,G__1475,G__1476,seq1470__$6);\n});\n\ncljs.core.vary_meta.cljs$lang$maxFixedArity = (6);\n\n/**\n * Same as (not (= obj1 obj2))\n */\ncljs.core.not_EQ_ = (function cljs$core$not_EQ_(var_args){\nvar G__1501 = arguments.length;\nswitch (G__1501) {\ncase 1:\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1503 = arguments.length;\nvar i__4731__auto___1504 = (0);\nwhile(true){\nif((i__4731__auto___1504 < len__4730__auto___1503)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1504]));\n\nvar G__1505 = (i__4731__auto___1504 + (1));\ni__4731__auto___1504 = G__1505;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn false;\n});\n\ncljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn (!(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)));\n});\n\ncljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$variadic = (function (x,y,more){\nreturn cljs.core.not(cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core._EQ_,x,y,more));\n});\n\n/** @this {Function} */\ncljs.core.not_EQ_.cljs$lang$applyTo = (function (seq1498){\nvar G__1499 = cljs.core.first(seq1498);\nvar seq1498__$1 = cljs.core.next(seq1498);\nvar G__1500 = cljs.core.first(seq1498__$1);\nvar seq1498__$2 = cljs.core.next(seq1498__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1499,G__1500,seq1498__$2);\n});\n\ncljs.core.not_EQ_.cljs$lang$maxFixedArity = (2);\n\n/**\n * If coll is empty, returns nil, else coll\n */\ncljs.core.not_empty = (function cljs$core$not_empty(coll){\nif(cljs.core.seq(coll)){\nreturn coll;\n} else {\nreturn null;\n}\n});\ncljs.core.nil_iter = (function cljs$core$nil_iter(){\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core.t_cljs$core1506 !== 'undefined')){\n} else {\n\n/**\n* @constructor\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.t_cljs$core1506 = (function (meta1507){\nthis.meta1507 = meta1507;\nthis.cljs$lang$protocol_mask$partition0$ = 393216;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.t_cljs$core1506.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_1508,meta1507__$1){\nvar self__ = this;\nvar _1508__$1 = this;\nreturn (new cljs.core.t_cljs$core1506(meta1507__$1));\n});\n\ncljs.core.t_cljs$core1506.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_1508){\nvar self__ = this;\nvar _1508__$1 = this;\nreturn self__.meta1507;\n});\n\ncljs.core.t_cljs$core1506.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn false;\n});\n\ncljs.core.t_cljs$core1506.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"No such element\"));\n});\n\ncljs.core.t_cljs$core1506.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.t_cljs$core1506.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta1507\",\"meta1507\",1714928407,null)], null);\n});\n\ncljs.core.t_cljs$core1506.cljs$lang$type = true;\n\ncljs.core.t_cljs$core1506.cljs$lang$ctorStr = \"cljs.core/t_cljs$core1506\";\n\ncljs.core.t_cljs$core1506.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/t_cljs$core1506\");\n});\n\n/**\n * Positional factory function for cljs.core/t_cljs$core1506.\n */\ncljs.core.__GT_t_cljs$core1506 = (function cljs$core$nil_iter_$___GT_t_cljs$core1506(meta1507){\nreturn (new cljs.core.t_cljs$core1506(meta1507));\n});\n\n}\n\nreturn (new cljs.core.t_cljs$core1506(cljs.core.PersistentArrayMap.EMPTY));\n});\n\n/**\n* @constructor\n*/\ncljs.core.StringIter = (function (s,i){\nthis.s = s;\nthis.i = i;\n});\ncljs.core.StringIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.i < self__.s.length);\n});\n\ncljs.core.StringIter.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nvar ret = self__.s.charAt(self__.i);\nself__.i = (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.StringIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.StringIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.StringIter.cljs$lang$type = true;\n\ncljs.core.StringIter.cljs$lang$ctorStr = \"cljs.core/StringIter\";\n\ncljs.core.StringIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/StringIter\");\n});\n\n/**\n * Positional factory function for cljs.core/StringIter.\n */\ncljs.core.__GT_StringIter = (function cljs$core$__GT_StringIter(s,i){\nreturn (new cljs.core.StringIter(s,i));\n});\n\ncljs.core.string_iter = (function cljs$core$string_iter(x){\nreturn (new cljs.core.StringIter(x,(0)));\n});\n\n/**\n* @constructor\n*/\ncljs.core.ArrayIter = (function (arr,i){\nthis.arr = arr;\nthis.i = i;\n});\ncljs.core.ArrayIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.i < self__.arr.length);\n});\n\ncljs.core.ArrayIter.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nvar ret = (self__.arr[self__.i]);\nself__.i = (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.ArrayIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.ArrayIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ArrayIter.cljs$lang$type = true;\n\ncljs.core.ArrayIter.cljs$lang$ctorStr = \"cljs.core/ArrayIter\";\n\ncljs.core.ArrayIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ArrayIter\");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayIter.\n */\ncljs.core.__GT_ArrayIter = (function cljs$core$__GT_ArrayIter(arr,i){\nreturn (new cljs.core.ArrayIter(arr,i));\n});\n\ncljs.core.array_iter = (function cljs$core$array_iter(x){\nreturn (new cljs.core.ArrayIter(x,(0)));\n});\ncljs.core.INIT = ({});\ncljs.core.START = ({});\n\n/**\n* @constructor\n*/\ncljs.core.SeqIter = (function (_seq,_next){\nthis._seq = _seq;\nthis._next = _next;\n});\ncljs.core.SeqIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nif((self__._seq === cljs.core.INIT)){\nself__._seq = cljs.core.START;\n\nself__._next = cljs.core.seq(self__._next);\n} else {\nif((self__._seq === self__._next)){\nself__._next = cljs.core.next(self__._seq);\n} else {\n}\n}\n\nreturn (!((self__._next == null)));\n});\n\ncljs.core.SeqIter.prototype.next = (function (){\nvar self__ = this;\nvar this$ = this;\nif((!(this$.hasNext()))){\nthrow (new Error(\"No such element\"));\n} else {\nself__._seq = self__._next;\n\nreturn cljs.core.first(self__._next);\n}\n});\n\ncljs.core.SeqIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.SeqIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"_seq\",\"_seq\",-449557847,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"_next\",\"_next\",101877036,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.SeqIter.cljs$lang$type = true;\n\ncljs.core.SeqIter.cljs$lang$ctorStr = \"cljs.core/SeqIter\";\n\ncljs.core.SeqIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/SeqIter\");\n});\n\n/**\n * Positional factory function for cljs.core/SeqIter.\n */\ncljs.core.__GT_SeqIter = (function cljs$core$__GT_SeqIter(_seq,_next){\nreturn (new cljs.core.SeqIter(_seq,_next));\n});\n\ncljs.core.seq_iter = (function cljs$core$seq_iter(coll){\nreturn (new cljs.core.SeqIter(cljs.core.INIT,coll));\n});\ncljs.core.iter = (function cljs$core$iter(coll){\nif(cljs.core.iterable_QMARK_(coll)){\nreturn cljs.core._iterator(coll);\n} else {\nif((coll == null)){\nreturn cljs.core.nil_iter();\n} else {\nif(typeof coll === 'string'){\nreturn cljs.core.string_iter(coll);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.array_iter(coll);\n} else {\nif(cljs.core.seqable_QMARK_(coll)){\nreturn cljs.core.seq_iter(coll);\n} else {\nthrow (new Error([\"Cannot create iterator from \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(coll)].join('')));\n\n}\n}\n}\n}\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.Many = (function (vals){\nthis.vals = vals;\n});\ncljs.core.Many.prototype.add = (function (o){\nvar self__ = this;\nvar this$ = this;\nself__.vals.push(o);\n\nreturn this$;\n});\n\ncljs.core.Many.prototype.remove = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn self__.vals.shift();\n});\n\ncljs.core.Many.prototype.isEmpty = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn (self__.vals.length === (0));\n});\n\ncljs.core.Many.prototype.toString = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn [\"Many: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.vals)].join('');\n});\n\ncljs.core.Many.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"vals\",\"vals\",-1886377036,null)], null);\n});\n\ncljs.core.Many.cljs$lang$type = true;\n\ncljs.core.Many.cljs$lang$ctorStr = \"cljs.core/Many\";\n\ncljs.core.Many.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Many\");\n});\n\n/**\n * Positional factory function for cljs.core/Many.\n */\ncljs.core.__GT_Many = (function cljs$core$__GT_Many(vals){\nreturn (new cljs.core.Many(vals));\n});\n\ncljs.core.NONE = ({});\n\n/**\n* @constructor\n*/\ncljs.core.Single = (function (val){\nthis.val = val;\n});\ncljs.core.Single.prototype.add = (function (o){\nvar self__ = this;\nvar this$ = this;\nif((self__.val === cljs.core.NONE)){\nself__.val = o;\n\nreturn this$;\n} else {\nreturn (new cljs.core.Many([self__.val,o]));\n}\n});\n\ncljs.core.Single.prototype.remove = (function (){\nvar self__ = this;\nvar this$ = this;\nif((self__.val === cljs.core.NONE)){\nthrow (new Error(\"Removing object from empty buffer\"));\n} else {\nvar ret = self__.val;\nself__.val = cljs.core.NONE;\n\nreturn ret;\n}\n});\n\ncljs.core.Single.prototype.isEmpty = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn (self__.val === cljs.core.NONE);\n});\n\ncljs.core.Single.prototype.toString = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn [\"Single: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.val)].join('');\n});\n\ncljs.core.Single.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Single.cljs$lang$type = true;\n\ncljs.core.Single.cljs$lang$ctorStr = \"cljs.core/Single\";\n\ncljs.core.Single.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Single\");\n});\n\n/**\n * Positional factory function for cljs.core/Single.\n */\ncljs.core.__GT_Single = (function cljs$core$__GT_Single(val){\nreturn (new cljs.core.Single(val));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.Empty = (function (){\n});\ncljs.core.Empty.prototype.add = (function (o){\nvar self__ = this;\nvar this$ = this;\nreturn (new cljs.core.Single(o));\n});\n\ncljs.core.Empty.prototype.remove = (function (){\nvar self__ = this;\nvar this$ = this;\nthrow (new Error(\"Removing object from empty buffer\"));\n});\n\ncljs.core.Empty.prototype.isEmpty = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn true;\n});\n\ncljs.core.Empty.prototype.toString = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn \"Empty\";\n});\n\ncljs.core.Empty.getBasis = (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.Empty.cljs$lang$type = true;\n\ncljs.core.Empty.cljs$lang$ctorStr = \"cljs.core/Empty\";\n\ncljs.core.Empty.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Empty\");\n});\n\n/**\n * Positional factory function for cljs.core/Empty.\n */\ncljs.core.__GT_Empty = (function cljs$core$__GT_Empty(){\nreturn (new cljs.core.Empty());\n});\n\ncljs.core.EMPTY = (new cljs.core.Empty());\n\n/**\n* @constructor\n*/\ncljs.core.MultiIterator = (function (iters){\nthis.iters = iters;\n});\ncljs.core.MultiIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nvar iters__$1 = cljs.core.seq(self__.iters);\nwhile(true){\nif((!((iters__$1 == null)))){\nvar iter = cljs.core.first(iters__$1);\nif((!(iter.hasNext()))){\nreturn false;\n} else {\nvar G__1509 = cljs.core.next(iters__$1);\niters__$1 = G__1509;\ncontinue;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n});\n\ncljs.core.MultiIterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nvar nexts = [];\nvar n__4607__auto___1510 = self__.iters.length;\nvar i_1511 = (0);\nwhile(true){\nif((i_1511 < n__4607__auto___1510)){\n(nexts[i_1511] = (self__.iters[i_1511]).next());\n\nvar G__1512 = (i_1511 + (1));\ni_1511 = G__1512;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2(nexts,(0));\n});\n\ncljs.core.MultiIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"iters\",\"iters\",719353031,null)], null);\n});\n\ncljs.core.MultiIterator.cljs$lang$type = true;\n\ncljs.core.MultiIterator.cljs$lang$ctorStr = \"cljs.core/MultiIterator\";\n\ncljs.core.MultiIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/MultiIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/MultiIterator.\n */\ncljs.core.__GT_MultiIterator = (function cljs$core$__GT_MultiIterator(iters){\nreturn (new cljs.core.MultiIterator(iters));\n});\n\ncljs.core.chunkIteratorSeq = (function cljs$core$chunkIteratorSeq(iter){\nreturn (new cljs.core.LazySeq(null,(function (){\nif(iter.hasNext()){\nvar arr = [];\nvar n = (0);\nwhile(true){\nif(cljs.core.truth_((function (){var and__4120__auto__ = iter.hasNext();\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (n < (32));\n} else {\nreturn and__4120__auto__;\n}\n})())){\n(arr[n] = iter.next());\n\nvar G__1513 = (n + (1));\nn = G__1513;\ncontinue;\n} else {\nreturn cljs.core.chunk_cons(cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$3(arr,(0),n),(cljs.core.chunkIteratorSeq.cljs$core$IFn$_invoke$arity$1 ? cljs.core.chunkIteratorSeq.cljs$core$IFn$_invoke$arity$1(iter) : cljs.core.chunkIteratorSeq.call(null,iter)));\n}\nbreak;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\n/**\n* @constructor\n*/\ncljs.core.TransformerIterator = (function (buffer,_next,completed,xf,sourceIter,multi){\nthis.buffer = buffer;\nthis._next = _next;\nthis.completed = completed;\nthis.xf = xf;\nthis.sourceIter = sourceIter;\nthis.multi = multi;\n});\ncljs.core.TransformerIterator.prototype.step = (function (){\nvar self__ = this;\nvar this$ = this;\nif((!((self__._next === cljs.core.NONE)))){\nreturn true;\n} else {\nwhile(true){\nif((self__._next === cljs.core.NONE)){\nif(self__.buffer.isEmpty()){\nif(self__.completed){\nreturn false;\n} else {\nif(self__.sourceIter.hasNext()){\nvar iter = ((self__.multi)?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(self__.xf,cljs.core.cons(null,self__.sourceIter.next())):(function (){var G__1514 = null;\nvar G__1515 = self__.sourceIter.next();\nreturn (self__.xf.cljs$core$IFn$_invoke$arity$2 ? self__.xf.cljs$core$IFn$_invoke$arity$2(G__1514,G__1515) : self__.xf.call(null,G__1514,G__1515));\n})());\nif(cljs.core.reduced_QMARK_(iter)){\n(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(null) : self__.xf.call(null,null));\n\nself__.completed = true;\n} else {\n}\n\ncontinue;\n} else {\n(self__.xf.cljs$core$IFn$_invoke$arity$1 ? self__.xf.cljs$core$IFn$_invoke$arity$1(null) : self__.xf.call(null,null));\n\nself__.completed = true;\n\ncontinue;\n}\n}\n} else {\nself__._next = self__.buffer.remove();\n\ncontinue;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n}\n});\n\ncljs.core.TransformerIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn this$.step();\n});\n\ncljs.core.TransformerIterator.prototype.next = (function (){\nvar self__ = this;\nvar this$ = this;\nif(this$.hasNext()){\nvar ret = self__._next;\nself__._next = cljs.core.NONE;\n\nreturn ret;\n} else {\nthrow (new Error(\"No such element\"));\n}\n});\n\ncljs.core.TransformerIterator.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.TransformerIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"buffer\",\"buffer\",-2037140571,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"_next\",\"_next\",101877036,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"completed\",\"completed\",1154475024,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"xf\",\"xf\",2042434515,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"sourceIter\",\"sourceIter\",1068220306,null),new cljs.core.Symbol(null,\"multi\",\"multi\",1450238522,null)], null);\n});\n\ncljs.core.TransformerIterator.cljs$lang$type = true;\n\ncljs.core.TransformerIterator.cljs$lang$ctorStr = \"cljs.core/TransformerIterator\";\n\ncljs.core.TransformerIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/TransformerIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/TransformerIterator.\n */\ncljs.core.__GT_TransformerIterator = (function cljs$core$__GT_TransformerIterator(buffer,_next,completed,xf,sourceIter,multi){\nreturn (new cljs.core.TransformerIterator(buffer,_next,completed,xf,sourceIter,multi));\n});\n\nvar G__1516_1519 = cljs.core.TransformerIterator.prototype;\nvar G__1517_1520 = cljs.core.ITER_SYMBOL;\nvar G__1518_1521 = ((function (G__1516_1519,G__1517_1520){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__1516_1519,G__1517_1520))\n;\ngoog.object.set(G__1516_1519,G__1517_1520,G__1518_1521);\ncljs.core.transformer_iterator = (function cljs$core$transformer_iterator(xform,sourceIter,multi){\nvar iterator = (new cljs.core.TransformerIterator(cljs.core.EMPTY,cljs.core.NONE,false,null,sourceIter,multi));\niterator.xf = (function (){var G__1522 = ((function (iterator){\nreturn (function() {\nvar G__1523 = null;\nvar G__1523__0 = (function (){\nreturn null;\n});\nvar G__1523__1 = (function (acc){\nreturn acc;\n});\nvar G__1523__2 = (function (acc,o){\niterator.buffer = iterator.buffer.add(o);\n\nreturn acc;\n});\nG__1523 = function(acc,o){\nswitch(arguments.length){\ncase 0:\nreturn G__1523__0.call(this);\ncase 1:\nreturn G__1523__1.call(this,acc);\ncase 2:\nreturn G__1523__2.call(this,acc,o);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1523.cljs$core$IFn$_invoke$arity$0 = G__1523__0;\nG__1523.cljs$core$IFn$_invoke$arity$1 = G__1523__1;\nG__1523.cljs$core$IFn$_invoke$arity$2 = G__1523__2;\nreturn G__1523;\n})()\n;})(iterator))\n;\nreturn (xform.cljs$core$IFn$_invoke$arity$1 ? xform.cljs$core$IFn$_invoke$arity$1(G__1522) : xform.call(null,G__1522));\n})();\n\nreturn iterator;\n});\ncljs.core.TransformerIterator.create = (function (xform,source){\nreturn cljs.core.transformer_iterator(xform,source,false);\n});\ncljs.core.TransformerIterator.createMulti = (function (xform,sources){\nreturn cljs.core.transformer_iterator(xform,(new cljs.core.MultiIterator(cljs.core.to_array(sources))),true);\n});\n/**\n * Coerces coll to a (possibly empty) sequence, if it is not already\n *   one. Will not force a lazy seq. (sequence nil) yields (), When a\n *   transducer is supplied, returns a lazy sequence of applications of\n *   the transform to the items in coll(s), i.e. to the set of first\n *   items of each coll, followed by the set of second\n *   items in each coll, until any one of the colls is exhausted.  Any\n *   remaining items in other colls are ignored. The transform should accept\n *   number-of-colls arguments\n */\ncljs.core.sequence = (function cljs$core$sequence(var_args){\nvar G__1528 = arguments.length;\nswitch (G__1528) {\ncase 1:\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1530 = arguments.length;\nvar i__4731__auto___1531 = (0);\nwhile(true){\nif((i__4731__auto___1531 < len__4730__auto___1530)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1531]));\n\nvar G__1532 = (i__4731__auto___1531 + (1));\ni__4731__auto___1531 = G__1532;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.sequence.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nif(cljs.core.seq_QMARK_(coll)){\nreturn coll;\n} else {\nvar or__4131__auto__ = cljs.core.seq(coll);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n}\n});\n\ncljs.core.sequence.cljs$core$IFn$_invoke$arity$2 = (function (xform,coll){\nvar or__4131__auto__ = cljs.core.chunkIteratorSeq(cljs.core.TransformerIterator.create(xform,cljs.core.iter(coll)));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.sequence.cljs$core$IFn$_invoke$arity$variadic = (function (xform,coll,colls){\nvar or__4131__auto__ = cljs.core.chunkIteratorSeq(cljs.core.TransformerIterator.createMulti(xform,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.iter,cljs.core.cons(coll,colls))));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\n/** @this {Function} */\ncljs.core.sequence.cljs$lang$applyTo = (function (seq1525){\nvar G__1526 = cljs.core.first(seq1525);\nvar seq1525__$1 = cljs.core.next(seq1525);\nvar G__1527 = cljs.core.first(seq1525__$1);\nvar seq1525__$2 = cljs.core.next(seq1525__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1526,G__1527,seq1525__$2);\n});\n\ncljs.core.sequence.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns true if (pred x) is logical true for every x in coll, else\n *   false.\n */\ncljs.core.every_QMARK_ = (function cljs$core$every_QMARK_(pred,coll){\nwhile(true){\nif((cljs.core.seq(coll) == null)){\nreturn true;\n} else {\nif(cljs.core.truth_((function (){var G__1533 = cljs.core.first(coll);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__1533) : pred.call(null,G__1533));\n})())){\nvar G__1534 = pred;\nvar G__1535 = cljs.core.next(coll);\npred = G__1534;\ncoll = G__1535;\ncontinue;\n} else {\nreturn false;\n\n}\n}\nbreak;\n}\n});\n/**\n * Returns false if (pred x) is logical true for every x in\n *   coll, else true.\n */\ncljs.core.not_every_QMARK_ = (function cljs$core$not_every_QMARK_(pred,coll){\nreturn (!(cljs.core.every_QMARK_(pred,coll)));\n});\n/**\n * Returns the first logical true value of (pred x) for any x in coll,\n *   else nil.  One common idiom is to use a set as pred, for example\n *   this will return :fred if :fred is in the sequence, otherwise nil:\n *   (some #{:fred} coll)\n */\ncljs.core.some = (function cljs$core$some(pred,coll){\nwhile(true){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nvar or__4131__auto__ = (function (){var G__1537 = cljs.core.first(s);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__1537) : pred.call(null,G__1537));\n})();\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar G__1538 = pred;\nvar G__1539 = cljs.core.next(s);\npred = G__1538;\ncoll = G__1539;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Returns false if (pred x) is logical true for any x in coll,\n *   else true.\n */\ncljs.core.not_any_QMARK_ = (function cljs$core$not_any_QMARK_(pred,coll){\nreturn cljs.core.not(cljs.core.some(pred,coll));\n});\n/**\n * Returns true if n is even, throws an exception if n is not an integer\n */\ncljs.core.even_QMARK_ = (function cljs$core$even_QMARK_(n){\nif(cljs.core.integer_QMARK_(n)){\nreturn ((n & (1)) === (0));\n} else {\nthrow (new Error([\"Argument must be an integer: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n)].join('')));\n}\n});\n/**\n * Returns true if n is odd, throws an exception if n is not an integer\n */\ncljs.core.odd_QMARK_ = (function cljs$core$odd_QMARK_(n){\nreturn (!(cljs.core.even_QMARK_(n)));\n});\n/**\n * Takes a fn f and returns a fn that takes the same arguments as f,\n *   has the same effects, if any, and returns the opposite truth value.\n */\ncljs.core.complement = (function cljs$core$complement(f){\nreturn (function() {\nvar G__1540 = null;\nvar G__1540__0 = (function (){\nreturn cljs.core.not((f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)));\n});\nvar G__1540__1 = (function (x){\nreturn cljs.core.not((f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x)));\n});\nvar G__1540__2 = (function (x,y){\nreturn cljs.core.not((f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y)));\n});\nvar G__1540__3 = (function() { \nvar G__1541__delegate = function (x,y,zs){\nreturn cljs.core.not(cljs.core.apply.cljs$core$IFn$_invoke$arity$4(f,x,y,zs));\n};\nvar G__1541 = function (x,y,var_args){\nvar zs = null;\nif (arguments.length > 2) {\nvar G__1542__i = 0, G__1542__a = new Array(arguments.length -  2);\nwhile (G__1542__i < G__1542__a.length) {G__1542__a[G__1542__i] = arguments[G__1542__i + 2]; ++G__1542__i;}\n  zs = new cljs.core.IndexedSeq(G__1542__a,0,null);\n} \nreturn G__1541__delegate.call(this,x,y,zs);};\nG__1541.cljs$lang$maxFixedArity = 2;\nG__1541.cljs$lang$applyTo = (function (arglist__1543){\nvar x = cljs.core.first(arglist__1543);\narglist__1543 = cljs.core.next(arglist__1543);\nvar y = cljs.core.first(arglist__1543);\nvar zs = cljs.core.rest(arglist__1543);\nreturn G__1541__delegate(x,y,zs);\n});\nG__1541.cljs$core$IFn$_invoke$arity$variadic = G__1541__delegate;\nreturn G__1541;\n})()\n;\nG__1540 = function(x,y,var_args){\nvar zs = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1540__0.call(this);\ncase 1:\nreturn G__1540__1.call(this,x);\ncase 2:\nreturn G__1540__2.call(this,x,y);\ndefault:\nvar G__1544 = null;\nif (arguments.length > 2) {\nvar G__1545__i = 0, G__1545__a = new Array(arguments.length -  2);\nwhile (G__1545__i < G__1545__a.length) {G__1545__a[G__1545__i] = arguments[G__1545__i + 2]; ++G__1545__i;}\nG__1544 = new cljs.core.IndexedSeq(G__1545__a,0,null);\n}\nreturn G__1540__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__1544);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1540.cljs$lang$maxFixedArity = 2;\nG__1540.cljs$lang$applyTo = G__1540__3.cljs$lang$applyTo;\nG__1540.cljs$core$IFn$_invoke$arity$0 = G__1540__0;\nG__1540.cljs$core$IFn$_invoke$arity$1 = G__1540__1;\nG__1540.cljs$core$IFn$_invoke$arity$2 = G__1540__2;\nG__1540.cljs$core$IFn$_invoke$arity$variadic = G__1540__3.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1540;\n})()\n});\n/**\n * Returns a function that takes any number of arguments and returns x.\n */\ncljs.core.constantly = (function cljs$core$constantly(x){\nreturn (function() { \nvar G__1546__delegate = function (args){\nreturn x;\n};\nvar G__1546 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__1547__i = 0, G__1547__a = new Array(arguments.length -  0);\nwhile (G__1547__i < G__1547__a.length) {G__1547__a[G__1547__i] = arguments[G__1547__i + 0]; ++G__1547__i;}\n  args = new cljs.core.IndexedSeq(G__1547__a,0,null);\n} \nreturn G__1546__delegate.call(this,args);};\nG__1546.cljs$lang$maxFixedArity = 0;\nG__1546.cljs$lang$applyTo = (function (arglist__1548){\nvar args = cljs.core.seq(arglist__1548);\nreturn G__1546__delegate(args);\n});\nG__1546.cljs$core$IFn$_invoke$arity$variadic = G__1546__delegate;\nreturn G__1546;\n})()\n;\n});\n/**\n * Takes a set of functions and returns a fn that is the composition\n *   of those fns.  The returned fn takes a variable number of args,\n *   applies the rightmost of fns to the args, the next\n *   fn (right-to-left) to the result, etc.\n */\ncljs.core.comp = (function cljs$core$comp(var_args){\nvar G__1554 = arguments.length;\nswitch (G__1554) {\ncase 0:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1572 = arguments.length;\nvar i__4731__auto___1573 = (0);\nwhile(true){\nif((i__4731__auto___1573 < len__4730__auto___1572)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1573]));\n\nvar G__1574 = (i__4731__auto___1573 + (1));\ni__4731__auto___1573 = G__1574;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.identity;\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn f;\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$2 = (function (f,g){\nreturn (function() {\nvar G__1575 = null;\nvar G__1575__0 = (function (){\nvar G__1555 = (g.cljs$core$IFn$_invoke$arity$0 ? g.cljs$core$IFn$_invoke$arity$0() : g.call(null));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1555) : f.call(null,G__1555));\n});\nvar G__1575__1 = (function (x){\nvar G__1556 = (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(x) : g.call(null,x));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1556) : f.call(null,G__1556));\n});\nvar G__1575__2 = (function (x,y){\nvar G__1557 = (g.cljs$core$IFn$_invoke$arity$2 ? g.cljs$core$IFn$_invoke$arity$2(x,y) : g.call(null,x,y));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1557) : f.call(null,G__1557));\n});\nvar G__1575__3 = (function (x,y,z){\nvar G__1558 = (g.cljs$core$IFn$_invoke$arity$3 ? g.cljs$core$IFn$_invoke$arity$3(x,y,z) : g.call(null,x,y,z));\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1558) : f.call(null,G__1558));\n});\nvar G__1575__4 = (function() { \nvar G__1576__delegate = function (x,y,z,args){\nvar G__1559 = cljs.core.apply.cljs$core$IFn$_invoke$arity$5(g,x,y,z,args);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1559) : f.call(null,G__1559));\n};\nvar G__1576 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1577__i = 0, G__1577__a = new Array(arguments.length -  3);\nwhile (G__1577__i < G__1577__a.length) {G__1577__a[G__1577__i] = arguments[G__1577__i + 3]; ++G__1577__i;}\n  args = new cljs.core.IndexedSeq(G__1577__a,0,null);\n} \nreturn G__1576__delegate.call(this,x,y,z,args);};\nG__1576.cljs$lang$maxFixedArity = 3;\nG__1576.cljs$lang$applyTo = (function (arglist__1578){\nvar x = cljs.core.first(arglist__1578);\narglist__1578 = cljs.core.next(arglist__1578);\nvar y = cljs.core.first(arglist__1578);\narglist__1578 = cljs.core.next(arglist__1578);\nvar z = cljs.core.first(arglist__1578);\nvar args = cljs.core.rest(arglist__1578);\nreturn G__1576__delegate(x,y,z,args);\n});\nG__1576.cljs$core$IFn$_invoke$arity$variadic = G__1576__delegate;\nreturn G__1576;\n})()\n;\nG__1575 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1575__0.call(this);\ncase 1:\nreturn G__1575__1.call(this,x);\ncase 2:\nreturn G__1575__2.call(this,x,y);\ncase 3:\nreturn G__1575__3.call(this,x,y,z);\ndefault:\nvar G__1579 = null;\nif (arguments.length > 3) {\nvar G__1580__i = 0, G__1580__a = new Array(arguments.length -  3);\nwhile (G__1580__i < G__1580__a.length) {G__1580__a[G__1580__i] = arguments[G__1580__i + 3]; ++G__1580__i;}\nG__1579 = new cljs.core.IndexedSeq(G__1580__a,0,null);\n}\nreturn G__1575__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1579);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1575.cljs$lang$maxFixedArity = 3;\nG__1575.cljs$lang$applyTo = G__1575__4.cljs$lang$applyTo;\nG__1575.cljs$core$IFn$_invoke$arity$0 = G__1575__0;\nG__1575.cljs$core$IFn$_invoke$arity$1 = G__1575__1;\nG__1575.cljs$core$IFn$_invoke$arity$2 = G__1575__2;\nG__1575.cljs$core$IFn$_invoke$arity$3 = G__1575__3;\nG__1575.cljs$core$IFn$_invoke$arity$variadic = G__1575__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1575;\n})()\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$3 = (function (f,g,h){\nreturn (function() {\nvar G__1581 = null;\nvar G__1581__0 = (function (){\nvar G__1560 = (function (){var G__1561 = (h.cljs$core$IFn$_invoke$arity$0 ? h.cljs$core$IFn$_invoke$arity$0() : h.call(null));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__1561) : g.call(null,G__1561));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1560) : f.call(null,G__1560));\n});\nvar G__1581__1 = (function (x){\nvar G__1562 = (function (){var G__1563 = (h.cljs$core$IFn$_invoke$arity$1 ? h.cljs$core$IFn$_invoke$arity$1(x) : h.call(null,x));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__1563) : g.call(null,G__1563));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1562) : f.call(null,G__1562));\n});\nvar G__1581__2 = (function (x,y){\nvar G__1564 = (function (){var G__1565 = (h.cljs$core$IFn$_invoke$arity$2 ? h.cljs$core$IFn$_invoke$arity$2(x,y) : h.call(null,x,y));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__1565) : g.call(null,G__1565));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1564) : f.call(null,G__1564));\n});\nvar G__1581__3 = (function (x,y,z){\nvar G__1566 = (function (){var G__1567 = (h.cljs$core$IFn$_invoke$arity$3 ? h.cljs$core$IFn$_invoke$arity$3(x,y,z) : h.call(null,x,y,z));\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__1567) : g.call(null,G__1567));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1566) : f.call(null,G__1566));\n});\nvar G__1581__4 = (function() { \nvar G__1582__delegate = function (x,y,z,args){\nvar G__1568 = (function (){var G__1569 = cljs.core.apply.cljs$core$IFn$_invoke$arity$5(h,x,y,z,args);\nreturn (g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(G__1569) : g.call(null,G__1569));\n})();\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1568) : f.call(null,G__1568));\n};\nvar G__1582 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1583__i = 0, G__1583__a = new Array(arguments.length -  3);\nwhile (G__1583__i < G__1583__a.length) {G__1583__a[G__1583__i] = arguments[G__1583__i + 3]; ++G__1583__i;}\n  args = new cljs.core.IndexedSeq(G__1583__a,0,null);\n} \nreturn G__1582__delegate.call(this,x,y,z,args);};\nG__1582.cljs$lang$maxFixedArity = 3;\nG__1582.cljs$lang$applyTo = (function (arglist__1584){\nvar x = cljs.core.first(arglist__1584);\narglist__1584 = cljs.core.next(arglist__1584);\nvar y = cljs.core.first(arglist__1584);\narglist__1584 = cljs.core.next(arglist__1584);\nvar z = cljs.core.first(arglist__1584);\nvar args = cljs.core.rest(arglist__1584);\nreturn G__1582__delegate(x,y,z,args);\n});\nG__1582.cljs$core$IFn$_invoke$arity$variadic = G__1582__delegate;\nreturn G__1582;\n})()\n;\nG__1581 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1581__0.call(this);\ncase 1:\nreturn G__1581__1.call(this,x);\ncase 2:\nreturn G__1581__2.call(this,x,y);\ncase 3:\nreturn G__1581__3.call(this,x,y,z);\ndefault:\nvar G__1585 = null;\nif (arguments.length > 3) {\nvar G__1586__i = 0, G__1586__a = new Array(arguments.length -  3);\nwhile (G__1586__i < G__1586__a.length) {G__1586__a[G__1586__i] = arguments[G__1586__i + 3]; ++G__1586__i;}\nG__1585 = new cljs.core.IndexedSeq(G__1586__a,0,null);\n}\nreturn G__1581__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1585);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1581.cljs$lang$maxFixedArity = 3;\nG__1581.cljs$lang$applyTo = G__1581__4.cljs$lang$applyTo;\nG__1581.cljs$core$IFn$_invoke$arity$0 = G__1581__0;\nG__1581.cljs$core$IFn$_invoke$arity$1 = G__1581__1;\nG__1581.cljs$core$IFn$_invoke$arity$2 = G__1581__2;\nG__1581.cljs$core$IFn$_invoke$arity$3 = G__1581__3;\nG__1581.cljs$core$IFn$_invoke$arity$variadic = G__1581__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1581;\n})()\n});\n\ncljs.core.comp.cljs$core$IFn$_invoke$arity$variadic = (function (f1,f2,f3,fs){\nvar fs__$1 = cljs.core.reverse(cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(f1,f2,f3,fs));\nreturn ((function (fs__$1){\nreturn (function() { \nvar G__1587__delegate = function (args){\nvar ret = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.first(fs__$1),args);\nvar fs__$2 = cljs.core.next(fs__$1);\nwhile(true){\nif(fs__$2){\nvar G__1588 = (function (){var fexpr__1570 = cljs.core.first(fs__$2);\nreturn (fexpr__1570.cljs$core$IFn$_invoke$arity$1 ? fexpr__1570.cljs$core$IFn$_invoke$arity$1(ret) : fexpr__1570.call(null,ret));\n})();\nvar G__1589 = cljs.core.next(fs__$2);\nret = G__1588;\nfs__$2 = G__1589;\ncontinue;\n} else {\nreturn ret;\n}\nbreak;\n}\n};\nvar G__1587 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__1590__i = 0, G__1590__a = new Array(arguments.length -  0);\nwhile (G__1590__i < G__1590__a.length) {G__1590__a[G__1590__i] = arguments[G__1590__i + 0]; ++G__1590__i;}\n  args = new cljs.core.IndexedSeq(G__1590__a,0,null);\n} \nreturn G__1587__delegate.call(this,args);};\nG__1587.cljs$lang$maxFixedArity = 0;\nG__1587.cljs$lang$applyTo = (function (arglist__1591){\nvar args = cljs.core.seq(arglist__1591);\nreturn G__1587__delegate(args);\n});\nG__1587.cljs$core$IFn$_invoke$arity$variadic = G__1587__delegate;\nreturn G__1587;\n})()\n;\n;})(fs__$1))\n});\n\n/** @this {Function} */\ncljs.core.comp.cljs$lang$applyTo = (function (seq1550){\nvar G__1551 = cljs.core.first(seq1550);\nvar seq1550__$1 = cljs.core.next(seq1550);\nvar G__1552 = cljs.core.first(seq1550__$1);\nvar seq1550__$2 = cljs.core.next(seq1550__$1);\nvar G__1553 = cljs.core.first(seq1550__$2);\nvar seq1550__$3 = cljs.core.next(seq1550__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1551,G__1552,G__1553,seq1550__$3);\n});\n\ncljs.core.comp.cljs$lang$maxFixedArity = (3);\n\n/**\n * Takes a function f and fewer than the normal arguments to f, and\n *   returns a fn that takes a variable number of additional args. When\n *   called, the returned function calls f with args + additional args.\n */\ncljs.core.partial = (function cljs$core$partial(var_args){\nvar G__1598 = arguments.length;\nswitch (G__1598) {\ncase 1:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1600 = arguments.length;\nvar i__4731__auto___1601 = (0);\nwhile(true){\nif((i__4731__auto___1601 < len__4730__auto___1600)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1601]));\n\nvar G__1602 = (i__4731__auto___1601 + (1));\ni__4731__auto___1601 = G__1602;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.partial.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn f;\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$2 = (function (f,arg1){\nreturn (function() {\nvar G__1603 = null;\nvar G__1603__0 = (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(arg1) : f.call(null,arg1));\n});\nvar G__1603__1 = (function (x){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(arg1,x) : f.call(null,arg1,x));\n});\nvar G__1603__2 = (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(arg1,x,y) : f.call(null,arg1,x,y));\n});\nvar G__1603__3 = (function (x,y,z){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(arg1,x,y,z) : f.call(null,arg1,x,y,z));\n});\nvar G__1603__4 = (function() { \nvar G__1604__delegate = function (x,y,z,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,arg1,x,y,z,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([args], 0));\n};\nvar G__1604 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1605__i = 0, G__1605__a = new Array(arguments.length -  3);\nwhile (G__1605__i < G__1605__a.length) {G__1605__a[G__1605__i] = arguments[G__1605__i + 3]; ++G__1605__i;}\n  args = new cljs.core.IndexedSeq(G__1605__a,0,null);\n} \nreturn G__1604__delegate.call(this,x,y,z,args);};\nG__1604.cljs$lang$maxFixedArity = 3;\nG__1604.cljs$lang$applyTo = (function (arglist__1606){\nvar x = cljs.core.first(arglist__1606);\narglist__1606 = cljs.core.next(arglist__1606);\nvar y = cljs.core.first(arglist__1606);\narglist__1606 = cljs.core.next(arglist__1606);\nvar z = cljs.core.first(arglist__1606);\nvar args = cljs.core.rest(arglist__1606);\nreturn G__1604__delegate(x,y,z,args);\n});\nG__1604.cljs$core$IFn$_invoke$arity$variadic = G__1604__delegate;\nreturn G__1604;\n})()\n;\nG__1603 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1603__0.call(this);\ncase 1:\nreturn G__1603__1.call(this,x);\ncase 2:\nreturn G__1603__2.call(this,x,y);\ncase 3:\nreturn G__1603__3.call(this,x,y,z);\ndefault:\nvar G__1607 = null;\nif (arguments.length > 3) {\nvar G__1608__i = 0, G__1608__a = new Array(arguments.length -  3);\nwhile (G__1608__i < G__1608__a.length) {G__1608__a[G__1608__i] = arguments[G__1608__i + 3]; ++G__1608__i;}\nG__1607 = new cljs.core.IndexedSeq(G__1608__a,0,null);\n}\nreturn G__1603__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1607);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1603.cljs$lang$maxFixedArity = 3;\nG__1603.cljs$lang$applyTo = G__1603__4.cljs$lang$applyTo;\nG__1603.cljs$core$IFn$_invoke$arity$0 = G__1603__0;\nG__1603.cljs$core$IFn$_invoke$arity$1 = G__1603__1;\nG__1603.cljs$core$IFn$_invoke$arity$2 = G__1603__2;\nG__1603.cljs$core$IFn$_invoke$arity$3 = G__1603__3;\nG__1603.cljs$core$IFn$_invoke$arity$variadic = G__1603__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1603;\n})()\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$3 = (function (f,arg1,arg2){\nreturn (function() {\nvar G__1609 = null;\nvar G__1609__0 = (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(arg1,arg2) : f.call(null,arg1,arg2));\n});\nvar G__1609__1 = (function (x){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(arg1,arg2,x) : f.call(null,arg1,arg2,x));\n});\nvar G__1609__2 = (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(arg1,arg2,x,y) : f.call(null,arg1,arg2,x,y));\n});\nvar G__1609__3 = (function (x,y,z){\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(arg1,arg2,x,y,z) : f.call(null,arg1,arg2,x,y,z));\n});\nvar G__1609__4 = (function() { \nvar G__1610__delegate = function (x,y,z,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,arg1,arg2,x,y,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([z,args], 0));\n};\nvar G__1610 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1611__i = 0, G__1611__a = new Array(arguments.length -  3);\nwhile (G__1611__i < G__1611__a.length) {G__1611__a[G__1611__i] = arguments[G__1611__i + 3]; ++G__1611__i;}\n  args = new cljs.core.IndexedSeq(G__1611__a,0,null);\n} \nreturn G__1610__delegate.call(this,x,y,z,args);};\nG__1610.cljs$lang$maxFixedArity = 3;\nG__1610.cljs$lang$applyTo = (function (arglist__1612){\nvar x = cljs.core.first(arglist__1612);\narglist__1612 = cljs.core.next(arglist__1612);\nvar y = cljs.core.first(arglist__1612);\narglist__1612 = cljs.core.next(arglist__1612);\nvar z = cljs.core.first(arglist__1612);\nvar args = cljs.core.rest(arglist__1612);\nreturn G__1610__delegate(x,y,z,args);\n});\nG__1610.cljs$core$IFn$_invoke$arity$variadic = G__1610__delegate;\nreturn G__1610;\n})()\n;\nG__1609 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1609__0.call(this);\ncase 1:\nreturn G__1609__1.call(this,x);\ncase 2:\nreturn G__1609__2.call(this,x,y);\ncase 3:\nreturn G__1609__3.call(this,x,y,z);\ndefault:\nvar G__1613 = null;\nif (arguments.length > 3) {\nvar G__1614__i = 0, G__1614__a = new Array(arguments.length -  3);\nwhile (G__1614__i < G__1614__a.length) {G__1614__a[G__1614__i] = arguments[G__1614__i + 3]; ++G__1614__i;}\nG__1613 = new cljs.core.IndexedSeq(G__1614__a,0,null);\n}\nreturn G__1609__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1613);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1609.cljs$lang$maxFixedArity = 3;\nG__1609.cljs$lang$applyTo = G__1609__4.cljs$lang$applyTo;\nG__1609.cljs$core$IFn$_invoke$arity$0 = G__1609__0;\nG__1609.cljs$core$IFn$_invoke$arity$1 = G__1609__1;\nG__1609.cljs$core$IFn$_invoke$arity$2 = G__1609__2;\nG__1609.cljs$core$IFn$_invoke$arity$3 = G__1609__3;\nG__1609.cljs$core$IFn$_invoke$arity$variadic = G__1609__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1609;\n})()\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$4 = (function (f,arg1,arg2,arg3){\nreturn (function() {\nvar G__1615 = null;\nvar G__1615__0 = (function (){\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(arg1,arg2,arg3) : f.call(null,arg1,arg2,arg3));\n});\nvar G__1615__1 = (function (x){\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(arg1,arg2,arg3,x) : f.call(null,arg1,arg2,arg3,x));\n});\nvar G__1615__2 = (function (x,y){\nreturn (f.cljs$core$IFn$_invoke$arity$5 ? f.cljs$core$IFn$_invoke$arity$5(arg1,arg2,arg3,x,y) : f.call(null,arg1,arg2,arg3,x,y));\n});\nvar G__1615__3 = (function (x,y,z){\nreturn (f.cljs$core$IFn$_invoke$arity$6 ? f.cljs$core$IFn$_invoke$arity$6(arg1,arg2,arg3,x,y,z) : f.call(null,arg1,arg2,arg3,x,y,z));\n});\nvar G__1615__4 = (function() { \nvar G__1616__delegate = function (x,y,z,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,arg1,arg2,arg3,x,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([y,z,args], 0));\n};\nvar G__1616 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1617__i = 0, G__1617__a = new Array(arguments.length -  3);\nwhile (G__1617__i < G__1617__a.length) {G__1617__a[G__1617__i] = arguments[G__1617__i + 3]; ++G__1617__i;}\n  args = new cljs.core.IndexedSeq(G__1617__a,0,null);\n} \nreturn G__1616__delegate.call(this,x,y,z,args);};\nG__1616.cljs$lang$maxFixedArity = 3;\nG__1616.cljs$lang$applyTo = (function (arglist__1618){\nvar x = cljs.core.first(arglist__1618);\narglist__1618 = cljs.core.next(arglist__1618);\nvar y = cljs.core.first(arglist__1618);\narglist__1618 = cljs.core.next(arglist__1618);\nvar z = cljs.core.first(arglist__1618);\nvar args = cljs.core.rest(arglist__1618);\nreturn G__1616__delegate(x,y,z,args);\n});\nG__1616.cljs$core$IFn$_invoke$arity$variadic = G__1616__delegate;\nreturn G__1616;\n})()\n;\nG__1615 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1615__0.call(this);\ncase 1:\nreturn G__1615__1.call(this,x);\ncase 2:\nreturn G__1615__2.call(this,x,y);\ncase 3:\nreturn G__1615__3.call(this,x,y,z);\ndefault:\nvar G__1619 = null;\nif (arguments.length > 3) {\nvar G__1620__i = 0, G__1620__a = new Array(arguments.length -  3);\nwhile (G__1620__i < G__1620__a.length) {G__1620__a[G__1620__i] = arguments[G__1620__i + 3]; ++G__1620__i;}\nG__1619 = new cljs.core.IndexedSeq(G__1620__a,0,null);\n}\nreturn G__1615__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1619);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1615.cljs$lang$maxFixedArity = 3;\nG__1615.cljs$lang$applyTo = G__1615__4.cljs$lang$applyTo;\nG__1615.cljs$core$IFn$_invoke$arity$0 = G__1615__0;\nG__1615.cljs$core$IFn$_invoke$arity$1 = G__1615__1;\nG__1615.cljs$core$IFn$_invoke$arity$2 = G__1615__2;\nG__1615.cljs$core$IFn$_invoke$arity$3 = G__1615__3;\nG__1615.cljs$core$IFn$_invoke$arity$variadic = G__1615__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1615;\n})()\n});\n\ncljs.core.partial.cljs$core$IFn$_invoke$arity$variadic = (function (f,arg1,arg2,arg3,more){\nreturn (function() { \nvar G__1621__delegate = function (args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,arg1,arg2,arg3,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(more,args));\n};\nvar G__1621 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__1622__i = 0, G__1622__a = new Array(arguments.length -  0);\nwhile (G__1622__i < G__1622__a.length) {G__1622__a[G__1622__i] = arguments[G__1622__i + 0]; ++G__1622__i;}\n  args = new cljs.core.IndexedSeq(G__1622__a,0,null);\n} \nreturn G__1621__delegate.call(this,args);};\nG__1621.cljs$lang$maxFixedArity = 0;\nG__1621.cljs$lang$applyTo = (function (arglist__1623){\nvar args = cljs.core.seq(arglist__1623);\nreturn G__1621__delegate(args);\n});\nG__1621.cljs$core$IFn$_invoke$arity$variadic = G__1621__delegate;\nreturn G__1621;\n})()\n;\n});\n\n/** @this {Function} */\ncljs.core.partial.cljs$lang$applyTo = (function (seq1593){\nvar G__1594 = cljs.core.first(seq1593);\nvar seq1593__$1 = cljs.core.next(seq1593);\nvar G__1595 = cljs.core.first(seq1593__$1);\nvar seq1593__$2 = cljs.core.next(seq1593__$1);\nvar G__1596 = cljs.core.first(seq1593__$2);\nvar seq1593__$3 = cljs.core.next(seq1593__$2);\nvar G__1597 = cljs.core.first(seq1593__$3);\nvar seq1593__$4 = cljs.core.next(seq1593__$3);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1594,G__1595,G__1596,G__1597,seq1593__$4);\n});\n\ncljs.core.partial.cljs$lang$maxFixedArity = (4);\n\n/**\n * Takes a function f, and returns a function that calls f, replacing\n *   a nil first argument to f with the supplied value x. Higher arity\n *   versions can replace arguments in the second and third\n *   positions (y, z). Note that the function f can take any number of\n *   arguments, not just the one(s) being nil-patched.\n */\ncljs.core.fnil = (function cljs$core$fnil(var_args){\nvar G__1625 = arguments.length;\nswitch (G__1625) {\ncase 2:\nreturn cljs.core.fnil.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.fnil.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.fnil.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.fnil.cljs$core$IFn$_invoke$arity$2 = (function (f,x){\nreturn (function() {\nvar G__1643 = null;\nvar G__1643__1 = (function (a){\nvar G__1626 = (((a == null))?x:a);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1626) : f.call(null,G__1626));\n});\nvar G__1643__2 = (function (a,b){\nvar G__1627 = (((a == null))?x:a);\nvar G__1628 = b;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1627,G__1628) : f.call(null,G__1627,G__1628));\n});\nvar G__1643__3 = (function (a,b,c){\nvar G__1629 = (((a == null))?x:a);\nvar G__1630 = b;\nvar G__1631 = c;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1629,G__1630,G__1631) : f.call(null,G__1629,G__1630,G__1631));\n});\nvar G__1643__4 = (function() { \nvar G__1644__delegate = function (a,b,c,ds){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,(((a == null))?x:a),b,c,ds);\n};\nvar G__1644 = function (a,b,c,var_args){\nvar ds = null;\nif (arguments.length > 3) {\nvar G__1645__i = 0, G__1645__a = new Array(arguments.length -  3);\nwhile (G__1645__i < G__1645__a.length) {G__1645__a[G__1645__i] = arguments[G__1645__i + 3]; ++G__1645__i;}\n  ds = new cljs.core.IndexedSeq(G__1645__a,0,null);\n} \nreturn G__1644__delegate.call(this,a,b,c,ds);};\nG__1644.cljs$lang$maxFixedArity = 3;\nG__1644.cljs$lang$applyTo = (function (arglist__1646){\nvar a = cljs.core.first(arglist__1646);\narglist__1646 = cljs.core.next(arglist__1646);\nvar b = cljs.core.first(arglist__1646);\narglist__1646 = cljs.core.next(arglist__1646);\nvar c = cljs.core.first(arglist__1646);\nvar ds = cljs.core.rest(arglist__1646);\nreturn G__1644__delegate(a,b,c,ds);\n});\nG__1644.cljs$core$IFn$_invoke$arity$variadic = G__1644__delegate;\nreturn G__1644;\n})()\n;\nG__1643 = function(a,b,c,var_args){\nvar ds = var_args;\nswitch(arguments.length){\ncase 1:\nreturn G__1643__1.call(this,a);\ncase 2:\nreturn G__1643__2.call(this,a,b);\ncase 3:\nreturn G__1643__3.call(this,a,b,c);\ndefault:\nvar G__1647 = null;\nif (arguments.length > 3) {\nvar G__1648__i = 0, G__1648__a = new Array(arguments.length -  3);\nwhile (G__1648__i < G__1648__a.length) {G__1648__a[G__1648__i] = arguments[G__1648__i + 3]; ++G__1648__i;}\nG__1647 = new cljs.core.IndexedSeq(G__1648__a,0,null);\n}\nreturn G__1643__4.cljs$core$IFn$_invoke$arity$variadic(a,b,c, G__1647);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1643.cljs$lang$maxFixedArity = 3;\nG__1643.cljs$lang$applyTo = G__1643__4.cljs$lang$applyTo;\nG__1643.cljs$core$IFn$_invoke$arity$1 = G__1643__1;\nG__1643.cljs$core$IFn$_invoke$arity$2 = G__1643__2;\nG__1643.cljs$core$IFn$_invoke$arity$3 = G__1643__3;\nG__1643.cljs$core$IFn$_invoke$arity$variadic = G__1643__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1643;\n})()\n});\n\ncljs.core.fnil.cljs$core$IFn$_invoke$arity$3 = (function (f,x,y){\nreturn (function() {\nvar G__1649 = null;\nvar G__1649__2 = (function (a,b){\nvar G__1632 = (((a == null))?x:a);\nvar G__1633 = (((b == null))?y:b);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1632,G__1633) : f.call(null,G__1632,G__1633));\n});\nvar G__1649__3 = (function (a,b,c){\nvar G__1634 = (((a == null))?x:a);\nvar G__1635 = (((b == null))?y:b);\nvar G__1636 = c;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1634,G__1635,G__1636) : f.call(null,G__1634,G__1635,G__1636));\n});\nvar G__1649__4 = (function() { \nvar G__1650__delegate = function (a,b,c,ds){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,(((a == null))?x:a),(((b == null))?y:b),c,ds);\n};\nvar G__1650 = function (a,b,c,var_args){\nvar ds = null;\nif (arguments.length > 3) {\nvar G__1651__i = 0, G__1651__a = new Array(arguments.length -  3);\nwhile (G__1651__i < G__1651__a.length) {G__1651__a[G__1651__i] = arguments[G__1651__i + 3]; ++G__1651__i;}\n  ds = new cljs.core.IndexedSeq(G__1651__a,0,null);\n} \nreturn G__1650__delegate.call(this,a,b,c,ds);};\nG__1650.cljs$lang$maxFixedArity = 3;\nG__1650.cljs$lang$applyTo = (function (arglist__1652){\nvar a = cljs.core.first(arglist__1652);\narglist__1652 = cljs.core.next(arglist__1652);\nvar b = cljs.core.first(arglist__1652);\narglist__1652 = cljs.core.next(arglist__1652);\nvar c = cljs.core.first(arglist__1652);\nvar ds = cljs.core.rest(arglist__1652);\nreturn G__1650__delegate(a,b,c,ds);\n});\nG__1650.cljs$core$IFn$_invoke$arity$variadic = G__1650__delegate;\nreturn G__1650;\n})()\n;\nG__1649 = function(a,b,c,var_args){\nvar ds = var_args;\nswitch(arguments.length){\ncase 2:\nreturn G__1649__2.call(this,a,b);\ncase 3:\nreturn G__1649__3.call(this,a,b,c);\ndefault:\nvar G__1653 = null;\nif (arguments.length > 3) {\nvar G__1654__i = 0, G__1654__a = new Array(arguments.length -  3);\nwhile (G__1654__i < G__1654__a.length) {G__1654__a[G__1654__i] = arguments[G__1654__i + 3]; ++G__1654__i;}\nG__1653 = new cljs.core.IndexedSeq(G__1654__a,0,null);\n}\nreturn G__1649__4.cljs$core$IFn$_invoke$arity$variadic(a,b,c, G__1653);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1649.cljs$lang$maxFixedArity = 3;\nG__1649.cljs$lang$applyTo = G__1649__4.cljs$lang$applyTo;\nG__1649.cljs$core$IFn$_invoke$arity$2 = G__1649__2;\nG__1649.cljs$core$IFn$_invoke$arity$3 = G__1649__3;\nG__1649.cljs$core$IFn$_invoke$arity$variadic = G__1649__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1649;\n})()\n});\n\ncljs.core.fnil.cljs$core$IFn$_invoke$arity$4 = (function (f,x,y,z){\nreturn (function() {\nvar G__1655 = null;\nvar G__1655__2 = (function (a,b){\nvar G__1637 = (((a == null))?x:a);\nvar G__1638 = (((b == null))?y:b);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1637,G__1638) : f.call(null,G__1637,G__1638));\n});\nvar G__1655__3 = (function (a,b,c){\nvar G__1639 = (((a == null))?x:a);\nvar G__1640 = (((b == null))?y:b);\nvar G__1641 = (((c == null))?z:c);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1639,G__1640,G__1641) : f.call(null,G__1639,G__1640,G__1641));\n});\nvar G__1655__4 = (function() { \nvar G__1656__delegate = function (a,b,c,ds){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,(((a == null))?x:a),(((b == null))?y:b),(((c == null))?z:c),ds);\n};\nvar G__1656 = function (a,b,c,var_args){\nvar ds = null;\nif (arguments.length > 3) {\nvar G__1657__i = 0, G__1657__a = new Array(arguments.length -  3);\nwhile (G__1657__i < G__1657__a.length) {G__1657__a[G__1657__i] = arguments[G__1657__i + 3]; ++G__1657__i;}\n  ds = new cljs.core.IndexedSeq(G__1657__a,0,null);\n} \nreturn G__1656__delegate.call(this,a,b,c,ds);};\nG__1656.cljs$lang$maxFixedArity = 3;\nG__1656.cljs$lang$applyTo = (function (arglist__1658){\nvar a = cljs.core.first(arglist__1658);\narglist__1658 = cljs.core.next(arglist__1658);\nvar b = cljs.core.first(arglist__1658);\narglist__1658 = cljs.core.next(arglist__1658);\nvar c = cljs.core.first(arglist__1658);\nvar ds = cljs.core.rest(arglist__1658);\nreturn G__1656__delegate(a,b,c,ds);\n});\nG__1656.cljs$core$IFn$_invoke$arity$variadic = G__1656__delegate;\nreturn G__1656;\n})()\n;\nG__1655 = function(a,b,c,var_args){\nvar ds = var_args;\nswitch(arguments.length){\ncase 2:\nreturn G__1655__2.call(this,a,b);\ncase 3:\nreturn G__1655__3.call(this,a,b,c);\ndefault:\nvar G__1659 = null;\nif (arguments.length > 3) {\nvar G__1660__i = 0, G__1660__a = new Array(arguments.length -  3);\nwhile (G__1660__i < G__1660__a.length) {G__1660__a[G__1660__i] = arguments[G__1660__i + 3]; ++G__1660__i;}\nG__1659 = new cljs.core.IndexedSeq(G__1660__a,0,null);\n}\nreturn G__1655__4.cljs$core$IFn$_invoke$arity$variadic(a,b,c, G__1659);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1655.cljs$lang$maxFixedArity = 3;\nG__1655.cljs$lang$applyTo = G__1655__4.cljs$lang$applyTo;\nG__1655.cljs$core$IFn$_invoke$arity$2 = G__1655__2;\nG__1655.cljs$core$IFn$_invoke$arity$3 = G__1655__3;\nG__1655.cljs$core$IFn$_invoke$arity$variadic = G__1655__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1655;\n})()\n});\n\ncljs.core.fnil.cljs$lang$maxFixedArity = 4;\n\n/**\n * Returns a lazy sequence consisting of the result of applying f to 0\n *   and the first item of coll, followed by applying f to 1 and the second\n *   item in coll, etc, until coll is exhausted. Thus function f should\n *   accept 2 arguments, index and item. Returns a stateful transducer when\n *   no collection is provided.\n */\ncljs.core.map_indexed = (function cljs$core$map_indexed(var_args){\nvar G__1662 = arguments.length;\nswitch (G__1662) {\ncase 1:\nreturn cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.map_indexed.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (rf){\nvar i = cljs.core.volatile_BANG_((-1));\nreturn ((function (i){\nreturn (function() {\nvar G__1676 = null;\nvar G__1676__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1676__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1676__2 = (function (result,input){\nvar G__1663 = result;\nvar G__1664 = (function (){var G__1665 = i.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(i.cljs$core$IDeref$_deref$arity$1(null) + (1)));\nvar G__1666 = input;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1665,G__1666) : f.call(null,G__1665,G__1666));\n})();\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(G__1663,G__1664) : rf.call(null,G__1663,G__1664));\n});\nG__1676 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1676__0.call(this);\ncase 1:\nreturn G__1676__1.call(this,result);\ncase 2:\nreturn G__1676__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1676.cljs$core$IFn$_invoke$arity$0 = G__1676__0;\nG__1676.cljs$core$IFn$_invoke$arity$1 = G__1676__1;\nG__1676.cljs$core$IFn$_invoke$arity$2 = G__1676__2;\nreturn G__1676;\n})()\n;})(i))\n});\n});\n\ncljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nvar mapi = (function cljs$core$mapi(idx,coll__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll__$1);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c = cljs.core.chunk_first(s);\nvar size = cljs.core.count(c);\nvar b = cljs.core.chunk_buffer(size);\nvar n__4607__auto___1677 = size;\nvar i_1678 = (0);\nwhile(true){\nif((i_1678 < n__4607__auto___1677)){\ncljs.core.chunk_append(b,(function (){var G__1671 = (idx + i_1678);\nvar G__1672 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_1678);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1671,G__1672) : f.call(null,G__1671,G__1672));\n})());\n\nvar G__1679 = (i_1678 + (1));\ni_1678 = G__1679;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs$core$mapi((idx + size),cljs.core.chunk_rest(s)));\n} else {\nreturn cljs.core.cons((function (){var G__1673 = idx;\nvar G__1674 = cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1673,G__1674) : f.call(null,G__1673,G__1674));\n})(),cljs$core$mapi((idx + (1)),cljs.core.rest(s)));\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\nreturn mapi((0),coll);\n});\n\ncljs.core.map_indexed.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a lazy sequence of the non-nil results of (f item). Note,\n *   this means false return values will be included.  f must be free of\n *   side-effects.  Returns a transducer when no collection is provided.\n */\ncljs.core.keep = (function cljs$core$keep(var_args){\nvar G__1681 = arguments.length;\nswitch (G__1681) {\ncase 1:\nreturn cljs.core.keep.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.keep.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.keep.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (rf){\nreturn (function() {\nvar G__1685 = null;\nvar G__1685__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1685__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1685__2 = (function (result,input){\nvar v = (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(input) : f.call(null,input));\nif((v == null)){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\n}\n});\nG__1685 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1685__0.call(this);\ncase 1:\nreturn G__1685__1.call(this,result);\ncase 2:\nreturn G__1685__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1685.cljs$core$IFn$_invoke$arity$0 = G__1685__0;\nG__1685.cljs$core$IFn$_invoke$arity$1 = G__1685__1;\nG__1685.cljs$core$IFn$_invoke$arity$2 = G__1685__2;\nreturn G__1685;\n})()\n});\n});\n\ncljs.core.keep.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c = cljs.core.chunk_first(s);\nvar size = cljs.core.count(c);\nvar b = cljs.core.chunk_buffer(size);\nvar n__4607__auto___1686 = size;\nvar i_1687 = (0);\nwhile(true){\nif((i_1687 < n__4607__auto___1686)){\nvar x_1688 = (function (){var G__1682 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_1687);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1682) : f.call(null,G__1682));\n})();\nif((x_1688 == null)){\n} else {\ncljs.core.chunk_append(b,x_1688);\n}\n\nvar G__1689 = (i_1687 + (1));\ni_1687 = G__1689;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs.core.keep.cljs$core$IFn$_invoke$arity$2(f,cljs.core.chunk_rest(s)));\n} else {\nvar x = (function (){var G__1683 = cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1683) : f.call(null,G__1683));\n})();\nif((x == null)){\nreturn cljs.core.keep.cljs$core$IFn$_invoke$arity$2(f,cljs.core.rest(s));\n} else {\nreturn cljs.core.cons(x,cljs.core.keep.cljs$core$IFn$_invoke$arity$2(f,cljs.core.rest(s)));\n}\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.keep.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IWatchable}\n * @implements {cljs.core.IAtom}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IDeref}\n*/\ncljs.core.Atom = (function (state,meta,validator,watches){\nthis.state = state;\nthis.meta = meta;\nthis.validator = validator;\nthis.watches = watches;\nthis.cljs$lang$protocol_mask$partition1$ = 16386;\nthis.cljs$lang$protocol_mask$partition0$ = 6455296;\n});\ncljs.core.Atom.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Atom.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (o,other){\nvar self__ = this;\nvar o__$1 = this;\nreturn (o__$1 === other);\n});\n\ncljs.core.Atom.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.state;\n});\n\ncljs.core.Atom.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Atom.prototype.cljs$core$IWatchable$_notify_watches$arity$3 = (function (this$,oldval,newval){\nvar self__ = this;\nvar this$__$1 = this;\nvar seq__1690 = cljs.core.seq(self__.watches);\nvar chunk__1691 = null;\nvar count__1692 = (0);\nvar i__1693 = (0);\nwhile(true){\nif((i__1693 < count__1692)){\nvar vec__1700 = chunk__1691.cljs$core$IIndexed$_nth$arity$2(null,i__1693);\nvar key = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1700,(0),null);\nvar f = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1700,(1),null);\n(f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(key,this$__$1,oldval,newval) : f.call(null,key,this$__$1,oldval,newval));\n\n\nvar G__1706 = seq__1690;\nvar G__1707 = chunk__1691;\nvar G__1708 = count__1692;\nvar G__1709 = (i__1693 + (1));\nseq__1690 = G__1706;\nchunk__1691 = G__1707;\ncount__1692 = G__1708;\ni__1693 = G__1709;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__1690);\nif(temp__5720__auto__){\nvar seq__1690__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__1690__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__1690__$1);\nvar G__1710 = cljs.core.chunk_rest(seq__1690__$1);\nvar G__1711 = c__4550__auto__;\nvar G__1712 = cljs.core.count(c__4550__auto__);\nvar G__1713 = (0);\nseq__1690 = G__1710;\nchunk__1691 = G__1711;\ncount__1692 = G__1712;\ni__1693 = G__1713;\ncontinue;\n} else {\nvar vec__1703 = cljs.core.first(seq__1690__$1);\nvar key = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1703,(0),null);\nvar f = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__1703,(1),null);\n(f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(key,this$__$1,oldval,newval) : f.call(null,key,this$__$1,oldval,newval));\n\n\nvar G__1714 = cljs.core.next(seq__1690__$1);\nvar G__1715 = null;\nvar G__1716 = (0);\nvar G__1717 = (0);\nseq__1690 = G__1714;\nchunk__1691 = G__1715;\ncount__1692 = G__1716;\ni__1693 = G__1717;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.Atom.prototype.cljs$core$IWatchable$_add_watch$arity$3 = (function (this$,key,f){\nvar self__ = this;\nvar this$__$1 = this;\nthis$__$1.watches = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.watches,key,f);\n\nreturn this$__$1;\n});\n\ncljs.core.Atom.prototype.cljs$core$IWatchable$_remove_watch$arity$2 = (function (this$,key){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.watches = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.watches,key);\n});\n\ncljs.core.Atom.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn goog.getUid(this$__$1);\n});\n\ncljs.core.Atom.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"state\",\"state\",-348086572,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"validator\",\"validator\",-325659154,null),new cljs.core.Symbol(null,\"watches\",\"watches\",1367433992,null)], null);\n});\n\ncljs.core.Atom.cljs$lang$type = true;\n\ncljs.core.Atom.cljs$lang$ctorStr = \"cljs.core/Atom\";\n\ncljs.core.Atom.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Atom\");\n});\n\n/**\n * Positional factory function for cljs.core/Atom.\n */\ncljs.core.__GT_Atom = (function cljs$core$__GT_Atom(state,meta,validator,watches){\nreturn (new cljs.core.Atom(state,meta,validator,watches));\n});\n\n/**\n * Creates and returns an Atom with an initial value of x and zero or\n *   more options (in any order):\n * \n *   :meta metadata-map\n * \n *   :validator validate-fn\n * \n *   If metadata-map is supplied, it will become the metadata on the\n *   atom. validate-fn must be nil or a side-effect-free fn of one\n *   argument, which will be passed the intended new state on any state\n *   change. If the new state is unacceptable, the validate-fn should\n *   return false or throw an Error.  If either of these error conditions\n *   occur, then the value of the atom will not change.\n */\ncljs.core.atom = (function cljs$core$atom(var_args){\nvar G__1721 = arguments.length;\nswitch (G__1721) {\ncase 1:\nreturn cljs.core.atom.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1726 = arguments.length;\nvar i__4731__auto___1727 = (0);\nwhile(true){\nif((i__4731__auto___1727 < len__4730__auto___1726)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1727]));\n\nvar G__1728 = (i__4731__auto___1727 + (1));\ni__4731__auto___1727 = G__1728;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.atom.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.atom.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn (new cljs.core.Atom(x,null,null,null));\n});\n\ncljs.core.atom.cljs$core$IFn$_invoke$arity$variadic = (function (x,p__1722){\nvar map__1723 = p__1722;\nvar map__1723__$1 = (((((!((map__1723 == null))))?(((((map__1723.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__1723.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__1723):map__1723);\nvar meta = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__1723__$1,new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964));\nvar validator = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__1723__$1,new cljs.core.Keyword(null,\"validator\",\"validator\",-1966190681));\nreturn (new cljs.core.Atom(x,meta,validator,null));\n});\n\n/** @this {Function} */\ncljs.core.atom.cljs$lang$applyTo = (function (seq1719){\nvar G__1720 = cljs.core.first(seq1719);\nvar seq1719__$1 = cljs.core.next(seq1719);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1720,seq1719__$1);\n});\n\ncljs.core.atom.cljs$lang$maxFixedArity = (1);\n\n/**\n * Sets the value of atom to newval without regard for the\n *   current value. Returns new-value.\n */\ncljs.core.reset_BANG_ = (function cljs$core$reset_BANG_(a,new_value){\nif((a instanceof cljs.core.Atom)){\nvar validate = a.validator;\nif((validate == null)){\n} else {\nif(cljs.core.truth_((validate.cljs$core$IFn$_invoke$arity$1 ? validate.cljs$core$IFn$_invoke$arity$1(new_value) : validate.call(null,new_value)))){\n} else {\nthrow (new Error(\"Validator rejected reference state\"));\n}\n}\n\nvar old_value = a.state;\na.state = new_value;\n\nif((a.watches == null)){\n} else {\na.cljs$core$IWatchable$_notify_watches$arity$3(null,old_value,new_value);\n}\n\nreturn new_value;\n} else {\nreturn cljs.core._reset_BANG_(a,new_value);\n}\n});\n/**\n * Sets the value of atom to newval. Returns [old new], the value of the\n * atom before and after the reset.\n */\ncljs.core.reset_vals_BANG_ = (function cljs$core$reset_vals_BANG_(a,new_value){\nvar validate = a.validator;\nif((validate == null)){\n} else {\nif(cljs.core.truth_((validate.cljs$core$IFn$_invoke$arity$1 ? validate.cljs$core$IFn$_invoke$arity$1(new_value) : validate.call(null,new_value)))){\n} else {\nthrow (new Error(\"Validator rejected reference state\"));\n}\n}\n\nvar old_value = a.state;\na.state = new_value;\n\nif((a.watches == null)){\n} else {\ncljs.core._notify_watches(a,old_value,new_value);\n}\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [old_value,new_value], null);\n});\n/**\n * Atomically swaps the value of atom to be:\n *   (apply f current-value-of-atom args). Note that f may be called\n *   multiple times, and thus should be free of side effects.  Returns\n *   the value that was swapped in.\n */\ncljs.core.swap_BANG_ = (function cljs$core$swap_BANG_(var_args){\nvar G__1735 = arguments.length;\nswitch (G__1735) {\ncase 2:\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1743 = arguments.length;\nvar i__4731__auto___1744 = (0);\nwhile(true){\nif((i__4731__auto___1744 < len__4730__auto___1743)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1744]));\n\nvar G__1745 = (i__4731__auto___1744 + (1));\ni__4731__auto___1744 = G__1745;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (a,f){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,(function (){var G__1736 = a.state;\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1736) : f.call(null,G__1736));\n})());\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$2(a,f);\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (a,f,x){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,(function (){var G__1737 = a.state;\nvar G__1738 = x;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1737,G__1738) : f.call(null,G__1737,G__1738));\n})());\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$3(a,f,x);\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4 = (function (a,f,x,y){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,(function (){var G__1739 = a.state;\nvar G__1740 = x;\nvar G__1741 = y;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1739,G__1740,G__1741) : f.call(null,G__1739,G__1740,G__1741));\n})());\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$4(a,f,x,y);\n}\n});\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (a,f,x,y,more){\nif((a instanceof cljs.core.Atom)){\nreturn cljs.core.reset_BANG_(a,cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,a.state,x,y,more));\n} else {\nreturn cljs.core._swap_BANG_.cljs$core$IFn$_invoke$arity$5(a,f,x,y,more);\n}\n});\n\n/** @this {Function} */\ncljs.core.swap_BANG_.cljs$lang$applyTo = (function (seq1730){\nvar G__1731 = cljs.core.first(seq1730);\nvar seq1730__$1 = cljs.core.next(seq1730);\nvar G__1732 = cljs.core.first(seq1730__$1);\nvar seq1730__$2 = cljs.core.next(seq1730__$1);\nvar G__1733 = cljs.core.first(seq1730__$2);\nvar seq1730__$3 = cljs.core.next(seq1730__$2);\nvar G__1734 = cljs.core.first(seq1730__$3);\nvar seq1730__$4 = cljs.core.next(seq1730__$3);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1731,G__1732,G__1733,G__1734,seq1730__$4);\n});\n\ncljs.core.swap_BANG_.cljs$lang$maxFixedArity = (4);\n\n/**\n * Atomically swaps the value of atom to be:\n *   (apply f current-value-of-atom args). Note that f may be called\n *   multiple times, and thus should be free of side effects.\n *   Returns [old new], the value of the atom before and after the swap.\n */\ncljs.core.swap_vals_BANG_ = (function cljs$core$swap_vals_BANG_(var_args){\nvar G__1752 = arguments.length;\nswitch (G__1752) {\ncase 2:\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1760 = arguments.length;\nvar i__4731__auto___1761 = (0);\nwhile(true){\nif((i__4731__auto___1761 < len__4730__auto___1760)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1761]));\n\nvar G__1762 = (i__4731__auto___1761 + (1));\ni__4731__auto___1761 = G__1762;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (a,f){\nreturn cljs.core.reset_vals_BANG_(a,(function (){var G__1753 = a.state;\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1753) : f.call(null,G__1753));\n})());\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (a,f,x){\nreturn cljs.core.reset_vals_BANG_(a,(function (){var G__1754 = a.state;\nvar G__1755 = x;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1754,G__1755) : f.call(null,G__1754,G__1755));\n})());\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$4 = (function (a,f,x,y){\nreturn cljs.core.reset_vals_BANG_(a,(function (){var G__1756 = a.state;\nvar G__1757 = x;\nvar G__1758 = y;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1756,G__1757,G__1758) : f.call(null,G__1756,G__1757,G__1758));\n})());\n});\n\ncljs.core.swap_vals_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (a,f,x,y,more){\nreturn cljs.core.reset_vals_BANG_(a,cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,a.state,x,y,more));\n});\n\n/** @this {Function} */\ncljs.core.swap_vals_BANG_.cljs$lang$applyTo = (function (seq1747){\nvar G__1748 = cljs.core.first(seq1747);\nvar seq1747__$1 = cljs.core.next(seq1747);\nvar G__1749 = cljs.core.first(seq1747__$1);\nvar seq1747__$2 = cljs.core.next(seq1747__$1);\nvar G__1750 = cljs.core.first(seq1747__$2);\nvar seq1747__$3 = cljs.core.next(seq1747__$2);\nvar G__1751 = cljs.core.first(seq1747__$3);\nvar seq1747__$4 = cljs.core.next(seq1747__$3);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1748,G__1749,G__1750,G__1751,seq1747__$4);\n});\n\ncljs.core.swap_vals_BANG_.cljs$lang$maxFixedArity = (4);\n\n/**\n * Atomically sets the value of atom to newval if and only if the\n *   current value of the atom is equal to oldval. Returns true if\n *   set happened, else false.\n */\ncljs.core.compare_and_set_BANG_ = (function cljs$core$compare_and_set_BANG_(a,oldval,newval){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(a.cljs$core$IDeref$_deref$arity$1(null),oldval)){\ncljs.core.reset_BANG_(a,newval);\n\nreturn true;\n} else {\nreturn false;\n}\n});\n/**\n * Sets the validator-fn for an atom. validator-fn must be nil or a\n *   side-effect-free fn of one argument, which will be passed the intended\n *   new state on any state change. If the new state is unacceptable, the\n *   validator-fn should return false or throw an Error. If the current state\n *   is not acceptable to the new validator, an Error will be thrown and the\n *   validator will not be changed.\n */\ncljs.core.set_validator_BANG_ = (function cljs$core$set_validator_BANG_(iref,val){\nif((((!((val == null)))) && (cljs.core.not((function (){var G__1764 = cljs.core._deref(iref);\nreturn (val.cljs$core$IFn$_invoke$arity$1 ? val.cljs$core$IFn$_invoke$arity$1(G__1764) : val.call(null,G__1764));\n})())))){\nthrow (new Error(\"Validator rejected reference state\"));\n} else {\n}\n\nreturn iref.validator = val;\n});\n/**\n * Gets the validator-fn for a var/ref/agent/atom.\n */\ncljs.core.get_validator = (function cljs$core$get_validator(iref){\nreturn iref.validator;\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IVolatile}\n * @implements {cljs.core.IDeref}\n*/\ncljs.core.Volatile = (function (state){\nthis.state = state;\nthis.cljs$lang$protocol_mask$partition0$ = 32768;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.Volatile.prototype.cljs$core$IVolatile$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Volatile.prototype.cljs$core$IVolatile$_vreset_BANG_$arity$2 = (function (_,new_state){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.state = new_state;\n});\n\ncljs.core.Volatile.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.state;\n});\n\ncljs.core.Volatile.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"state\",\"state\",-348086572,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Volatile.cljs$lang$type = true;\n\ncljs.core.Volatile.cljs$lang$ctorStr = \"cljs.core/Volatile\";\n\ncljs.core.Volatile.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Volatile\");\n});\n\n/**\n * Positional factory function for cljs.core/Volatile.\n */\ncljs.core.__GT_Volatile = (function cljs$core$__GT_Volatile(state){\nreturn (new cljs.core.Volatile(state));\n});\n\n/**\n * Creates and returns a Volatile with an initial value of val.\n */\ncljs.core.volatile_BANG_ = (function cljs$core$volatile_BANG_(val){\nreturn (new cljs.core.Volatile(val));\n});\n/**\n * Returns true if x is a volatile.\n */\ncljs.core.volatile_QMARK_ = (function cljs$core$volatile_QMARK_(x){\nreturn (x instanceof cljs.core.Volatile);\n});\n/**\n * Sets the value of volatile to newval without regard for the\n * current value. Returns newval.\n */\ncljs.core.vreset_BANG_ = (function cljs$core$vreset_BANG_(vol,newval){\nreturn cljs.core._vreset_BANG_(vol,newval);\n});\n/**\n * Returns a lazy sequence of the non-nil results of (f index item). Note,\n *   this means false return values will be included.  f must be free of\n *   side-effects.  Returns a stateful transducer when no collection is\n *   provided.\n */\ncljs.core.keep_indexed = (function cljs$core$keep_indexed(var_args){\nvar G__1766 = arguments.length;\nswitch (G__1766) {\ncase 1:\nreturn cljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (rf){\nvar ia = cljs.core.volatile_BANG_((-1));\nreturn ((function (ia){\nreturn (function() {\nvar G__1776 = null;\nvar G__1776__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1776__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1776__2 = (function (result,input){\nvar i = ia.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(ia.cljs$core$IDeref$_deref$arity$1(null) + (1)));\nvar v = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(i,input) : f.call(null,i,input));\nif((v == null)){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\n}\n});\nG__1776 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1776__0.call(this);\ncase 1:\nreturn G__1776__1.call(this,result);\ncase 2:\nreturn G__1776__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1776.cljs$core$IFn$_invoke$arity$0 = G__1776__0;\nG__1776.cljs$core$IFn$_invoke$arity$1 = G__1776__1;\nG__1776.cljs$core$IFn$_invoke$arity$2 = G__1776__2;\nreturn G__1776;\n})()\n;})(ia))\n});\n});\n\ncljs.core.keep_indexed.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nvar keepi = (function cljs$core$keepi(idx,coll__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll__$1);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c = cljs.core.chunk_first(s);\nvar size = cljs.core.count(c);\nvar b = cljs.core.chunk_buffer(size);\nvar n__4607__auto___1777 = size;\nvar i_1778 = (0);\nwhile(true){\nif((i_1778 < n__4607__auto___1777)){\nvar x_1779 = (function (){var G__1771 = (idx + i_1778);\nvar G__1772 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_1778);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1771,G__1772) : f.call(null,G__1771,G__1772));\n})();\nif((x_1779 == null)){\n} else {\ncljs.core.chunk_append(b,x_1779);\n}\n\nvar G__1780 = (i_1778 + (1));\ni_1778 = G__1780;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs$core$keepi((idx + size),cljs.core.chunk_rest(s)));\n} else {\nvar x = (function (){var G__1773 = idx;\nvar G__1774 = cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1773,G__1774) : f.call(null,G__1773,G__1774));\n})();\nif((x == null)){\nreturn cljs$core$keepi((idx + (1)),cljs.core.rest(s));\n} else {\nreturn cljs.core.cons(x,cljs$core$keepi((idx + (1)),cljs.core.rest(s)));\n}\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\nreturn keepi((0),coll);\n});\n\ncljs.core.keep_indexed.cljs$lang$maxFixedArity = 2;\n\n/**\n * Takes a set of predicates and returns a function f that returns true if all of its\n *   composing predicates return a logical true value against all of its arguments, else it returns\n *   false. Note that f is short-circuiting in that it will stop execution on the first\n *   argument that triggers a logical false result against the original predicates.\n */\ncljs.core.every_pred = (function cljs$core$every_pred(var_args){\nvar G__1792 = arguments.length;\nswitch (G__1792) {\ncase 1:\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1794 = arguments.length;\nvar i__4731__auto___1795 = (0);\nwhile(true){\nif((i__4731__auto___1795 < len__4730__auto___1794)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1795]));\n\nvar G__1796 = (i__4731__auto___1795 + (1));\ni__4731__auto___1795 = G__1796;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.every_pred.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$1 = (function (p){\nreturn (function() {\nvar cljs$core$ep1 = null;\nvar cljs$core$ep1__0 = (function (){\nreturn true;\n});\nvar cljs$core$ep1__1 = (function (x){\nreturn cljs.core.boolean$((p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x)));\n});\nvar cljs$core$ep1__2 = (function (x,y){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep1__3 = (function (x,y,z){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(z) : p.call(null,z));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep1__4 = (function() { \nvar G__1797__delegate = function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = cljs$core$ep1.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(p,args);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__1797 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1798__i = 0, G__1798__a = new Array(arguments.length -  3);\nwhile (G__1798__i < G__1798__a.length) {G__1798__a[G__1798__i] = arguments[G__1798__i + 3]; ++G__1798__i;}\n  args = new cljs.core.IndexedSeq(G__1798__a,0,null);\n} \nreturn G__1797__delegate.call(this,x,y,z,args);};\nG__1797.cljs$lang$maxFixedArity = 3;\nG__1797.cljs$lang$applyTo = (function (arglist__1799){\nvar x = cljs.core.first(arglist__1799);\narglist__1799 = cljs.core.next(arglist__1799);\nvar y = cljs.core.first(arglist__1799);\narglist__1799 = cljs.core.next(arglist__1799);\nvar z = cljs.core.first(arglist__1799);\nvar args = cljs.core.rest(arglist__1799);\nreturn G__1797__delegate(x,y,z,args);\n});\nG__1797.cljs$core$IFn$_invoke$arity$variadic = G__1797__delegate;\nreturn G__1797;\n})()\n;\ncljs$core$ep1 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$ep1__0.call(this);\ncase 1:\nreturn cljs$core$ep1__1.call(this,x);\ncase 2:\nreturn cljs$core$ep1__2.call(this,x,y);\ncase 3:\nreturn cljs$core$ep1__3.call(this,x,y,z);\ndefault:\nvar G__1800 = null;\nif (arguments.length > 3) {\nvar G__1801__i = 0, G__1801__a = new Array(arguments.length -  3);\nwhile (G__1801__i < G__1801__a.length) {G__1801__a[G__1801__i] = arguments[G__1801__i + 3]; ++G__1801__i;}\nG__1800 = new cljs.core.IndexedSeq(G__1801__a,0,null);\n}\nreturn cljs$core$ep1__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1800);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$ep1.cljs$lang$maxFixedArity = 3;\ncljs$core$ep1.cljs$lang$applyTo = cljs$core$ep1__4.cljs$lang$applyTo;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$0 = cljs$core$ep1__0;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$1 = cljs$core$ep1__1;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$2 = cljs$core$ep1__2;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$3 = cljs$core$ep1__3;\ncljs$core$ep1.cljs$core$IFn$_invoke$arity$variadic = cljs$core$ep1__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$ep1;\n})()\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$2 = (function (p1,p2){\nreturn (function() {\nvar cljs$core$ep2 = null;\nvar cljs$core$ep2__0 = (function (){\nreturn true;\n});\nvar cljs$core$ep2__1 = (function (x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep2__2 = (function (x,y){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$2)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep2__3 = (function (x,y,z){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(and__4120__auto____$2)){\nvar and__4120__auto____$3 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$3)){\nvar and__4120__auto____$4 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$4)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep2__4 = (function() { \nvar G__1802__delegate = function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = cljs$core$ep2.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(((function (and__4120__auto__){\nreturn (function (p1__1781_SHARP_){\nvar and__4120__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__1781_SHARP_) : p1.call(null,p1__1781_SHARP_));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__1781_SHARP_) : p2.call(null,p1__1781_SHARP_));\n} else {\nreturn and__4120__auto____$1;\n}\n});})(and__4120__auto__))\n,args);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__1802 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1803__i = 0, G__1803__a = new Array(arguments.length -  3);\nwhile (G__1803__i < G__1803__a.length) {G__1803__a[G__1803__i] = arguments[G__1803__i + 3]; ++G__1803__i;}\n  args = new cljs.core.IndexedSeq(G__1803__a,0,null);\n} \nreturn G__1802__delegate.call(this,x,y,z,args);};\nG__1802.cljs$lang$maxFixedArity = 3;\nG__1802.cljs$lang$applyTo = (function (arglist__1804){\nvar x = cljs.core.first(arglist__1804);\narglist__1804 = cljs.core.next(arglist__1804);\nvar y = cljs.core.first(arglist__1804);\narglist__1804 = cljs.core.next(arglist__1804);\nvar z = cljs.core.first(arglist__1804);\nvar args = cljs.core.rest(arglist__1804);\nreturn G__1802__delegate(x,y,z,args);\n});\nG__1802.cljs$core$IFn$_invoke$arity$variadic = G__1802__delegate;\nreturn G__1802;\n})()\n;\ncljs$core$ep2 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$ep2__0.call(this);\ncase 1:\nreturn cljs$core$ep2__1.call(this,x);\ncase 2:\nreturn cljs$core$ep2__2.call(this,x,y);\ncase 3:\nreturn cljs$core$ep2__3.call(this,x,y,z);\ndefault:\nvar G__1805 = null;\nif (arguments.length > 3) {\nvar G__1806__i = 0, G__1806__a = new Array(arguments.length -  3);\nwhile (G__1806__i < G__1806__a.length) {G__1806__a[G__1806__i] = arguments[G__1806__i + 3]; ++G__1806__i;}\nG__1805 = new cljs.core.IndexedSeq(G__1806__a,0,null);\n}\nreturn cljs$core$ep2__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1805);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$ep2.cljs$lang$maxFixedArity = 3;\ncljs$core$ep2.cljs$lang$applyTo = cljs$core$ep2__4.cljs$lang$applyTo;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$0 = cljs$core$ep2__0;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$1 = cljs$core$ep2__1;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$2 = cljs$core$ep2__2;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$3 = cljs$core$ep2__3;\ncljs$core$ep2.cljs$core$IFn$_invoke$arity$variadic = cljs$core$ep2__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$ep2;\n})()\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$3 = (function (p1,p2,p3){\nreturn (function() {\nvar cljs$core$ep3 = null;\nvar cljs$core$ep3__0 = (function (){\nreturn true;\n});\nvar cljs$core$ep3__1 = (function (x){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep3__2 = (function (x,y){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 = (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$2)){\nvar and__4120__auto____$3 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$3)){\nvar and__4120__auto____$4 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$4)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep3__3 = (function (x,y,z){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 = (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(and__4120__auto____$2)){\nvar and__4120__auto____$3 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$3)){\nvar and__4120__auto____$4 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$4)){\nvar and__4120__auto____$5 = (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$5)){\nvar and__4120__auto____$6 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(and__4120__auto____$6)){\nvar and__4120__auto____$7 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\nif(cljs.core.truth_(and__4120__auto____$7)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(z) : p3.call(null,z));\n} else {\nreturn and__4120__auto____$7;\n}\n} else {\nreturn and__4120__auto____$6;\n}\n} else {\nreturn and__4120__auto____$5;\n}\n} else {\nreturn and__4120__auto____$4;\n}\n} else {\nreturn and__4120__auto____$3;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})());\n});\nvar cljs$core$ep3__4 = (function() { \nvar G__1807__delegate = function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = cljs$core$ep3.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(((function (and__4120__auto__){\nreturn (function (p1__1782_SHARP_){\nvar and__4120__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__1782_SHARP_) : p1.call(null,p1__1782_SHARP_));\nif(cljs.core.truth_(and__4120__auto____$1)){\nvar and__4120__auto____$2 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__1782_SHARP_) : p2.call(null,p1__1782_SHARP_));\nif(cljs.core.truth_(and__4120__auto____$2)){\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(p1__1782_SHARP_) : p3.call(null,p1__1782_SHARP_));\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n});})(and__4120__auto__))\n,args);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__1807 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1808__i = 0, G__1808__a = new Array(arguments.length -  3);\nwhile (G__1808__i < G__1808__a.length) {G__1808__a[G__1808__i] = arguments[G__1808__i + 3]; ++G__1808__i;}\n  args = new cljs.core.IndexedSeq(G__1808__a,0,null);\n} \nreturn G__1807__delegate.call(this,x,y,z,args);};\nG__1807.cljs$lang$maxFixedArity = 3;\nG__1807.cljs$lang$applyTo = (function (arglist__1809){\nvar x = cljs.core.first(arglist__1809);\narglist__1809 = cljs.core.next(arglist__1809);\nvar y = cljs.core.first(arglist__1809);\narglist__1809 = cljs.core.next(arglist__1809);\nvar z = cljs.core.first(arglist__1809);\nvar args = cljs.core.rest(arglist__1809);\nreturn G__1807__delegate(x,y,z,args);\n});\nG__1807.cljs$core$IFn$_invoke$arity$variadic = G__1807__delegate;\nreturn G__1807;\n})()\n;\ncljs$core$ep3 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$ep3__0.call(this);\ncase 1:\nreturn cljs$core$ep3__1.call(this,x);\ncase 2:\nreturn cljs$core$ep3__2.call(this,x,y);\ncase 3:\nreturn cljs$core$ep3__3.call(this,x,y,z);\ndefault:\nvar G__1810 = null;\nif (arguments.length > 3) {\nvar G__1811__i = 0, G__1811__a = new Array(arguments.length -  3);\nwhile (G__1811__i < G__1811__a.length) {G__1811__a[G__1811__i] = arguments[G__1811__i + 3]; ++G__1811__i;}\nG__1810 = new cljs.core.IndexedSeq(G__1811__a,0,null);\n}\nreturn cljs$core$ep3__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1810);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$ep3.cljs$lang$maxFixedArity = 3;\ncljs$core$ep3.cljs$lang$applyTo = cljs$core$ep3__4.cljs$lang$applyTo;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$0 = cljs$core$ep3__0;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$1 = cljs$core$ep3__1;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$2 = cljs$core$ep3__2;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$3 = cljs$core$ep3__3;\ncljs$core$ep3.cljs$core$IFn$_invoke$arity$variadic = cljs$core$ep3__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$ep3;\n})()\n});\n\ncljs.core.every_pred.cljs$core$IFn$_invoke$arity$variadic = (function (p1,p2,p3,ps){\nvar ps__$1 = cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(p1,p2,p3,ps);\nreturn ((function (ps__$1){\nreturn (function() {\nvar cljs$core$epn = null;\nvar cljs$core$epn__0 = (function (){\nreturn true;\n});\nvar cljs$core$epn__1 = (function (x){\nreturn cljs.core.every_QMARK_(((function (ps__$1){\nreturn (function (p1__1783_SHARP_){\nreturn (p1__1783_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1783_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__1783_SHARP_.call(null,x));\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$epn__2 = (function (x,y){\nreturn cljs.core.every_QMARK_(((function (ps__$1){\nreturn (function (p1__1784_SHARP_){\nvar and__4120__auto__ = (p1__1784_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1784_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__1784_SHARP_.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (p1__1784_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1784_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__1784_SHARP_.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$epn__3 = (function (x,y,z){\nreturn cljs.core.every_QMARK_(((function (ps__$1){\nreturn (function (p1__1785_SHARP_){\nvar and__4120__auto__ = (p1__1785_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1785_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__1785_SHARP_.call(null,x));\nif(cljs.core.truth_(and__4120__auto__)){\nvar and__4120__auto____$1 = (p1__1785_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1785_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__1785_SHARP_.call(null,y));\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (p1__1785_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1785_SHARP_.cljs$core$IFn$_invoke$arity$1(z) : p1__1785_SHARP_.call(null,z));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$epn__4 = (function() { \nvar G__1812__delegate = function (x,y,z,args){\nreturn cljs.core.boolean$((function (){var and__4120__auto__ = cljs$core$epn.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.every_QMARK_(((function (and__4120__auto__,ps__$1){\nreturn (function (p1__1786_SHARP_){\nreturn cljs.core.every_QMARK_(p1__1786_SHARP_,args);\n});})(and__4120__auto__,ps__$1))\n,ps__$1);\n} else {\nreturn and__4120__auto__;\n}\n})());\n};\nvar G__1812 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1813__i = 0, G__1813__a = new Array(arguments.length -  3);\nwhile (G__1813__i < G__1813__a.length) {G__1813__a[G__1813__i] = arguments[G__1813__i + 3]; ++G__1813__i;}\n  args = new cljs.core.IndexedSeq(G__1813__a,0,null);\n} \nreturn G__1812__delegate.call(this,x,y,z,args);};\nG__1812.cljs$lang$maxFixedArity = 3;\nG__1812.cljs$lang$applyTo = (function (arglist__1814){\nvar x = cljs.core.first(arglist__1814);\narglist__1814 = cljs.core.next(arglist__1814);\nvar y = cljs.core.first(arglist__1814);\narglist__1814 = cljs.core.next(arglist__1814);\nvar z = cljs.core.first(arglist__1814);\nvar args = cljs.core.rest(arglist__1814);\nreturn G__1812__delegate(x,y,z,args);\n});\nG__1812.cljs$core$IFn$_invoke$arity$variadic = G__1812__delegate;\nreturn G__1812;\n})()\n;\ncljs$core$epn = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$epn__0.call(this);\ncase 1:\nreturn cljs$core$epn__1.call(this,x);\ncase 2:\nreturn cljs$core$epn__2.call(this,x,y);\ncase 3:\nreturn cljs$core$epn__3.call(this,x,y,z);\ndefault:\nvar G__1815 = null;\nif (arguments.length > 3) {\nvar G__1816__i = 0, G__1816__a = new Array(arguments.length -  3);\nwhile (G__1816__i < G__1816__a.length) {G__1816__a[G__1816__i] = arguments[G__1816__i + 3]; ++G__1816__i;}\nG__1815 = new cljs.core.IndexedSeq(G__1816__a,0,null);\n}\nreturn cljs$core$epn__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1815);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$epn.cljs$lang$maxFixedArity = 3;\ncljs$core$epn.cljs$lang$applyTo = cljs$core$epn__4.cljs$lang$applyTo;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$0 = cljs$core$epn__0;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$1 = cljs$core$epn__1;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$2 = cljs$core$epn__2;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$3 = cljs$core$epn__3;\ncljs$core$epn.cljs$core$IFn$_invoke$arity$variadic = cljs$core$epn__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$epn;\n})()\n;})(ps__$1))\n});\n\n/** @this {Function} */\ncljs.core.every_pred.cljs$lang$applyTo = (function (seq1788){\nvar G__1789 = cljs.core.first(seq1788);\nvar seq1788__$1 = cljs.core.next(seq1788);\nvar G__1790 = cljs.core.first(seq1788__$1);\nvar seq1788__$2 = cljs.core.next(seq1788__$1);\nvar G__1791 = cljs.core.first(seq1788__$2);\nvar seq1788__$3 = cljs.core.next(seq1788__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1789,G__1790,G__1791,seq1788__$3);\n});\n\ncljs.core.every_pred.cljs$lang$maxFixedArity = (3);\n\n/**\n * Takes a set of predicates and returns a function f that returns the first logical true value\n *   returned by one of its composing predicates against any of its arguments, else it returns\n *   logical false. Note that f is short-circuiting in that it will stop execution on the first\n *   argument that triggers a logical true result against the original predicates.\n */\ncljs.core.some_fn = (function cljs$core$some_fn(var_args){\nvar G__1828 = arguments.length;\nswitch (G__1828) {\ncase 1:\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1830 = arguments.length;\nvar i__4731__auto___1831 = (0);\nwhile(true){\nif((i__4731__auto___1831 < len__4730__auto___1830)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1831]));\n\nvar G__1832 = (i__4731__auto___1831 + (1));\ni__4731__auto___1831 = G__1832;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.some_fn.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$1 = (function (p){\nreturn (function() {\nvar cljs$core$sp1 = null;\nvar cljs$core$sp1__0 = (function (){\nreturn null;\n});\nvar cljs$core$sp1__1 = (function (x){\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\n});\nvar cljs$core$sp1__2 = (function (x,y){\nvar or__4131__auto__ = (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\n}\n});\nvar cljs$core$sp1__3 = (function (x,y,z){\nvar or__4131__auto__ = (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(x) : p.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(y) : p.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p.cljs$core$IFn$_invoke$arity$1 ? p.cljs$core$IFn$_invoke$arity$1(z) : p.call(null,z));\n}\n}\n});\nvar cljs$core$sp1__4 = (function() { \nvar G__1833__delegate = function (x,y,z,args){\nvar or__4131__auto__ = cljs$core$sp1.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(p,args);\n}\n};\nvar G__1833 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1834__i = 0, G__1834__a = new Array(arguments.length -  3);\nwhile (G__1834__i < G__1834__a.length) {G__1834__a[G__1834__i] = arguments[G__1834__i + 3]; ++G__1834__i;}\n  args = new cljs.core.IndexedSeq(G__1834__a,0,null);\n} \nreturn G__1833__delegate.call(this,x,y,z,args);};\nG__1833.cljs$lang$maxFixedArity = 3;\nG__1833.cljs$lang$applyTo = (function (arglist__1835){\nvar x = cljs.core.first(arglist__1835);\narglist__1835 = cljs.core.next(arglist__1835);\nvar y = cljs.core.first(arglist__1835);\narglist__1835 = cljs.core.next(arglist__1835);\nvar z = cljs.core.first(arglist__1835);\nvar args = cljs.core.rest(arglist__1835);\nreturn G__1833__delegate(x,y,z,args);\n});\nG__1833.cljs$core$IFn$_invoke$arity$variadic = G__1833__delegate;\nreturn G__1833;\n})()\n;\ncljs$core$sp1 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$sp1__0.call(this);\ncase 1:\nreturn cljs$core$sp1__1.call(this,x);\ncase 2:\nreturn cljs$core$sp1__2.call(this,x,y);\ncase 3:\nreturn cljs$core$sp1__3.call(this,x,y,z);\ndefault:\nvar G__1836 = null;\nif (arguments.length > 3) {\nvar G__1837__i = 0, G__1837__a = new Array(arguments.length -  3);\nwhile (G__1837__i < G__1837__a.length) {G__1837__a[G__1837__i] = arguments[G__1837__i + 3]; ++G__1837__i;}\nG__1836 = new cljs.core.IndexedSeq(G__1837__a,0,null);\n}\nreturn cljs$core$sp1__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1836);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$sp1.cljs$lang$maxFixedArity = 3;\ncljs$core$sp1.cljs$lang$applyTo = cljs$core$sp1__4.cljs$lang$applyTo;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$0 = cljs$core$sp1__0;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$1 = cljs$core$sp1__1;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$2 = cljs$core$sp1__2;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$3 = cljs$core$sp1__3;\ncljs$core$sp1.cljs$core$IFn$_invoke$arity$variadic = cljs$core$sp1__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$sp1;\n})()\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$2 = (function (p1,p2){\nreturn (function() {\nvar cljs$core$sp2 = null;\nvar cljs$core$sp2__0 = (function (){\nreturn null;\n});\nvar cljs$core$sp2__1 = (function (x){\nvar or__4131__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\n}\n});\nvar cljs$core$sp2__2 = (function (x,y){\nvar or__4131__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\n}\n}\n}\n});\nvar cljs$core$sp2__3 = (function (x,y,z){\nvar or__4131__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar or__4131__auto____$3 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nvar or__4131__auto____$4 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$4)){\nreturn or__4131__auto____$4;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\n}\n}\n}\n}\n}\n});\nvar cljs$core$sp2__4 = (function() { \nvar G__1838__delegate = function (x,y,z,args){\nvar or__4131__auto__ = cljs$core$sp2.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(((function (or__4131__auto__){\nreturn (function (p1__1817_SHARP_){\nvar or__4131__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__1817_SHARP_) : p1.call(null,p1__1817_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__1817_SHARP_) : p2.call(null,p1__1817_SHARP_));\n}\n});})(or__4131__auto__))\n,args);\n}\n};\nvar G__1838 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1839__i = 0, G__1839__a = new Array(arguments.length -  3);\nwhile (G__1839__i < G__1839__a.length) {G__1839__a[G__1839__i] = arguments[G__1839__i + 3]; ++G__1839__i;}\n  args = new cljs.core.IndexedSeq(G__1839__a,0,null);\n} \nreturn G__1838__delegate.call(this,x,y,z,args);};\nG__1838.cljs$lang$maxFixedArity = 3;\nG__1838.cljs$lang$applyTo = (function (arglist__1840){\nvar x = cljs.core.first(arglist__1840);\narglist__1840 = cljs.core.next(arglist__1840);\nvar y = cljs.core.first(arglist__1840);\narglist__1840 = cljs.core.next(arglist__1840);\nvar z = cljs.core.first(arglist__1840);\nvar args = cljs.core.rest(arglist__1840);\nreturn G__1838__delegate(x,y,z,args);\n});\nG__1838.cljs$core$IFn$_invoke$arity$variadic = G__1838__delegate;\nreturn G__1838;\n})()\n;\ncljs$core$sp2 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$sp2__0.call(this);\ncase 1:\nreturn cljs$core$sp2__1.call(this,x);\ncase 2:\nreturn cljs$core$sp2__2.call(this,x,y);\ncase 3:\nreturn cljs$core$sp2__3.call(this,x,y,z);\ndefault:\nvar G__1841 = null;\nif (arguments.length > 3) {\nvar G__1842__i = 0, G__1842__a = new Array(arguments.length -  3);\nwhile (G__1842__i < G__1842__a.length) {G__1842__a[G__1842__i] = arguments[G__1842__i + 3]; ++G__1842__i;}\nG__1841 = new cljs.core.IndexedSeq(G__1842__a,0,null);\n}\nreturn cljs$core$sp2__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1841);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$sp2.cljs$lang$maxFixedArity = 3;\ncljs$core$sp2.cljs$lang$applyTo = cljs$core$sp2__4.cljs$lang$applyTo;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$0 = cljs$core$sp2__0;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$1 = cljs$core$sp2__1;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$2 = cljs$core$sp2__2;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$3 = cljs$core$sp2__3;\ncljs$core$sp2.cljs$core$IFn$_invoke$arity$variadic = cljs$core$sp2__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$sp2;\n})()\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$3 = (function (p1,p2,p3){\nreturn (function() {\nvar cljs$core$sp3 = null;\nvar cljs$core$sp3__0 = (function (){\nreturn null;\n});\nvar cljs$core$sp3__1 = (function (x){\nvar or__4131__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\n}\n}\n});\nvar cljs$core$sp3__2 = (function (x,y){\nvar or__4131__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar or__4131__auto____$3 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nvar or__4131__auto____$4 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$4)){\nreturn or__4131__auto____$4;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\n}\n}\n}\n}\n}\n});\nvar cljs$core$sp3__3 = (function (x,y,z){\nvar or__4131__auto__ = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(x) : p1.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(x) : p2.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(x) : p3.call(null,x));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nvar or__4131__auto____$3 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(y) : p1.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$3)){\nreturn or__4131__auto____$3;\n} else {\nvar or__4131__auto____$4 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(y) : p2.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$4)){\nreturn or__4131__auto____$4;\n} else {\nvar or__4131__auto____$5 = (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(y) : p3.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$5)){\nreturn or__4131__auto____$5;\n} else {\nvar or__4131__auto____$6 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(z) : p1.call(null,z));\nif(cljs.core.truth_(or__4131__auto____$6)){\nreturn or__4131__auto____$6;\n} else {\nvar or__4131__auto____$7 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(z) : p2.call(null,z));\nif(cljs.core.truth_(or__4131__auto____$7)){\nreturn or__4131__auto____$7;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(z) : p3.call(null,z));\n}\n}\n}\n}\n}\n}\n}\n}\n});\nvar cljs$core$sp3__4 = (function() { \nvar G__1843__delegate = function (x,y,z,args){\nvar or__4131__auto__ = cljs$core$sp3.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(((function (or__4131__auto__){\nreturn (function (p1__1818_SHARP_){\nvar or__4131__auto____$1 = (p1.cljs$core$IFn$_invoke$arity$1 ? p1.cljs$core$IFn$_invoke$arity$1(p1__1818_SHARP_) : p1.call(null,p1__1818_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (p2.cljs$core$IFn$_invoke$arity$1 ? p2.cljs$core$IFn$_invoke$arity$1(p1__1818_SHARP_) : p2.call(null,p1__1818_SHARP_));\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn (p3.cljs$core$IFn$_invoke$arity$1 ? p3.cljs$core$IFn$_invoke$arity$1(p1__1818_SHARP_) : p3.call(null,p1__1818_SHARP_));\n}\n}\n});})(or__4131__auto__))\n,args);\n}\n};\nvar G__1843 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1844__i = 0, G__1844__a = new Array(arguments.length -  3);\nwhile (G__1844__i < G__1844__a.length) {G__1844__a[G__1844__i] = arguments[G__1844__i + 3]; ++G__1844__i;}\n  args = new cljs.core.IndexedSeq(G__1844__a,0,null);\n} \nreturn G__1843__delegate.call(this,x,y,z,args);};\nG__1843.cljs$lang$maxFixedArity = 3;\nG__1843.cljs$lang$applyTo = (function (arglist__1845){\nvar x = cljs.core.first(arglist__1845);\narglist__1845 = cljs.core.next(arglist__1845);\nvar y = cljs.core.first(arglist__1845);\narglist__1845 = cljs.core.next(arglist__1845);\nvar z = cljs.core.first(arglist__1845);\nvar args = cljs.core.rest(arglist__1845);\nreturn G__1843__delegate(x,y,z,args);\n});\nG__1843.cljs$core$IFn$_invoke$arity$variadic = G__1843__delegate;\nreturn G__1843;\n})()\n;\ncljs$core$sp3 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$sp3__0.call(this);\ncase 1:\nreturn cljs$core$sp3__1.call(this,x);\ncase 2:\nreturn cljs$core$sp3__2.call(this,x,y);\ncase 3:\nreturn cljs$core$sp3__3.call(this,x,y,z);\ndefault:\nvar G__1846 = null;\nif (arguments.length > 3) {\nvar G__1847__i = 0, G__1847__a = new Array(arguments.length -  3);\nwhile (G__1847__i < G__1847__a.length) {G__1847__a[G__1847__i] = arguments[G__1847__i + 3]; ++G__1847__i;}\nG__1846 = new cljs.core.IndexedSeq(G__1847__a,0,null);\n}\nreturn cljs$core$sp3__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1846);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$sp3.cljs$lang$maxFixedArity = 3;\ncljs$core$sp3.cljs$lang$applyTo = cljs$core$sp3__4.cljs$lang$applyTo;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$0 = cljs$core$sp3__0;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$1 = cljs$core$sp3__1;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$2 = cljs$core$sp3__2;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$3 = cljs$core$sp3__3;\ncljs$core$sp3.cljs$core$IFn$_invoke$arity$variadic = cljs$core$sp3__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$sp3;\n})()\n});\n\ncljs.core.some_fn.cljs$core$IFn$_invoke$arity$variadic = (function (p1,p2,p3,ps){\nvar ps__$1 = cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(p1,p2,p3,ps);\nreturn ((function (ps__$1){\nreturn (function() {\nvar cljs$core$spn = null;\nvar cljs$core$spn__0 = (function (){\nreturn null;\n});\nvar cljs$core$spn__1 = (function (x){\nreturn cljs.core.some(((function (ps__$1){\nreturn (function (p1__1819_SHARP_){\nreturn (p1__1819_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1819_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__1819_SHARP_.call(null,x));\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$spn__2 = (function (x,y){\nreturn cljs.core.some(((function (ps__$1){\nreturn (function (p1__1820_SHARP_){\nvar or__4131__auto__ = (p1__1820_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1820_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__1820_SHARP_.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (p1__1820_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1820_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__1820_SHARP_.call(null,y));\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$spn__3 = (function (x,y,z){\nreturn cljs.core.some(((function (ps__$1){\nreturn (function (p1__1821_SHARP_){\nvar or__4131__auto__ = (p1__1821_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1821_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p1__1821_SHARP_.call(null,x));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (p1__1821_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1821_SHARP_.cljs$core$IFn$_invoke$arity$1(y) : p1__1821_SHARP_.call(null,y));\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn (p1__1821_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p1__1821_SHARP_.cljs$core$IFn$_invoke$arity$1(z) : p1__1821_SHARP_.call(null,z));\n}\n}\n});})(ps__$1))\n,ps__$1);\n});\nvar cljs$core$spn__4 = (function() { \nvar G__1848__delegate = function (x,y,z,args){\nvar or__4131__auto__ = cljs$core$spn.cljs$core$IFn$_invoke$arity$3(x,y,z);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.some(((function (or__4131__auto__,ps__$1){\nreturn (function (p1__1822_SHARP_){\nreturn cljs.core.some(p1__1822_SHARP_,args);\n});})(or__4131__auto__,ps__$1))\n,ps__$1);\n}\n};\nvar G__1848 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__1849__i = 0, G__1849__a = new Array(arguments.length -  3);\nwhile (G__1849__i < G__1849__a.length) {G__1849__a[G__1849__i] = arguments[G__1849__i + 3]; ++G__1849__i;}\n  args = new cljs.core.IndexedSeq(G__1849__a,0,null);\n} \nreturn G__1848__delegate.call(this,x,y,z,args);};\nG__1848.cljs$lang$maxFixedArity = 3;\nG__1848.cljs$lang$applyTo = (function (arglist__1850){\nvar x = cljs.core.first(arglist__1850);\narglist__1850 = cljs.core.next(arglist__1850);\nvar y = cljs.core.first(arglist__1850);\narglist__1850 = cljs.core.next(arglist__1850);\nvar z = cljs.core.first(arglist__1850);\nvar args = cljs.core.rest(arglist__1850);\nreturn G__1848__delegate(x,y,z,args);\n});\nG__1848.cljs$core$IFn$_invoke$arity$variadic = G__1848__delegate;\nreturn G__1848;\n})()\n;\ncljs$core$spn = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn cljs$core$spn__0.call(this);\ncase 1:\nreturn cljs$core$spn__1.call(this,x);\ncase 2:\nreturn cljs$core$spn__2.call(this,x,y);\ncase 3:\nreturn cljs$core$spn__3.call(this,x,y,z);\ndefault:\nvar G__1851 = null;\nif (arguments.length > 3) {\nvar G__1852__i = 0, G__1852__a = new Array(arguments.length -  3);\nwhile (G__1852__i < G__1852__a.length) {G__1852__a[G__1852__i] = arguments[G__1852__i + 3]; ++G__1852__i;}\nG__1851 = new cljs.core.IndexedSeq(G__1852__a,0,null);\n}\nreturn cljs$core$spn__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__1851);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\ncljs$core$spn.cljs$lang$maxFixedArity = 3;\ncljs$core$spn.cljs$lang$applyTo = cljs$core$spn__4.cljs$lang$applyTo;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$0 = cljs$core$spn__0;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$1 = cljs$core$spn__1;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$2 = cljs$core$spn__2;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$3 = cljs$core$spn__3;\ncljs$core$spn.cljs$core$IFn$_invoke$arity$variadic = cljs$core$spn__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn cljs$core$spn;\n})()\n;})(ps__$1))\n});\n\n/** @this {Function} */\ncljs.core.some_fn.cljs$lang$applyTo = (function (seq1824){\nvar G__1825 = cljs.core.first(seq1824);\nvar seq1824__$1 = cljs.core.next(seq1824);\nvar G__1826 = cljs.core.first(seq1824__$1);\nvar seq1824__$2 = cljs.core.next(seq1824__$1);\nvar G__1827 = cljs.core.first(seq1824__$2);\nvar seq1824__$3 = cljs.core.next(seq1824__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1825,G__1826,G__1827,seq1824__$3);\n});\n\ncljs.core.some_fn.cljs$lang$maxFixedArity = (3);\n\n/**\n * Returns a lazy sequence consisting of the result of applying f to\n *   the set of first items of each coll, followed by applying f to the\n *   set of second items in each coll, until any one of the colls is\n *   exhausted.  Any remaining items in other colls are ignored. Function\n *   f should accept number-of-colls arguments. Returns a transducer when\n *   no collection is provided.\n */\ncljs.core.map = (function cljs$core$map(var_args){\nvar G__1860 = arguments.length;\nswitch (G__1860) {\ncase 1:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1873 = arguments.length;\nvar i__4731__auto___1874 = (0);\nwhile(true){\nif((i__4731__auto___1874 < len__4730__auto___1873)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1874]));\n\nvar G__1875 = (i__4731__auto___1874 + (1));\ni__4731__auto___1874 = G__1875;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (rf){\nreturn (function() {\nvar G__1876 = null;\nvar G__1876__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1876__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1876__2 = (function (result,input){\nvar G__1861 = result;\nvar G__1862 = (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(input) : f.call(null,input));\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(G__1861,G__1862) : rf.call(null,G__1861,G__1862));\n});\nvar G__1876__3 = (function() { \nvar G__1877__delegate = function (result,input,inputs){\nvar G__1863 = result;\nvar G__1864 = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(f,input,inputs);\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(G__1863,G__1864) : rf.call(null,G__1863,G__1864));\n};\nvar G__1877 = function (result,input,var_args){\nvar inputs = null;\nif (arguments.length > 2) {\nvar G__1878__i = 0, G__1878__a = new Array(arguments.length -  2);\nwhile (G__1878__i < G__1878__a.length) {G__1878__a[G__1878__i] = arguments[G__1878__i + 2]; ++G__1878__i;}\n  inputs = new cljs.core.IndexedSeq(G__1878__a,0,null);\n} \nreturn G__1877__delegate.call(this,result,input,inputs);};\nG__1877.cljs$lang$maxFixedArity = 2;\nG__1877.cljs$lang$applyTo = (function (arglist__1879){\nvar result = cljs.core.first(arglist__1879);\narglist__1879 = cljs.core.next(arglist__1879);\nvar input = cljs.core.first(arglist__1879);\nvar inputs = cljs.core.rest(arglist__1879);\nreturn G__1877__delegate(result,input,inputs);\n});\nG__1877.cljs$core$IFn$_invoke$arity$variadic = G__1877__delegate;\nreturn G__1877;\n})()\n;\nG__1876 = function(result,input,var_args){\nvar inputs = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__1876__0.call(this);\ncase 1:\nreturn G__1876__1.call(this,result);\ncase 2:\nreturn G__1876__2.call(this,result,input);\ndefault:\nvar G__1880 = null;\nif (arguments.length > 2) {\nvar G__1881__i = 0, G__1881__a = new Array(arguments.length -  2);\nwhile (G__1881__i < G__1881__a.length) {G__1881__a[G__1881__i] = arguments[G__1881__i + 2]; ++G__1881__i;}\nG__1880 = new cljs.core.IndexedSeq(G__1881__a,0,null);\n}\nreturn G__1876__3.cljs$core$IFn$_invoke$arity$variadic(result,input, G__1880);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1876.cljs$lang$maxFixedArity = 2;\nG__1876.cljs$lang$applyTo = G__1876__3.cljs$lang$applyTo;\nG__1876.cljs$core$IFn$_invoke$arity$0 = G__1876__0;\nG__1876.cljs$core$IFn$_invoke$arity$1 = G__1876__1;\nG__1876.cljs$core$IFn$_invoke$arity$2 = G__1876__2;\nG__1876.cljs$core$IFn$_invoke$arity$variadic = G__1876__3.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__1876;\n})()\n});\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c = cljs.core.chunk_first(s);\nvar size = cljs.core.count(c);\nvar b = cljs.core.chunk_buffer(size);\nvar n__4607__auto___1882 = size;\nvar i_1883 = (0);\nwhile(true){\nif((i_1883 < n__4607__auto___1882)){\ncljs.core.chunk_append(b,(function (){var G__1865 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_1883);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1865) : f.call(null,G__1865));\n})());\n\nvar G__1884 = (i_1883 + (1));\ni_1883 = G__1884;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,cljs.core.chunk_rest(s)));\n} else {\nreturn cljs.core.cons((function (){var G__1866 = cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__1866) : f.call(null,G__1866));\n})(),cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,cljs.core.rest(s)));\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$3 = (function (f,c1,c2){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s1 = cljs.core.seq(c1);\nvar s2 = cljs.core.seq(c2);\nif(((s1) && (s2))){\nreturn cljs.core.cons((function (){var G__1867 = cljs.core.first(s1);\nvar G__1868 = cljs.core.first(s2);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1867,G__1868) : f.call(null,G__1867,G__1868));\n})(),cljs.core.map.cljs$core$IFn$_invoke$arity$3(f,cljs.core.rest(s1),cljs.core.rest(s2)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$4 = (function (f,c1,c2,c3){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s1 = cljs.core.seq(c1);\nvar s2 = cljs.core.seq(c2);\nvar s3 = cljs.core.seq(c3);\nif(((s1) && (s2) && (s3))){\nreturn cljs.core.cons((function (){var G__1869 = cljs.core.first(s1);\nvar G__1870 = cljs.core.first(s2);\nvar G__1871 = cljs.core.first(s3);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__1869,G__1870,G__1871) : f.call(null,G__1869,G__1870,G__1871));\n})(),cljs.core.map.cljs$core$IFn$_invoke$arity$4(f,cljs.core.rest(s1),cljs.core.rest(s2),cljs.core.rest(s3)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.map.cljs$core$IFn$_invoke$arity$variadic = (function (f,c1,c2,c3,colls){\nvar step = (function cljs$core$step(cs){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar ss = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.seq,cs);\nif(cljs.core.every_QMARK_(cljs.core.identity,ss)){\nreturn cljs.core.cons(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,ss),cljs$core$step(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.rest,ss)));\n} else {\nreturn null;\n}\n}),null,null));\n});\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (step){\nreturn (function (p1__1853_SHARP_){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,p1__1853_SHARP_);\n});})(step))\n,step(cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(colls,c3,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([c2,c1], 0))));\n});\n\n/** @this {Function} */\ncljs.core.map.cljs$lang$applyTo = (function (seq1855){\nvar G__1856 = cljs.core.first(seq1855);\nvar seq1855__$1 = cljs.core.next(seq1855);\nvar G__1857 = cljs.core.first(seq1855__$1);\nvar seq1855__$2 = cljs.core.next(seq1855__$1);\nvar G__1858 = cljs.core.first(seq1855__$2);\nvar seq1855__$3 = cljs.core.next(seq1855__$2);\nvar G__1859 = cljs.core.first(seq1855__$3);\nvar seq1855__$4 = cljs.core.next(seq1855__$3);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1856,G__1857,G__1858,G__1859,seq1855__$4);\n});\n\ncljs.core.map.cljs$lang$maxFixedArity = (4);\n\n/**\n * Returns a lazy sequence of the first n items in coll, or all items if\n *   there are fewer than n.  Returns a stateful transducer when\n *   no collection is provided.\n */\ncljs.core.take = (function cljs$core$take(var_args){\nvar G__1886 = arguments.length;\nswitch (G__1886) {\ncase 1:\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.take.cljs$core$IFn$_invoke$arity$1 = (function (n){\nif(typeof n === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? n)\"));\n}\n\nreturn (function (rf){\nvar na = cljs.core.volatile_BANG_(n);\nreturn ((function (na){\nreturn (function() {\nvar G__1888 = null;\nvar G__1888__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1888__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1888__2 = (function (result,input){\nvar n__$1 = cljs.core.deref(na);\nvar nn = na.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(na.cljs$core$IDeref$_deref$arity$1(null) - (1)));\nvar result__$1 = (((n__$1 > (0)))?(rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input)):result);\nif((!((nn > (0))))){\nreturn cljs.core.ensure_reduced(result__$1);\n} else {\nreturn result__$1;\n}\n});\nG__1888 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1888__0.call(this);\ncase 1:\nreturn G__1888__1.call(this,result);\ncase 2:\nreturn G__1888__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1888.cljs$core$IFn$_invoke$arity$0 = G__1888__0;\nG__1888.cljs$core$IFn$_invoke$arity$1 = G__1888__1;\nG__1888.cljs$core$IFn$_invoke$arity$2 = G__1888__2;\nreturn G__1888;\n})()\n;})(na))\n});\n});\n\ncljs.core.take.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nif(typeof n === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? n)\"));\n}\n\nreturn (new cljs.core.LazySeq(null,(function (){\nif((n > (0))){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.take.cljs$core$IFn$_invoke$arity$2((n - (1)),cljs.core.rest(s)));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.take.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a lazy sequence of all but the first n items in coll.\n *   Returns a stateful transducer when no collection is provided.\n */\ncljs.core.drop = (function cljs$core$drop(var_args){\nvar G__1890 = arguments.length;\nswitch (G__1890) {\ncase 1:\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.drop.cljs$core$IFn$_invoke$arity$1 = (function (n){\nif(typeof n === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? n)\"));\n}\n\nreturn (function (rf){\nvar na = cljs.core.volatile_BANG_(n);\nreturn ((function (na){\nreturn (function() {\nvar G__1892 = null;\nvar G__1892__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1892__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1892__2 = (function (result,input){\nvar n__$1 = cljs.core.deref(na);\nna.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(na.cljs$core$IDeref$_deref$arity$1(null) - (1)));\n\nif((n__$1 > (0))){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__1892 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1892__0.call(this);\ncase 1:\nreturn G__1892__1.call(this,result);\ncase 2:\nreturn G__1892__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1892.cljs$core$IFn$_invoke$arity$0 = G__1892__0;\nG__1892.cljs$core$IFn$_invoke$arity$1 = G__1892__1;\nG__1892.cljs$core$IFn$_invoke$arity$2 = G__1892__2;\nreturn G__1892;\n})()\n;})(na))\n});\n});\n\ncljs.core.drop.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nif(typeof n === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? n)\"));\n}\n\nvar step = (function (n__$1,coll__$1){\nwhile(true){\nvar s = cljs.core.seq(coll__$1);\nif((((n__$1 > (0))) && (s))){\nvar G__1893 = (n__$1 - (1));\nvar G__1894 = cljs.core.rest(s);\nn__$1 = G__1893;\ncoll__$1 = G__1894;\ncontinue;\n} else {\nreturn s;\n}\nbreak;\n}\n});\nreturn (new cljs.core.LazySeq(null,((function (step){\nreturn (function (){\nreturn step(n,coll);\n});})(step))\n,null,null));\n});\n\ncljs.core.drop.cljs$lang$maxFixedArity = 2;\n\n/**\n * Return a lazy sequence of all but the last n (default 1) items in coll\n */\ncljs.core.drop_last = (function cljs$core$drop_last(var_args){\nvar G__1896 = arguments.length;\nswitch (G__1896) {\ncase 1:\nreturn cljs.core.drop_last.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.drop_last.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn cljs.core.drop_last.cljs$core$IFn$_invoke$arity$2((1),s);\n});\n\ncljs.core.drop_last.cljs$core$IFn$_invoke$arity$2 = (function (n,s){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3((function (x,_){\nreturn x;\n}),s,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,s));\n});\n\ncljs.core.drop_last.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a seq of the last n items in coll.  Depending on the type\n *   of coll may be no better than linear time.  For vectors, see also subvec.\n */\ncljs.core.take_last = (function cljs$core$take_last(n,coll){\nvar s = cljs.core.seq(coll);\nvar lead = cljs.core.seq(cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,coll));\nwhile(true){\nif(lead){\nvar G__1898 = cljs.core.next(s);\nvar G__1899 = cljs.core.next(lead);\ns = G__1898;\nlead = G__1899;\ncontinue;\n} else {\nreturn s;\n}\nbreak;\n}\n});\n/**\n * Returns a lazy sequence of the items in coll starting from the\n *   first item for which (pred item) returns logical false.  Returns a\n *   stateful transducer when no collection is provided.\n */\ncljs.core.drop_while = (function cljs$core$drop_while(var_args){\nvar G__1901 = arguments.length;\nswitch (G__1901) {\ncase 1:\nreturn cljs.core.drop_while.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.drop_while.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn (function (rf){\nvar da = cljs.core.volatile_BANG_(true);\nreturn ((function (da){\nreturn (function() {\nvar G__1905 = null;\nvar G__1905__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1905__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1905__2 = (function (result,input){\nvar drop_QMARK_ = cljs.core.deref(da);\nif(cljs.core.truth_((function (){var and__4120__auto__ = drop_QMARK_;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn result;\n} else {\ncljs.core.vreset_BANG_(da,null);\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__1905 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1905__0.call(this);\ncase 1:\nreturn G__1905__1.call(this,result);\ncase 2:\nreturn G__1905__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1905.cljs$core$IFn$_invoke$arity$0 = G__1905__0;\nG__1905.cljs$core$IFn$_invoke$arity$1 = G__1905__1;\nG__1905.cljs$core$IFn$_invoke$arity$2 = G__1905__2;\nreturn G__1905;\n})()\n;})(da))\n});\n});\n\ncljs.core.drop_while.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nvar step = (function (pred__$1,coll__$1){\nwhile(true){\nvar s = cljs.core.seq(coll__$1);\nif(cljs.core.truth_((function (){var and__4120__auto__ = s;\nif(and__4120__auto__){\nvar G__1903 = cljs.core.first(s);\nreturn (pred__$1.cljs$core$IFn$_invoke$arity$1 ? pred__$1.cljs$core$IFn$_invoke$arity$1(G__1903) : pred__$1.call(null,G__1903));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar G__1906 = pred__$1;\nvar G__1907 = cljs.core.rest(s);\npred__$1 = G__1906;\ncoll__$1 = G__1907;\ncontinue;\n} else {\nreturn s;\n}\nbreak;\n}\n});\nreturn (new cljs.core.LazySeq(null,((function (step){\nreturn (function (){\nreturn step(pred,coll);\n});})(step))\n,null,null));\n});\n\ncljs.core.drop_while.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Cycle = (function (meta,all,prev,current,_next){\nthis.meta = meta;\nthis.all = all;\nthis.prev = prev;\nthis.current = current;\nthis._next = _next;\nthis.cljs$lang$protocol_mask$partition0$ = 26083532;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\ncljs.core.Cycle.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Cycle.prototype.currentval = (function (){\nvar self__ = this;\nvar coll = this;\nif(self__.current){\n} else {\nvar temp__5718__auto___1914 = cljs.core.next(self__.prev);\nif(temp__5718__auto___1914){\nvar c_1915 = temp__5718__auto___1914;\nself__.current = c_1915;\n} else {\nself__.current = self__.all;\n}\n}\n\nreturn self__.current;\n});\n\ncljs.core.Cycle.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Cycle.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ISeq$_rest$arity$1(null);\n});\n\ncljs.core.Cycle.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Cycle.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (!((self__.current == null)));\n});\n\ncljs.core.Cycle.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nvar s = coll__$1.currentval();\nvar ret = cljs.core.first(s);\nwhile(true){\nvar s__$1 = (function (){var or__4131__auto__ = cljs.core.next(s);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn self__.all;\n}\n})();\nvar ret__$1 = (function (){var G__1910 = ret;\nvar G__1911 = cljs.core.first(s__$1);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1910,G__1911) : f.call(null,G__1910,G__1911));\n})();\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__1916 = s__$1;\nvar G__1917 = ret__$1;\ns = G__1916;\nret = G__1917;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Cycle.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nvar s = coll__$1.currentval();\nvar ret = start;\nwhile(true){\nvar ret__$1 = (function (){var G__1912 = ret;\nvar G__1913 = cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__1912,G__1913) : f.call(null,G__1912,G__1913));\n})();\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__1918 = (function (){var or__4131__auto__ = cljs.core.next(s);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn self__.all;\n}\n})();\nvar G__1919 = ret__$1;\ns = G__1918;\nret = G__1919;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Cycle.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.first(coll__$1.currentval());\n});\n\ncljs.core.Cycle.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__._next == null)){\nself__._next = (new cljs.core.Cycle(null,self__.all,coll__$1.currentval(),null,null));\n} else {\n}\n\nreturn self__._next;\n});\n\ncljs.core.Cycle.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.Cycle.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Cycle(new_meta,self__.all,self__.prev,self__.current,self__._next));\n}\n});\n\ncljs.core.Cycle.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.Cycle.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"all\",\"all\",-1762306027,null),new cljs.core.Symbol(null,\"prev\",\"prev\",43462301,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"current\",\"current\",552492924,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"_next\",\"_next\",101877036,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Cycle.cljs$lang$type = true;\n\ncljs.core.Cycle.cljs$lang$ctorStr = \"cljs.core/Cycle\";\n\ncljs.core.Cycle.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Cycle\");\n});\n\n/**\n * Positional factory function for cljs.core/Cycle.\n */\ncljs.core.__GT_Cycle = (function cljs$core$__GT_Cycle(meta,all,prev,current,_next){\nreturn (new cljs.core.Cycle(meta,all,prev,current,_next));\n});\n\n/**\n * Returns a lazy (infinite!) sequence of repetitions of the items in coll.\n */\ncljs.core.cycle = (function cljs$core$cycle(coll){\nvar temp__5718__auto__ = cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar vals = temp__5718__auto__;\nreturn (new cljs.core.Cycle(null,vals,null,vals,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n/**\n * Returns a vector of [(take n coll) (drop n coll)]\n */\ncljs.core.split_at = (function cljs$core$split_at(n,coll){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,coll),cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,coll)], null);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Repeat = (function (meta,count,val,next,__hash){\nthis.meta = meta;\nthis.count = count;\nthis.val = val;\nthis.next = next;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32374988;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\ncljs.core.Repeat.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Repeat.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Repeat.prototype.indexOf = (function() {\nvar G__1920 = null;\nvar G__1920__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__1920__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1920 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1920__1.call(this,x);\ncase 2:\nreturn G__1920__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1920.cljs$core$IFn$_invoke$arity$1 = G__1920__1;\nG__1920.cljs$core$IFn$_invoke$arity$2 = G__1920__2;\nreturn G__1920;\n})()\n;\n\ncljs.core.Repeat.prototype.lastIndexOf = (function() {\nvar G__1921 = null;\nvar G__1921__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,self__.count);\n});\nvar G__1921__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__1921 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__1921__1.call(this,x);\ncase 2:\nreturn G__1921__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1921.cljs$core$IFn$_invoke$arity$1 = G__1921__1;\nG__1921.cljs$core$IFn$_invoke$arity$2 = G__1921__2;\nreturn G__1921;\n})()\n;\n\ncljs.core.Repeat.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Repeat.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.next == null)){\nif((self__.count > (1))){\nself__.next = (new cljs.core.Repeat(null,(self__.count - (1)),self__.val,null,null));\n\nreturn self__.next;\n} else {\nif(((-1) === self__.count)){\nreturn coll__$1;\n} else {\nreturn null;\n}\n}\n} else {\nreturn self__.next;\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.Repeat.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Repeat.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn false;\n});\n\ncljs.core.Repeat.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.count === (-1))){\nvar ret = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(self__.val,self__.val) : f.call(null,self__.val,self__.val));\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar G__1922 = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nret = G__1922;\ncontinue;\n}\nbreak;\n}\n} else {\nvar i = (1);\nvar ret = self__.val;\nwhile(true){\nif((i < self__.count)){\nvar ret__$1 = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__1923 = (i + (1));\nvar G__1924 = ret__$1;\ni = G__1923;\nret = G__1924;\ncontinue;\n}\n} else {\nreturn ret;\n}\nbreak;\n}\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.count === (-1))){\nvar ret = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(start,self__.val) : f.call(null,start,self__.val));\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar G__1925 = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nret = G__1925;\ncontinue;\n}\nbreak;\n}\n} else {\nvar i = (0);\nvar ret = start;\nwhile(true){\nif((i < self__.count)){\nvar ret__$1 = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,self__.val) : f.call(null,ret,self__.val));\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__1926 = (i + (1));\nvar G__1927 = ret__$1;\ni = G__1926;\nret = G__1927;\ncontinue;\n}\n} else {\nreturn ret;\n}\nbreak;\n}\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.Repeat.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.next == null)){\nif((self__.count > (1))){\nself__.next = (new cljs.core.Repeat(null,(self__.count - (1)),self__.val,null,null));\n\nreturn self__.next;\n} else {\nif(((-1) === self__.count)){\nreturn coll__$1;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n}\n} else {\nreturn self__.next;\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.Repeat.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Repeat(new_meta,self__.count,self__.val,self__.next,null));\n}\n});\n\ncljs.core.Repeat.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.Repeat.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"count\",\"count\",-514511684,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"next\",\"next\",1522830042,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Repeat.cljs$lang$type = true;\n\ncljs.core.Repeat.cljs$lang$ctorStr = \"cljs.core/Repeat\";\n\ncljs.core.Repeat.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Repeat\");\n});\n\n/**\n * Positional factory function for cljs.core/Repeat.\n */\ncljs.core.__GT_Repeat = (function cljs$core$__GT_Repeat(meta,count,val,next,__hash){\nreturn (new cljs.core.Repeat(meta,count,val,next,__hash));\n});\n\n/**\n * Returns a lazy (infinite!, or length n if supplied) sequence of xs.\n */\ncljs.core.repeat = (function cljs$core$repeat(var_args){\nvar G__1929 = arguments.length;\nswitch (G__1929) {\ncase 1:\nreturn cljs.core.repeat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.repeat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.repeat.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn (new cljs.core.Repeat(null,(-1),x,null,null));\n});\n\ncljs.core.repeat.cljs$core$IFn$_invoke$arity$2 = (function (n,x){\nif((n > (0))){\nreturn (new cljs.core.Repeat(null,n,x,null,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.repeat.cljs$lang$maxFixedArity = 2;\n\n/**\n * DEPRECATED: Use 'repeat' instead.\n *   Returns a lazy seq of n xs.\n */\ncljs.core.replicate = (function cljs$core$replicate(n,x){\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(x));\n});\n/**\n * Takes a function of no args, presumably with side effects, and\n *   returns an infinite (or length n if supplied) lazy sequence of calls\n *   to it\n */\ncljs.core.repeatedly = (function cljs$core$repeatedly(var_args){\nvar G__1932 = arguments.length;\nswitch (G__1932) {\ncase 1:\nreturn cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn cljs.core.cons((f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1(f));\n}),null,null));\n});\n\ncljs.core.repeatedly.cljs$core$IFn$_invoke$arity$2 = (function (n,f){\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1(f));\n});\n\ncljs.core.repeatedly.cljs$lang$maxFixedArity = 2;\n\ncljs.core.UNREALIZED_SEED = ({});\n\n/**\n* @constructor\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Iterate = (function (meta,f,prev_seed,seed,next){\nthis.meta = meta;\nthis.f = f;\nthis.prev_seed = prev_seed;\nthis.seed = seed;\nthis.next = next;\nthis.cljs$lang$protocol_mask$partition0$ = 26083532;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\ncljs.core.Iterate.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Iterate.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Iterate.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ISeq$_rest$arity$1(null);\n});\n\ncljs.core.Iterate.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Iterate.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (!((self__.seed === cljs.core.UNREALIZED_SEED)));\n});\n\ncljs.core.Iterate.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,rf){\nvar self__ = this;\nvar coll__$1 = this;\nvar first = coll__$1.cljs$core$ISeq$_first$arity$1(null);\nvar v = (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(first) : self__.f.call(null,first));\nvar ret = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(first,v) : rf.call(null,first,v));\nvar v__$1 = v;\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar v__$2 = (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(v__$1) : self__.f.call(null,v__$1));\nvar G__1934 = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(ret,v__$2) : rf.call(null,ret,v__$2));\nvar G__1935 = v__$2;\nret = G__1934;\nv__$1 = G__1935;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Iterate.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,rf,start){\nvar self__ = this;\nvar coll__$1 = this;\nvar v = coll__$1.cljs$core$ISeq$_first$arity$1(null);\nvar ret = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(start,v) : rf.call(null,start,v));\nvar v__$1 = v;\nwhile(true){\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.deref(ret);\n} else {\nvar v__$2 = (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(v__$1) : self__.f.call(null,v__$1));\nvar G__1936 = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(ret,v__$2) : rf.call(null,ret,v__$2));\nvar G__1937 = v__$2;\nret = G__1936;\nv__$1 = G__1937;\ncontinue;\n}\nbreak;\n}\n});\n\ncljs.core.Iterate.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((cljs.core.UNREALIZED_SEED === self__.seed)){\nself__.seed = (self__.f.cljs$core$IFn$_invoke$arity$1 ? self__.f.cljs$core$IFn$_invoke$arity$1(self__.prev_seed) : self__.f.call(null,self__.prev_seed));\n} else {\n}\n\nreturn self__.seed;\n});\n\ncljs.core.Iterate.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.next == null)){\nself__.next = (new cljs.core.Iterate(null,self__.f,coll__$1.cljs$core$ISeq$_first$arity$1(null),cljs.core.UNREALIZED_SEED,null));\n} else {\n}\n\nreturn self__.next;\n});\n\ncljs.core.Iterate.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.Iterate.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.Iterate(new_meta,self__.f,self__.prev_seed,self__.seed,self__.next));\n}\n});\n\ncljs.core.Iterate.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.Iterate.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"prev-seed\",\"prev-seed\",2126381367,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"seed\",\"seed\",1709144854,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"next\",\"next\",1522830042,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Iterate.cljs$lang$type = true;\n\ncljs.core.Iterate.cljs$lang$ctorStr = \"cljs.core/Iterate\";\n\ncljs.core.Iterate.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Iterate\");\n});\n\n/**\n * Positional factory function for cljs.core/Iterate.\n */\ncljs.core.__GT_Iterate = (function cljs$core$__GT_Iterate(meta,f,prev_seed,seed,next){\nreturn (new cljs.core.Iterate(meta,f,prev_seed,seed,next));\n});\n\n/**\n * Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\n */\ncljs.core.iterate = (function cljs$core$iterate(f,x){\nreturn (new cljs.core.Iterate(null,f,null,x,null));\n});\n/**\n * Returns a lazy seq of the first item in each coll, then the second etc.\n */\ncljs.core.interleave = (function cljs$core$interleave(var_args){\nvar G__1942 = arguments.length;\nswitch (G__1942) {\ncase 0:\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1944 = arguments.length;\nvar i__4731__auto___1945 = (0);\nwhile(true){\nif((i__4731__auto___1945 < len__4730__auto___1944)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1945]));\n\nvar G__1946 = (i__4731__auto___1945 + (1));\ni__4731__auto___1945 = G__1946;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn cljs.core.interleave.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$1 = (function (c1){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn c1;\n}),null,null));\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$2 = (function (c1,c2){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s1 = cljs.core.seq(c1);\nvar s2 = cljs.core.seq(c2);\nif(((s1) && (s2))){\nreturn cljs.core.cons(cljs.core.first(s1),cljs.core.cons(cljs.core.first(s2),cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(cljs.core.rest(s1),cljs.core.rest(s2))));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.interleave.cljs$core$IFn$_invoke$arity$variadic = (function (c1,c2,colls){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar ss = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.seq,cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(colls,c2,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([c1], 0)));\nif(cljs.core.every_QMARK_(cljs.core.identity,ss)){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,ss),cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.interleave,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.rest,ss)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\n/** @this {Function} */\ncljs.core.interleave.cljs$lang$applyTo = (function (seq1939){\nvar G__1940 = cljs.core.first(seq1939);\nvar seq1939__$1 = cljs.core.next(seq1939);\nvar G__1941 = cljs.core.first(seq1939__$1);\nvar seq1939__$2 = cljs.core.next(seq1939__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1940,G__1941,seq1939__$2);\n});\n\ncljs.core.interleave.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a lazy seq of the elements of coll separated by sep.\n *   Returns a stateful transducer when no collection is provided.\n */\ncljs.core.interpose = (function cljs$core$interpose(var_args){\nvar G__1948 = arguments.length;\nswitch (G__1948) {\ncase 1:\nreturn cljs.core.interpose.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.interpose.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.interpose.cljs$core$IFn$_invoke$arity$1 = (function (sep){\nreturn (function (rf){\nvar started = cljs.core.volatile_BANG_(false);\nreturn ((function (started){\nreturn (function() {\nvar G__1950 = null;\nvar G__1950__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1950__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1950__2 = (function (result,input){\nif(cljs.core.truth_(cljs.core.deref(started))){\nvar sepr = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,sep) : rf.call(null,result,sep));\nif(cljs.core.reduced_QMARK_(sepr)){\nreturn sepr;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(sepr,input) : rf.call(null,sepr,input));\n}\n} else {\ncljs.core.vreset_BANG_(started,true);\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__1950 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1950__0.call(this);\ncase 1:\nreturn G__1950__1.call(this,result);\ncase 2:\nreturn G__1950__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1950.cljs$core$IFn$_invoke$arity$0 = G__1950__0;\nG__1950.cljs$core$IFn$_invoke$arity$1 = G__1950__1;\nG__1950.cljs$core$IFn$_invoke$arity$2 = G__1950__2;\nreturn G__1950;\n})()\n;})(started))\n});\n});\n\ncljs.core.interpose.cljs$core$IFn$_invoke$arity$2 = (function (sep,coll){\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2((1),cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(sep),coll));\n});\n\ncljs.core.interpose.cljs$lang$maxFixedArity = 2;\n\n/**\n * Take a collection of collections, and return a lazy seq\n *   of items from the inner collection\n */\ncljs.core.flatten1 = (function cljs$core$flatten1(colls){\nvar cat = (function cljs$core$flatten1_$_cat(coll,colls__$1){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5718__auto__ = cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar coll__$1 = temp__5718__auto__;\nreturn cljs.core.cons(cljs.core.first(coll__$1),cljs$core$flatten1_$_cat(cljs.core.rest(coll__$1),colls__$1));\n} else {\nif(cljs.core.seq(colls__$1)){\nreturn cljs$core$flatten1_$_cat(cljs.core.first(colls__$1),cljs.core.rest(colls__$1));\n} else {\nreturn null;\n}\n}\n}),null,null));\n});\nreturn cat(null,colls);\n});\n/**\n * Returns the result of applying concat to the result of applying map\n *   to f and colls.  Thus function f should return a collection. Returns\n *   a transducer when no collections are provided\n */\ncljs.core.mapcat = (function cljs$core$mapcat(var_args){\nvar G__1954 = arguments.length;\nswitch (G__1954) {\ncase 1:\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1956 = arguments.length;\nvar i__4731__auto___1957 = (0);\nwhile(true){\nif((i__4731__auto___1957 < len__4730__auto___1956)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1957]));\n\nvar G__1958 = (i__4731__auto___1957 + (1));\ni__4731__auto___1957 = G__1958;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.mapcat.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$1(f),cljs.core.cat);\n});\n\ncljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic = (function (f,colls){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.concat,cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.map,f,colls));\n});\n\n/** @this {Function} */\ncljs.core.mapcat.cljs$lang$applyTo = (function (seq1952){\nvar G__1953 = cljs.core.first(seq1952);\nvar seq1952__$1 = cljs.core.next(seq1952);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1953,seq1952__$1);\n});\n\ncljs.core.mapcat.cljs$lang$maxFixedArity = (1);\n\n/**\n * Returns a lazy sequence of the items in coll for which\n *   (pred item) returns logical true. pred must be free of side-effects.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.filter = (function cljs$core$filter(var_args){\nvar G__1960 = arguments.length;\nswitch (G__1960) {\ncase 1:\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.filter.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn (function (rf){\nreturn (function() {\nvar G__1963 = null;\nvar G__1963__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__1963__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__1963__2 = (function (result,input){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input)))){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n} else {\nreturn result;\n}\n});\nG__1963 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__1963__0.call(this);\ncase 1:\nreturn G__1963__1.call(this,result);\ncase 2:\nreturn G__1963__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__1963.cljs$core$IFn$_invoke$arity$0 = G__1963__0;\nG__1963.cljs$core$IFn$_invoke$arity$1 = G__1963__1;\nG__1963.cljs$core$IFn$_invoke$arity$2 = G__1963__2;\nreturn G__1963;\n})()\n});\n});\n\ncljs.core.filter.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s)){\nvar c = cljs.core.chunk_first(s);\nvar size = cljs.core.count(c);\nvar b = cljs.core.chunk_buffer(size);\nvar n__4607__auto___1964 = size;\nvar i_1965 = (0);\nwhile(true){\nif((i_1965 < n__4607__auto___1964)){\nif(cljs.core.truth_((function (){var G__1961 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_1965);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__1961) : pred.call(null,G__1961));\n})())){\ncljs.core.chunk_append(b,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c,i_1965));\n} else {\n}\n\nvar G__1966 = (i_1965 + (1));\ni_1965 = G__1966;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core.chunk_cons(cljs.core.chunk(b),cljs.core.filter.cljs$core$IFn$_invoke$arity$2(pred,cljs.core.chunk_rest(s)));\n} else {\nvar f = cljs.core.first(s);\nvar r = cljs.core.rest(s);\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(f) : pred.call(null,f)))){\nreturn cljs.core.cons(f,cljs.core.filter.cljs$core$IFn$_invoke$arity$2(pred,r));\n} else {\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2(pred,r);\n}\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.filter.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a lazy sequence of the items in coll for which\n *   (pred item) returns logical false. pred must be free of side-effects.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.remove = (function cljs$core$remove(var_args){\nvar G__1968 = arguments.length;\nswitch (G__1968) {\ncase 1:\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.remove.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.remove.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$1(cljs.core.complement(pred));\n});\n\ncljs.core.remove.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.complement(pred),coll);\n});\n\ncljs.core.remove.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n *   branch? must be a fn of one arg that returns true if passed a node\n *   that can have children (but may not).  children must be a fn of one\n *   arg that returns a sequence of the children. Will only be called on\n *   nodes for which branch? returns true. Root is the root node of the\n *   tree.\n */\ncljs.core.tree_seq = (function cljs$core$tree_seq(branch_QMARK_,children,root){\nvar walk = (function cljs$core$tree_seq_$_walk(node){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn cljs.core.cons(node,(cljs.core.truth_((branch_QMARK_.cljs$core$IFn$_invoke$arity$1 ? branch_QMARK_.cljs$core$IFn$_invoke$arity$1(node) : branch_QMARK_.call(null,node)))?cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(cljs$core$tree_seq_$_walk,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(children.cljs$core$IFn$_invoke$arity$1 ? children.cljs$core$IFn$_invoke$arity$1(node) : children.call(null,node))], 0)):null));\n}),null,null));\n});\nreturn walk(root);\n});\n/**\n * Takes any nested combination of sequential things (lists, vectors,\n *   etc.) and returns their contents as a single, flat sequence.\n *   (flatten nil) returns nil.\n */\ncljs.core.flatten = (function cljs$core$flatten(x){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__1970_SHARP_){\nreturn (!(cljs.core.sequential_QMARK_(p1__1970_SHARP_)));\n}),cljs.core.rest(cljs.core.tree_seq(cljs.core.sequential_QMARK_,cljs.core.seq,x)));\n});\n/**\n * Returns a new coll consisting of to-coll with all of the items of\n *   from-coll conjoined. A transducer may be supplied.\n */\ncljs.core.into = (function cljs$core$into(var_args){\nvar G__1972 = arguments.length;\nswitch (G__1972) {\ncase 0:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$1 = (function (to){\nreturn to;\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$2 = (function (to,from){\nif((!((to == null)))){\nif((((!((to == null))))?(((((to.cljs$lang$protocol_mask$partition1$ & (4))) || ((cljs.core.PROTOCOL_SENTINEL === to.cljs$core$IEditableCollection$))))?true:false):false)){\nreturn cljs.core._with_meta(cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj_BANG_,cljs.core.transient$(to),from)),cljs.core.meta(to));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,to,from);\n}\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.List.EMPTY,from);\n}\n});\n\ncljs.core.into.cljs$core$IFn$_invoke$arity$3 = (function (to,xform,from){\nif((((!((to == null))))?(((((to.cljs$lang$protocol_mask$partition1$ & (4))) || ((cljs.core.PROTOCOL_SENTINEL === to.cljs$core$IEditableCollection$))))?true:false):false)){\nreturn cljs.core._with_meta(cljs.core.persistent_BANG_(cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(xform,cljs.core.conj_BANG_,cljs.core.transient$(to),from)),cljs.core.meta(to));\n} else {\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(xform,cljs.core.conj,to,from);\n}\n});\n\ncljs.core.into.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns a vector consisting of the result of applying f to the\n *   set of first items of each coll, followed by applying f to the set\n *   of second items in each coll, until any one of the colls is\n *   exhausted.  Any remaining items in other colls are ignored. Function\n *   f should accept number-of-colls arguments.\n */\ncljs.core.mapv = (function cljs$core$mapv(var_args){\nvar G__1982 = arguments.length;\nswitch (G__1982) {\ncase 2:\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___1984 = arguments.length;\nvar i__4731__auto___1985 = (0);\nwhile(true){\nif((i__4731__auto___1985 < len__4730__auto___1984)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___1985]));\n\nvar G__1986 = (i__4731__auto___1985 + (1));\ni__4731__auto___1985 = G__1986;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((4)),(0),null));\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(o) : f.call(null,o)));\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),coll));\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$3 = (function (f,c1,c2){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$3(f,c1,c2));\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$4 = (function (f,c1,c2,c3){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$4(f,c1,c2,c3));\n});\n\ncljs.core.mapv.cljs$core$IFn$_invoke$arity$variadic = (function (f,c1,c2,c3,colls){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(cljs.core.map,f,c1,c2,c3,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([colls], 0)));\n});\n\n/** @this {Function} */\ncljs.core.mapv.cljs$lang$applyTo = (function (seq1977){\nvar G__1978 = cljs.core.first(seq1977);\nvar seq1977__$1 = cljs.core.next(seq1977);\nvar G__1979 = cljs.core.first(seq1977__$1);\nvar seq1977__$2 = cljs.core.next(seq1977__$1);\nvar G__1980 = cljs.core.first(seq1977__$2);\nvar seq1977__$3 = cljs.core.next(seq1977__$2);\nvar G__1981 = cljs.core.first(seq1977__$3);\nvar seq1977__$4 = cljs.core.next(seq1977__$3);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__1978,G__1979,G__1980,G__1981,seq1977__$4);\n});\n\ncljs.core.mapv.cljs$lang$maxFixedArity = (4);\n\n/**\n * Returns a vector of the items in coll for which\n *   (pred item) returns logical true. pred must be free of side-effects.\n */\ncljs.core.filterv = (function cljs$core$filterv(pred,coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (v,o){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(o) : pred.call(null,o)))){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(v,o);\n} else {\nreturn v;\n}\n}),cljs.core.transient$(cljs.core.PersistentVector.EMPTY),coll));\n});\n/**\n * Returns a lazy sequence of lists of n items each, at offsets step\n *   apart. If step is not supplied, defaults to n, i.e. the partitions\n *   do not overlap. If a pad collection is supplied, use its elements as\n *   necessary to complete last partition up to n items. In case there are\n *   not enough padding elements, return a partition with less than n items.\n */\ncljs.core.partition = (function cljs$core$partition(var_args){\nvar G__1988 = arguments.length;\nswitch (G__1988) {\ncase 2:\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.partition.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$3(n,n,coll);\n});\n\ncljs.core.partition.cljs$core$IFn$_invoke$arity$3 = (function (n,step,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nvar p = cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,s);\nif((n === cljs.core.count(p))){\nreturn cljs.core.cons(p,cljs.core.partition.cljs$core$IFn$_invoke$arity$3(n,step,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(step,s)));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition.cljs$core$IFn$_invoke$arity$4 = (function (n,step,pad,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nvar p = cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,s);\nif((n === cljs.core.count(p))){\nreturn cljs.core.cons(p,cljs.core.partition.cljs$core$IFn$_invoke$arity$4(n,step,pad,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(step,s)));\n} else {\nreturn (new cljs.core.List(null,cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(p,pad)),null,(1),null));\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition.cljs$lang$maxFixedArity = 4;\n\n/**\n * Returns the value in a nested associative structure,\n *   where ks is a sequence of keys. Returns nil if the key is not present,\n *   or the not-found value if supplied.\n */\ncljs.core.get_in = (function cljs$core$get_in(var_args){\nvar G__1991 = arguments.length;\nswitch (G__1991) {\ncase 2:\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.get_in.cljs$core$IFn$_invoke$arity$2 = (function (m,ks){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.get,m,ks);\n});\n\ncljs.core.get_in.cljs$core$IFn$_invoke$arity$3 = (function (m,ks,not_found){\nvar sentinel = cljs.core.lookup_sentinel;\nvar m__$1 = m;\nvar ks__$1 = cljs.core.seq(ks);\nwhile(true){\nif((!((ks__$1 == null)))){\nvar m__$2 = cljs.core.get.cljs$core$IFn$_invoke$arity$3(m__$1,cljs.core.first(ks__$1),sentinel);\nif((sentinel === m__$2)){\nreturn not_found;\n} else {\nvar G__1993 = sentinel;\nvar G__1994 = m__$2;\nvar G__1995 = cljs.core.next(ks__$1);\nsentinel = G__1993;\nm__$1 = G__1994;\nks__$1 = G__1995;\ncontinue;\n}\n} else {\nreturn m__$1;\n}\nbreak;\n}\n});\n\ncljs.core.get_in.cljs$lang$maxFixedArity = 3;\n\n/**\n * Associates a value in a nested associative structure, where ks is a\n *   sequence of keys and v is the new value and returns a new nested structure.\n *   If any levels do not exist, hash-maps will be created.\n */\ncljs.core.assoc_in = (function cljs$core$assoc_in(m,p__1996,v){\nvar vec__1997 = p__1996;\nvar seq__1998 = cljs.core.seq(vec__1997);\nvar first__1999 = cljs.core.first(seq__1998);\nvar seq__1998__$1 = cljs.core.next(seq__1998);\nvar k = first__1999;\nvar ks = seq__1998__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2000 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2001 = ks;\nvar G__2002 = v;\nreturn (cljs.core.assoc_in.cljs$core$IFn$_invoke$arity$3 ? cljs.core.assoc_in.cljs$core$IFn$_invoke$arity$3(G__2000,G__2001,G__2002) : cljs.core.assoc_in.call(null,G__2000,G__2001,G__2002));\n})());\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,v);\n}\n});\n/**\n * 'Updates' a value in a nested associative structure, where ks is a\n *   sequence of keys and f is a function that will take the old value\n *   and any supplied args and return the new value, and returns a new\n *   nested structure.  If any levels do not exist, hash-maps will be\n *   created.\n */\ncljs.core.update_in = (function cljs$core$update_in(var_args){\nvar G__2011 = arguments.length;\nswitch (G__2011) {\ncase 3:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___2043 = arguments.length;\nvar i__4731__auto___2044 = (0);\nwhile(true){\nif((i__4731__auto___2044 < len__4730__auto___2043)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___2044]));\n\nvar G__2045 = (i__4731__auto___2044 + (1));\ni__4731__auto___2044 = G__2045;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((6)),(0),null));\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$3 = (function (m,p__2012,f){\nvar vec__2013 = p__2012;\nvar seq__2014 = cljs.core.seq(vec__2013);\nvar first__2015 = cljs.core.first(seq__2014);\nvar seq__2014__$1 = cljs.core.next(seq__2014);\nvar k = first__2015;\nvar ks = seq__2014__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2016 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__2016) : f.call(null,G__2016));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$4 = (function (m,p__2017,f,a){\nvar vec__2018 = p__2017;\nvar seq__2019 = cljs.core.seq(vec__2018);\nvar first__2020 = cljs.core.first(seq__2019);\nvar seq__2019__$1 = cljs.core.next(seq__2019);\nvar k = first__2020;\nvar ks = seq__2019__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2021 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2022 = a;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__2021,G__2022) : f.call(null,G__2021,G__2022));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$5 = (function (m,p__2023,f,a,b){\nvar vec__2024 = p__2023;\nvar seq__2025 = cljs.core.seq(vec__2024);\nvar first__2026 = cljs.core.first(seq__2025);\nvar seq__2025__$1 = cljs.core.next(seq__2025);\nvar k = first__2026;\nvar ks = seq__2025__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$5(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a,b));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2027 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2028 = a;\nvar G__2029 = b;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2027,G__2028,G__2029) : f.call(null,G__2027,G__2028,G__2029));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$6 = (function (m,p__2030,f,a,b,c){\nvar vec__2031 = p__2030;\nvar seq__2032 = cljs.core.seq(vec__2031);\nvar first__2033 = cljs.core.first(seq__2032);\nvar seq__2032__$1 = cljs.core.next(seq__2032);\nvar k = first__2033;\nvar ks = seq__2032__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.update_in.cljs$core$IFn$_invoke$arity$6(cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a,b,c));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2034 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2035 = a;\nvar G__2036 = b;\nvar G__2037 = c;\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(G__2034,G__2035,G__2036,G__2037) : f.call(null,G__2034,G__2035,G__2036,G__2037));\n})());\n}\n});\n\ncljs.core.update_in.cljs$core$IFn$_invoke$arity$variadic = (function (m,p__2038,f,a,b,c,args){\nvar vec__2039 = p__2038;\nvar seq__2040 = cljs.core.seq(vec__2039);\nvar first__2041 = cljs.core.first(seq__2040);\nvar seq__2040__$1 = cljs.core.next(seq__2040);\nvar k = first__2041;\nvar ks = seq__2040__$1;\nif(ks){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(cljs.core.update_in,cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),ks,f,a,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([b,c,args], 0)));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),a,b,c,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([args], 0)));\n}\n});\n\n/** @this {Function} */\ncljs.core.update_in.cljs$lang$applyTo = (function (seq2004){\nvar G__2005 = cljs.core.first(seq2004);\nvar seq2004__$1 = cljs.core.next(seq2004);\nvar G__2006 = cljs.core.first(seq2004__$1);\nvar seq2004__$2 = cljs.core.next(seq2004__$1);\nvar G__2007 = cljs.core.first(seq2004__$2);\nvar seq2004__$3 = cljs.core.next(seq2004__$2);\nvar G__2008 = cljs.core.first(seq2004__$3);\nvar seq2004__$4 = cljs.core.next(seq2004__$3);\nvar G__2009 = cljs.core.first(seq2004__$4);\nvar seq2004__$5 = cljs.core.next(seq2004__$4);\nvar G__2010 = cljs.core.first(seq2004__$5);\nvar seq2004__$6 = cljs.core.next(seq2004__$5);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2005,G__2006,G__2007,G__2008,G__2009,G__2010,seq2004__$6);\n});\n\ncljs.core.update_in.cljs$lang$maxFixedArity = (6);\n\n/**\n * 'Updates' a value in an associative structure, where k is a\n *   key and f is a function that will take the old value\n *   and any supplied args and return the new value, and returns a new\n *   structure.  If the key does not exist, nil is passed as the old value.\n */\ncljs.core.update = (function cljs$core$update(var_args){\nvar G__2054 = arguments.length;\nswitch (G__2054) {\ncase 3:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___2066 = arguments.length;\nvar i__4731__auto___2067 = (0);\nwhile(true){\nif((i__4731__auto___2067 < len__4730__auto___2066)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___2067]));\n\nvar G__2068 = (i__4731__auto___2067 + (1));\ni__4731__auto___2067 = G__2068;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((6)),(0),null));\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$3 = (function (m,k,f){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2055 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__2055) : f.call(null,G__2055));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$4 = (function (m,k,f,x){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2056 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2057 = x;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__2056,G__2057) : f.call(null,G__2056,G__2057));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$5 = (function (m,k,f,x,y){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2058 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2059 = x;\nvar G__2060 = y;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2058,G__2059,G__2060) : f.call(null,G__2058,G__2059,G__2060));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$6 = (function (m,k,f,x,y,z){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2061 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2062 = x;\nvar G__2063 = y;\nvar G__2064 = z;\nreturn (f.cljs$core$IFn$_invoke$arity$4 ? f.cljs$core$IFn$_invoke$arity$4(G__2061,G__2062,G__2063,G__2064) : f.call(null,G__2061,G__2062,G__2063,G__2064));\n})());\n});\n\ncljs.core.update.cljs$core$IFn$_invoke$arity$variadic = (function (m,k,f,x,y,z,more){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(f,cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k),x,y,z,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([more], 0)));\n});\n\n/** @this {Function} */\ncljs.core.update.cljs$lang$applyTo = (function (seq2047){\nvar G__2048 = cljs.core.first(seq2047);\nvar seq2047__$1 = cljs.core.next(seq2047);\nvar G__2049 = cljs.core.first(seq2047__$1);\nvar seq2047__$2 = cljs.core.next(seq2047__$1);\nvar G__2050 = cljs.core.first(seq2047__$2);\nvar seq2047__$3 = cljs.core.next(seq2047__$2);\nvar G__2051 = cljs.core.first(seq2047__$3);\nvar seq2047__$4 = cljs.core.next(seq2047__$3);\nvar G__2052 = cljs.core.first(seq2047__$4);\nvar seq2047__$5 = cljs.core.next(seq2047__$4);\nvar G__2053 = cljs.core.first(seq2047__$5);\nvar seq2047__$6 = cljs.core.next(seq2047__$5);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2048,G__2049,G__2050,G__2051,G__2052,G__2053,seq2047__$6);\n});\n\ncljs.core.update.cljs$lang$maxFixedArity = (6);\n\n\n/**\n* @constructor\n*/\ncljs.core.VectorNode = (function (edit,arr){\nthis.edit = edit;\nthis.arr = arr;\n});\n\ncljs.core.VectorNode.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"edit\",\"edit\",-1302639,null),new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null)], null);\n});\n\ncljs.core.VectorNode.cljs$lang$type = true;\n\ncljs.core.VectorNode.cljs$lang$ctorStr = \"cljs.core/VectorNode\";\n\ncljs.core.VectorNode.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/VectorNode\");\n});\n\n/**\n * Positional factory function for cljs.core/VectorNode.\n */\ncljs.core.__GT_VectorNode = (function cljs$core$__GT_VectorNode(edit,arr){\nreturn (new cljs.core.VectorNode(edit,arr));\n});\n\ncljs.core.pv_fresh_node = (function cljs$core$pv_fresh_node(edit){\nreturn (new cljs.core.VectorNode(edit,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]));\n});\ncljs.core.pv_aget = (function cljs$core$pv_aget(node,idx){\nreturn (node.arr[idx]);\n});\ncljs.core.pv_aset = (function cljs$core$pv_aset(node,idx,val){\nreturn (node.arr[idx] = val);\n});\ncljs.core.pv_clone_node = (function cljs$core$pv_clone_node(node){\nreturn (new cljs.core.VectorNode(node.edit,cljs.core.aclone(node.arr)));\n});\ncljs.core.tail_off = (function cljs$core$tail_off(pv){\nvar cnt = pv.cnt;\nif((cnt < (32))){\nreturn (0);\n} else {\nreturn (((cnt - (1)) >>> (5)) << (5));\n}\n});\ncljs.core.new_path = (function cljs$core$new_path(edit,level,node){\nvar ll = level;\nvar ret = node;\nwhile(true){\nif((ll === (0))){\nreturn ret;\n} else {\nvar embed = ret;\nvar r = cljs.core.pv_fresh_node(edit);\nvar _ = cljs.core.pv_aset(r,(0),embed);\nvar G__2069 = (ll - (5));\nvar G__2070 = r;\nll = G__2069;\nret = G__2070;\ncontinue;\n}\nbreak;\n}\n});\ncljs.core.push_tail = (function cljs$core$push_tail(pv,level,parent,tailnode){\nvar ret = cljs.core.pv_clone_node(parent);\nvar subidx = (((pv.cnt - (1)) >>> level) & (31));\nif(((5) === level)){\ncljs.core.pv_aset(ret,subidx,tailnode);\n\nreturn ret;\n} else {\nvar child = cljs.core.pv_aget(parent,subidx);\nif((!((child == null)))){\nvar node_to_insert = (function (){var G__2071 = pv;\nvar G__2072 = (level - (5));\nvar G__2073 = child;\nvar G__2074 = tailnode;\nreturn (cljs.core.push_tail.cljs$core$IFn$_invoke$arity$4 ? cljs.core.push_tail.cljs$core$IFn$_invoke$arity$4(G__2071,G__2072,G__2073,G__2074) : cljs.core.push_tail.call(null,G__2071,G__2072,G__2073,G__2074));\n})();\ncljs.core.pv_aset(ret,subidx,node_to_insert);\n\nreturn ret;\n} else {\nvar node_to_insert = cljs.core.new_path(null,(level - (5)),tailnode);\ncljs.core.pv_aset(ret,subidx,node_to_insert);\n\nreturn ret;\n}\n}\n});\ncljs.core.vector_index_out_of_bounds = (function cljs$core$vector_index_out_of_bounds(i,cnt){\nthrow (new Error([\"No item \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(i),\" in vector of length \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cnt)].join('')));\n});\ncljs.core.first_array_for_longvec = (function cljs$core$first_array_for_longvec(pv){\nvar node = pv.root;\nvar level = pv.shift;\nwhile(true){\nif((level > (0))){\nvar G__2075 = cljs.core.pv_aget(node,(0));\nvar G__2076 = (level - (5));\nnode = G__2075;\nlevel = G__2076;\ncontinue;\n} else {\nreturn node.arr;\n}\nbreak;\n}\n});\ncljs.core.unchecked_array_for = (function cljs$core$unchecked_array_for(pv,i){\nif((i >= cljs.core.tail_off(pv))){\nreturn pv.tail;\n} else {\nvar node = pv.root;\nvar level = pv.shift;\nwhile(true){\nif((level > (0))){\nvar G__2077 = cljs.core.pv_aget(node,((i >>> level) & (31)));\nvar G__2078 = (level - (5));\nnode = G__2077;\nlevel = G__2078;\ncontinue;\n} else {\nreturn node.arr;\n}\nbreak;\n}\n}\n});\ncljs.core.array_for = (function cljs$core$array_for(pv,i){\nif(((((0) <= i)) && ((i < pv.cnt)))){\nreturn cljs.core.unchecked_array_for(pv,i);\n} else {\nreturn cljs.core.vector_index_out_of_bounds(i,pv.cnt);\n}\n});\ncljs.core.do_assoc = (function cljs$core$do_assoc(pv,level,node,i,val){\nvar ret = cljs.core.pv_clone_node(node);\nif((level === (0))){\ncljs.core.pv_aset(ret,(i & (31)),val);\n\nreturn ret;\n} else {\nvar subidx = ((i >>> level) & (31));\ncljs.core.pv_aset(ret,subidx,(function (){var G__2079 = pv;\nvar G__2080 = (level - (5));\nvar G__2081 = cljs.core.pv_aget(node,subidx);\nvar G__2082 = i;\nvar G__2083 = val;\nreturn (cljs.core.do_assoc.cljs$core$IFn$_invoke$arity$5 ? cljs.core.do_assoc.cljs$core$IFn$_invoke$arity$5(G__2079,G__2080,G__2081,G__2082,G__2083) : cljs.core.do_assoc.call(null,G__2079,G__2080,G__2081,G__2082,G__2083));\n})());\n\nreturn ret;\n}\n});\ncljs.core.pop_tail = (function cljs$core$pop_tail(pv,level,node){\nvar subidx = (((pv.cnt - (2)) >>> level) & (31));\nif((level > (5))){\nvar new_child = (function (){var G__2084 = pv;\nvar G__2085 = (level - (5));\nvar G__2086 = cljs.core.pv_aget(node,subidx);\nreturn (cljs.core.pop_tail.cljs$core$IFn$_invoke$arity$3 ? cljs.core.pop_tail.cljs$core$IFn$_invoke$arity$3(G__2084,G__2085,G__2086) : cljs.core.pop_tail.call(null,G__2084,G__2085,G__2086));\n})();\nif((((new_child == null)) && ((subidx === (0))))){\nreturn null;\n} else {\nvar ret = cljs.core.pv_clone_node(node);\ncljs.core.pv_aset(ret,subidx,new_child);\n\nreturn ret;\n}\n} else {\nif((subidx === (0))){\nreturn null;\n} else {\nvar ret = cljs.core.pv_clone_node(node);\ncljs.core.pv_aset(ret,subidx,null);\n\nreturn ret;\n\n}\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.RangedIterator = (function (i,base,arr,v,start,end){\nthis.i = i;\nthis.base = base;\nthis.arr = arr;\nthis.v = v;\nthis.start = start;\nthis.end = end;\n});\ncljs.core.RangedIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar this$ = this;\nreturn (self__.i < self__.end);\n});\n\ncljs.core.RangedIterator.prototype.next = (function (){\nvar self__ = this;\nvar this$ = this;\nif(((self__.i - self__.base) === (32))){\nself__.arr = cljs.core.unchecked_array_for(self__.v,self__.i);\n\nself__.base = (self__.base + (32));\n} else {\n}\n\nvar ret = (self__.arr[(self__.i & (31))]);\nself__.i = (self__.i + (1));\n\nreturn ret;\n});\n\ncljs.core.RangedIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"base\",\"base\",1825810849,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"v\",\"v\",1661996586,null),new cljs.core.Symbol(null,\"start\",\"start\",1285322546,null),new cljs.core.Symbol(null,\"end\",\"end\",1372345569,null)], null);\n});\n\ncljs.core.RangedIterator.cljs$lang$type = true;\n\ncljs.core.RangedIterator.cljs$lang$ctorStr = \"cljs.core/RangedIterator\";\n\ncljs.core.RangedIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/RangedIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/RangedIterator.\n */\ncljs.core.__GT_RangedIterator = (function cljs$core$__GT_RangedIterator(i,base,arr,v,start,end){\nreturn (new cljs.core.RangedIterator(i,base,arr,v,start,end));\n});\n\ncljs.core.ranged_iterator = (function cljs$core$ranged_iterator(v,start,end){\nvar i = start;\nreturn (new cljs.core.RangedIterator(i,(i - (i % (32))),(((start < cljs.core.count(v)))?cljs.core.unchecked_array_for(v,i):null),v,start,end));\n});\ncljs.core.pv_reduce = (function cljs$core$pv_reduce(var_args){\nvar G__2088 = arguments.length;\nswitch (G__2088) {\ncase 4:\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4 = (function (pv,f,start,end){\nif((start < end)){\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5(pv,f,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(pv,start),(start + (1)),end);\n} else {\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n}\n});\n\ncljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5 = (function (pv,f,init,start,end){\nvar acc = init;\nvar i = start;\nvar arr = cljs.core.unchecked_array_for(pv,start);\nwhile(true){\nif((i < end)){\nvar j = (i & (31));\nvar arr__$1 = (((j === (0)))?cljs.core.unchecked_array_for(pv,i):arr);\nvar nacc = (function (){var G__2089 = acc;\nvar G__2090 = (arr__$1[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__2089,G__2090) : f.call(null,G__2089,G__2090));\n})();\nif(cljs.core.reduced_QMARK_(nacc)){\nreturn cljs.core.deref(nacc);\n} else {\nvar G__2092 = nacc;\nvar G__2093 = (i + (1));\nvar G__2094 = arr__$1;\nacc = G__2092;\ni = G__2093;\narr = G__2094;\ncontinue;\n}\n} else {\nreturn acc;\n}\nbreak;\n}\n});\n\ncljs.core.pv_reduce.cljs$lang$maxFixedArity = 5;\n\n\n\n\n\n\n\n\n/**\n * Marker protocol\n * @interface\n */\ncljs.core.APersistentVector = function(){};\n\n\n/**\n* @constructor\n * @implements {cljs.core.APersistentVector}\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentVector = (function (meta,cnt,shift,root,tail,__hash){\nthis.meta = meta;\nthis.cnt = cnt;\nthis.shift = shift;\nthis.root = root;\nthis.tail = tail;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 167666463;\nthis.cljs$lang$protocol_mask$partition1$ = 139268;\n});\ncljs.core.PersistentVector.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IFind$_find$arity$2 = (function (coll,n){\nvar self__ = this;\nvar coll__$1 = this;\nif(((((0) <= n)) && ((n < self__.cnt)))){\nreturn (new cljs.core.MapEntry(n,(cljs.core.unchecked_array_for(coll__$1,n)[(n & (31))]),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentVector.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentVector.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentVector.prototype.indexOf = (function() {\nvar G__2101 = null;\nvar G__2101__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2101__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2101 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2101__1.call(this,x);\ncase 2:\nreturn G__2101__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2101.cljs$core$IFn$_invoke$arity$1 = G__2101__1;\nG__2101.cljs$core$IFn$_invoke$arity$2 = G__2101__2;\nreturn G__2101;\n})()\n;\n\ncljs.core.PersistentVector.prototype.lastIndexOf = (function() {\nvar G__2102 = null;\nvar G__2102__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2102__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2102 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2102__1.call(this,x);\ncase 2:\nreturn G__2102__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2102.cljs$core$IFn$_invoke$arity$1 = G__2102__1;\nG__2102.cljs$core$IFn$_invoke$arity$2 = G__2102__2;\nreturn G__2102;\n})()\n;\n\ncljs.core.PersistentVector.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif(typeof k === 'number'){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (v,f,init){\nvar self__ = this;\nvar v__$1 = this;\nvar i = (0);\nvar init__$1 = init;\nwhile(true){\nif((i < self__.cnt)){\nvar arr = cljs.core.unchecked_array_for(v__$1,i);\nvar len = arr.length;\nvar init__$2 = (function (){var j = (0);\nvar init__$2 = init__$1;\nwhile(true){\nif((j < len)){\nvar init__$3 = (function (){var G__2096 = init__$2;\nvar G__2097 = (j + i);\nvar G__2098 = (arr[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2096,G__2097,G__2098) : f.call(null,G__2096,G__2097,G__2098));\n})();\nif(cljs.core.reduced_QMARK_(init__$3)){\nreturn init__$3;\n} else {\nvar G__2103 = (j + (1));\nvar G__2104 = init__$3;\nj = G__2103;\ninit__$2 = G__2104;\ncontinue;\n}\n} else {\nreturn init__$2;\n}\nbreak;\n}\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__2105 = (i + len);\nvar G__2106 = init__$2;\ni = G__2105;\ninit__$1 = G__2106;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$APersistentVector$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (coll,n){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (cljs.core.array_for(coll__$1,n)[(n & (31))]);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (coll,n,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif(((((0) <= n)) && ((n < self__.cnt)))){\nreturn (cljs.core.unchecked_array_for(coll__$1,n)[(n & (31))]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (coll,n,val){\nvar self__ = this;\nvar coll__$1 = this;\nif(((((0) <= n)) && ((n < self__.cnt)))){\nif((cljs.core.tail_off(coll__$1) <= n)){\nvar new_tail = cljs.core.aclone(self__.tail);\n(new_tail[(n & (31))] = val);\n\nreturn (new cljs.core.PersistentVector(self__.meta,self__.cnt,self__.shift,self__.root,new_tail,null));\n} else {\nreturn (new cljs.core.PersistentVector(self__.meta,self__.cnt,self__.shift,cljs.core.do_assoc(coll__$1,self__.shift,self__.root,n,val),self__.tail,null));\n}\n} else {\nif((n === self__.cnt)){\nreturn coll__$1.cljs$core$ICollection$_conj$arity$2(null,val);\n} else {\nthrow (new Error([\"Index \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n),\" out of bounds  [0,\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.cnt),\"]\"].join('')));\n\n}\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.ranged_iterator(this$__$1,(0),self__.cnt);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.PersistentVector(self__.meta,self__.cnt,self__.shift,self__.root,self__.tail,self__.__hash));\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IStack$_peek$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$2(null,(self__.cnt - (1)));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IStack$_pop$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt === (0))){\nthrow (new Error(\"Can't pop empty vector\"));\n} else {\nif(((1) === self__.cnt)){\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n} else {\nif(((1) < (self__.cnt - cljs.core.tail_off(coll__$1)))){\nreturn (new cljs.core.PersistentVector(self__.meta,(self__.cnt - (1)),self__.shift,self__.root,self__.tail.slice((0),(-1)),null));\n} else {\nvar new_tail = cljs.core.unchecked_array_for(coll__$1,(self__.cnt - (2)));\nvar nr = cljs.core.pop_tail(coll__$1,self__.shift,self__.root);\nvar new_root = (((nr == null))?cljs.core.PersistentVector.EMPTY_NODE:nr);\nvar cnt_1 = (self__.cnt - (1));\nif(((((5) < self__.shift)) && ((cljs.core.pv_aget(new_root,(1)) == null)))){\nreturn (new cljs.core.PersistentVector(self__.meta,cnt_1,(self__.shift - (5)),cljs.core.pv_aget(new_root,(0)),new_tail,null));\n} else {\nreturn (new cljs.core.PersistentVector(self__.meta,cnt_1,self__.shift,new_root,new_tail,null));\n}\n\n}\n}\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nreturn (new cljs.core.RSeq(coll__$1,(self__.cnt - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nif((other instanceof cljs.core.PersistentVector)){\nif((self__.cnt === cljs.core.count(other))){\nvar me_iter = coll__$1.cljs$core$IIterable$_iterator$arity$1(null);\nvar you_iter = other.cljs$core$IIterable$_iterator$arity$1(null);\nwhile(true){\nif(me_iter.hasNext()){\nvar x = me_iter.next();\nvar y = you_iter.next();\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(x,y)){\ncontinue;\n} else {\nreturn false;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n} else {\nreturn false;\n}\n} else {\nreturn cljs.core.equiv_sequential(coll__$1,other);\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.TransientVector(self__.cnt,self__.shift,cljs.core.tv_editable_root(self__.root),cljs.core.tv_editable_tail(self__.tail)));\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (v,f){\nvar self__ = this;\nvar v__$1 = this;\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4(v__$1,f,(0),self__.cnt);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (v,f,init){\nvar self__ = this;\nvar v__$1 = this;\nvar i = (0);\nvar init__$1 = init;\nwhile(true){\nif((i < self__.cnt)){\nvar arr = cljs.core.unchecked_array_for(v__$1,i);\nvar len = arr.length;\nvar init__$2 = (function (){var j = (0);\nvar init__$2 = init__$1;\nwhile(true){\nif((j < len)){\nvar init__$3 = (function (){var G__2099 = init__$2;\nvar G__2100 = (arr[j]);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__2099,G__2100) : f.call(null,G__2099,G__2100));\n})();\nif(cljs.core.reduced_QMARK_(init__$3)){\nreturn init__$3;\n} else {\nvar G__2107 = (j + (1));\nvar G__2108 = init__$3;\nj = G__2107;\ninit__$2 = G__2108;\ncontinue;\n}\n} else {\nreturn init__$2;\n}\nbreak;\n}\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__2109 = (i + len);\nvar G__2110 = init__$2;\ni = G__2109;\ninit__$1 = G__2110;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,k,v){\nvar self__ = this;\nvar coll__$1 = this;\nif(typeof k === 'number'){\nreturn coll__$1.cljs$core$IVector$_assoc_n$arity$3(null,k,v);\n} else {\nthrow (new Error(\"Vector's key for assoc must be a number.\"));\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.integer_QMARK_(k)){\nreturn ((((0) <= k)) && ((k < self__.cnt)));\n} else {\nreturn false;\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt === (0))){\nreturn null;\n} else {\nif((self__.cnt <= (32))){\nreturn (new cljs.core.IndexedSeq(self__.tail,(0),null));\n} else {\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(coll__$1,cljs.core.first_array_for_longvec(coll__$1),(0),(0));\n\n}\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentVector(new_meta,self__.cnt,self__.shift,self__.root,self__.tail,self__.__hash));\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nif(((self__.cnt - cljs.core.tail_off(coll__$1)) < (32))){\nvar len = self__.tail.length;\nvar new_tail = (new Array((len + (1))));\nvar n__4607__auto___2111 = len;\nvar i_2112 = (0);\nwhile(true){\nif((i_2112 < n__4607__auto___2111)){\n(new_tail[i_2112] = (self__.tail[i_2112]));\n\nvar G__2113 = (i_2112 + (1));\ni_2112 = G__2113;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(new_tail[len] = o);\n\nreturn (new cljs.core.PersistentVector(self__.meta,(self__.cnt + (1)),self__.shift,self__.root,new_tail,null));\n} else {\nvar root_overflow_QMARK_ = ((self__.cnt >>> (5)) > ((1) << self__.shift));\nvar new_shift = ((root_overflow_QMARK_)?(self__.shift + (5)):self__.shift);\nvar new_root = ((root_overflow_QMARK_)?(function (){var n_r = cljs.core.pv_fresh_node(null);\ncljs.core.pv_aset(n_r,(0),self__.root);\n\ncljs.core.pv_aset(n_r,(1),cljs.core.new_path(null,self__.shift,(new cljs.core.VectorNode(null,self__.tail))));\n\nreturn n_r;\n})():cljs.core.push_tail(coll__$1,self__.shift,self__.root,(new cljs.core.VectorNode(null,self__.tail))));\nreturn (new cljs.core.PersistentVector(self__.meta,(self__.cnt + (1)),new_shift,new_root,[o],null));\n}\n});\n\ncljs.core.PersistentVector.prototype.call = (function() {\nvar G__2114 = null;\nvar G__2114__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__2114__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__2114 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2114__2.call(this,self__,k);\ncase 3:\nreturn G__2114__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2114.cljs$core$IFn$_invoke$arity$2 = G__2114__2;\nG__2114.cljs$core$IFn$_invoke$arity$3 = G__2114__3;\nreturn G__2114;\n})()\n;\n\ncljs.core.PersistentVector.prototype.apply = (function (self__,args2095){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2095)));\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentVector.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"shift\",\"shift\",-1657295705,null),new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.Symbol(null,\"tail\",\"tail\",494507963,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentVector.cljs$lang$type = true;\n\ncljs.core.PersistentVector.cljs$lang$ctorStr = \"cljs.core/PersistentVector\";\n\ncljs.core.PersistentVector.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentVector\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentVector.\n */\ncljs.core.__GT_PersistentVector = (function cljs$core$__GT_PersistentVector(meta,cnt,shift,root,tail,__hash){\nreturn (new cljs.core.PersistentVector(meta,cnt,shift,root,tail,__hash));\n});\n\ncljs.core.PersistentVector.EMPTY_NODE = (new cljs.core.VectorNode(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]));\ncljs.core.PersistentVector.EMPTY = (new cljs.core.PersistentVector(null,(0),(5),cljs.core.PersistentVector.EMPTY_NODE,[],cljs.core.empty_ordered_hash));\ncljs.core.PersistentVector.fromArray = (function (xs,no_clone){\nvar l = xs.length;\nvar xs__$1 = ((no_clone)?xs:cljs.core.aclone(xs));\nif((l < (32))){\nreturn (new cljs.core.PersistentVector(null,l,(5),cljs.core.PersistentVector.EMPTY_NODE,xs__$1,null));\n} else {\nvar node = xs__$1.slice((0),(32));\nvar v = (new cljs.core.PersistentVector(null,(32),(5),cljs.core.PersistentVector.EMPTY_NODE,node,null));\nvar i = (32);\nvar out = v.cljs$core$IEditableCollection$_as_transient$arity$1(null);\nwhile(true){\nif((i < l)){\nvar G__2115 = (i + (1));\nvar G__2116 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,(xs__$1[i]));\ni = G__2115;\nout = G__2116;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n}\n});\nvar G__2117_2120 = cljs.core.PersistentVector.prototype;\nvar G__2118_2121 = cljs.core.ITER_SYMBOL;\nvar G__2119_2122 = ((function (G__2117_2120,G__2118_2121){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2117_2120,G__2118_2121))\n;\ngoog.object.set(G__2117_2120,G__2118_2121,G__2119_2122);\n/**\n * Creates a new vector containing the contents of coll. JavaScript arrays\n *   will be aliased and should not be modified.\n */\ncljs.core.vec = (function cljs$core$vec(coll){\nif(cljs.core.map_entry_QMARK_(coll)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.key(coll),cljs.core.val(coll)], null);\n} else {\nif(cljs.core.vector_QMARK_(coll)){\nreturn cljs.core.with_meta(coll,null);\n} else {\nif(cljs.core.array_QMARK_(coll)){\nreturn cljs.core.PersistentVector.fromArray(coll,true);\n} else {\nreturn cljs.core._persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj_BANG_,cljs.core._as_transient(cljs.core.PersistentVector.EMPTY),coll));\n\n}\n}\n}\n});\n/**\n * Creates a new vector containing the args.\n */\ncljs.core.vector = (function cljs$core$vector(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2124 = arguments.length;\nvar i__4731__auto___2125 = (0);\nwhile(true){\nif((i__4731__auto___2125 < len__4730__auto___2124)){\nargs__4736__auto__.push((arguments[i__4731__auto___2125]));\n\nvar G__2126 = (i__4731__auto___2125 + (1));\ni__4731__auto___2125 = G__2126;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.vector.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.vector.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nif((((args instanceof cljs.core.IndexedSeq)) && ((args.i === (0))))){\nreturn cljs.core.PersistentVector.fromArray(args.arr,true);\n} else {\nreturn cljs.core.vec(args);\n}\n});\n\ncljs.core.vector.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.vector.cljs$lang$applyTo = (function (seq2123){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2123));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ASeq}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ChunkedSeq = (function (vec,node,i,off,meta,__hash){\nthis.vec = vec;\nthis.node = node;\nthis.i = i;\nthis.off = off;\nthis.meta = meta;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32375020;\nthis.cljs$lang$protocol_mask$partition1$ = 1536;\n});\ncljs.core.ChunkedSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ChunkedSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ChunkedSeq.prototype.indexOf = (function() {\nvar G__2127 = null;\nvar G__2127__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2127__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2127 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2127__1.call(this,x);\ncase 2:\nreturn G__2127__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2127.cljs$core$IFn$_invoke$arity$1 = G__2127__1;\nG__2127.cljs$core$IFn$_invoke$arity$2 = G__2127__2;\nreturn G__2127;\n})()\n;\n\ncljs.core.ChunkedSeq.prototype.lastIndexOf = (function() {\nvar G__2128 = null;\nvar G__2128__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2128__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2128 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2128__1.call(this,x);\ncase 2:\nreturn G__2128__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2128.cljs$core$IFn$_invoke$arity$1 = G__2128__1;\nG__2128.cljs$core$IFn$_invoke$arity$2 = G__2128__2;\nreturn G__2128;\n})()\n;\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(((self__.off + (1)) < self__.node.length)){\nvar s = cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,self__.node,self__.i,(self__.off + (1)));\nif((s == null)){\nreturn null;\n} else {\nreturn s;\n}\n} else {\nreturn coll__$1.cljs$core$IChunkedNext$_chunked_next$arity$1(null);\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4(self__.vec,f,(self__.i + self__.off),cljs.core.count(self__.vec));\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5(self__.vec,f,start,(self__.i + self__.off),cljs.core.count(self__.vec));\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (self__.node[self__.off]);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(((self__.off + (1)) < self__.node.length)){\nvar s = cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,self__.node,self__.i,(self__.off + (1)));\nif((s == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn s;\n}\n} else {\nreturn coll__$1.cljs$core$IChunkedSeq$_chunked_rest$arity$1(null);\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.array_chunk.cljs$core$IFn$_invoke$arity$2(self__.node,self__.off);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar end = (self__.i + self__.node.length);\nif((end < cljs.core._count(self__.vec))){\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,cljs.core.unchecked_array_for(self__.vec,end),end,(0));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$5(self__.vec,self__.node,self__.i,self__.off,new_meta);\n}\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar end = (self__.i + self__.node.length);\nif((end < cljs.core._count(self__.vec))){\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4(self__.vec,cljs.core.unchecked_array_for(self__.vec,end),end,(0));\n} else {\nreturn null;\n}\n});\n\ncljs.core.ChunkedSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"vec\",\"vec\",982683596,null),new cljs.core.Symbol(null,\"node\",\"node\",-2073234571,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"off\",\"off\",-2047994980,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ChunkedSeq.cljs$lang$type = true;\n\ncljs.core.ChunkedSeq.cljs$lang$ctorStr = \"cljs.core/ChunkedSeq\";\n\ncljs.core.ChunkedSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ChunkedSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/ChunkedSeq.\n */\ncljs.core.__GT_ChunkedSeq = (function cljs$core$__GT_ChunkedSeq(vec,node,i,off,meta,__hash){\nreturn (new cljs.core.ChunkedSeq(vec,node,i,off,meta,__hash));\n});\n\nvar G__2129_2132 = cljs.core.ChunkedSeq.prototype;\nvar G__2130_2133 = cljs.core.ITER_SYMBOL;\nvar G__2131_2134 = ((function (G__2129_2132,G__2130_2133){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2129_2132,G__2130_2133))\n;\ngoog.object.set(G__2129_2132,G__2130_2133,G__2131_2134);\ncljs.core.chunked_seq = (function cljs$core$chunked_seq(var_args){\nvar G__2136 = arguments.length;\nswitch (G__2136) {\ncase 3:\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn cljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$3 = (function (vec,i,off){\nreturn (new cljs.core.ChunkedSeq(vec,cljs.core.array_for(vec,i),i,off,null,null));\n});\n\ncljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$4 = (function (vec,node,i,off){\nreturn (new cljs.core.ChunkedSeq(vec,node,i,off,null,null));\n});\n\ncljs.core.chunked_seq.cljs$core$IFn$_invoke$arity$5 = (function (vec,node,i,off,meta){\nreturn (new cljs.core.ChunkedSeq(vec,node,i,off,meta,null));\n});\n\ncljs.core.chunked_seq.cljs$lang$maxFixedArity = 5;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Subvec = (function (meta,v,start,end,__hash){\nthis.meta = meta;\nthis.v = v;\nthis.start = start;\nthis.end = end;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 167666463;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\n});\ncljs.core.Subvec.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Subvec.prototype.cljs$core$IFind$_find$arity$2 = (function (coll,n){\nvar self__ = this;\nvar coll__$1 = this;\nif((n < (0))){\nreturn null;\n} else {\nvar idx = (self__.start + n);\nif((idx < self__.end)){\nreturn (new cljs.core.MapEntry(n,cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(self__.v,idx),null));\n} else {\nreturn null;\n}\n}\n});\n\ncljs.core.Subvec.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Subvec.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Subvec.prototype.indexOf = (function() {\nvar G__2145 = null;\nvar G__2145__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2145__2 = (function (x,start__$1){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__2145 = function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__2145__1.call(this,x);\ncase 2:\nreturn G__2145__2.call(this,x,start__$1);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2145.cljs$core$IFn$_invoke$arity$1 = G__2145__1;\nG__2145.cljs$core$IFn$_invoke$arity$2 = G__2145__2;\nreturn G__2145;\n})()\n;\n\ncljs.core.Subvec.prototype.lastIndexOf = (function() {\nvar G__2146 = null;\nvar G__2146__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2146__2 = (function (x,start__$1){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__2146 = function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__2146__1.call(this,x);\ncase 2:\nreturn G__2146__2.call(this,x,start__$1);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2146.cljs$core$IFn$_invoke$arity$1 = G__2146__1;\nG__2146.cljs$core$IFn$_invoke$arity$2 = G__2146__2;\nreturn G__2146;\n})()\n;\n\ncljs.core.Subvec.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.Subvec.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif(typeof k === 'number'){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (coll,f,init){\nvar self__ = this;\nvar coll__$1 = this;\nvar i = self__.start;\nvar j = (0);\nvar init__$1 = init;\nwhile(true){\nif((i < self__.end)){\nvar init__$2 = (function (){var G__2139 = init__$1;\nvar G__2140 = j;\nvar G__2141 = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,i);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2139,G__2140,G__2141) : f.call(null,G__2139,G__2140,G__2141));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__2147 = (i + (1));\nvar G__2148 = (j + (1));\nvar G__2149 = init__$2;\ni = G__2147;\nj = G__2148;\ninit__$1 = G__2149;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (coll,n){\nvar self__ = this;\nvar coll__$1 = this;\nif((((n < (0))) || ((self__.end <= (self__.start + n))))){\nreturn cljs.core.vector_index_out_of_bounds(n,(self__.end - self__.start));\n} else {\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,(self__.start + n));\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (coll,n,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif((((n < (0))) || ((self__.end <= (self__.start + n))))){\nreturn not_found;\n} else {\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$3(self__.v,(self__.start + n),not_found);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (coll,n,val){\nvar self__ = this;\nvar coll__$1 = this;\nvar v_pos = (self__.start + n);\nif((((n < (0))) || (((self__.end + (1)) <= v_pos)))){\nthrow (new Error([\"Index \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n),\" out of bounds [0,\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(coll__$1.cljs$core$ICounted$_count$arity$1(null)),\"]\"].join('')));\n} else {\nreturn cljs.core.build_subvec(self__.meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.v,v_pos,val),self__.start,(function (){var x__4219__auto__ = self__.end;\nvar y__4220__auto__ = (v_pos + (1));\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})(),null);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((((!((self__.v == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === self__.v.cljs$core$APersistentVector$))))?true:false):false)){\nreturn cljs.core.ranged_iterator(self__.v,self__.start,self__.end);\n} else {\nreturn cljs.core.seq_iter(coll__$1);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Subvec.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.Subvec(self__.meta,self__.v,self__.start,self__.end,self__.__hash));\n});\n\ncljs.core.Subvec.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (self__.end - self__.start);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IStack$_peek$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,(self__.end - (1)));\n});\n\ncljs.core.Subvec.prototype.cljs$core$IStack$_pop$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.start === self__.end)){\nthrow (new Error(\"Can't pop empty vector\"));\n} else {\nreturn cljs.core.build_subvec(self__.meta,self__.v,self__.start,(self__.end - (1)),null);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((!((self__.start === self__.end)))){\nreturn (new cljs.core.RSeq(coll__$1,((self__.end - self__.start) - (1)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.PersistentVector.EMPTY,self__.meta);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nif((((!((self__.v == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === self__.v.cljs$core$APersistentVector$))))?true:false):false)){\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$4(self__.v,f,self__.start,self__.end);\n} else {\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(coll__$1,f);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,init){\nvar self__ = this;\nvar coll__$1 = this;\nif((((!((self__.v == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === self__.v.cljs$core$APersistentVector$))))?true:false):false)){\nreturn cljs.core.pv_reduce.cljs$core$IFn$_invoke$arity$5(self__.v,f,init,self__.start,self__.end);\n} else {\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(coll__$1,f,init);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,key,val){\nvar self__ = this;\nvar coll__$1 = this;\nif(typeof key === 'number'){\nreturn coll__$1.cljs$core$IVector$_assoc_n$arity$3(null,key,val);\n} else {\nthrow (new Error(\"Subvec's key for assoc must be a number.\"));\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar subvec_seq = ((function (coll__$1){\nreturn (function cljs$core$subvec_seq(i){\nif((i === self__.end)){\nreturn null;\n} else {\nreturn cljs.core.cons(cljs.core._nth.cljs$core$IFn$_invoke$arity$2(self__.v,i),(new cljs.core.LazySeq(null,((function (coll__$1){\nreturn (function (){\nreturn cljs$core$subvec_seq((i + (1)));\n});})(coll__$1))\n,null,null)));\n}\n});})(coll__$1))\n;\nreturn subvec_seq(self__.start);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn cljs.core.build_subvec(new_meta,self__.v,self__.start,self__.end,self__.__hash);\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.build_subvec(self__.meta,cljs.core._assoc_n(self__.v,self__.end,o),self__.start,(self__.end + (1)),null);\n});\n\ncljs.core.Subvec.prototype.call = (function() {\nvar G__2150 = null;\nvar G__2150__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__2150__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__2150 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2150__2.call(this,self__,k);\ncase 3:\nreturn G__2150__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2150.cljs$core$IFn$_invoke$arity$2 = G__2150__2;\nG__2150.cljs$core$IFn$_invoke$arity$3 = G__2150__3;\nreturn G__2150;\n})()\n;\n\ncljs.core.Subvec.prototype.apply = (function (self__,args2138){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2138)));\n});\n\ncljs.core.Subvec.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.Subvec.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"v\",\"v\",1661996586,null),new cljs.core.Symbol(null,\"start\",\"start\",1285322546,null),new cljs.core.Symbol(null,\"end\",\"end\",1372345569,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Subvec.cljs$lang$type = true;\n\ncljs.core.Subvec.cljs$lang$ctorStr = \"cljs.core/Subvec\";\n\ncljs.core.Subvec.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Subvec\");\n});\n\n/**\n * Positional factory function for cljs.core/Subvec.\n */\ncljs.core.__GT_Subvec = (function cljs$core$__GT_Subvec(meta,v,start,end,__hash){\nreturn (new cljs.core.Subvec(meta,v,start,end,__hash));\n});\n\nvar G__2151_2154 = cljs.core.Subvec.prototype;\nvar G__2152_2155 = cljs.core.ITER_SYMBOL;\nvar G__2153_2156 = ((function (G__2151_2154,G__2152_2155){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2151_2154,G__2152_2155))\n;\ngoog.object.set(G__2151_2154,G__2152_2155,G__2153_2156);\ncljs.core.build_subvec = (function cljs$core$build_subvec(meta,v,start,end,__hash){\nwhile(true){\nif((v instanceof cljs.core.Subvec)){\nvar G__2157 = meta;\nvar G__2158 = v.v;\nvar G__2159 = (v.start + start);\nvar G__2160 = (v.start + end);\nvar G__2161 = __hash;\nmeta = G__2157;\nv = G__2158;\nstart = G__2159;\nend = G__2160;\n__hash = G__2161;\ncontinue;\n} else {\nif(cljs.core.vector_QMARK_(v)){\n} else {\nthrow (new Error(\"v must satisfy IVector\"));\n}\n\nvar c_2162 = cljs.core.count(v);\nif((((start < (0))) || ((end < (0))) || ((start > c_2162)) || ((end > c_2162)))){\nthrow (new Error(\"Index out of bounds\"));\n} else {\n}\n\nreturn (new cljs.core.Subvec(meta,v,start,end,__hash));\n}\nbreak;\n}\n});\n/**\n * Returns a persistent vector of the items in vector from\n *   start (inclusive) to end (exclusive).  If end is not supplied,\n *   defaults to (count vector). This operation is O(1) and very fast, as\n *   the resulting vector shares structure with the original and no\n *   trimming is done.\n */\ncljs.core.subvec = (function cljs$core$subvec(var_args){\nvar G__2164 = arguments.length;\nswitch (G__2164) {\ncase 2:\nreturn cljs.core.subvec.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.subvec.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.subvec.cljs$core$IFn$_invoke$arity$2 = (function (v,start){\nreturn cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(v,start,cljs.core.count(v));\n});\n\ncljs.core.subvec.cljs$core$IFn$_invoke$arity$3 = (function (v,start,end){\nif((((!((start == null)))) && ((!((end == null)))))){\n} else {\nthrow (new Error(\"Assert failed: (and (not (nil? start)) (not (nil? end)))\"));\n}\n\nreturn cljs.core.build_subvec(null,v,(start | (0)),(end | (0)),null);\n});\n\ncljs.core.subvec.cljs$lang$maxFixedArity = 3;\n\ncljs.core.tv_ensure_editable = (function cljs$core$tv_ensure_editable(edit,node){\nif((edit === node.edit)){\nreturn node;\n} else {\nreturn (new cljs.core.VectorNode(edit,cljs.core.aclone(node.arr)));\n}\n});\ncljs.core.tv_editable_root = (function cljs$core$tv_editable_root(node){\nreturn (new cljs.core.VectorNode(({}),cljs.core.aclone(node.arr)));\n});\ncljs.core.tv_editable_tail = (function cljs$core$tv_editable_tail(tl){\nvar ret = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\ncljs.core.array_copy(tl,(0),ret,(0),tl.length);\n\nreturn ret;\n});\ncljs.core.tv_push_tail = (function cljs$core$tv_push_tail(tv,level,parent,tail_node){\nvar ret = cljs.core.tv_ensure_editable(tv.root.edit,parent);\nvar subidx = (((tv.cnt - (1)) >>> level) & (31));\ncljs.core.pv_aset(ret,subidx,(((level === (5)))?tail_node:(function (){var child = cljs.core.pv_aget(ret,subidx);\nif((!((child == null)))){\nvar G__2168 = tv;\nvar G__2169 = (level - (5));\nvar G__2170 = child;\nvar G__2171 = tail_node;\nreturn (cljs.core.tv_push_tail.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tv_push_tail.cljs$core$IFn$_invoke$arity$4(G__2168,G__2169,G__2170,G__2171) : cljs.core.tv_push_tail.call(null,G__2168,G__2169,G__2170,G__2171));\n} else {\nreturn cljs.core.new_path(tv.root.edit,(level - (5)),tail_node);\n}\n})()));\n\nreturn ret;\n});\ncljs.core.tv_pop_tail = (function cljs$core$tv_pop_tail(tv,level,node){\nvar node__$1 = cljs.core.tv_ensure_editable(tv.root.edit,node);\nvar subidx = (((tv.cnt - (2)) >>> level) & (31));\nif((level > (5))){\nvar new_child = (function (){var G__2172 = tv;\nvar G__2173 = (level - (5));\nvar G__2174 = cljs.core.pv_aget(node__$1,subidx);\nreturn (cljs.core.tv_pop_tail.cljs$core$IFn$_invoke$arity$3 ? cljs.core.tv_pop_tail.cljs$core$IFn$_invoke$arity$3(G__2172,G__2173,G__2174) : cljs.core.tv_pop_tail.call(null,G__2172,G__2173,G__2174));\n})();\nif((((new_child == null)) && ((subidx === (0))))){\nreturn null;\n} else {\ncljs.core.pv_aset(node__$1,subidx,new_child);\n\nreturn node__$1;\n}\n} else {\nif((subidx === (0))){\nreturn null;\n} else {\ncljs.core.pv_aset(node__$1,subidx,null);\n\nreturn node__$1;\n\n}\n}\n});\ncljs.core.unchecked_editable_array_for = (function cljs$core$unchecked_editable_array_for(tv,i){\nif((i >= cljs.core.tail_off(tv))){\nreturn tv.tail;\n} else {\nvar root = tv.root;\nvar node = root;\nvar level = tv.shift;\nwhile(true){\nif((level > (0))){\nvar G__2175 = cljs.core.tv_ensure_editable(root.edit,cljs.core.pv_aget(node,((i >>> level) & (31))));\nvar G__2176 = (level - (5));\nnode = G__2175;\nlevel = G__2176;\ncontinue;\n} else {\nreturn node.arr;\n}\nbreak;\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientVector}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientVector = (function (cnt,shift,root,tail){\nthis.cnt = cnt;\nthis.shift = shift;\nthis.root = root;\nthis.tail = tail;\nthis.cljs$lang$protocol_mask$partition1$ = 88;\nthis.cljs$lang$protocol_mask$partition0$ = 275;\n});\ncljs.core.TransientVector.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 = (function (tcoll,o){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(self__.root.edit){\nif(((self__.cnt - cljs.core.tail_off(tcoll__$1)) < (32))){\n(self__.tail[(self__.cnt & (31))] = o);\n\nself__.cnt = (self__.cnt + (1));\n\nreturn tcoll__$1;\n} else {\nvar tail_node = (new cljs.core.VectorNode(self__.root.edit,self__.tail));\nvar new_tail = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\n(new_tail[(0)] = o);\n\nself__.tail = new_tail;\n\nif(((self__.cnt >>> (5)) > ((1) << self__.shift))){\nvar new_root_array = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar new_shift = (self__.shift + (5));\n(new_root_array[(0)] = self__.root);\n\n(new_root_array[(1)] = cljs.core.new_path(self__.root.edit,self__.shift,tail_node));\n\nself__.root = (new cljs.core.VectorNode(self__.root.edit,new_root_array));\n\nself__.shift = new_shift;\n\nself__.cnt = (self__.cnt + (1));\n\nreturn tcoll__$1;\n} else {\nvar new_root = cljs.core.tv_push_tail(tcoll__$1,self__.shift,self__.root,tail_node);\nself__.root = new_root;\n\nself__.cnt = (self__.cnt + (1));\n\nreturn tcoll__$1;\n}\n}\n} else {\nthrow (new Error(\"conj! after persistent!\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(self__.root.edit){\nself__.root.edit = null;\n\nvar len = (self__.cnt - cljs.core.tail_off(tcoll__$1));\nvar trimmed_tail = (new Array(len));\ncljs.core.array_copy(self__.tail,(0),trimmed_tail,(0),len);\n\nreturn (new cljs.core.PersistentVector(null,self__.cnt,self__.shift,self__.root,trimmed_tail,null));\n} else {\nthrow (new Error(\"persistent! called twice\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 = (function (tcoll,key,val){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(typeof key === 'number'){\nreturn tcoll__$1.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3(null,key,val);\n} else {\nthrow (new Error(\"TransientVector's key for assoc! must be a number.\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientVector$_assoc_n_BANG_$arity$3 = (function (tcoll,n,val){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(self__.root.edit){\nif(((((0) <= n)) && ((n < self__.cnt)))){\nif((cljs.core.tail_off(tcoll__$1) <= n)){\n(self__.tail[(n & (31))] = val);\n\nreturn tcoll__$1;\n} else {\nvar new_root = (function (){var fexpr__2178 = ((function (tcoll__$1){\nreturn (function cljs$core$go(level,node){\nvar node__$1 = cljs.core.tv_ensure_editable(self__.root.edit,node);\nif((level === (0))){\ncljs.core.pv_aset(node__$1,(n & (31)),val);\n\nreturn node__$1;\n} else {\nvar subidx = ((n >>> level) & (31));\ncljs.core.pv_aset(node__$1,subidx,cljs$core$go((level - (5)),cljs.core.pv_aget(node__$1,subidx)));\n\nreturn node__$1;\n}\n});})(tcoll__$1))\n;\nreturn fexpr__2178(self__.shift,self__.root);\n})();\nself__.root = new_root;\n\nreturn tcoll__$1;\n}\n} else {\nif((n === self__.cnt)){\nreturn tcoll__$1.cljs$core$ITransientCollection$_conj_BANG_$arity$2(null,val);\n} else {\nthrow (new Error([\"Index \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n),\" out of bounds for TransientVector of length\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.cnt)].join('')));\n\n}\n}\n} else {\nthrow (new Error(\"assoc! after persistent!\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ITransientVector$_pop_BANG_$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(self__.root.edit){\nif((self__.cnt === (0))){\nthrow (new Error(\"Can't pop empty vector\"));\n} else {\nif(((1) === self__.cnt)){\nself__.cnt = (0);\n\nreturn tcoll__$1;\n} else {\nif((((self__.cnt - (1)) & (31)) > (0))){\nself__.cnt = (self__.cnt - (1));\n\nreturn tcoll__$1;\n} else {\nvar new_tail = cljs.core.unchecked_editable_array_for(tcoll__$1,(self__.cnt - (2)));\nvar new_root = (function (){var nr = cljs.core.tv_pop_tail(tcoll__$1,self__.shift,self__.root);\nif((!((nr == null)))){\nreturn nr;\n} else {\nreturn (new cljs.core.VectorNode(self__.root.edit,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]));\n}\n})();\nif(((((5) < self__.shift)) && ((cljs.core.pv_aget(new_root,(1)) == null)))){\nvar new_root__$1 = cljs.core.tv_ensure_editable(self__.root.edit,cljs.core.pv_aget(new_root,(0)));\nself__.root = new_root__$1;\n\nself__.shift = (self__.shift - (5));\n\nself__.cnt = (self__.cnt - (1));\n\nself__.tail = new_tail;\n\nreturn tcoll__$1;\n} else {\nself__.root = new_root;\n\nself__.cnt = (self__.cnt - (1));\n\nself__.tail = new_tail;\n\nreturn tcoll__$1;\n}\n\n}\n}\n}\n} else {\nthrow (new Error(\"pop! after persistent!\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(self__.root.edit){\nreturn self__.cnt;\n} else {\nthrow (new Error(\"count after persistent!\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (coll,n){\nvar self__ = this;\nvar coll__$1 = this;\nif(self__.root.edit){\nreturn (cljs.core.array_for(coll__$1,n)[(n & (31))]);\n} else {\nthrow (new Error(\"nth after persistent!\"));\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (coll,n,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif(((((0) <= n)) && ((n < self__.cnt)))){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$2(null,n);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.TransientVector.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif(typeof k === 'number'){\nreturn coll__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.TransientVector.prototype.call = (function() {\nvar G__2179 = null;\nvar G__2179__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2179__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2179 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2179__2.call(this,self__,k);\ncase 3:\nreturn G__2179__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2179.cljs$core$IFn$_invoke$arity$2 = G__2179__2;\nG__2179.cljs$core$IFn$_invoke$arity$3 = G__2179__3;\nreturn G__2179;\n})()\n;\n\ncljs.core.TransientVector.prototype.apply = (function (self__,args2177){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2177)));\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.TransientVector.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.TransientVector.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"shift\",\"shift\",-1657295705,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"tail\",\"tail\",494507963,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.TransientVector.cljs$lang$type = true;\n\ncljs.core.TransientVector.cljs$lang$ctorStr = \"cljs.core/TransientVector\";\n\ncljs.core.TransientVector.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/TransientVector\");\n});\n\n/**\n * Positional factory function for cljs.core/TransientVector.\n */\ncljs.core.__GT_TransientVector = (function cljs$core$__GT_TransientVector(cnt,shift,root,tail){\nreturn (new cljs.core.TransientVector(cnt,shift,root,tail));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.PersistentQueueIter = (function (fseq,riter){\nthis.fseq = fseq;\nthis.riter = riter;\n});\ncljs.core.PersistentQueueIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nvar or__4131__auto__ = (((!((self__.fseq == null)))) && (cljs.core.seq(self__.fseq)));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar and__4120__auto__ = (!((self__.riter == null)));\nif(and__4120__auto__){\nreturn self__.riter.hasNext();\n} else {\nreturn and__4120__auto__;\n}\n}\n});\n\ncljs.core.PersistentQueueIter.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif((!((self__.fseq == null)))){\nvar ret = cljs.core.first(self__.fseq);\nself__.fseq = cljs.core.next(self__.fseq);\n\nreturn ret;\n} else {\nif((((!((self__.riter == null)))) && (self__.riter.hasNext()))){\nreturn self__.riter.next();\n} else {\nthrow (new Error(\"No such element\"));\n\n}\n}\n});\n\ncljs.core.PersistentQueueIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.PersistentQueueIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"fseq\",\"fseq\",-1466412450,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"riter\",\"riter\",-237834262,null)], null);\n});\n\ncljs.core.PersistentQueueIter.cljs$lang$type = true;\n\ncljs.core.PersistentQueueIter.cljs$lang$ctorStr = \"cljs.core/PersistentQueueIter\";\n\ncljs.core.PersistentQueueIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentQueueIter\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentQueueIter.\n */\ncljs.core.__GT_PersistentQueueIter = (function cljs$core$__GT_PersistentQueueIter(fseq,riter){\nreturn (new cljs.core.PersistentQueueIter(fseq,riter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.PersistentQueueSeq = (function (meta,front,rear,__hash){\nthis.meta = meta;\nthis.front = front;\nthis.rear = rear;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 31850700;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.PersistentQueueSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentQueueSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentQueueSeq.prototype.indexOf = (function() {\nvar G__2180 = null;\nvar G__2180__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2180__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2180 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2180__1.call(this,x);\ncase 2:\nreturn G__2180__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2180.cljs$core$IFn$_invoke$arity$1 = G__2180__1;\nG__2180.cljs$core$IFn$_invoke$arity$2 = G__2180__2;\nreturn G__2180;\n})()\n;\n\ncljs.core.PersistentQueueSeq.prototype.lastIndexOf = (function() {\nvar G__2181 = null;\nvar G__2181__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2181__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2181 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2181__1.call(this,x);\ncase 2:\nreturn G__2181__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2181.cljs$core$IFn$_invoke$arity$1 = G__2181__1;\nG__2181.cljs$core$IFn$_invoke$arity$2 = G__2181__2;\nreturn G__2181;\n})()\n;\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar temp__5718__auto__ = cljs.core.next(self__.front);\nif(temp__5718__auto__){\nvar f1 = temp__5718__auto__;\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,f1,self__.rear,null));\n} else {\nif((!((self__.rear == null)))){\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,self__.rear,null,null));\n} else {\nreturn null;\n}\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.List.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.first(self__.front);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar temp__5718__auto__ = cljs.core.next(self__.front);\nif(temp__5718__auto__){\nvar f1 = temp__5718__auto__;\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,f1,self__.rear,null));\n} else {\nif((self__.rear == null)){\nreturn coll__$1.cljs$core$IEmptyableCollection$_empty$arity$1(null);\n} else {\nreturn (new cljs.core.PersistentQueueSeq(self__.meta,self__.rear,null,null));\n}\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentQueueSeq(new_meta,self__.front,self__.rear,self__.__hash));\n}\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.PersistentQueueSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"front\",\"front\",117022539,null),new cljs.core.Symbol(null,\"rear\",\"rear\",-900164830,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentQueueSeq.cljs$lang$type = true;\n\ncljs.core.PersistentQueueSeq.cljs$lang$ctorStr = \"cljs.core/PersistentQueueSeq\";\n\ncljs.core.PersistentQueueSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentQueueSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentQueueSeq.\n */\ncljs.core.__GT_PersistentQueueSeq = (function cljs$core$__GT_PersistentQueueSeq(meta,front,rear,__hash){\nreturn (new cljs.core.PersistentQueueSeq(meta,front,rear,__hash));\n});\n\nvar G__2182_2185 = cljs.core.PersistentQueueSeq.prototype;\nvar G__2183_2186 = cljs.core.ITER_SYMBOL;\nvar G__2184_2187 = ((function (G__2182_2185,G__2183_2186){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2182_2185,G__2183_2186))\n;\ngoog.object.set(G__2182_2185,G__2183_2186,G__2184_2187);\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n*/\ncljs.core.PersistentQueue = (function (meta,count,front,rear,__hash){\nthis.meta = meta;\nthis.count = count;\nthis.front = front;\nthis.rear = rear;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\nthis.cljs$lang$protocol_mask$partition0$ = 31858766;\n});\ncljs.core.PersistentQueue.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentQueue.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentQueue.prototype.indexOf = (function() {\nvar G__2188 = null;\nvar G__2188__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2188__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2188 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2188__1.call(this,x);\ncase 2:\nreturn G__2188__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2188.cljs$core$IFn$_invoke$arity$1 = G__2188__1;\nG__2188.cljs$core$IFn$_invoke$arity$2 = G__2188__2;\nreturn G__2188;\n})()\n;\n\ncljs.core.PersistentQueue.prototype.lastIndexOf = (function() {\nvar G__2189 = null;\nvar G__2189__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(self__.count.cljs$core$IFn$_invoke$arity$1 ? self__.count.cljs$core$IFn$_invoke$arity$1(coll) : self__.count.call(null,coll)));\n});\nvar G__2189__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2189 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2189__1.call(this,x);\ncase 2:\nreturn G__2189__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2189.cljs$core$IFn$_invoke$arity$1 = G__2189__1;\nG__2189.cljs$core$IFn$_invoke$arity$2 = G__2189__2;\nreturn G__2189;\n})()\n;\n\ncljs.core.PersistentQueue.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentQueueIter(self__.front,cljs.core._iterator(self__.rear)));\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentQueue(self__.meta,self__.count,self__.front,self__.rear,self__.__hash));\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.count;\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IStack$_peek$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.first(self__.front);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IStack$_pop$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.truth_(self__.front)){\nvar temp__5718__auto__ = cljs.core.next(self__.front);\nif(temp__5718__auto__){\nvar f1 = temp__5718__auto__;\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count - (1)),f1,self__.rear,null));\n} else {\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count - (1)),cljs.core.seq(self__.rear),cljs.core.PersistentVector.EMPTY,null));\n}\n} else {\nreturn coll__$1;\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.PersistentQueue.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.first(self__.front);\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.rest(cljs.core.seq(coll__$1));\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar rear__$1 = cljs.core.seq(self__.rear);\nif(cljs.core.truth_((function (){var or__4131__auto__ = self__.front;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn rear__$1;\n}\n})())){\nreturn (new cljs.core.PersistentQueueSeq(null,self__.front,cljs.core.seq(rear__$1),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentQueue(new_meta,self__.count,self__.front,self__.rear,self__.__hash));\n}\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.truth_(self__.front)){\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count + (1)),self__.front,cljs.core.conj.cljs$core$IFn$_invoke$arity$2((function (){var or__4131__auto__ = self__.rear;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentVector.EMPTY;\n}\n})(),o),null));\n} else {\nreturn (new cljs.core.PersistentQueue(self__.meta,(self__.count + (1)),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(self__.front,o),cljs.core.PersistentVector.EMPTY,null));\n}\n});\n\ncljs.core.PersistentQueue.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"count\",\"count\",-514511684,null),new cljs.core.Symbol(null,\"front\",\"front\",117022539,null),new cljs.core.Symbol(null,\"rear\",\"rear\",-900164830,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentQueue.cljs$lang$type = true;\n\ncljs.core.PersistentQueue.cljs$lang$ctorStr = \"cljs.core/PersistentQueue\";\n\ncljs.core.PersistentQueue.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentQueue\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentQueue.\n */\ncljs.core.__GT_PersistentQueue = (function cljs$core$__GT_PersistentQueue(meta,count,front,rear,__hash){\nreturn (new cljs.core.PersistentQueue(meta,count,front,rear,__hash));\n});\n\ncljs.core.PersistentQueue.EMPTY = (new cljs.core.PersistentQueue(null,(0),null,cljs.core.PersistentVector.EMPTY,cljs.core.empty_ordered_hash));\nvar G__2190_2193 = cljs.core.PersistentQueue.prototype;\nvar G__2191_2194 = cljs.core.ITER_SYMBOL;\nvar G__2192_2195 = ((function (G__2190_2193,G__2191_2194){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2190_2193,G__2191_2194))\n;\ngoog.object.set(G__2190_2193,G__2191_2194,G__2192_2195);\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n*/\ncljs.core.NeverEquiv = (function (){\nthis.cljs$lang$protocol_mask$partition0$ = 2097152;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.NeverEquiv.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.NeverEquiv.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (o,other){\nvar self__ = this;\nvar o__$1 = this;\nreturn false;\n});\n\ncljs.core.NeverEquiv.getBasis = (function (){\nreturn cljs.core.PersistentVector.EMPTY;\n});\n\ncljs.core.NeverEquiv.cljs$lang$type = true;\n\ncljs.core.NeverEquiv.cljs$lang$ctorStr = \"cljs.core/NeverEquiv\";\n\ncljs.core.NeverEquiv.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/NeverEquiv\");\n});\n\n/**\n * Positional factory function for cljs.core/NeverEquiv.\n */\ncljs.core.__GT_NeverEquiv = (function cljs$core$__GT_NeverEquiv(){\nreturn (new cljs.core.NeverEquiv());\n});\n\ncljs.core.never_equiv = (new cljs.core.NeverEquiv());\n/**\n * Test map equivalence. Returns true if x equals y, otherwise returns false.\n */\ncljs.core.equiv_map = (function cljs$core$equiv_map(x,y){\nreturn cljs.core.boolean$(((((cljs.core.map_QMARK_(y)) && ((!(cljs.core.record_QMARK_(y))))))?(((cljs.core.count(x) === cljs.core.count(y)))?(((((!((x == null))))?(((((x.cljs$lang$protocol_mask$partition0$ & (1048576))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IKVReduce$))))?true:(((!x.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IKVReduce,x):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IKVReduce,x)))?cljs.core.reduce_kv((function (_,k,v){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(y,k,cljs.core.never_equiv),v)){\nreturn true;\n} else {\nreturn cljs.core.reduced(false);\n}\n}),true,x):cljs.core.every_QMARK_((function (xkv){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(y,cljs.core.first(xkv),cljs.core.never_equiv),cljs.core.second(xkv));\n}),x)):null):null));\n});\ncljs.core.scan_array = (function cljs$core$scan_array(incr,k,array){\nvar len = array.length;\nvar i = (0);\nwhile(true){\nif((i < len)){\nif((k === (array[i]))){\nreturn i;\n} else {\nvar G__2197 = (i + incr);\ni = G__2197;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\ncljs.core.obj_map_compare_keys = (function cljs$core$obj_map_compare_keys(a,b){\nvar a__$1 = cljs.core.hash(a);\nvar b__$1 = cljs.core.hash(b);\nif((a__$1 < b__$1)){\nreturn (-1);\n} else {\nif((a__$1 > b__$1)){\nreturn (1);\n} else {\nreturn (0);\n\n}\n}\n});\ncljs.core.obj_map__GT_hash_map = (function cljs$core$obj_map__GT_hash_map(m,k,v){\nvar ks = m.keys;\nvar len = ks.length;\nvar so = m.strobj;\nvar mm = cljs.core.meta(m);\nvar i = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif((i < len)){\nvar k__$1 = (ks[i]);\nvar G__2198 = (i + (1));\nvar G__2199 = cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,k__$1,goog.object.get(so,k__$1));\ni = G__2198;\nout = G__2199;\ncontinue;\n} else {\nreturn cljs.core._with_meta(cljs.core.persistent_BANG_(cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,k,v)),mm);\n}\nbreak;\n}\n});\ncljs.core.obj_clone = (function cljs$core$obj_clone(obj,ks){\nvar new_obj = ({});\nvar l = ks.length;\nvar i_2205 = (0);\nwhile(true){\nif((i_2205 < l)){\nvar k_2206 = (ks[i_2205]);\nvar G__2202_2207 = new_obj;\nvar G__2203_2208 = k_2206;\nvar G__2204_2209 = goog.object.get(obj,k_2206);\ngoog.object.set(G__2202_2207,G__2203_2208,G__2204_2209);\n\nvar G__2210 = (i_2205 + (1));\ni_2205 = G__2210;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn new_obj;\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.ObjMap = (function (meta,keys,strobj,update_count,__hash){\nthis.meta = meta;\nthis.keys = keys;\nthis.strobj = strobj;\nthis.update_count = update_count;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 16123663;\nthis.cljs$lang$protocol_mask$partition1$ = 4;\n});\ncljs.core.ObjMap.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ObjMap.prototype.cljs$core$IFind$_find$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif(((goog.isString(k)) && ((!((cljs.core.scan_array((1),k,self__.keys) == null)))))){\nreturn (new cljs.core.MapEntry(k,(self__.strobj[k]),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.ObjMap.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ObjMap.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif(((goog.isString(k)) && ((!((cljs.core.scan_array((1),k,self__.keys) == null)))))){\nreturn (self__.strobj[k]);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (coll,f,init){\nvar self__ = this;\nvar coll__$1 = this;\nvar len = self__.keys.length;\nvar keys__$1 = self__.keys.sort(cljs.core.obj_map_compare_keys);\nvar init__$1 = init;\nwhile(true){\nif(cljs.core.seq(keys__$1)){\nvar k = cljs.core.first(keys__$1);\nvar init__$2 = (function (){var G__2213 = init__$1;\nvar G__2214 = k;\nvar G__2215 = (self__.strobj[k]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2213,G__2214,G__2215) : f.call(null,G__2213,G__2214,G__2215));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__2216 = cljs.core.rest(keys__$1);\nvar G__2217 = init__$2;\nkeys__$1 = G__2216;\ninit__$1 = G__2217;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.keys.length;\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_map(coll__$1,other);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.transient$(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashMap.EMPTY,coll__$1));\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.ObjMap.EMPTY,self__.meta);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif(((goog.isString(k)) && ((!((cljs.core.scan_array((1),k,self__.keys) == null)))))){\nvar new_keys = cljs.core.aclone(self__.keys);\nvar new_strobj = cljs.core.obj_clone(self__.strobj,self__.keys);\nnew_keys.splice(cljs.core.scan_array((1),k,new_keys),(1));\n\ndelete new_strobj[k];\n\nreturn (new cljs.core.ObjMap(self__.meta,new_keys,new_strobj,(self__.update_count + (1)),null));\n} else {\nreturn coll__$1;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,k,v){\nvar self__ = this;\nvar coll__$1 = this;\nif(goog.isString(k)){\nif((((self__.update_count > cljs.core.ObjMap.HASHMAP_THRESHOLD)) || ((self__.keys.length >= cljs.core.ObjMap.HASHMAP_THRESHOLD)))){\nreturn cljs.core.obj_map__GT_hash_map(coll__$1,k,v);\n} else {\nif((!((cljs.core.scan_array((1),k,self__.keys) == null)))){\nvar new_strobj = cljs.core.obj_clone(self__.strobj,self__.keys);\ngoog.object.set(new_strobj,k,v);\n\nreturn (new cljs.core.ObjMap(self__.meta,self__.keys,new_strobj,(self__.update_count + (1)),null));\n} else {\nvar new_strobj = cljs.core.obj_clone(self__.strobj,self__.keys);\nvar new_keys = cljs.core.aclone(self__.keys);\ngoog.object.set(new_strobj,k,v);\n\nnew_keys.push(k);\n\nreturn (new cljs.core.ObjMap(self__.meta,new_keys,new_strobj,(self__.update_count + (1)),null));\n}\n}\n} else {\nreturn cljs.core.obj_map__GT_hash_map(coll__$1,k,v);\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif(((goog.isString(k)) && ((!((cljs.core.scan_array((1),k,self__.keys) == null)))))){\nreturn true;\n} else {\nreturn false;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.keys.length > (0))){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (coll__$1){\nreturn (function (p1__2211_SHARP_){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__2211_SHARP_,(self__.strobj[p1__2211_SHARP_])],null));\n});})(coll__$1))\n,self__.keys.sort(cljs.core.obj_map_compare_keys));\n} else {\nreturn null;\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ObjMap(new_meta,self__.keys,self__.strobj,self__.update_count,self__.__hash));\n}\n});\n\ncljs.core.ObjMap.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,coll__$1,entry);\n}\n});\n\ncljs.core.ObjMap.prototype.call = (function() {\nvar G__2218 = null;\nvar G__2218__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2218__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2218 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2218__2.call(this,self__,k);\ncase 3:\nreturn G__2218__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2218.cljs$core$IFn$_invoke$arity$2 = G__2218__2;\nG__2218.cljs$core$IFn$_invoke$arity$3 = G__2218__3;\nreturn G__2218;\n})()\n;\n\ncljs.core.ObjMap.prototype.apply = (function (self__,args2212){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2212)));\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.ObjMap.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"keys\",\"keys\",-1586012071,null),new cljs.core.Symbol(null,\"strobj\",\"strobj\",1088091283,null),new cljs.core.Symbol(null,\"update-count\",\"update-count\",-411982269,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ObjMap.cljs$lang$type = true;\n\ncljs.core.ObjMap.cljs$lang$ctorStr = \"cljs.core/ObjMap\";\n\ncljs.core.ObjMap.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ObjMap\");\n});\n\n/**\n * Positional factory function for cljs.core/ObjMap.\n */\ncljs.core.__GT_ObjMap = (function cljs$core$__GT_ObjMap(meta,keys,strobj,update_count,__hash){\nreturn (new cljs.core.ObjMap(meta,keys,strobj,update_count,__hash));\n});\n\ncljs.core.ObjMap.EMPTY = (new cljs.core.ObjMap(null,[],({}),(0),cljs.core.empty_unordered_hash));\ncljs.core.ObjMap.HASHMAP_THRESHOLD = (8);\ncljs.core.ObjMap.fromObject = (function (ks,obj){\nreturn (new cljs.core.ObjMap(null,ks,obj,(0),null));\n});\n\n/**\n* @constructor\n*/\ncljs.core.RecordIter = (function (i,record,base_count,fields,ext_map_iter){\nthis.i = i;\nthis.record = record;\nthis.base_count = base_count;\nthis.fields = fields;\nthis.ext_map_iter = ext_map_iter;\n});\ncljs.core.RecordIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nvar or__4131__auto__ = (self__.i < self__.base_count);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn self__.ext_map_iter.hasNext();\n}\n});\n\ncljs.core.RecordIter.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif((self__.i < self__.base_count)){\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(self__.fields,self__.i);\nself__.i = (self__.i + (1));\n\nreturn (new cljs.core.MapEntry(k,cljs.core._lookup.cljs$core$IFn$_invoke$arity$2(self__.record,k),null));\n} else {\nreturn self__.ext_map_iter.next();\n}\n});\n\ncljs.core.RecordIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.RecordIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"record\",\"record\",861424668,null),new cljs.core.Symbol(null,\"base-count\",\"base-count\",-1180647182,null),new cljs.core.Symbol(null,\"fields\",\"fields\",-291534703,null),new cljs.core.Symbol(null,\"ext-map-iter\",\"ext-map-iter\",-1215982757,null)], null);\n});\n\ncljs.core.RecordIter.cljs$lang$type = true;\n\ncljs.core.RecordIter.cljs$lang$ctorStr = \"cljs.core/RecordIter\";\n\ncljs.core.RecordIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/RecordIter\");\n});\n\n/**\n * Positional factory function for cljs.core/RecordIter.\n */\ncljs.core.__GT_RecordIter = (function cljs$core$__GT_RecordIter(i,record,base_count,fields,ext_map_iter){\nreturn (new cljs.core.RecordIter(i,record,base_count,fields,ext_map_iter));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.ES6EntriesIterator = (function (s){\nthis.s = s;\n});\ncljs.core.ES6EntriesIterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif((!((self__.s == null)))){\nvar vec__2221 = cljs.core.first(self__.s);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2221,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2221,(1),null);\nself__.s = cljs.core.next(self__.s);\n\nreturn ({\"value\": [k,v], \"done\": false});\n} else {\nreturn ({\"value\": null, \"done\": true});\n}\n});\n\ncljs.core.ES6EntriesIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ES6EntriesIterator.cljs$lang$type = true;\n\ncljs.core.ES6EntriesIterator.cljs$lang$ctorStr = \"cljs.core/ES6EntriesIterator\";\n\ncljs.core.ES6EntriesIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ES6EntriesIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/ES6EntriesIterator.\n */\ncljs.core.__GT_ES6EntriesIterator = (function cljs$core$__GT_ES6EntriesIterator(s){\nreturn (new cljs.core.ES6EntriesIterator(s));\n});\n\ncljs.core.es6_entries_iterator = (function cljs$core$es6_entries_iterator(coll){\nreturn (new cljs.core.ES6EntriesIterator(cljs.core.seq(coll)));\n});\n\n/**\n* @constructor\n*/\ncljs.core.ES6SetEntriesIterator = (function (s){\nthis.s = s;\n});\ncljs.core.ES6SetEntriesIterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif((!((self__.s == null)))){\nvar x = cljs.core.first(self__.s);\nself__.s = cljs.core.next(self__.s);\n\nreturn ({\"value\": [x,x], \"done\": false});\n} else {\nreturn ({\"value\": null, \"done\": true});\n}\n});\n\ncljs.core.ES6SetEntriesIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ES6SetEntriesIterator.cljs$lang$type = true;\n\ncljs.core.ES6SetEntriesIterator.cljs$lang$ctorStr = \"cljs.core/ES6SetEntriesIterator\";\n\ncljs.core.ES6SetEntriesIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ES6SetEntriesIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/ES6SetEntriesIterator.\n */\ncljs.core.__GT_ES6SetEntriesIterator = (function cljs$core$__GT_ES6SetEntriesIterator(s){\nreturn (new cljs.core.ES6SetEntriesIterator(s));\n});\n\ncljs.core.es6_set_entries_iterator = (function cljs$core$es6_set_entries_iterator(coll){\nreturn (new cljs.core.ES6SetEntriesIterator(cljs.core.seq(coll)));\n});\ncljs.core.array_index_of_nil_QMARK_ = (function cljs$core$array_index_of_nil_QMARK_(arr){\nvar len = arr.length;\nvar i = (0);\nwhile(true){\nif((len <= i)){\nreturn (-1);\n} else {\nif(((arr[i]) == null)){\nreturn i;\n} else {\nvar G__2224 = (i + (2));\ni = G__2224;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_keyword_QMARK_ = (function cljs$core$array_index_of_keyword_QMARK_(arr,k){\nvar len = arr.length;\nvar kstr = k.fqn;\nvar i = (0);\nwhile(true){\nif((len <= i)){\nreturn (-1);\n} else {\nif(((((arr[i]) instanceof cljs.core.Keyword)) && ((kstr === (arr[i]).fqn)))){\nreturn i;\n} else {\nvar G__2225 = (i + (2));\ni = G__2225;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_symbol_QMARK_ = (function cljs$core$array_index_of_symbol_QMARK_(arr,k){\nvar len = arr.length;\nvar kstr = k.str;\nvar i = (0);\nwhile(true){\nif((len <= i)){\nreturn (-1);\n} else {\nif(((((arr[i]) instanceof cljs.core.Symbol)) && ((kstr === (arr[i]).str)))){\nreturn i;\n} else {\nvar G__2226 = (i + (2));\ni = G__2226;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_identical_QMARK_ = (function cljs$core$array_index_of_identical_QMARK_(arr,k){\nvar len = arr.length;\nvar i = (0);\nwhile(true){\nif((len <= i)){\nreturn (-1);\n} else {\nif((k === (arr[i]))){\nreturn i;\n} else {\nvar G__2227 = (i + (2));\ni = G__2227;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of_equiv_QMARK_ = (function cljs$core$array_index_of_equiv_QMARK_(arr,k){\nvar len = arr.length;\nvar i = (0);\nwhile(true){\nif((len <= i)){\nreturn (-1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(k,(arr[i]))){\nreturn i;\n} else {\nvar G__2228 = (i + (2));\ni = G__2228;\ncontinue;\n\n}\n}\nbreak;\n}\n});\ncljs.core.array_index_of = (function cljs$core$array_index_of(arr,k){\nif((k instanceof cljs.core.Keyword)){\nreturn cljs.core.array_index_of_keyword_QMARK_(arr,k);\n} else {\nif(((goog.isString(k)) || (typeof k === 'number'))){\nreturn cljs.core.array_index_of_identical_QMARK_(arr,k);\n} else {\nif((k instanceof cljs.core.Symbol)){\nreturn cljs.core.array_index_of_symbol_QMARK_(arr,k);\n} else {\nif((k == null)){\nreturn cljs.core.array_index_of_nil_QMARK_(arr);\n} else {\nreturn cljs.core.array_index_of_equiv_QMARK_(arr,k);\n\n}\n}\n}\n}\n});\ncljs.core.array_map_index_of = (function cljs$core$array_map_index_of(m,k){\nreturn cljs.core.array_index_of(m.arr,k);\n});\ncljs.core.array_extend_kv = (function cljs$core$array_extend_kv(arr,k,v){\nvar l = arr.length;\nvar narr = (new Array((l + (2))));\nvar i_2229 = (0);\nwhile(true){\nif((i_2229 < l)){\n(narr[i_2229] = (arr[i_2229]));\n\nvar G__2230 = (i_2229 + (1));\ni_2229 = G__2230;\ncontinue;\n} else {\n}\nbreak;\n}\n\n(narr[l] = k);\n\n(narr[(l + (1))] = v);\n\nreturn narr;\n});\ncljs.core.array_map_extend_kv = (function cljs$core$array_map_extend_kv(m,k,v){\nreturn cljs.core.array_extend_kv(m.arr,k,v);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.MapEntry = (function (key,val,__hash){\nthis.key = key;\nthis.val = val;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 166619935;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.MapEntry.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MapEntry.prototype.cljs$core$IFind$_find$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nvar G__2232 = k;\nswitch (G__2232) {\ncase (0):\nreturn (new cljs.core.MapEntry((0),self__.key,null));\n\nbreak;\ncase (1):\nreturn (new cljs.core.MapEntry((1),self__.val,null));\n\nbreak;\ndefault:\nreturn null;\n\n}\n});\n\ncljs.core.MapEntry.prototype.indexOf = (function() {\nvar G__2234 = null;\nvar G__2234__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2234__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2234 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2234__1.call(this,x);\ncase 2:\nreturn G__2234__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2234.cljs$core$IFn$_invoke$arity$1 = G__2234__1;\nG__2234.cljs$core$IFn$_invoke$arity$2 = G__2234__2;\nreturn G__2234;\n})()\n;\n\ncljs.core.MapEntry.prototype.lastIndexOf = (function() {\nvar G__2235 = null;\nvar G__2235__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2235__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2235 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2235__1.call(this,x);\ncase 2:\nreturn G__2235__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2235.cljs$core$IFn$_invoke$arity$1 = G__2235__1;\nG__2235.cljs$core$IFn$_invoke$arity$2 = G__2235__2;\nreturn G__2235;\n})()\n;\n\ncljs.core.MapEntry.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (node,k,not_found){\nvar self__ = this;\nvar node__$1 = this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (node,n){\nvar self__ = this;\nvar node__$1 = this;\nif((n === (0))){\nreturn self__.key;\n} else {\nif((n === (1))){\nreturn self__.val;\n} else {\nthrow (new Error(\"Index out of bounds\"));\n\n}\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (node,n,not_found){\nvar self__ = this;\nvar node__$1 = this;\nif((n === (0))){\nreturn self__.key;\n} else {\nif((n === (1))){\nreturn self__.val;\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (node,n,v){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null).cljs$core$IVector$_assoc_n$arity$3(null,n,v);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IMeta$_meta$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn null;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ICounted$_count$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (2);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IMapEntry$_key$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.key;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IMapEntry$_val$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IStack$_peek$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IStack$_pop$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key], null);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (new cljs.core.IndexedSeq([self__.val,self__.key],(0),null));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn null;\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (node,f){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(node__$1,f);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (node,f,start){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(node__$1,f,start);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (node,k,v){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),k,v);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nreturn (((k === (0))) || ((k === (1))));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (new cljs.core.IndexedSeq([self__.key,self__.val],(0),null));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (node,meta){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.with_meta(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),meta);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$ICollection$_conj$arity$2 = (function (node,o){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val,o], null);\n});\n\ncljs.core.MapEntry.prototype.call = (function() {\nvar G__2236 = null;\nvar G__2236__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar node = self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__2236__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar node = self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__2236 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2236__2.call(this,self__,k);\ncase 3:\nreturn G__2236__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2236.cljs$core$IFn$_invoke$arity$2 = G__2236__2;\nG__2236.cljs$core$IFn$_invoke$arity$3 = G__2236__3;\nreturn G__2236;\n})()\n;\n\ncljs.core.MapEntry.prototype.apply = (function (self__,args2231){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2231)));\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar node = this;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar node = this;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.MapEntry.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"key\",\"key\",124488940,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.MapEntry.cljs$lang$type = true;\n\ncljs.core.MapEntry.cljs$lang$ctorStr = \"cljs.core/MapEntry\";\n\ncljs.core.MapEntry.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/MapEntry\");\n});\n\n/**\n * Positional factory function for cljs.core/MapEntry.\n */\ncljs.core.__GT_MapEntry = (function cljs$core$__GT_MapEntry(key,val,__hash){\nreturn (new cljs.core.MapEntry(key,val,__hash));\n});\n\n/**\n * Returns true if x satisfies IMapEntry\n */\ncljs.core.map_entry_QMARK_ = (function cljs$core$map_entry_QMARK_(x){\nif((!((x == null)))){\nif((((x.cljs$lang$protocol_mask$partition0$ & (2048))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IMapEntry$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentArrayMapSeq = (function (arr,i,_meta){\nthis.arr = arr;\nthis.i = i;\nthis._meta = _meta;\nthis.cljs$lang$protocol_mask$partition0$ = 32374990;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.PersistentArrayMapSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.indexOf = (function() {\nvar G__2238 = null;\nvar G__2238__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2238__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2238 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2238__1.call(this,x);\ncase 2:\nreturn G__2238__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2238.cljs$core$IFn$_invoke$arity$1 = G__2238__1;\nG__2238.cljs$core$IFn$_invoke$arity$2 = G__2238__2;\nreturn G__2238;\n})()\n;\n\ncljs.core.PersistentArrayMapSeq.prototype.lastIndexOf = (function() {\nvar G__2239 = null;\nvar G__2239__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2239__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2239 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2239__1.call(this,x);\ncase 2:\nreturn G__2239__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2239.cljs$core$IFn$_invoke$arity$1 = G__2239__1;\nG__2239.cljs$core$IFn$_invoke$arity$2 = G__2239__2;\nreturn G__2239;\n})()\n;\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__._meta;\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.i < (self__.arr.length - (2)))){\nreturn (new cljs.core.PersistentArrayMapSeq(self__.arr,(self__.i + (2)),null));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn ((self__.arr.length - self__.i) / (2));\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.MapEntry((self__.arr[self__.i]),(self__.arr[(self__.i + (1))]),null));\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.i < (self__.arr.length - (2)))){\nreturn (new cljs.core.PersistentArrayMapSeq(self__.arr,(self__.i + (2)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__._meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentArrayMapSeq(self__.arr,self__.i,new_meta));\n}\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"_meta\",\"_meta\",-1716892533,null)], null);\n});\n\ncljs.core.PersistentArrayMapSeq.cljs$lang$type = true;\n\ncljs.core.PersistentArrayMapSeq.cljs$lang$ctorStr = \"cljs.core/PersistentArrayMapSeq\";\n\ncljs.core.PersistentArrayMapSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentArrayMapSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentArrayMapSeq.\n */\ncljs.core.__GT_PersistentArrayMapSeq = (function cljs$core$__GT_PersistentArrayMapSeq(arr,i,_meta){\nreturn (new cljs.core.PersistentArrayMapSeq(arr,i,_meta));\n});\n\nvar G__2240_2243 = cljs.core.PersistentArrayMapSeq.prototype;\nvar G__2241_2244 = cljs.core.ITER_SYMBOL;\nvar G__2242_2245 = ((function (G__2240_2243,G__2241_2244){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2240_2243,G__2241_2244))\n;\ngoog.object.set(G__2240_2243,G__2241_2244,G__2242_2245);\ncljs.core.persistent_array_map_seq = (function cljs$core$persistent_array_map_seq(arr,i,_meta){\nif((i <= (arr.length - (2)))){\nreturn (new cljs.core.PersistentArrayMapSeq(arr,i,_meta));\n} else {\nreturn null;\n}\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.PersistentArrayMapIterator = (function (arr,i,cnt){\nthis.arr = arr;\nthis.i = i;\nthis.cnt = cnt;\n});\ncljs.core.PersistentArrayMapIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.i < self__.cnt);\n});\n\ncljs.core.PersistentArrayMapIterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nvar ret = (new cljs.core.MapEntry((self__.arr[self__.i]),(self__.arr[(self__.i + (1))]),null));\nself__.i = (self__.i + (2));\n\nreturn ret;\n});\n\ncljs.core.PersistentArrayMapIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null)], null);\n});\n\ncljs.core.PersistentArrayMapIterator.cljs$lang$type = true;\n\ncljs.core.PersistentArrayMapIterator.cljs$lang$ctorStr = \"cljs.core/PersistentArrayMapIterator\";\n\ncljs.core.PersistentArrayMapIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentArrayMapIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentArrayMapIterator.\n */\ncljs.core.__GT_PersistentArrayMapIterator = (function cljs$core$__GT_PersistentArrayMapIterator(arr,i,cnt){\nreturn (new cljs.core.PersistentArrayMapIterator(arr,i,cnt));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentArrayMap = (function (meta,cnt,arr,__hash){\nthis.meta = meta;\nthis.cnt = cnt;\nthis.arr = arr;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 16647951;\nthis.cljs$lang$protocol_mask$partition1$ = 139268;\n});\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFind$_find$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nvar idx = cljs.core.array_map_index_of(coll__$1,k);\nif((idx === (-1))){\nreturn null;\n} else {\nreturn (new cljs.core.MapEntry((self__.arr[idx]),(self__.arr[(idx + (1))]),null));\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentArrayMap.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentArrayMap.prototype.keys = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.keys(coll));\n});\n\ncljs.core.PersistentArrayMap.prototype.entries = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentArrayMap.prototype.values = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.vals(coll));\n});\n\ncljs.core.PersistentArrayMap.prototype.has = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentArrayMap.prototype.get = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentArrayMap.prototype.forEach = (function (f){\nvar self__ = this;\nvar coll = this;\nvar seq__2247 = cljs.core.seq(coll);\nvar chunk__2248 = null;\nvar count__2249 = (0);\nvar i__2250 = (0);\nwhile(true){\nif((i__2250 < count__2249)){\nvar vec__2257 = chunk__2248.cljs$core$IIndexed$_nth$arity$2(null,i__2250);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2257,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2257,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2269 = seq__2247;\nvar G__2270 = chunk__2248;\nvar G__2271 = count__2249;\nvar G__2272 = (i__2250 + (1));\nseq__2247 = G__2269;\nchunk__2248 = G__2270;\ncount__2249 = G__2271;\ni__2250 = G__2272;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2247);\nif(temp__5720__auto__){\nvar seq__2247__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2247__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2247__$1);\nvar G__2273 = cljs.core.chunk_rest(seq__2247__$1);\nvar G__2274 = c__4550__auto__;\nvar G__2275 = cljs.core.count(c__4550__auto__);\nvar G__2276 = (0);\nseq__2247 = G__2273;\nchunk__2248 = G__2274;\ncount__2249 = G__2275;\ni__2250 = G__2276;\ncontinue;\n} else {\nvar vec__2260 = cljs.core.first(seq__2247__$1);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2260,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2260,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2277 = cljs.core.next(seq__2247__$1);\nvar G__2278 = null;\nvar G__2279 = (0);\nvar G__2280 = (0);\nseq__2247 = G__2277;\nchunk__2248 = G__2278;\ncount__2249 = G__2279;\ni__2250 = G__2280;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nvar idx = cljs.core.array_map_index_of(coll__$1,k);\nif((idx === (-1))){\nreturn not_found;\n} else {\nreturn (self__.arr[(idx + (1))]);\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (coll,f,init){\nvar self__ = this;\nvar coll__$1 = this;\nvar len = self__.arr.length;\nvar i = (0);\nvar init__$1 = init;\nwhile(true){\nif((i < len)){\nvar init__$2 = (function (){var G__2263 = init__$1;\nvar G__2264 = (self__.arr[i]);\nvar G__2265 = (self__.arr[(i + (1))]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2263,G__2264,G__2265) : f.call(null,G__2263,G__2264,G__2265));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn cljs.core.deref(init__$2);\n} else {\nvar G__2281 = (i + (2));\nvar G__2282 = init__$2;\ni = G__2281;\ninit__$1 = G__2282;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn (new cljs.core.PersistentArrayMapIterator(self__.arr,(0),(self__.cnt * (2))));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.PersistentArrayMap(self__.meta,self__.cnt,self__.arr,self__.__hash));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nif(((cljs.core.map_QMARK_(other)) && ((!(cljs.core.record_QMARK_(other)))))){\nvar alen = self__.arr.length;\nvar other__$1 = other;\nif((self__.cnt === other__$1.cljs$core$ICounted$_count$arity$1(null))){\nvar i = (0);\nwhile(true){\nif((i < alen)){\nvar v = other__$1.cljs$core$ILookup$_lookup$arity$3(null,(self__.arr[i]),cljs.core.lookup_sentinel);\nif((!((v === cljs.core.lookup_sentinel)))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((self__.arr[(i + (1))]),v)){\nvar G__2283 = (i + (2));\ni = G__2283;\ncontinue;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.TransientArrayMap(({}),self__.arr.length,cljs.core.aclone(self__.arr)));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.PersistentArrayMap.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$2(coll__$1,f);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.iter_reduce.cljs$core$IFn$_invoke$arity$3(coll__$1,f,start);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nvar idx = cljs.core.array_map_index_of(coll__$1,k);\nif((idx >= (0))){\nvar len = self__.arr.length;\nvar new_len = (len - (2));\nif((new_len === (0))){\nreturn coll__$1.cljs$core$IEmptyableCollection$_empty$arity$1(null);\n} else {\nvar new_arr = (new Array(new_len));\nvar s = (0);\nvar d = (0);\nwhile(true){\nif((s >= len)){\nreturn (new cljs.core.PersistentArrayMap(self__.meta,(self__.cnt - (1)),new_arr,null));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(k,(self__.arr[s]))){\nvar G__2284 = (s + (2));\nvar G__2285 = d;\ns = G__2284;\nd = G__2285;\ncontinue;\n} else {\n(new_arr[d] = (self__.arr[s]));\n\n(new_arr[(d + (1))] = (self__.arr[(s + (1))]));\n\nvar G__2286 = (s + (2));\nvar G__2287 = (d + (2));\ns = G__2286;\nd = G__2287;\ncontinue;\n\n}\n}\nbreak;\n}\n}\n} else {\nreturn coll__$1;\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,k,v){\nvar self__ = this;\nvar coll__$1 = this;\nvar idx = cljs.core.array_map_index_of(coll__$1,k);\nif((idx === (-1))){\nif((self__.cnt < cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD)){\nvar arr__$1 = cljs.core.array_map_extend_kv(coll__$1,k,v);\nreturn (new cljs.core.PersistentArrayMap(self__.meta,(self__.cnt + (1)),arr__$1,null));\n} else {\nreturn cljs.core._with_meta(cljs.core._assoc(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashMap.EMPTY,coll__$1),k,v),self__.meta);\n}\n} else {\nif((v === (self__.arr[(idx + (1))]))){\nreturn coll__$1;\n} else {\nvar arr__$1 = (function (){var G__2268 = cljs.core.aclone(self__.arr);\n(G__2268[(idx + (1))] = v);\n\nreturn G__2268;\n})();\nreturn (new cljs.core.PersistentArrayMap(self__.meta,self__.cnt,arr__$1,null));\n\n}\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (!((cljs.core.array_map_index_of(coll__$1,k) === (-1))));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.persistent_array_map_seq(self__.arr,(0),null);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentArrayMap(new_meta,self__.cnt,self__.arr,self__.__hash));\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nvar ret = coll__$1;\nvar es = cljs.core.seq(entry);\nwhile(true){\nif((es == null)){\nreturn ret;\n} else {\nvar e = cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__2288 = cljs.core._assoc(ret,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(1)));\nvar G__2289 = cljs.core.next(es);\nret = G__2288;\nes = G__2289;\ncontinue;\n} else {\nthrow (new Error(\"conj on a map takes map entries or seqables of map entries\"));\n}\n}\nbreak;\n}\n}\n});\n\ncljs.core.PersistentArrayMap.prototype.call = (function() {\nvar G__2290 = null;\nvar G__2290__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2290__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2290 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2290__2.call(this,self__,k);\ncase 3:\nreturn G__2290__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2290.cljs$core$IFn$_invoke$arity$2 = G__2290__2;\nG__2290.cljs$core$IFn$_invoke$arity$3 = G__2290__3;\nreturn G__2290;\n})()\n;\n\ncljs.core.PersistentArrayMap.prototype.apply = (function (self__,args2246){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2246)));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentArrayMap.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentArrayMap.cljs$lang$type = true;\n\ncljs.core.PersistentArrayMap.cljs$lang$ctorStr = \"cljs.core/PersistentArrayMap\";\n\ncljs.core.PersistentArrayMap.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentArrayMap\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentArrayMap.\n */\ncljs.core.__GT_PersistentArrayMap = (function cljs$core$__GT_PersistentArrayMap(meta,cnt,arr,__hash){\nreturn (new cljs.core.PersistentArrayMap(meta,cnt,arr,__hash));\n});\n\ncljs.core.PersistentArrayMap.EMPTY = (new cljs.core.PersistentArrayMap(null,(0),[],cljs.core.empty_unordered_hash));\ncljs.core.PersistentArrayMap.HASHMAP_THRESHOLD = (8);\ncljs.core.PersistentArrayMap.fromArray = (function (arr,no_clone,no_check){\nvar arr__$1 = ((no_clone)?arr:cljs.core.aclone(arr));\nvar arr__$2 = ((no_check)?arr__$1:(function (){var ret = [];\nvar i_2291 = (0);\nwhile(true){\nif((i_2291 < arr__$1.length)){\nvar k_2292 = (arr__$1[i_2291]);\nvar v_2293 = (arr__$1[(i_2291 + (1))]);\nvar idx_2294 = cljs.core.array_index_of(ret,k_2292);\nif((idx_2294 === (-1))){\nret.push(k_2292);\n\nret.push(v_2293);\n} else {\n}\n\nvar G__2295 = (i_2291 + (2));\ni_2291 = G__2295;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn ret;\n})());\nvar cnt = (arr__$2.length / (2));\nreturn (new cljs.core.PersistentArrayMap(null,cnt,arr__$2,null));\n});\ncljs.core.PersistentArrayMap.createWithCheck = (function (arr){\nvar ret = [];\nvar i_2297 = (0);\nwhile(true){\nif((i_2297 < arr.length)){\nvar k_2298 = (arr[i_2297]);\nvar v_2299 = (arr[(i_2297 + (1))]);\nvar idx_2300 = cljs.core.array_index_of(ret,k_2298);\nif((idx_2300 === (-1))){\nvar G__2296_2301 = ret;\nG__2296_2301.push(k_2298);\n\nG__2296_2301.push(v_2299);\n\n} else {\nthrow (new Error([\"Duplicate key: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(k_2298)].join('')));\n}\n\nvar G__2302 = (i_2297 + (2));\ni_2297 = G__2302;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar cnt = (arr.length / (2));\nreturn (new cljs.core.PersistentArrayMap(null,cnt,arr,null));\n});\ncljs.core.PersistentArrayMap.createAsIfByAssoc = (function (arr){\nvar ret = [];\nvar i_2304 = (0);\nwhile(true){\nif((i_2304 < arr.length)){\nvar k_2305 = (arr[i_2304]);\nvar v_2306 = (arr[(i_2304 + (1))]);\nvar idx_2307 = cljs.core.array_index_of(ret,k_2305);\nif((idx_2307 === (-1))){\nvar G__2303_2308 = ret;\nG__2303_2308.push(k_2305);\n\nG__2303_2308.push(v_2306);\n\n} else {\n(ret[(idx_2307 + (1))] = v_2306);\n}\n\nvar G__2309 = (i_2304 + (2));\ni_2304 = G__2309;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn (new cljs.core.PersistentArrayMap(null,(ret.length / (2)),ret,null));\n});\nvar G__2310_2313 = cljs.core.PersistentArrayMap.prototype;\nvar G__2311_2314 = cljs.core.ITER_SYMBOL;\nvar G__2312_2315 = ((function (G__2310_2313,G__2311_2314){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2310_2313,G__2311_2314))\n;\ngoog.object.set(G__2310_2313,G__2311_2314,G__2312_2315);\n\n/**\n* @constructor\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ITransientMap}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientArrayMap = (function (editable_QMARK_,len,arr){\nthis.editable_QMARK_ = editable_QMARK_;\nthis.len = len;\nthis.arr = arr;\nthis.cljs$lang$protocol_mask$partition0$ = 259;\nthis.cljs$lang$protocol_mask$partition1$ = 56;\n});\ncljs.core.TransientArrayMap.prototype.cljs$core$ICounted$_count$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nreturn cljs.core.quot(self__.len,(2));\n} else {\nthrow (new Error(\"count after persistent!\"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (tcoll,k){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn tcoll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (tcoll,k,not_found){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nvar idx = cljs.core.array_map_index_of(tcoll__$1,k);\nif((idx === (-1))){\nreturn not_found;\n} else {\nreturn (self__.arr[(idx + (1))]);\n}\n} else {\nthrow (new Error(\"lookup after persistent!\"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 = (function (tcoll,o){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nif(cljs.core.map_entry_QMARK_(o)){\nreturn tcoll__$1.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3(null,cljs.core.key(o),cljs.core.val(o));\n} else {\nif(cljs.core.vector_QMARK_(o)){\nreturn tcoll__$1.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3(null,(o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((0)) : o.call(null,(0))),(o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((1)) : o.call(null,(1))));\n} else {\nvar es = cljs.core.seq(o);\nvar tcoll__$2 = tcoll__$1;\nwhile(true){\nvar temp__5718__auto__ = cljs.core.first(es);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e = temp__5718__auto__;\nvar G__2318 = cljs.core.next(es);\nvar G__2319 = cljs.core._assoc_BANG_(tcoll__$2,cljs.core.key(e),cljs.core.val(e));\nes = G__2318;\ntcoll__$2 = G__2319;\ncontinue;\n} else {\nreturn tcoll__$2;\n}\nbreak;\n}\n\n}\n}\n} else {\nthrow (new Error(\"conj! after persistent!\"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nself__.editable_QMARK_ = false;\n\nreturn (new cljs.core.PersistentArrayMap(null,cljs.core.quot(self__.len,(2)),self__.arr,null));\n} else {\nthrow (new Error(\"persistent! called twice\"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 = (function (tcoll,key,val){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nvar idx = cljs.core.array_map_index_of(tcoll__$1,key);\nif((idx === (-1))){\nif(((self__.len + (2)) <= ((2) * cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD))){\nself__.len = (self__.len + (2));\n\nself__.arr.push(key);\n\nself__.arr.push(val);\n\nreturn tcoll__$1;\n} else {\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(cljs.core.array__GT_transient_hash_map(self__.len,self__.arr),key,val);\n}\n} else {\nif((val === (self__.arr[(idx + (1))]))){\nreturn tcoll__$1;\n} else {\n(self__.arr[(idx + (1))] = val);\n\nreturn tcoll__$1;\n}\n}\n} else {\nthrow (new Error(\"assoc! after persistent!\"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$ITransientMap$_dissoc_BANG_$arity$2 = (function (tcoll,key){\nvar self__ = this;\nvar tcoll__$1 = this;\nif(cljs.core.truth_(self__.editable_QMARK_)){\nvar idx = cljs.core.array_map_index_of(tcoll__$1,key);\nif((idx >= (0))){\n(self__.arr[idx] = (self__.arr[(self__.len - (2))]));\n\n(self__.arr[(idx + (1))] = (self__.arr[(self__.len - (1))]));\n\nvar G__2317_2320 = self__.arr;\nG__2317_2320.pop();\n\nG__2317_2320.pop();\n\n\nself__.len = (self__.len - (2));\n} else {\n}\n\nreturn tcoll__$1;\n} else {\nthrow (new Error(\"dissoc! after persistent!\"));\n}\n});\n\ncljs.core.TransientArrayMap.prototype.call = (function() {\nvar G__2321 = null;\nvar G__2321__2 = (function (self__,key){\nvar self__ = this;\nvar self____$1 = this;\nvar tcoll = self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,null);\n});\nvar G__2321__3 = (function (self__,key,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar tcoll = self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\nG__2321 = function(self__,key,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2321__2.call(this,self__,key);\ncase 3:\nreturn G__2321__3.call(this,self__,key,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2321.cljs$core$IFn$_invoke$arity$2 = G__2321__2;\nG__2321.cljs$core$IFn$_invoke$arity$3 = G__2321__3;\nreturn G__2321;\n})()\n;\n\ncljs.core.TransientArrayMap.prototype.apply = (function (self__,args2316){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2316)));\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$IFn$_invoke$arity$1 = (function (key){\nvar self__ = this;\nvar tcoll = this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,null);\n});\n\ncljs.core.TransientArrayMap.prototype.cljs$core$IFn$_invoke$arity$2 = (function (key,not_found){\nvar self__ = this;\nvar tcoll = this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\n\ncljs.core.TransientArrayMap.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"editable?\",\"editable?\",-164945806,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"len\",\"len\",-1230778691,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null)], null);\n});\n\ncljs.core.TransientArrayMap.cljs$lang$type = true;\n\ncljs.core.TransientArrayMap.cljs$lang$ctorStr = \"cljs.core/TransientArrayMap\";\n\ncljs.core.TransientArrayMap.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/TransientArrayMap\");\n});\n\n/**\n * Positional factory function for cljs.core/TransientArrayMap.\n */\ncljs.core.__GT_TransientArrayMap = (function cljs$core$__GT_TransientArrayMap(editable_QMARK_,len,arr){\nreturn (new cljs.core.TransientArrayMap(editable_QMARK_,len,arr));\n});\n\ncljs.core.array__GT_transient_hash_map = (function cljs$core$array__GT_transient_hash_map(len,arr){\nvar out = cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nvar i = (0);\nwhile(true){\nif((i < len)){\nvar G__2322 = cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,(arr[i]),(arr[(i + (1))]));\nvar G__2323 = (i + (2));\nout = G__2322;\ni = G__2323;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.Box = (function (val){\nthis.val = val;\n});\n\ncljs.core.Box.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Box.cljs$lang$type = true;\n\ncljs.core.Box.cljs$lang$ctorStr = \"cljs.core/Box\";\n\ncljs.core.Box.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Box\");\n});\n\n/**\n * Positional factory function for cljs.core/Box.\n */\ncljs.core.__GT_Box = (function cljs$core$__GT_Box(val){\nreturn (new cljs.core.Box(val));\n});\n\n\n\n\n\n\ncljs.core.key_test = (function cljs$core$key_test(key,other){\nif((key === other)){\nreturn true;\n} else {\nif(cljs.core.keyword_identical_QMARK_(key,other)){\nreturn true;\n} else {\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(key,other);\n\n}\n}\n});\ncljs.core.mask = (function cljs$core$mask(hash,shift){\nreturn ((hash >>> shift) & (31));\n});\ncljs.core.clone_and_set = (function cljs$core$clone_and_set(var_args){\nvar G__2325 = arguments.length;\nswitch (G__2325) {\ncase 3:\nreturn cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 5:\nreturn cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3 = (function (arr,i,a){\nvar G__2326 = cljs.core.aclone(arr);\n(G__2326[i] = a);\n\nreturn G__2326;\n});\n\ncljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$5 = (function (arr,i,a,j,b){\nvar G__2327 = cljs.core.aclone(arr);\n(G__2327[i] = a);\n\n(G__2327[j] = b);\n\nreturn G__2327;\n});\n\ncljs.core.clone_and_set.cljs$lang$maxFixedArity = 5;\n\ncljs.core.remove_pair = (function cljs$core$remove_pair(arr,i){\nvar new_arr = (new Array((arr.length - (2))));\ncljs.core.array_copy(arr,(0),new_arr,(0),((2) * i));\n\ncljs.core.array_copy(arr,((2) * (i + (1))),new_arr,((2) * i),(new_arr.length - ((2) * i)));\n\nreturn new_arr;\n});\ncljs.core.bitmap_indexed_node_index = (function cljs$core$bitmap_indexed_node_index(bitmap,bit){\nreturn cljs.core.bit_count((bitmap & (bit - (1))));\n});\ncljs.core.bitpos = (function cljs$core$bitpos(hash,shift){\nreturn ((1) << ((hash >>> shift) & 0x01f));\n});\ncljs.core.edit_and_set = (function cljs$core$edit_and_set(var_args){\nvar G__2330 = arguments.length;\nswitch (G__2330) {\ncase 4:\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 6:\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4 = (function (inode,edit,i,a){\nvar editable = inode.ensure_editable(edit);\n(editable.arr[i] = a);\n\nreturn editable;\n});\n\ncljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6 = (function (inode,edit,i,a,j,b){\nvar editable = inode.ensure_editable(edit);\n(editable.arr[i] = a);\n\n(editable.arr[j] = b);\n\nreturn editable;\n});\n\ncljs.core.edit_and_set.cljs$lang$maxFixedArity = 6;\n\ncljs.core.inode_kv_reduce = (function cljs$core$inode_kv_reduce(arr,f,init){\nvar len = arr.length;\nvar i = (0);\nvar init__$1 = init;\nwhile(true){\nif((i < len)){\nvar init__$2 = (function (){var k = (arr[i]);\nif((!((k == null)))){\nvar G__2332 = init__$1;\nvar G__2333 = k;\nvar G__2334 = (arr[(i + (1))]);\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2332,G__2333,G__2334) : f.call(null,G__2332,G__2333,G__2334));\n} else {\nvar node = (arr[(i + (1))]);\nif((!((node == null)))){\nreturn node.kv_reduce(f,init__$1);\n} else {\nreturn init__$1;\n}\n}\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn init__$2;\n} else {\nvar G__2335 = (i + (2));\nvar G__2336 = init__$2;\ni = G__2335;\ninit__$1 = G__2336;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.NodeIterator = (function (arr,i,next_entry,next_iter){\nthis.arr = arr;\nthis.i = i;\nthis.next_entry = next_entry;\nthis.next_iter = next_iter;\n});\ncljs.core.NodeIterator.prototype.advance = (function (){\nvar self__ = this;\nvar this$ = this;\nvar len = self__.arr.length;\nwhile(true){\nif((self__.i < len)){\nvar key = (self__.arr[self__.i]);\nvar node_or_val = (self__.arr[(self__.i + (1))]);\nvar found = (((!((key == null))))?self__.next_entry = (new cljs.core.MapEntry(key,node_or_val,null)):(((!((node_or_val == null))))?(function (){var new_iter = cljs.core._iterator(node_or_val);\nif(new_iter.hasNext()){\nreturn self__.next_iter = new_iter;\n} else {\nreturn false;\n}\n})():false\n));\nself__.i = (self__.i + (2));\n\nif(found){\nreturn true;\n} else {\ncontinue;\n}\n} else {\nreturn false;\n}\nbreak;\n}\n});\n\ncljs.core.NodeIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar this$ = this;\nvar or__4131__auto__ = (!((self__.next_entry == null)));\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (!((self__.next_iter == null)));\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nreturn this$.advance();\n}\n}\n});\n\ncljs.core.NodeIterator.prototype.next = (function (){\nvar self__ = this;\nvar this$ = this;\nif((!((self__.next_entry == null)))){\nvar ret = self__.next_entry;\nself__.next_entry = null;\n\nreturn ret;\n} else {\nif((!((self__.next_iter == null)))){\nvar ret = self__.next_iter.next();\nif(self__.next_iter.hasNext()){\n} else {\nself__.next_iter = null;\n}\n\nreturn ret;\n} else {\nif(this$.advance()){\nreturn this$.next();\n} else {\nthrow (new Error(\"No such element\"));\n\n}\n}\n}\n});\n\ncljs.core.NodeIterator.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.NodeIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"next-entry\",\"next-entry\",1091342476,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"next-iter\",\"next-iter\",1526626239,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.NodeIterator.cljs$lang$type = true;\n\ncljs.core.NodeIterator.cljs$lang$ctorStr = \"cljs.core/NodeIterator\";\n\ncljs.core.NodeIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/NodeIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/NodeIterator.\n */\ncljs.core.__GT_NodeIterator = (function cljs$core$__GT_NodeIterator(arr,i,next_entry,next_iter){\nreturn (new cljs.core.NodeIterator(arr,i,next_entry,next_iter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIterable}\n*/\ncljs.core.BitmapIndexedNode = (function (edit,bitmap,arr){\nthis.edit = edit;\nthis.bitmap = bitmap;\nthis.arr = arr;\nthis.cljs$lang$protocol_mask$partition1$ = 131072;\nthis.cljs$lang$protocol_mask$partition0$ = 0;\n});\ncljs.core.BitmapIndexedNode.prototype.ensure_editable = (function (e){\nvar self__ = this;\nvar inode = this;\nif((e === self__.edit)){\nreturn inode;\n} else {\nvar n = cljs.core.bit_count(self__.bitmap);\nvar new_arr = (new Array((((n < (0)))?(4):((2) * (n + (1))))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * n));\n\nreturn (new cljs.core.BitmapIndexedNode(e,self__.bitmap,new_arr));\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_without_BANG_ = (function (edit__$1,shift,hash,key,removed_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar bit = (1 << ((hash >>> shift) & 0x01f));\nif(((self__.bitmap & bit) === (0))){\nreturn inode;\n} else {\nvar idx = cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil = (self__.arr[((2) * idx)]);\nvar val_or_node = (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil == null)){\nvar n = val_or_node.inode_without_BANG_(edit__$1,(shift + (5)),hash,key,removed_leaf_QMARK_);\nif((n === val_or_node)){\nreturn inode;\n} else {\nif((!((n == null)))){\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(((2) * idx) + (1)),n);\n} else {\nif((self__.bitmap === bit)){\nreturn null;\n} else {\nreturn inode.edit_and_remove_pair(edit__$1,bit,idx);\n\n}\n}\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nremoved_leaf_QMARK_.val = true;\n\nreturn inode.edit_and_remove_pair(edit__$1,bit,idx);\n} else {\nreturn inode;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.edit_and_remove_pair = (function (e,bit,i){\nvar self__ = this;\nvar inode = this;\nif((self__.bitmap === bit)){\nreturn null;\n} else {\nvar editable = inode.ensure_editable(e);\nvar earr = editable.arr;\nvar len = earr.length;\neditable.bitmap = (bit ^ editable.bitmap);\n\ncljs.core.array_copy(earr,((2) * (i + (1))),earr,((2) * i),(len - ((2) * (i + (1)))));\n\n(earr[(len - (2))] = null);\n\n(earr[(len - (1))] = null);\n\nreturn editable;\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_seq = (function (){\nvar self__ = this;\nvar inode = this;\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1(self__.arr);\n});\n\ncljs.core.BitmapIndexedNode.prototype.kv_reduce = (function (f,init){\nvar self__ = this;\nvar inode = this;\nreturn cljs.core.inode_kv_reduce(self__.arr,f,init);\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_lookup = (function (shift,hash,key,not_found){\nvar self__ = this;\nvar inode = this;\nvar bit = (1 << ((hash >>> shift) & 0x01f));\nif(((self__.bitmap & bit) === (0))){\nreturn not_found;\n} else {\nvar idx = cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil = (self__.arr[((2) * idx)]);\nvar val_or_node = (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil == null)){\nreturn val_or_node.inode_lookup((shift + (5)),hash,key,not_found);\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nreturn val_or_node;\n} else {\nreturn not_found;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_assoc_BANG_ = (function (edit__$1,shift,hash,key,val,added_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar bit = (1 << ((hash >>> shift) & 0x01f));\nvar idx = cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nif(((self__.bitmap & bit) === (0))){\nvar n = cljs.core.bit_count(self__.bitmap);\nif((((2) * n) < self__.arr.length)){\nvar editable = inode.ensure_editable(edit__$1);\nvar earr = editable.arr;\nadded_leaf_QMARK_.val = true;\n\ncljs.core.array_copy_downward(earr,((2) * idx),earr,((2) * (idx + (1))),((2) * (n - idx)));\n\n(earr[((2) * idx)] = key);\n\n(earr[(((2) * idx) + (1))] = val);\n\neditable.bitmap = (editable.bitmap | bit);\n\nreturn editable;\n} else {\nif((n >= (16))){\nvar nodes = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar jdx = ((hash >>> shift) & 0x01f);\n(nodes[jdx] = cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_));\n\nvar i_2337 = (0);\nvar j_2338 = (0);\nwhile(true){\nif((i_2337 < (32))){\nif((((self__.bitmap >>> i_2337) & (1)) === (0))){\nvar G__2339 = (i_2337 + (1));\nvar G__2340 = j_2338;\ni_2337 = G__2339;\nj_2338 = G__2340;\ncontinue;\n} else {\n(nodes[i_2337] = (((!(((self__.arr[j_2338]) == null))))?cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit__$1,(shift + (5)),cljs.core.hash((self__.arr[j_2338])),(self__.arr[j_2338]),(self__.arr[(j_2338 + (1))]),added_leaf_QMARK_):(self__.arr[(j_2338 + (1))])));\n\nvar G__2341 = (i_2337 + (1));\nvar G__2342 = (j_2338 + (2));\ni_2337 = G__2341;\nj_2338 = G__2342;\ncontinue;\n}\n} else {\n}\nbreak;\n}\n\nreturn (new cljs.core.ArrayNode(edit__$1,(n + (1)),nodes));\n} else {\nvar new_arr = (new Array(((2) * (n + (4)))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * idx));\n\n(new_arr[((2) * idx)] = key);\n\n(new_arr[(((2) * idx) + (1))] = val);\n\ncljs.core.array_copy(self__.arr,((2) * idx),new_arr,((2) * (idx + (1))),((2) * (n - idx)));\n\nadded_leaf_QMARK_.val = true;\n\nvar editable = inode.ensure_editable(edit__$1);\neditable.arr = new_arr;\n\neditable.bitmap = (editable.bitmap | bit);\n\nreturn editable;\n\n}\n}\n} else {\nvar key_or_nil = (self__.arr[((2) * idx)]);\nvar val_or_node = (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil == null)){\nvar n = val_or_node.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n === val_or_node)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(((2) * idx) + (1)),n);\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nif((val === val_or_node)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(((2) * idx) + (1)),val);\n}\n} else {\nadded_leaf_QMARK_.val = true;\n\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6(inode,edit__$1,((2) * idx),null,(((2) * idx) + (1)),cljs.core.create_node.cljs$core$IFn$_invoke$arity$7(edit__$1,(shift + (5)),key_or_nil,val_or_node,hash,key,val));\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_assoc = (function (shift,hash,key,val,added_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar bit = (1 << ((hash >>> shift) & 0x01f));\nvar idx = cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nif(((self__.bitmap & bit) === (0))){\nvar n = cljs.core.bit_count(self__.bitmap);\nif((n >= (16))){\nvar nodes = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];\nvar jdx = ((hash >>> shift) & 0x01f);\n(nodes[jdx] = cljs.core.BitmapIndexedNode.EMPTY.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_));\n\nvar i_2343 = (0);\nvar j_2344 = (0);\nwhile(true){\nif((i_2343 < (32))){\nif((((self__.bitmap >>> i_2343) & (1)) === (0))){\nvar G__2345 = (i_2343 + (1));\nvar G__2346 = j_2344;\ni_2343 = G__2345;\nj_2344 = G__2346;\ncontinue;\n} else {\n(nodes[i_2343] = (((!(((self__.arr[j_2344]) == null))))?cljs.core.BitmapIndexedNode.EMPTY.inode_assoc((shift + (5)),cljs.core.hash((self__.arr[j_2344])),(self__.arr[j_2344]),(self__.arr[(j_2344 + (1))]),added_leaf_QMARK_):(self__.arr[(j_2344 + (1))])));\n\nvar G__2347 = (i_2343 + (1));\nvar G__2348 = (j_2344 + (2));\ni_2343 = G__2347;\nj_2344 = G__2348;\ncontinue;\n}\n} else {\n}\nbreak;\n}\n\nreturn (new cljs.core.ArrayNode(null,(n + (1)),nodes));\n} else {\nvar new_arr = (new Array(((2) * (n + (1)))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * idx));\n\n(new_arr[((2) * idx)] = key);\n\n(new_arr[(((2) * idx) + (1))] = val);\n\ncljs.core.array_copy(self__.arr,((2) * idx),new_arr,((2) * (idx + (1))),((2) * (n - idx)));\n\nadded_leaf_QMARK_.val = true;\n\nreturn (new cljs.core.BitmapIndexedNode(null,(self__.bitmap | bit),new_arr));\n}\n} else {\nvar key_or_nil = (self__.arr[((2) * idx)]);\nvar val_or_node = (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil == null)){\nvar n = val_or_node.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n === val_or_node)){\nreturn inode;\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(((2) * idx) + (1)),n)));\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nif((val === val_or_node)){\nreturn inode;\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(((2) * idx) + (1)),val)));\n}\n} else {\nadded_leaf_QMARK_.val = true;\n\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$5(self__.arr,((2) * idx),null,(((2) * idx) + (1)),cljs.core.create_node.cljs$core$IFn$_invoke$arity$6((shift + (5)),key_or_nil,val_or_node,hash,key,val))));\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_find = (function (shift,hash,key,not_found){\nvar self__ = this;\nvar inode = this;\nvar bit = (1 << ((hash >>> shift) & 0x01f));\nif(((self__.bitmap & bit) === (0))){\nreturn not_found;\n} else {\nvar idx = cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil = (self__.arr[((2) * idx)]);\nvar val_or_node = (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil == null)){\nreturn val_or_node.inode_find((shift + (5)),hash,key,not_found);\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nreturn (new cljs.core.MapEntry(key_or_nil,val_or_node,null));\n} else {\nreturn not_found;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.inode_without = (function (shift,hash,key){\nvar self__ = this;\nvar inode = this;\nvar bit = (1 << ((hash >>> shift) & 0x01f));\nif(((self__.bitmap & bit) === (0))){\nreturn inode;\n} else {\nvar idx = cljs.core.bitmap_indexed_node_index(self__.bitmap,bit);\nvar key_or_nil = (self__.arr[((2) * idx)]);\nvar val_or_node = (self__.arr[(((2) * idx) + (1))]);\nif((key_or_nil == null)){\nvar n = val_or_node.inode_without((shift + (5)),hash,key);\nif((n === val_or_node)){\nreturn inode;\n} else {\nif((!((n == null)))){\nreturn (new cljs.core.BitmapIndexedNode(null,self__.bitmap,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(((2) * idx) + (1)),n)));\n} else {\nif((self__.bitmap === bit)){\nreturn null;\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,(self__.bitmap ^ bit),cljs.core.remove_pair(self__.arr,idx)));\n\n}\n}\n}\n} else {\nif(cljs.core.key_test(key,key_or_nil)){\nreturn (new cljs.core.BitmapIndexedNode(null,(self__.bitmap ^ bit),cljs.core.remove_pair(self__.arr,idx)));\n} else {\nreturn inode;\n\n}\n}\n}\n});\n\ncljs.core.BitmapIndexedNode.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.NodeIterator(self__.arr,(0),null,null));\n});\n\ncljs.core.BitmapIndexedNode.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"edit\",\"edit\",-1302639,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"bitmap\",\"bitmap\",501334601,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.BitmapIndexedNode.cljs$lang$type = true;\n\ncljs.core.BitmapIndexedNode.cljs$lang$ctorStr = \"cljs.core/BitmapIndexedNode\";\n\ncljs.core.BitmapIndexedNode.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/BitmapIndexedNode\");\n});\n\n/**\n * Positional factory function for cljs.core/BitmapIndexedNode.\n */\ncljs.core.__GT_BitmapIndexedNode = (function cljs$core$__GT_BitmapIndexedNode(edit,bitmap,arr){\nreturn (new cljs.core.BitmapIndexedNode(edit,bitmap,arr));\n});\n\ncljs.core.BitmapIndexedNode.EMPTY = (new cljs.core.BitmapIndexedNode(null,(0),[]));\ncljs.core.pack_array_node = (function cljs$core$pack_array_node(array_node,edit,idx){\nvar arr = array_node.arr;\nvar len = arr.length;\nvar new_arr = (new Array(((2) * (array_node.cnt - (1)))));\nvar i = (0);\nvar j = (1);\nvar bitmap = (0);\nwhile(true){\nif((i < len)){\nif((((!((i === idx)))) && ((!(((arr[i]) == null)))))){\n(new_arr[j] = (arr[i]));\n\nvar G__2349 = (i + (1));\nvar G__2350 = (j + (2));\nvar G__2351 = (bitmap | ((1) << i));\ni = G__2349;\nj = G__2350;\nbitmap = G__2351;\ncontinue;\n} else {\nvar G__2352 = (i + (1));\nvar G__2353 = j;\nvar G__2354 = bitmap;\ni = G__2352;\nj = G__2353;\nbitmap = G__2354;\ncontinue;\n}\n} else {\nreturn (new cljs.core.BitmapIndexedNode(edit,bitmap,new_arr));\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.ArrayNodeIterator = (function (arr,i,next_iter){\nthis.arr = arr;\nthis.i = i;\nthis.next_iter = next_iter;\n});\ncljs.core.ArrayNodeIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar this$ = this;\nvar len = self__.arr.length;\nwhile(true){\nif((!((((!((self__.next_iter == null)))) && (self__.next_iter.hasNext()))))){\nif((self__.i < len)){\nvar node = (self__.arr[self__.i]);\nself__.i = (self__.i + (1));\n\nif((!((node == null)))){\nself__.next_iter = cljs.core._iterator(node);\n} else {\n}\n\ncontinue;\n} else {\nreturn false;\n}\n} else {\nreturn true;\n}\nbreak;\n}\n});\n\ncljs.core.ArrayNodeIterator.prototype.next = (function (){\nvar self__ = this;\nvar this$ = this;\nif(this$.hasNext()){\nreturn self__.next_iter.next();\n} else {\nthrow (new Error(\"No such element\"));\n}\n});\n\ncljs.core.ArrayNodeIterator.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.ArrayNodeIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"next-iter\",\"next-iter\",1526626239,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ArrayNodeIterator.cljs$lang$type = true;\n\ncljs.core.ArrayNodeIterator.cljs$lang$ctorStr = \"cljs.core/ArrayNodeIterator\";\n\ncljs.core.ArrayNodeIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ArrayNodeIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayNodeIterator.\n */\ncljs.core.__GT_ArrayNodeIterator = (function cljs$core$__GT_ArrayNodeIterator(arr,i,next_iter){\nreturn (new cljs.core.ArrayNodeIterator(arr,i,next_iter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIterable}\n*/\ncljs.core.ArrayNode = (function (edit,cnt,arr){\nthis.edit = edit;\nthis.cnt = cnt;\nthis.arr = arr;\nthis.cljs$lang$protocol_mask$partition1$ = 131072;\nthis.cljs$lang$protocol_mask$partition0$ = 0;\n});\ncljs.core.ArrayNode.prototype.ensure_editable = (function (e){\nvar self__ = this;\nvar inode = this;\nif((e === self__.edit)){\nreturn inode;\n} else {\nreturn (new cljs.core.ArrayNode(e,self__.cnt,cljs.core.aclone(self__.arr)));\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_without_BANG_ = (function (edit__$1,shift,hash,key,removed_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar idx = ((hash >>> shift) & 0x01f);\nvar node = (self__.arr[idx]);\nif((node == null)){\nreturn inode;\n} else {\nvar n = node.inode_without_BANG_(edit__$1,(shift + (5)),hash,key,removed_leaf_QMARK_);\nif((n === node)){\nreturn inode;\n} else {\nif((n == null)){\nif((self__.cnt <= (8))){\nreturn cljs.core.pack_array_node(inode,edit__$1,idx);\n} else {\nvar editable = cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,n);\neditable.cnt = (editable.cnt - (1));\n\nreturn editable;\n}\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,n);\n\n}\n}\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_seq = (function (){\nvar self__ = this;\nvar inode = this;\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$1(self__.arr);\n});\n\ncljs.core.ArrayNode.prototype.kv_reduce = (function (f,init){\nvar self__ = this;\nvar inode = this;\nvar len = self__.arr.length;\nvar i = (0);\nvar init__$1 = init;\nwhile(true){\nif((i < len)){\nvar node = (self__.arr[i]);\nif((!((node == null)))){\nvar init__$2 = node.kv_reduce(f,init__$1);\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn init__$2;\n} else {\nvar G__2355 = (i + (1));\nvar G__2356 = init__$2;\ni = G__2355;\ninit__$1 = G__2356;\ncontinue;\n}\n} else {\nvar G__2357 = (i + (1));\nvar G__2358 = init__$1;\ni = G__2357;\ninit__$1 = G__2358;\ncontinue;\n}\n} else {\nreturn init__$1;\n}\nbreak;\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_lookup = (function (shift,hash,key,not_found){\nvar self__ = this;\nvar inode = this;\nvar idx = ((hash >>> shift) & 0x01f);\nvar node = (self__.arr[idx]);\nif((!((node == null)))){\nreturn node.inode_lookup((shift + (5)),hash,key,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_assoc_BANG_ = (function (edit__$1,shift,hash,key,val,added_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar idx = ((hash >>> shift) & 0x01f);\nvar node = (self__.arr[idx]);\nif((node == null)){\nvar editable = cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_));\neditable.cnt = (editable.cnt + (1));\n\nreturn editable;\n} else {\nvar n = node.inode_assoc_BANG_(edit__$1,(shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n === node)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,idx,n);\n}\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_assoc = (function (shift,hash,key,val,added_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar idx = ((hash >>> shift) & 0x01f);\nvar node = (self__.arr[idx]);\nif((node == null)){\nreturn (new cljs.core.ArrayNode(null,(self__.cnt + (1)),cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,cljs.core.BitmapIndexedNode.EMPTY.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_))));\n} else {\nvar n = node.inode_assoc((shift + (5)),hash,key,val,added_leaf_QMARK_);\nif((n === node)){\nreturn inode;\n} else {\nreturn (new cljs.core.ArrayNode(null,self__.cnt,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,n)));\n}\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_find = (function (shift,hash,key,not_found){\nvar self__ = this;\nvar inode = this;\nvar idx = ((hash >>> shift) & 0x01f);\nvar node = (self__.arr[idx]);\nif((!((node == null)))){\nreturn node.inode_find((shift + (5)),hash,key,not_found);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.ArrayNode.prototype.inode_without = (function (shift,hash,key){\nvar self__ = this;\nvar inode = this;\nvar idx = ((hash >>> shift) & 0x01f);\nvar node = (self__.arr[idx]);\nif((!((node == null)))){\nvar n = node.inode_without((shift + (5)),hash,key);\nif((n === node)){\nreturn inode;\n} else {\nif((n == null)){\nif((self__.cnt <= (8))){\nreturn cljs.core.pack_array_node(inode,null,idx);\n} else {\nreturn (new cljs.core.ArrayNode(null,(self__.cnt - (1)),cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,n)));\n}\n} else {\nreturn (new cljs.core.ArrayNode(null,self__.cnt,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,idx,n)));\n\n}\n}\n} else {\nreturn inode;\n}\n});\n\ncljs.core.ArrayNode.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.ArrayNodeIterator(self__.arr,(0),null));\n});\n\ncljs.core.ArrayNode.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"edit\",\"edit\",-1302639,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ArrayNode.cljs$lang$type = true;\n\ncljs.core.ArrayNode.cljs$lang$ctorStr = \"cljs.core/ArrayNode\";\n\ncljs.core.ArrayNode.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ArrayNode\");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayNode.\n */\ncljs.core.__GT_ArrayNode = (function cljs$core$__GT_ArrayNode(edit,cnt,arr){\nreturn (new cljs.core.ArrayNode(edit,cnt,arr));\n});\n\ncljs.core.hash_collision_node_find_index = (function cljs$core$hash_collision_node_find_index(arr,cnt,key){\nvar lim = ((2) * cnt);\nvar i = (0);\nwhile(true){\nif((i < lim)){\nif(cljs.core.key_test(key,(arr[i]))){\nreturn i;\n} else {\nvar G__2359 = (i + (2));\ni = G__2359;\ncontinue;\n}\n} else {\nreturn (-1);\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIterable}\n*/\ncljs.core.HashCollisionNode = (function (edit,collision_hash,cnt,arr){\nthis.edit = edit;\nthis.collision_hash = collision_hash;\nthis.cnt = cnt;\nthis.arr = arr;\nthis.cljs$lang$protocol_mask$partition1$ = 131072;\nthis.cljs$lang$protocol_mask$partition0$ = 0;\n});\ncljs.core.HashCollisionNode.prototype.ensure_editable = (function (e){\nvar self__ = this;\nvar inode = this;\nif((e === self__.edit)){\nreturn inode;\n} else {\nvar new_arr = (new Array(((2) * (self__.cnt + (1)))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),((2) * self__.cnt));\n\nreturn (new cljs.core.HashCollisionNode(e,self__.collision_hash,self__.cnt,new_arr));\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_without_BANG_ = (function (edit__$1,shift,hash,key,removed_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nvar idx = cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx === (-1))){\nreturn inode;\n} else {\nremoved_leaf_QMARK_.val = true;\n\nif((self__.cnt === (1))){\nreturn null;\n} else {\nvar editable = inode.ensure_editable(edit__$1);\nvar earr = editable.arr;\n(earr[idx] = (earr[(((2) * self__.cnt) - (2))]));\n\n(earr[(idx + (1))] = (earr[(((2) * self__.cnt) - (1))]));\n\n(earr[(((2) * self__.cnt) - (1))] = null);\n\n(earr[(((2) * self__.cnt) - (2))] = null);\n\neditable.cnt = (editable.cnt - (1));\n\nreturn editable;\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_seq = (function (){\nvar self__ = this;\nvar inode = this;\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1(self__.arr);\n});\n\ncljs.core.HashCollisionNode.prototype.kv_reduce = (function (f,init){\nvar self__ = this;\nvar inode = this;\nreturn cljs.core.inode_kv_reduce(self__.arr,f,init);\n});\n\ncljs.core.HashCollisionNode.prototype.inode_lookup = (function (shift,hash,key,not_found){\nvar self__ = this;\nvar inode = this;\nvar idx = cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx < (0))){\nreturn not_found;\n} else {\nif(cljs.core.key_test(key,(self__.arr[idx]))){\nreturn (self__.arr[(idx + (1))]);\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_assoc_BANG_ = (function (edit__$1,shift,hash,key,val,added_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nif((hash === self__.collision_hash)){\nvar idx = cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx === (-1))){\nif((self__.arr.length > ((2) * self__.cnt))){\nvar editable = cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$6(inode,edit__$1,((2) * self__.cnt),key,(((2) * self__.cnt) + (1)),val);\nadded_leaf_QMARK_.val = true;\n\neditable.cnt = (editable.cnt + (1));\n\nreturn editable;\n} else {\nvar len = self__.arr.length;\nvar new_arr = (new Array((len + (2))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),len);\n\n(new_arr[len] = key);\n\n(new_arr[(len + (1))] = val);\n\nadded_leaf_QMARK_.val = true;\n\nreturn inode.ensure_editable_array(edit__$1,(self__.cnt + (1)),new_arr);\n}\n} else {\nif(((self__.arr[(idx + (1))]) === val)){\nreturn inode;\n} else {\nreturn cljs.core.edit_and_set.cljs$core$IFn$_invoke$arity$4(inode,edit__$1,(idx + (1)),val);\n}\n}\n} else {\nreturn (new cljs.core.BitmapIndexedNode(edit__$1,(1 << ((self__.collision_hash >>> shift) & 0x01f)),[null,inode,null,null])).inode_assoc_BANG_(edit__$1,shift,hash,key,val,added_leaf_QMARK_);\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_assoc = (function (shift,hash,key,val,added_leaf_QMARK_){\nvar self__ = this;\nvar inode = this;\nif((hash === self__.collision_hash)){\nvar idx = cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx === (-1))){\nvar len = ((2) * self__.cnt);\nvar new_arr = (new Array((len + (2))));\ncljs.core.array_copy(self__.arr,(0),new_arr,(0),len);\n\n(new_arr[len] = key);\n\n(new_arr[(len + (1))] = val);\n\nadded_leaf_QMARK_.val = true;\n\nreturn (new cljs.core.HashCollisionNode(null,self__.collision_hash,(self__.cnt + (1)),new_arr));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((self__.arr[(idx + (1))]),val)){\nreturn inode;\n} else {\nreturn (new cljs.core.HashCollisionNode(null,self__.collision_hash,self__.cnt,cljs.core.clone_and_set.cljs$core$IFn$_invoke$arity$3(self__.arr,(idx + (1)),val)));\n}\n}\n} else {\nreturn (new cljs.core.BitmapIndexedNode(null,(1 << ((self__.collision_hash >>> shift) & 0x01f)),[null,inode])).inode_assoc(shift,hash,key,val,added_leaf_QMARK_);\n}\n});\n\ncljs.core.HashCollisionNode.prototype.ensure_editable_array = (function (e,count,array){\nvar self__ = this;\nvar inode = this;\nif((e === self__.edit)){\nself__.arr = array;\n\nself__.cnt = count;\n\nreturn inode;\n} else {\nreturn (new cljs.core.HashCollisionNode(self__.edit,self__.collision_hash,count,array));\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_find = (function (shift,hash,key,not_found){\nvar self__ = this;\nvar inode = this;\nvar idx = cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx < (0))){\nreturn not_found;\n} else {\nif(cljs.core.key_test(key,(self__.arr[idx]))){\nreturn (new cljs.core.MapEntry((self__.arr[idx]),(self__.arr[(idx + (1))]),null));\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.inode_without = (function (shift,hash,key){\nvar self__ = this;\nvar inode = this;\nvar idx = cljs.core.hash_collision_node_find_index(self__.arr,self__.cnt,key);\nif((idx === (-1))){\nreturn inode;\n} else {\nif((self__.cnt === (1))){\nreturn null;\n} else {\nreturn (new cljs.core.HashCollisionNode(null,self__.collision_hash,(self__.cnt - (1)),cljs.core.remove_pair(self__.arr,cljs.core.quot(idx,(2)))));\n\n}\n}\n});\n\ncljs.core.HashCollisionNode.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.NodeIterator(self__.arr,(0),null,null));\n});\n\ncljs.core.HashCollisionNode.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"edit\",\"edit\",-1302639,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"collision-hash\",\"collision-hash\",-35831342,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.HashCollisionNode.cljs$lang$type = true;\n\ncljs.core.HashCollisionNode.cljs$lang$ctorStr = \"cljs.core/HashCollisionNode\";\n\ncljs.core.HashCollisionNode.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/HashCollisionNode\");\n});\n\n/**\n * Positional factory function for cljs.core/HashCollisionNode.\n */\ncljs.core.__GT_HashCollisionNode = (function cljs$core$__GT_HashCollisionNode(edit,collision_hash,cnt,arr){\nreturn (new cljs.core.HashCollisionNode(edit,collision_hash,cnt,arr));\n});\n\ncljs.core.create_node = (function cljs$core$create_node(var_args){\nvar G__2361 = arguments.length;\nswitch (G__2361) {\ncase 6:\nreturn cljs.core.create_node.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase 7:\nreturn cljs.core.create_node.cljs$core$IFn$_invoke$arity$7((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.create_node.cljs$core$IFn$_invoke$arity$6 = (function (shift,key1,val1,key2hash,key2,val2){\nvar key1hash = cljs.core.hash(key1);\nif((key1hash === key2hash)){\nreturn (new cljs.core.HashCollisionNode(null,key1hash,(2),[key1,val1,key2,val2]));\n} else {\nvar added_leaf_QMARK_ = (new cljs.core.Box(false));\nreturn cljs.core.BitmapIndexedNode.EMPTY.inode_assoc(shift,key1hash,key1,val1,added_leaf_QMARK_).inode_assoc(shift,key2hash,key2,val2,added_leaf_QMARK_);\n}\n});\n\ncljs.core.create_node.cljs$core$IFn$_invoke$arity$7 = (function (edit,shift,key1,val1,key2hash,key2,val2){\nvar key1hash = cljs.core.hash(key1);\nif((key1hash === key2hash)){\nreturn (new cljs.core.HashCollisionNode(null,key1hash,(2),[key1,val1,key2,val2]));\n} else {\nvar added_leaf_QMARK_ = (new cljs.core.Box(false));\nreturn cljs.core.BitmapIndexedNode.EMPTY.inode_assoc_BANG_(edit,shift,key1hash,key1,val1,added_leaf_QMARK_).inode_assoc_BANG_(edit,shift,key2hash,key2,val2,added_leaf_QMARK_);\n}\n});\n\ncljs.core.create_node.cljs$lang$maxFixedArity = 7;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.NodeSeq = (function (meta,nodes,i,s,__hash){\nthis.meta = meta;\nthis.nodes = nodes;\nthis.i = i;\nthis.s = s;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32374988;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.NodeSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.NodeSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.NodeSeq.prototype.indexOf = (function() {\nvar G__2363 = null;\nvar G__2363__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2363__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2363 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2363__1.call(this,x);\ncase 2:\nreturn G__2363__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2363.cljs$core$IFn$_invoke$arity$1 = G__2363__1;\nG__2363.cljs$core$IFn$_invoke$arity$2 = G__2363__2;\nreturn G__2363;\n})()\n;\n\ncljs.core.NodeSeq.prototype.lastIndexOf = (function() {\nvar G__2364 = null;\nvar G__2364__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2364__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2364 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2364__1.call(this,x);\ncase 2:\nreturn G__2364__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2364.cljs$core$IFn$_invoke$arity$1 = G__2364__1;\nG__2364.cljs$core$IFn$_invoke$arity$2 = G__2364__2;\nreturn G__2364;\n})()\n;\n\ncljs.core.NodeSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.s == null)){\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,(self__.i + (2)),null);\n} else {\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s));\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.s == null)){\nreturn (new cljs.core.MapEntry((self__.nodes[self__.i]),(self__.nodes[(self__.i + (1))]),null));\n} else {\nreturn cljs.core.first(self__.s);\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar ret = (((self__.s == null))?cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,(self__.i + (2)),null):cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s)));\nif((!((ret == null)))){\nreturn ret;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1;\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.NodeSeq(new_meta,self__.nodes,self__.i,self__.s,self__.__hash));\n}\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.NodeSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"nodes\",\"nodes\",-459054278,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.NodeSeq.cljs$lang$type = true;\n\ncljs.core.NodeSeq.cljs$lang$ctorStr = \"cljs.core/NodeSeq\";\n\ncljs.core.NodeSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/NodeSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/NodeSeq.\n */\ncljs.core.__GT_NodeSeq = (function cljs$core$__GT_NodeSeq(meta,nodes,i,s,__hash){\nreturn (new cljs.core.NodeSeq(meta,nodes,i,s,__hash));\n});\n\nvar G__2365_2368 = cljs.core.NodeSeq.prototype;\nvar G__2366_2369 = cljs.core.ITER_SYMBOL;\nvar G__2367_2370 = ((function (G__2365_2368,G__2366_2369){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2365_2368,G__2366_2369))\n;\ngoog.object.set(G__2365_2368,G__2366_2369,G__2367_2370);\ncljs.core.create_inode_seq = (function cljs$core$create_inode_seq(var_args){\nvar G__2372 = arguments.length;\nswitch (G__2372) {\ncase 1:\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 3:\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$1 = (function (nodes){\nreturn cljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3(nodes,(0),null);\n});\n\ncljs.core.create_inode_seq.cljs$core$IFn$_invoke$arity$3 = (function (nodes,i,s){\nif((s == null)){\nvar len = nodes.length;\nvar j = i;\nwhile(true){\nif((j < len)){\nif((!(((nodes[j]) == null)))){\nreturn (new cljs.core.NodeSeq(null,nodes,j,null,null));\n} else {\nvar temp__5718__auto__ = (nodes[(j + (1))]);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar node = temp__5718__auto__;\nvar temp__5718__auto____$1 = node.inode_seq();\nif(cljs.core.truth_(temp__5718__auto____$1)){\nvar node_seq = temp__5718__auto____$1;\nreturn (new cljs.core.NodeSeq(null,nodes,(j + (2)),node_seq,null));\n} else {\nvar G__2374 = (j + (2));\nj = G__2374;\ncontinue;\n}\n} else {\nvar G__2375 = (j + (2));\nj = G__2375;\ncontinue;\n}\n}\n} else {\nreturn null;\n}\nbreak;\n}\n} else {\nreturn (new cljs.core.NodeSeq(null,nodes,i,s,null));\n}\n});\n\ncljs.core.create_inode_seq.cljs$lang$maxFixedArity = 3;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ArrayNodeSeq = (function (meta,nodes,i,s,__hash){\nthis.meta = meta;\nthis.nodes = nodes;\nthis.i = i;\nthis.s = s;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32374988;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.ArrayNodeSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ArrayNodeSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ArrayNodeSeq.prototype.indexOf = (function() {\nvar G__2376 = null;\nvar G__2376__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2376__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2376 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2376__1.call(this,x);\ncase 2:\nreturn G__2376__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2376.cljs$core$IFn$_invoke$arity$1 = G__2376__1;\nG__2376.cljs$core$IFn$_invoke$arity$2 = G__2376__2;\nreturn G__2376;\n})()\n;\n\ncljs.core.ArrayNodeSeq.prototype.lastIndexOf = (function() {\nvar G__2377 = null;\nvar G__2377__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2377__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2377 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2377__1.call(this,x);\ncase 2:\nreturn G__2377__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2377.cljs$core$IFn$_invoke$arity$1 = G__2377__1;\nG__2377.cljs$core$IFn$_invoke$arity$2 = G__2377__2;\nreturn G__2377;\n})()\n;\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s));\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.first(self__.s);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar ret = cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3(self__.nodes,self__.i,cljs.core.next(self__.s));\nif((!((ret == null)))){\nreturn ret;\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1;\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ArrayNodeSeq(new_meta,self__.nodes,self__.i,self__.s,self__.__hash));\n}\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.ArrayNodeSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"nodes\",\"nodes\",-459054278,null),new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.Symbol(null,\"s\",\"s\",-948495851,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ArrayNodeSeq.cljs$lang$type = true;\n\ncljs.core.ArrayNodeSeq.cljs$lang$ctorStr = \"cljs.core/ArrayNodeSeq\";\n\ncljs.core.ArrayNodeSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ArrayNodeSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayNodeSeq.\n */\ncljs.core.__GT_ArrayNodeSeq = (function cljs$core$__GT_ArrayNodeSeq(meta,nodes,i,s,__hash){\nreturn (new cljs.core.ArrayNodeSeq(meta,nodes,i,s,__hash));\n});\n\nvar G__2378_2381 = cljs.core.ArrayNodeSeq.prototype;\nvar G__2379_2382 = cljs.core.ITER_SYMBOL;\nvar G__2380_2383 = ((function (G__2378_2381,G__2379_2382){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2378_2381,G__2379_2382))\n;\ngoog.object.set(G__2378_2381,G__2379_2382,G__2380_2383);\ncljs.core.create_array_node_seq = (function cljs$core$create_array_node_seq(var_args){\nvar G__2385 = arguments.length;\nswitch (G__2385) {\ncase 1:\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 3:\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$1 = (function (nodes){\nreturn cljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3(nodes,(0),null);\n});\n\ncljs.core.create_array_node_seq.cljs$core$IFn$_invoke$arity$3 = (function (nodes,i,s){\nif((s == null)){\nvar len = nodes.length;\nvar j = i;\nwhile(true){\nif((j < len)){\nvar temp__5718__auto__ = (nodes[j]);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar nj = temp__5718__auto__;\nvar temp__5718__auto____$1 = nj.inode_seq();\nif(cljs.core.truth_(temp__5718__auto____$1)){\nvar ns = temp__5718__auto____$1;\nreturn (new cljs.core.ArrayNodeSeq(null,nodes,(j + (1)),ns,null));\n} else {\nvar G__2387 = (j + (1));\nj = G__2387;\ncontinue;\n}\n} else {\nvar G__2388 = (j + (1));\nj = G__2388;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n} else {\nreturn (new cljs.core.ArrayNodeSeq(null,nodes,i,s,null));\n}\n});\n\ncljs.core.create_array_node_seq.cljs$lang$maxFixedArity = 3;\n\n\n/**\n* @constructor\n*/\ncljs.core.HashMapIter = (function (nil_val,root_iter,seen){\nthis.nil_val = nil_val;\nthis.root_iter = root_iter;\nthis.seen = seen;\n});\ncljs.core.HashMapIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (((!(self__.seen))) || (self__.root_iter.hasNext()));\n});\n\ncljs.core.HashMapIter.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif((!(self__.seen))){\nself__.seen = true;\n\nreturn (new cljs.core.MapEntry(null,self__.nil_val,null));\n} else {\nreturn self__.root_iter.next();\n}\n});\n\ncljs.core.HashMapIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.HashMapIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"nil-val\",\"nil-val\",-513933559,null),new cljs.core.Symbol(null,\"root-iter\",\"root-iter\",1974672108,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"seen\",\"seen\",1121531738,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.HashMapIter.cljs$lang$type = true;\n\ncljs.core.HashMapIter.cljs$lang$ctorStr = \"cljs.core/HashMapIter\";\n\ncljs.core.HashMapIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/HashMapIter\");\n});\n\n/**\n * Positional factory function for cljs.core/HashMapIter.\n */\ncljs.core.__GT_HashMapIter = (function cljs$core$__GT_HashMapIter(nil_val,root_iter,seen){\nreturn (new cljs.core.HashMapIter(nil_val,root_iter,seen));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentHashMap = (function (meta,cnt,root,has_nil_QMARK_,nil_val,__hash){\nthis.meta = meta;\nthis.cnt = cnt;\nthis.root = root;\nthis.has_nil_QMARK_ = has_nil_QMARK_;\nthis.nil_val = nil_val;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 16123663;\nthis.cljs$lang$protocol_mask$partition1$ = 139268;\n});\ncljs.core.PersistentHashMap.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IFind$_find$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif((k == null)){\nif(self__.has_nil_QMARK_){\nreturn (new cljs.core.MapEntry(null,self__.nil_val,null));\n} else {\nreturn null;\n}\n} else {\nif((self__.root == null)){\nreturn null;\n} else {\nreturn self__.root.inode_find((0),cljs.core.hash(k),k,null);\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentHashMap.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentHashMap.prototype.keys = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.keys(coll));\n});\n\ncljs.core.PersistentHashMap.prototype.entries = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashMap.prototype.values = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.vals(coll));\n});\n\ncljs.core.PersistentHashMap.prototype.has = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentHashMap.prototype.get = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentHashMap.prototype.forEach = (function (f){\nvar self__ = this;\nvar coll = this;\nvar seq__2390 = cljs.core.seq(coll);\nvar chunk__2391 = null;\nvar count__2392 = (0);\nvar i__2393 = (0);\nwhile(true){\nif((i__2393 < count__2392)){\nvar vec__2400 = chunk__2391.cljs$core$IIndexed$_nth$arity$2(null,i__2393);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2400,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2400,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2408 = seq__2390;\nvar G__2409 = chunk__2391;\nvar G__2410 = count__2392;\nvar G__2411 = (i__2393 + (1));\nseq__2390 = G__2408;\nchunk__2391 = G__2409;\ncount__2392 = G__2410;\ni__2393 = G__2411;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2390);\nif(temp__5720__auto__){\nvar seq__2390__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2390__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2390__$1);\nvar G__2412 = cljs.core.chunk_rest(seq__2390__$1);\nvar G__2413 = c__4550__auto__;\nvar G__2414 = cljs.core.count(c__4550__auto__);\nvar G__2415 = (0);\nseq__2390 = G__2412;\nchunk__2391 = G__2413;\ncount__2392 = G__2414;\ni__2393 = G__2415;\ncontinue;\n} else {\nvar vec__2403 = cljs.core.first(seq__2390__$1);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2403,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2403,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2416 = cljs.core.next(seq__2390__$1);\nvar G__2417 = null;\nvar G__2418 = (0);\nvar G__2419 = (0);\nseq__2390 = G__2416;\nchunk__2391 = G__2417;\ncount__2392 = G__2418;\ni__2393 = G__2419;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif((k == null)){\nif(self__.has_nil_QMARK_){\nreturn self__.nil_val;\n} else {\nreturn not_found;\n}\n} else {\nif((self__.root == null)){\nreturn not_found;\n} else {\nreturn self__.root.inode_lookup((0),cljs.core.hash(k),k,not_found);\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (coll,f,init){\nvar self__ = this;\nvar coll__$1 = this;\nvar init__$1 = ((self__.has_nil_QMARK_)?(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(init,null,self__.nil_val) : f.call(null,init,null,self__.nil_val)):init);\nif(cljs.core.reduced_QMARK_(init__$1)){\nreturn cljs.core.deref(init__$1);\n} else {\nif((!((self__.root == null)))){\nreturn cljs.core.unreduced(self__.root.kv_reduce(f,init__$1));\n} else {\nreturn init__$1;\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar root_iter = ((self__.root)?cljs.core._iterator(self__.root):cljs.core.nil_iter());\nif(self__.has_nil_QMARK_){\nreturn (new cljs.core.HashMapIter(self__.nil_val,root_iter,false));\n} else {\nreturn root_iter;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.PersistentHashMap(self__.meta,self__.cnt,self__.root,self__.has_nil_QMARK_,self__.nil_val,self__.__hash));\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_map(coll__$1,other);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.TransientHashMap(({}),self__.root,self__.cnt,self__.has_nil_QMARK_,self__.nil_val));\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.PersistentHashMap.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif((k == null)){\nif(self__.has_nil_QMARK_){\nreturn (new cljs.core.PersistentHashMap(self__.meta,(self__.cnt - (1)),self__.root,false,null,null));\n} else {\nreturn coll__$1;\n}\n} else {\nif((self__.root == null)){\nreturn coll__$1;\n} else {\nvar new_root = self__.root.inode_without((0),cljs.core.hash(k),k);\nif((new_root === self__.root)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(self__.meta,(self__.cnt - (1)),new_root,self__.has_nil_QMARK_,self__.nil_val,null));\n}\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,k,v){\nvar self__ = this;\nvar coll__$1 = this;\nif((k == null)){\nif(((self__.has_nil_QMARK_) && ((v === self__.nil_val)))){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(self__.meta,((self__.has_nil_QMARK_)?self__.cnt:(self__.cnt + (1))),self__.root,true,v,null));\n}\n} else {\nvar added_leaf_QMARK_ = (new cljs.core.Box(false));\nvar new_root = (((self__.root == null))?cljs.core.BitmapIndexedNode.EMPTY:self__.root).inode_assoc((0),cljs.core.hash(k),k,v,added_leaf_QMARK_);\nif((new_root === self__.root)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(self__.meta,((added_leaf_QMARK_.val)?(self__.cnt + (1)):self__.cnt),new_root,self__.has_nil_QMARK_,self__.nil_val,null));\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nif((k == null)){\nreturn self__.has_nil_QMARK_;\n} else {\nif((self__.root == null)){\nreturn false;\n} else {\nreturn (!((self__.root.inode_lookup((0),cljs.core.hash(k),k,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)));\n\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nvar s = (((!((self__.root == null))))?self__.root.inode_seq():null);\nif(self__.has_nil_QMARK_){\nreturn cljs.core.cons((new cljs.core.MapEntry(null,self__.nil_val,null)),s);\n} else {\nreturn s;\n}\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashMap(new_meta,self__.cnt,self__.root,self__.has_nil_QMARK_,self__.nil_val,self__.__hash));\n}\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nvar ret = coll__$1;\nvar es = cljs.core.seq(entry);\nwhile(true){\nif((es == null)){\nreturn ret;\n} else {\nvar e = cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__2420 = cljs.core._assoc(ret,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(1)));\nvar G__2421 = cljs.core.next(es);\nret = G__2420;\nes = G__2421;\ncontinue;\n} else {\nthrow (new Error(\"conj on a map takes map entries or seqables of map entries\"));\n}\n}\nbreak;\n}\n}\n});\n\ncljs.core.PersistentHashMap.prototype.call = (function() {\nvar G__2422 = null;\nvar G__2422__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2422__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2422 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2422__2.call(this,self__,k);\ncase 3:\nreturn G__2422__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2422.cljs$core$IFn$_invoke$arity$2 = G__2422__2;\nG__2422.cljs$core$IFn$_invoke$arity$3 = G__2422__3;\nreturn G__2422;\n})()\n;\n\ncljs.core.PersistentHashMap.prototype.apply = (function (self__,args2389){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2389)));\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentHashMap.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"has-nil?\",\"has-nil?\",825886722,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"boolean\",\"boolean\",-278886877,null)], null)),new cljs.core.Symbol(null,\"nil-val\",\"nil-val\",-513933559,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentHashMap.cljs$lang$type = true;\n\ncljs.core.PersistentHashMap.cljs$lang$ctorStr = \"cljs.core/PersistentHashMap\";\n\ncljs.core.PersistentHashMap.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentHashMap\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentHashMap.\n */\ncljs.core.__GT_PersistentHashMap = (function cljs$core$__GT_PersistentHashMap(meta,cnt,root,has_nil_QMARK_,nil_val,__hash){\nreturn (new cljs.core.PersistentHashMap(meta,cnt,root,has_nil_QMARK_,nil_val,__hash));\n});\n\ncljs.core.PersistentHashMap.EMPTY = (new cljs.core.PersistentHashMap(null,(0),null,false,null,cljs.core.empty_unordered_hash));\ncljs.core.PersistentHashMap.fromArray = (function (arr,no_clone){\nvar arr__$1 = ((no_clone)?arr:cljs.core.aclone(arr));\nvar len = arr__$1.length;\nvar i = (0);\nvar ret = cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif((i < len)){\nvar G__2423 = (i + (2));\nvar G__2424 = cljs.core._assoc_BANG_(ret,(arr__$1[i]),(arr__$1[(i + (1))]));\ni = G__2423;\nret = G__2424;\ncontinue;\n} else {\nreturn cljs.core._persistent_BANG_(ret);\n}\nbreak;\n}\n});\ncljs.core.PersistentHashMap.fromArrays = (function (ks,vs){\nvar len = ks.length;\nvar i = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif((i < len)){\nvar G__2425 = (i + (1));\nvar G__2426 = cljs.core._assoc_BANG_(out,(ks[i]),(vs[i]));\ni = G__2425;\nout = G__2426;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n});\ncljs.core.PersistentHashMap.createWithCheck = (function (arr){\nvar len = arr.length;\nvar ret = cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nvar i_2427 = (0);\nwhile(true){\nif((i_2427 < len)){\ncljs.core._assoc_BANG_(ret,(arr[i_2427]),(arr[(i_2427 + (1))]));\n\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core._count(ret),((i_2427 / (2)) + (1)))){\nthrow (new Error([\"Duplicate key: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((arr[i_2427]))].join('')));\n} else {\nvar G__2428 = (i_2427 + (2));\ni_2427 = G__2428;\ncontinue;\n}\n} else {\n}\nbreak;\n}\n\nreturn cljs.core._persistent_BANG_(ret);\n});\nvar G__2429_2432 = cljs.core.PersistentHashMap.prototype;\nvar G__2430_2433 = cljs.core.ITER_SYMBOL;\nvar G__2431_2434 = ((function (G__2429_2432,G__2430_2433){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2429_2432,G__2430_2433))\n;\ngoog.object.set(G__2429_2432,G__2430_2433,G__2431_2434);\n\n/**\n* @constructor\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ITransientMap}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ITransientAssociative}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientHashMap = (function (edit,root,count,has_nil_QMARK_,nil_val){\nthis.edit = edit;\nthis.root = root;\nthis.count = count;\nthis.has_nil_QMARK_ = has_nil_QMARK_;\nthis.nil_val = nil_val;\nthis.cljs$lang$protocol_mask$partition0$ = 259;\nthis.cljs$lang$protocol_mask$partition1$ = 56;\n});\ncljs.core.TransientHashMap.prototype.conj_BANG_ = (function (o){\nvar self__ = this;\nvar tcoll = this;\nif(self__.edit){\nif(cljs.core.map_entry_QMARK_(o)){\nreturn tcoll.assoc_BANG_(cljs.core.key(o),cljs.core.val(o));\n} else {\nif(cljs.core.vector_QMARK_(o)){\nreturn tcoll.assoc_BANG_((o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((0)) : o.call(null,(0))),(o.cljs$core$IFn$_invoke$arity$1 ? o.cljs$core$IFn$_invoke$arity$1((1)) : o.call(null,(1))));\n} else {\nvar es = cljs.core.seq(o);\nvar tcoll__$1 = tcoll;\nwhile(true){\nvar temp__5718__auto__ = cljs.core.first(es);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e = temp__5718__auto__;\nvar G__2436 = cljs.core.next(es);\nvar G__2437 = tcoll__$1.assoc_BANG_(cljs.core.key(e),cljs.core.val(e));\nes = G__2436;\ntcoll__$1 = G__2437;\ncontinue;\n} else {\nreturn tcoll__$1;\n}\nbreak;\n}\n\n}\n}\n} else {\nthrow (new Error(\"conj! after persistent\"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.assoc_BANG_ = (function (k,v){\nvar self__ = this;\nvar tcoll = this;\nif(self__.edit){\nif((k == null)){\nif((self__.nil_val === v)){\n} else {\nself__.nil_val = v;\n}\n\nif(self__.has_nil_QMARK_){\n} else {\nself__.count = (self__.count + (1));\n\nself__.has_nil_QMARK_ = true;\n}\n\nreturn tcoll;\n} else {\nvar added_leaf_QMARK_ = (new cljs.core.Box(false));\nvar node = (((self__.root == null))?cljs.core.BitmapIndexedNode.EMPTY:self__.root).inode_assoc_BANG_(self__.edit,(0),cljs.core.hash(k),k,v,added_leaf_QMARK_);\nif((node === self__.root)){\n} else {\nself__.root = node;\n}\n\nif(added_leaf_QMARK_.val){\nself__.count = (self__.count + (1));\n} else {\n}\n\nreturn tcoll;\n}\n} else {\nthrow (new Error(\"assoc! after persistent!\"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.without_BANG_ = (function (k){\nvar self__ = this;\nvar tcoll = this;\nif(self__.edit){\nif((k == null)){\nif(self__.has_nil_QMARK_){\nself__.has_nil_QMARK_ = false;\n\nself__.nil_val = null;\n\nself__.count = (self__.count - (1));\n\nreturn tcoll;\n} else {\nreturn tcoll;\n}\n} else {\nif((self__.root == null)){\nreturn tcoll;\n} else {\nvar removed_leaf_QMARK_ = (new cljs.core.Box(false));\nvar node = self__.root.inode_without_BANG_(self__.edit,(0),cljs.core.hash(k),k,removed_leaf_QMARK_);\nif((node === self__.root)){\n} else {\nself__.root = node;\n}\n\nif(removed_leaf_QMARK_.val){\nself__.count = (self__.count - (1));\n} else {\n}\n\nreturn tcoll;\n}\n}\n} else {\nthrow (new Error(\"dissoc! after persistent!\"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.persistent_BANG_ = (function (){\nvar self__ = this;\nvar tcoll = this;\nif(self__.edit){\nself__.edit = null;\n\nreturn (new cljs.core.PersistentHashMap(null,self__.count,self__.root,self__.has_nil_QMARK_,self__.nil_val,null));\n} else {\nthrow (new Error(\"persistent! called twice\"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif(self__.edit){\nreturn self__.count;\n} else {\nthrow (new Error(\"count after persistent!\"));\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (tcoll,k){\nvar self__ = this;\nvar tcoll__$1 = this;\nif((k == null)){\nif(self__.has_nil_QMARK_){\nreturn self__.nil_val;\n} else {\nreturn null;\n}\n} else {\nif((self__.root == null)){\nreturn null;\n} else {\nreturn self__.root.inode_lookup((0),cljs.core.hash(k),k);\n}\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (tcoll,k,not_found){\nvar self__ = this;\nvar tcoll__$1 = this;\nif((k == null)){\nif(self__.has_nil_QMARK_){\nreturn self__.nil_val;\n} else {\nreturn not_found;\n}\n} else {\nif((self__.root == null)){\nreturn not_found;\n} else {\nreturn self__.root.inode_lookup((0),cljs.core.hash(k),k,not_found);\n}\n}\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 = (function (tcoll,val){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn tcoll__$1.conj_BANG_(val);\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn tcoll__$1.persistent_BANG_();\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientAssociative$_assoc_BANG_$arity$3 = (function (tcoll,key,val){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn tcoll__$1.assoc_BANG_(key,val);\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$ITransientMap$_dissoc_BANG_$arity$2 = (function (tcoll,key){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn tcoll__$1.without_BANG_(key);\n});\n\ncljs.core.TransientHashMap.prototype.call = (function() {\nvar G__2438 = null;\nvar G__2438__2 = (function (self__,key){\nvar self__ = this;\nvar self____$1 = this;\nvar tcoll = self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$2(null,key);\n});\nvar G__2438__3 = (function (self__,key,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar tcoll = self____$1;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\nG__2438 = function(self__,key,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2438__2.call(this,self__,key);\ncase 3:\nreturn G__2438__3.call(this,self__,key,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2438.cljs$core$IFn$_invoke$arity$2 = G__2438__2;\nG__2438.cljs$core$IFn$_invoke$arity$3 = G__2438__3;\nreturn G__2438;\n})()\n;\n\ncljs.core.TransientHashMap.prototype.apply = (function (self__,args2435){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2435)));\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$IFn$_invoke$arity$1 = (function (key){\nvar self__ = this;\nvar tcoll = this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$2(null,key);\n});\n\ncljs.core.TransientHashMap.prototype.cljs$core$IFn$_invoke$arity$2 = (function (key,not_found){\nvar self__ = this;\nvar tcoll = this;\nreturn tcoll.cljs$core$ILookup$_lookup$arity$3(null,key,not_found);\n});\n\ncljs.core.TransientHashMap.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"edit\",\"edit\",-1302639,null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"boolean\",\"boolean\",-278886877,null),new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"root\",\"root\",1191874074,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"count\",\"count\",-514511684,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"has-nil?\",\"has-nil?\",825886722,null),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"boolean\",\"boolean\",-278886877,null),new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"nil-val\",\"nil-val\",-513933559,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.TransientHashMap.cljs$lang$type = true;\n\ncljs.core.TransientHashMap.cljs$lang$ctorStr = \"cljs.core/TransientHashMap\";\n\ncljs.core.TransientHashMap.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/TransientHashMap\");\n});\n\n/**\n * Positional factory function for cljs.core/TransientHashMap.\n */\ncljs.core.__GT_TransientHashMap = (function cljs$core$__GT_TransientHashMap(edit,root,count,has_nil_QMARK_,nil_val){\nreturn (new cljs.core.TransientHashMap(edit,root,count,has_nil_QMARK_,nil_val));\n});\n\ncljs.core.tree_map_seq_push = (function cljs$core$tree_map_seq_push(node,stack,ascending_QMARK_){\nvar t = node;\nvar stack__$1 = stack;\nwhile(true){\nif((!((t == null)))){\nvar G__2439 = ((ascending_QMARK_)?t.left:t.right);\nvar G__2440 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack__$1,t);\nt = G__2439;\nstack__$1 = G__2440;\ncontinue;\n} else {\nreturn stack__$1;\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.PersistentTreeMapSeq = (function (meta,stack,ascending_QMARK_,cnt,__hash){\nthis.meta = meta;\nthis.stack = stack;\nthis.ascending_QMARK_ = ascending_QMARK_;\nthis.cnt = cnt;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32374990;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.PersistentTreeMapSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.indexOf = (function() {\nvar G__2441 = null;\nvar G__2441__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2441__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2441 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2441__1.call(this,x);\ncase 2:\nreturn G__2441__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2441.cljs$core$IFn$_invoke$arity$1 = G__2441__1;\nG__2441.cljs$core$IFn$_invoke$arity$2 = G__2441__2;\nreturn G__2441;\n})()\n;\n\ncljs.core.PersistentTreeMapSeq.prototype.lastIndexOf = (function() {\nvar G__2442 = null;\nvar G__2442__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2442__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2442 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2442__1.call(this,x);\ncase 2:\nreturn G__2442__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2442.cljs$core$IFn$_invoke$arity$1 = G__2442__1;\nG__2442.cljs$core$IFn$_invoke$arity$2 = G__2442__2;\nreturn G__2442;\n})()\n;\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$INext$_next$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nvar t = cljs.core.first(self__.stack);\nvar next_stack = cljs.core.tree_map_seq_push(((self__.ascending_QMARK_)?t.right:t.left),cljs.core.next(self__.stack),self__.ascending_QMARK_);\nif((next_stack == null)){\nreturn null;\n} else {\nreturn (new cljs.core.PersistentTreeMapSeq(null,next_stack,self__.ascending_QMARK_,(self__.cnt - (1)),null));\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt < (0))){\nreturn (cljs.core.count(cljs.core.next(coll__$1)) + (1));\n} else {\nreturn self__.cnt;\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core.peek(self__.stack);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nvar t = cljs.core.first(self__.stack);\nvar next_stack = cljs.core.tree_map_seq_push(((self__.ascending_QMARK_)?t.right:t.left),cljs.core.next(self__.stack),self__.ascending_QMARK_);\nif((!((next_stack == null)))){\nreturn (new cljs.core.PersistentTreeMapSeq(null,next_stack,self__.ascending_QMARK_,(self__.cnt - (1)),null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1;\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMapSeq(new_meta,self__.stack,self__.ascending_QMARK_,self__.cnt,self__.__hash));\n}\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"stack\",\"stack\",847125597,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"ascending?\",\"ascending?\",-1938452653,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"boolean\",\"boolean\",-278886877,null)], null)),new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentTreeMapSeq.cljs$lang$type = true;\n\ncljs.core.PersistentTreeMapSeq.cljs$lang$ctorStr = \"cljs.core/PersistentTreeMapSeq\";\n\ncljs.core.PersistentTreeMapSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentTreeMapSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentTreeMapSeq.\n */\ncljs.core.__GT_PersistentTreeMapSeq = (function cljs$core$__GT_PersistentTreeMapSeq(meta,stack,ascending_QMARK_,cnt,__hash){\nreturn (new cljs.core.PersistentTreeMapSeq(meta,stack,ascending_QMARK_,cnt,__hash));\n});\n\nvar G__2443_2446 = cljs.core.PersistentTreeMapSeq.prototype;\nvar G__2444_2447 = cljs.core.ITER_SYMBOL;\nvar G__2445_2448 = ((function (G__2443_2446,G__2444_2447){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2443_2446,G__2444_2447))\n;\ngoog.object.set(G__2443_2446,G__2444_2447,G__2445_2448);\ncljs.core.create_tree_map_seq = (function cljs$core$create_tree_map_seq(tree,ascending_QMARK_,cnt){\nreturn (new cljs.core.PersistentTreeMapSeq(null,cljs.core.tree_map_seq_push(tree,null,ascending_QMARK_),ascending_QMARK_,cnt,null));\n});\n\ncljs.core.balance_left = (function cljs$core$balance_left(key,val,ins,right){\nif((ins instanceof cljs.core.RedNode)){\nif((ins.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.key,ins.val,ins.left.blacken(),(new cljs.core.BlackNode(key,val,ins.right,right,null)),null));\n} else {\nif((ins.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.right.key,ins.right.val,(new cljs.core.BlackNode(ins.key,ins.val,ins.left,ins.right.left,null)),(new cljs.core.BlackNode(key,val,ins.right.right,right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(key,val,ins,right,null));\n\n}\n}\n} else {\nreturn (new cljs.core.BlackNode(key,val,ins,right,null));\n}\n});\ncljs.core.balance_right = (function cljs$core$balance_right(key,val,left,ins){\nif((ins instanceof cljs.core.RedNode)){\nif((ins.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.key,ins.val,(new cljs.core.BlackNode(key,val,left,ins.left,null)),ins.right.blacken(),null));\n} else {\nif((ins.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(ins.left.key,ins.left.val,(new cljs.core.BlackNode(key,val,left,ins.left.left,null)),(new cljs.core.BlackNode(ins.key,ins.val,ins.left.right,ins.right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(key,val,left,ins,null));\n\n}\n}\n} else {\nreturn (new cljs.core.BlackNode(key,val,left,ins,null));\n}\n});\ncljs.core.balance_left_del = (function cljs$core$balance_left_del(key,val,del,right){\nif((del instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(key,val,del.blacken(),right,null));\n} else {\nif((right instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_right(key,val,del,right.redden());\n} else {\nif((((right instanceof cljs.core.RedNode)) && ((right.left instanceof cljs.core.BlackNode)))){\nreturn (new cljs.core.RedNode(right.left.key,right.left.val,(new cljs.core.BlackNode(key,val,del,right.left.left,null)),cljs.core.balance_right(right.key,right.val,right.left.right,right.right.redden()),null));\n} else {\nthrow (new Error(\"red-black tree invariant violation\"));\n\n}\n}\n}\n});\ncljs.core.balance_right_del = (function cljs$core$balance_right_del(key,val,left,del){\nif((del instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(key,val,left,del.blacken(),null));\n} else {\nif((left instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_left(key,val,left.redden(),del);\n} else {\nif((((left instanceof cljs.core.RedNode)) && ((left.right instanceof cljs.core.BlackNode)))){\nreturn (new cljs.core.RedNode(left.right.key,left.right.val,cljs.core.balance_left(left.key,left.val,left.left.redden(),left.right.left),(new cljs.core.BlackNode(key,val,left.right.right,del,null)),null));\n} else {\nthrow (new Error(\"red-black tree invariant violation\"));\n\n}\n}\n}\n});\ncljs.core.tree_map_kv_reduce = (function cljs$core$tree_map_kv_reduce(node,f,init){\nvar init__$1 = (((!((node.left == null))))?(function (){var G__2449 = node.left;\nvar G__2450 = f;\nvar G__2451 = init;\nreturn (cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3 ? cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3(G__2449,G__2450,G__2451) : cljs.core.tree_map_kv_reduce.call(null,G__2449,G__2450,G__2451));\n})():init);\nif(cljs.core.reduced_QMARK_(init__$1)){\nreturn init__$1;\n} else {\nvar init__$2 = (function (){var G__2452 = init__$1;\nvar G__2453 = node.key;\nvar G__2454 = node.val;\nreturn (f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(G__2452,G__2453,G__2454) : f.call(null,G__2452,G__2453,G__2454));\n})();\nif(cljs.core.reduced_QMARK_(init__$2)){\nreturn init__$2;\n} else {\nif((!((node.right == null)))){\nvar G__2455 = node.right;\nvar G__2456 = f;\nvar G__2457 = init__$2;\nreturn (cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3 ? cljs.core.tree_map_kv_reduce.cljs$core$IFn$_invoke$arity$3(G__2455,G__2456,G__2457) : cljs.core.tree_map_kv_reduce.call(null,G__2455,G__2456,G__2457));\n} else {\nreturn init__$2;\n}\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.BlackNode = (function (key,val,left,right,__hash){\nthis.key = key;\nthis.val = val;\nthis.left = left;\nthis.right = right;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 166619935;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.BlackNode.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.BlackNode.prototype.cljs$core$IFind$_find$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nvar G__2459 = k;\nswitch (G__2459) {\ncase (0):\nreturn (new cljs.core.MapEntry((0),self__.key,null));\n\nbreak;\ncase (1):\nreturn (new cljs.core.MapEntry((1),self__.val,null));\n\nbreak;\ndefault:\nreturn null;\n\n}\n});\n\ncljs.core.BlackNode.prototype.lastIndexOf = (function() {\nvar G__2461 = null;\nvar G__2461__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2461__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2461 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2461__1.call(this,x);\ncase 2:\nreturn G__2461__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2461.cljs$core$IFn$_invoke$arity$1 = G__2461__1;\nG__2461.cljs$core$IFn$_invoke$arity$2 = G__2461__2;\nreturn G__2461;\n})()\n;\n\ncljs.core.BlackNode.prototype.indexOf = (function() {\nvar G__2462 = null;\nvar G__2462__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2462__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2462 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2462__1.call(this,x);\ncase 2:\nreturn G__2462__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2462.cljs$core$IFn$_invoke$arity$1 = G__2462__1;\nG__2462.cljs$core$IFn$_invoke$arity$2 = G__2462__2;\nreturn G__2462;\n})()\n;\n\ncljs.core.BlackNode.prototype.add_right = (function (ins){\nvar self__ = this;\nvar node = this;\nreturn ins.balance_right(node);\n});\n\ncljs.core.BlackNode.prototype.redden = (function (){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left,self__.right,null));\n});\n\ncljs.core.BlackNode.prototype.blacken = (function (){\nvar self__ = this;\nvar node = this;\nreturn node;\n});\n\ncljs.core.BlackNode.prototype.add_left = (function (ins){\nvar self__ = this;\nvar node = this;\nreturn ins.balance_left(node);\n});\n\ncljs.core.BlackNode.prototype.replace = (function (key__$1,val__$1,left__$1,right__$1){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.BlackNode(key__$1,val__$1,left__$1,right__$1,null));\n});\n\ncljs.core.BlackNode.prototype.balance_left = (function (parent){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.BlackNode(parent.key,parent.val,node,parent.right,null));\n});\n\ncljs.core.BlackNode.prototype.balance_right = (function (parent){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.BlackNode(parent.key,parent.val,parent.left,node,null));\n});\n\ncljs.core.BlackNode.prototype.remove_left = (function (del){\nvar self__ = this;\nvar node = this;\nreturn cljs.core.balance_left_del(self__.key,self__.val,del,self__.right);\n});\n\ncljs.core.BlackNode.prototype.kv_reduce = (function (f,init){\nvar self__ = this;\nvar node = this;\nreturn cljs.core.tree_map_kv_reduce(node,f,init);\n});\n\ncljs.core.BlackNode.prototype.remove_right = (function (del){\nvar self__ = this;\nvar node = this;\nreturn cljs.core.balance_right_del(self__.key,self__.val,self__.left,del);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (node,k,not_found){\nvar self__ = this;\nvar node__$1 = this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (node,n){\nvar self__ = this;\nvar node__$1 = this;\nif((n === (0))){\nreturn self__.key;\n} else {\nif((n === (1))){\nreturn self__.val;\n} else {\nthrow (new Error(\"Index out of bounds\"));\n\n}\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (node,n,not_found){\nvar self__ = this;\nvar node__$1 = this;\nif((n === (0))){\nreturn self__.key;\n} else {\nif((n === (1))){\nreturn self__.val;\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (node,n,v){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null).cljs$core$IVector$_assoc_n$arity$3(null,n,v);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IMeta$_meta$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn null;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ICounted$_count$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (2);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IMapEntry$_key$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.key;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IMapEntry$_val$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IStack$_peek$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IStack$_pop$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key], null);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (new cljs.core.IndexedSeq([self__.val,self__.key],(0),null));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn null;\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (node,f){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(node__$1,f);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (node,f,start){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(node__$1,f,start);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (node,k,v){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),k,v);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nreturn (((k === (0))) || ((k === (1))));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (new cljs.core.IndexedSeq([self__.key,self__.val],(0),null));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (node,meta){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core._with_meta(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),meta);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$ICollection$_conj$arity$2 = (function (node,o){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val,o], null);\n});\n\ncljs.core.BlackNode.prototype.call = (function() {\nvar G__2463 = null;\nvar G__2463__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar node = self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__2463__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar node = self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__2463 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2463__2.call(this,self__,k);\ncase 3:\nreturn G__2463__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2463.cljs$core$IFn$_invoke$arity$2 = G__2463__2;\nG__2463.cljs$core$IFn$_invoke$arity$3 = G__2463__3;\nreturn G__2463;\n})()\n;\n\ncljs.core.BlackNode.prototype.apply = (function (self__,args2458){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2458)));\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar node = this;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar node = this;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.BlackNode.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"key\",\"key\",124488940,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.Symbol(null,\"left\",\"left\",1241415590,null),new cljs.core.Symbol(null,\"right\",\"right\",1187949694,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.BlackNode.cljs$lang$type = true;\n\ncljs.core.BlackNode.cljs$lang$ctorStr = \"cljs.core/BlackNode\";\n\ncljs.core.BlackNode.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/BlackNode\");\n});\n\n/**\n * Positional factory function for cljs.core/BlackNode.\n */\ncljs.core.__GT_BlackNode = (function cljs$core$__GT_BlackNode(key,val,left,right,__hash){\nreturn (new cljs.core.BlackNode(key,val,left,right,__hash));\n});\n\nvar G__2464_2467 = cljs.core.BlackNode.prototype;\nvar G__2465_2468 = cljs.core.ITER_SYMBOL;\nvar G__2466_2469 = ((function (G__2464_2467,G__2465_2468){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2464_2467,G__2465_2468))\n;\ngoog.object.set(G__2464_2467,G__2465_2468,G__2466_2469);\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IVector}\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IStack}\n * @implements {cljs.core.IMapEntry}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.ILookup}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.RedNode = (function (key,val,left,right,__hash){\nthis.key = key;\nthis.val = val;\nthis.left = left;\nthis.right = right;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 166619935;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.RedNode.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RedNode.prototype.cljs$core$IFind$_find$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nvar G__2471 = k;\nswitch (G__2471) {\ncase (0):\nreturn (new cljs.core.MapEntry((0),self__.key,null));\n\nbreak;\ncase (1):\nreturn (new cljs.core.MapEntry((1),self__.val,null));\n\nbreak;\ndefault:\nreturn null;\n\n}\n});\n\ncljs.core.RedNode.prototype.lastIndexOf = (function() {\nvar G__2473 = null;\nvar G__2473__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2473__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2473 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2473__1.call(this,x);\ncase 2:\nreturn G__2473__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2473.cljs$core$IFn$_invoke$arity$1 = G__2473__1;\nG__2473.cljs$core$IFn$_invoke$arity$2 = G__2473__2;\nreturn G__2473;\n})()\n;\n\ncljs.core.RedNode.prototype.indexOf = (function() {\nvar G__2474 = null;\nvar G__2474__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2474__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2474 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2474__1.call(this,x);\ncase 2:\nreturn G__2474__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2474.cljs$core$IFn$_invoke$arity$1 = G__2474__1;\nG__2474.cljs$core$IFn$_invoke$arity$2 = G__2474__2;\nreturn G__2474;\n})()\n;\n\ncljs.core.RedNode.prototype.add_right = (function (ins){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left,ins,null));\n});\n\ncljs.core.RedNode.prototype.redden = (function (){\nvar self__ = this;\nvar node = this;\nthrow (new Error(\"red-black tree invariant violation\"));\n});\n\ncljs.core.RedNode.prototype.blacken = (function (){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.BlackNode(self__.key,self__.val,self__.left,self__.right,null));\n});\n\ncljs.core.RedNode.prototype.add_left = (function (ins){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,ins,self__.right,null));\n});\n\ncljs.core.RedNode.prototype.replace = (function (key__$1,val__$1,left__$1,right__$1){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.RedNode(key__$1,val__$1,left__$1,right__$1,null));\n});\n\ncljs.core.RedNode.prototype.balance_left = (function (parent){\nvar self__ = this;\nvar node = this;\nif((self__.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left.blacken(),(new cljs.core.BlackNode(parent.key,parent.val,self__.right,parent.right,null)),null));\n} else {\nif((self__.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.right.key,self__.right.val,(new cljs.core.BlackNode(self__.key,self__.val,self__.left,self__.right.left,null)),(new cljs.core.BlackNode(parent.key,parent.val,self__.right.right,parent.right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(parent.key,parent.val,node,parent.right,null));\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.balance_right = (function (parent){\nvar self__ = this;\nvar node = this;\nif((self__.right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.key,self__.val,(new cljs.core.BlackNode(parent.key,parent.val,parent.left,self__.left,null)),self__.right.blacken(),null));\n} else {\nif((self__.left instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(self__.left.key,self__.left.val,(new cljs.core.BlackNode(parent.key,parent.val,parent.left,self__.left.left,null)),(new cljs.core.BlackNode(self__.key,self__.val,self__.left.right,self__.right,null)),null));\n} else {\nreturn (new cljs.core.BlackNode(parent.key,parent.val,parent.left,node,null));\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.remove_left = (function (del){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,del,self__.right,null));\n});\n\ncljs.core.RedNode.prototype.kv_reduce = (function (f,init){\nvar self__ = this;\nvar node = this;\nreturn cljs.core.tree_map_kv_reduce(node,f,init);\n});\n\ncljs.core.RedNode.prototype.remove_right = (function (del){\nvar self__ = this;\nvar node = this;\nreturn (new cljs.core.RedNode(self__.key,self__.val,self__.left,del,null));\n});\n\ncljs.core.RedNode.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,null);\n});\n\ncljs.core.RedNode.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (node,k,not_found){\nvar self__ = this;\nvar node__$1 = this;\nreturn node__$1.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (node,n){\nvar self__ = this;\nvar node__$1 = this;\nif((n === (0))){\nreturn self__.key;\n} else {\nif((n === (1))){\nreturn self__.val;\n} else {\nthrow (new Error(\"Index out of bounds\"));\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (node,n,not_found){\nvar self__ = this;\nvar node__$1 = this;\nif((n === (0))){\nreturn self__.key;\n} else {\nif((n === (1))){\nreturn self__.val;\n} else {\nreturn not_found;\n\n}\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IVector$_assoc_n$arity$3 = (function (node,n,v){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null).cljs$core$IVector$_assoc_n$arity$3(null,n,v);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IMeta$_meta$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn null;\n});\n\ncljs.core.RedNode.prototype.cljs$core$ICounted$_count$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (2);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IMapEntry$_key$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.key;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IMapEntry$_val$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IStack$_peek$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn self__.val;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IStack$_pop$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key], null);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (new cljs.core.IndexedSeq([self__.val,self__.key],(0),null));\n});\n\ncljs.core.RedNode.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn null;\n});\n\ncljs.core.RedNode.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (node,f){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(node__$1,f);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (node,f,start){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$3(node__$1,f,start);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (node,k,v){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),k,v);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (node,k){\nvar self__ = this;\nvar node__$1 = this;\nreturn (((k === (0))) || ((k === (1))));\n});\n\ncljs.core.RedNode.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (node){\nvar self__ = this;\nvar node__$1 = this;\nreturn (new cljs.core.IndexedSeq([self__.key,self__.val],(0),null));\n});\n\ncljs.core.RedNode.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (node,meta){\nvar self__ = this;\nvar node__$1 = this;\nreturn cljs.core._with_meta(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val], null),meta);\n});\n\ncljs.core.RedNode.prototype.cljs$core$ICollection$_conj$arity$2 = (function (node,o){\nvar self__ = this;\nvar node__$1 = this;\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [self__.key,self__.val,o], null);\n});\n\ncljs.core.RedNode.prototype.call = (function() {\nvar G__2475 = null;\nvar G__2475__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar node = self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\nvar G__2475__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar node = self____$1;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\nG__2475 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2475__2.call(this,self__,k);\ncase 3:\nreturn G__2475__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2475.cljs$core$IFn$_invoke$arity$2 = G__2475__2;\nG__2475.cljs$core$IFn$_invoke$arity$3 = G__2475__3;\nreturn G__2475;\n})()\n;\n\ncljs.core.RedNode.prototype.apply = (function (self__,args2470){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2470)));\n});\n\ncljs.core.RedNode.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar node = this;\nreturn node.cljs$core$IIndexed$_nth$arity$2(null,k);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar node = this;\nreturn node.cljs$core$IIndexed$_nth$arity$3(null,k,not_found);\n});\n\ncljs.core.RedNode.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"key\",\"key\",124488940,null),new cljs.core.Symbol(null,\"val\",\"val\",1769233139,null),new cljs.core.Symbol(null,\"left\",\"left\",1241415590,null),new cljs.core.Symbol(null,\"right\",\"right\",1187949694,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.RedNode.cljs$lang$type = true;\n\ncljs.core.RedNode.cljs$lang$ctorStr = \"cljs.core/RedNode\";\n\ncljs.core.RedNode.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/RedNode\");\n});\n\n/**\n * Positional factory function for cljs.core/RedNode.\n */\ncljs.core.__GT_RedNode = (function cljs$core$__GT_RedNode(key,val,left,right,__hash){\nreturn (new cljs.core.RedNode(key,val,left,right,__hash));\n});\n\nvar G__2476_2479 = cljs.core.RedNode.prototype;\nvar G__2477_2480 = cljs.core.ITER_SYMBOL;\nvar G__2478_2481 = ((function (G__2476_2479,G__2477_2480){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2476_2479,G__2477_2480))\n;\ngoog.object.set(G__2476_2479,G__2477_2480,G__2478_2481);\ncljs.core.tree_map_add = (function cljs$core$tree_map_add(comp,tree,k,v,found){\nif((tree == null)){\nreturn (new cljs.core.RedNode(k,v,null,null,null));\n} else {\nvar c = (function (){var G__2482 = k;\nvar G__2483 = tree.key;\nreturn (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(G__2482,G__2483) : comp.call(null,G__2482,G__2483));\n})();\nif((c === (0))){\n(found[(0)] = tree);\n\nreturn null;\n} else {\nif((c < (0))){\nvar ins = (function (){var G__2484 = comp;\nvar G__2485 = tree.left;\nvar G__2486 = k;\nvar G__2487 = v;\nvar G__2488 = found;\nreturn (cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5 ? cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5(G__2484,G__2485,G__2486,G__2487,G__2488) : cljs.core.tree_map_add.call(null,G__2484,G__2485,G__2486,G__2487,G__2488));\n})();\nif((!((ins == null)))){\nreturn tree.add_left(ins);\n} else {\nreturn null;\n}\n} else {\nvar ins = (function (){var G__2489 = comp;\nvar G__2490 = tree.right;\nvar G__2491 = k;\nvar G__2492 = v;\nvar G__2493 = found;\nreturn (cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5 ? cljs.core.tree_map_add.cljs$core$IFn$_invoke$arity$5(G__2489,G__2490,G__2491,G__2492,G__2493) : cljs.core.tree_map_add.call(null,G__2489,G__2490,G__2491,G__2492,G__2493));\n})();\nif((!((ins == null)))){\nreturn tree.add_right(ins);\n} else {\nreturn null;\n}\n\n}\n}\n}\n});\ncljs.core.tree_map_append = (function cljs$core$tree_map_append(left,right){\nif((left == null)){\nreturn right;\n} else {\nif((right == null)){\nreturn left;\n} else {\nif((left instanceof cljs.core.RedNode)){\nif((right instanceof cljs.core.RedNode)){\nvar app = (function (){var G__2494 = left.right;\nvar G__2495 = right.left;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__2494,G__2495) : cljs.core.tree_map_append.call(null,G__2494,G__2495));\n})();\nif((app instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(app.key,app.val,(new cljs.core.RedNode(left.key,left.val,left.left,app.left,null)),(new cljs.core.RedNode(right.key,right.val,app.right,right.right,null)),null));\n} else {\nreturn (new cljs.core.RedNode(left.key,left.val,left.left,(new cljs.core.RedNode(right.key,right.val,app,right.right,null)),null));\n}\n} else {\nreturn (new cljs.core.RedNode(left.key,left.val,left.left,(function (){var G__2496 = left.right;\nvar G__2497 = right;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__2496,G__2497) : cljs.core.tree_map_append.call(null,G__2496,G__2497));\n})(),null));\n}\n} else {\nif((right instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(right.key,right.val,(function (){var G__2498 = left;\nvar G__2499 = right.left;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__2498,G__2499) : cljs.core.tree_map_append.call(null,G__2498,G__2499));\n})(),right.right,null));\n} else {\nvar app = (function (){var G__2500 = left.right;\nvar G__2501 = right.left;\nreturn (cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2 ? cljs.core.tree_map_append.cljs$core$IFn$_invoke$arity$2(G__2500,G__2501) : cljs.core.tree_map_append.call(null,G__2500,G__2501));\n})();\nif((app instanceof cljs.core.RedNode)){\nreturn (new cljs.core.RedNode(app.key,app.val,(new cljs.core.BlackNode(left.key,left.val,left.left,app.left,null)),(new cljs.core.BlackNode(right.key,right.val,app.right,right.right,null)),null));\n} else {\nreturn cljs.core.balance_left_del(left.key,left.val,left.left,(new cljs.core.BlackNode(right.key,right.val,app,right.right,null)));\n}\n\n}\n}\n}\n}\n});\ncljs.core.tree_map_remove = (function cljs$core$tree_map_remove(comp,tree,k,found){\nif((!((tree == null)))){\nvar c = (function (){var G__2502 = k;\nvar G__2503 = tree.key;\nreturn (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(G__2502,G__2503) : comp.call(null,G__2502,G__2503));\n})();\nif((c === (0))){\n(found[(0)] = tree);\n\nreturn cljs.core.tree_map_append(tree.left,tree.right);\n} else {\nif((c < (0))){\nvar del = (function (){var G__2504 = comp;\nvar G__2505 = tree.left;\nvar G__2506 = k;\nvar G__2507 = found;\nreturn (cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4(G__2504,G__2505,G__2506,G__2507) : cljs.core.tree_map_remove.call(null,G__2504,G__2505,G__2506,G__2507));\n})();\nif((((!((del == null)))) || ((!(((found[(0)]) == null)))))){\nif((tree.left instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_left_del(tree.key,tree.val,del,tree.right);\n} else {\nreturn (new cljs.core.RedNode(tree.key,tree.val,del,tree.right,null));\n}\n} else {\nreturn null;\n}\n} else {\nvar del = (function (){var G__2508 = comp;\nvar G__2509 = tree.right;\nvar G__2510 = k;\nvar G__2511 = found;\nreturn (cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_remove.cljs$core$IFn$_invoke$arity$4(G__2508,G__2509,G__2510,G__2511) : cljs.core.tree_map_remove.call(null,G__2508,G__2509,G__2510,G__2511));\n})();\nif((((!((del == null)))) || ((!(((found[(0)]) == null)))))){\nif((tree.right instanceof cljs.core.BlackNode)){\nreturn cljs.core.balance_right_del(tree.key,tree.val,tree.left,del);\n} else {\nreturn (new cljs.core.RedNode(tree.key,tree.val,tree.left,del,null));\n}\n} else {\nreturn null;\n}\n\n}\n}\n} else {\nreturn null;\n}\n});\ncljs.core.tree_map_replace = (function cljs$core$tree_map_replace(comp,tree,k,v){\nvar tk = tree.key;\nvar c = (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(k,tk) : comp.call(null,k,tk));\nif((c === (0))){\nreturn tree.replace(tk,v,tree.left,tree.right);\n} else {\nif((c < (0))){\nreturn tree.replace(tk,tree.val,(function (){var G__2512 = comp;\nvar G__2513 = tree.left;\nvar G__2514 = k;\nvar G__2515 = v;\nreturn (cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4(G__2512,G__2513,G__2514,G__2515) : cljs.core.tree_map_replace.call(null,G__2512,G__2513,G__2514,G__2515));\n})(),tree.right);\n} else {\nreturn tree.replace(tk,tree.val,tree.left,(function (){var G__2516 = comp;\nvar G__2517 = tree.right;\nvar G__2518 = k;\nvar G__2519 = v;\nreturn (cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4 ? cljs.core.tree_map_replace.cljs$core$IFn$_invoke$arity$4(G__2516,G__2517,G__2518,G__2519) : cljs.core.tree_map_replace.call(null,G__2516,G__2517,G__2518,G__2519));\n})());\n\n}\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IFind}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISorted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentTreeMap = (function (comp,tree,cnt,meta,__hash){\nthis.comp = comp;\nthis.tree = tree;\nthis.cnt = cnt;\nthis.meta = meta;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 418776847;\nthis.cljs$lang$protocol_mask$partition1$ = 8192;\n});\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFind$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFind$_find$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.entry_at(k);\n});\n\ncljs.core.PersistentTreeMap.prototype.forEach = (function (f){\nvar self__ = this;\nvar coll = this;\nvar seq__2521 = cljs.core.seq(coll);\nvar chunk__2522 = null;\nvar count__2523 = (0);\nvar i__2524 = (0);\nwhile(true){\nif((i__2524 < count__2523)){\nvar vec__2531 = chunk__2522.cljs$core$IIndexed$_nth$arity$2(null,i__2524);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2531,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2531,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2543 = seq__2521;\nvar G__2544 = chunk__2522;\nvar G__2545 = count__2523;\nvar G__2546 = (i__2524 + (1));\nseq__2521 = G__2543;\nchunk__2522 = G__2544;\ncount__2523 = G__2545;\ni__2524 = G__2546;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2521);\nif(temp__5720__auto__){\nvar seq__2521__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2521__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2521__$1);\nvar G__2547 = cljs.core.chunk_rest(seq__2521__$1);\nvar G__2548 = c__4550__auto__;\nvar G__2549 = cljs.core.count(c__4550__auto__);\nvar G__2550 = (0);\nseq__2521 = G__2547;\nchunk__2522 = G__2548;\ncount__2523 = G__2549;\ni__2524 = G__2550;\ncontinue;\n} else {\nvar vec__2534 = cljs.core.first(seq__2521__$1);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2534,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2534,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2551 = cljs.core.next(seq__2521__$1);\nvar G__2552 = null;\nvar G__2553 = (0);\nvar G__2554 = (0);\nseq__2521 = G__2551;\nchunk__2522 = G__2552;\ncount__2523 = G__2553;\ni__2524 = G__2554;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.get = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentTreeMap.prototype.entries = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeMap.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentTreeMap.prototype.keys = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.keys(coll));\n});\n\ncljs.core.PersistentTreeMap.prototype.values = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.vals(coll));\n});\n\ncljs.core.PersistentTreeMap.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentTreeMap.prototype.entry_at = (function (k){\nvar self__ = this;\nvar coll = this;\nvar t = self__.tree;\nwhile(true){\nif((!((t == null)))){\nvar c = (function (){var G__2537 = k;\nvar G__2538 = t.key;\nreturn (self__.comp.cljs$core$IFn$_invoke$arity$2 ? self__.comp.cljs$core$IFn$_invoke$arity$2(G__2537,G__2538) : self__.comp.call(null,G__2537,G__2538));\n})();\nif((c === (0))){\nreturn t;\n} else {\nif((c < (0))){\nvar G__2555 = t.left;\nt = G__2555;\ncontinue;\n} else {\nvar G__2556 = t.right;\nt = G__2556;\ncontinue;\n\n}\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.has = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,k,null);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,k,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nvar n = coll__$1.entry_at(k);\nif((!((n == null)))){\nreturn n.val;\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (coll,f,init){\nvar self__ = this;\nvar coll__$1 = this;\nif((!((self__.tree == null)))){\nreturn cljs.core.unreduced(cljs.core.tree_map_kv_reduce(self__.tree,f,init));\n} else {\nreturn init;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.PersistentTreeMap(self__.comp,self__.tree,self__.cnt,self__.meta,self__.__hash));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.cnt;\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nreturn cljs.core.create_tree_map_seq(self__.tree,false,self__.cnt);\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_map(coll__$1,other);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentTreeMap(self__.comp,null,(0),self__.meta,(0)));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nvar found = [null];\nvar t = cljs.core.tree_map_remove(self__.comp,self__.tree,k,found);\nif((t == null)){\nif((cljs.core.nth.cljs$core$IFn$_invoke$arity$2(found,(0)) == null)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,null,(0),self__.meta,null));\n}\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,t.blacken(),(self__.cnt - (1)),self__.meta,null));\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (coll,k,v){\nvar self__ = this;\nvar coll__$1 = this;\nvar found = [null];\nvar t = cljs.core.tree_map_add(self__.comp,self__.tree,k,v,found);\nif((t == null)){\nvar found_node = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(found,(0));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(v,found_node.val)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,cljs.core.tree_map_replace(self__.comp,self__.tree,k,v),self__.cnt,self__.meta,null));\n}\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,t.blacken(),(self__.cnt + (1)),self__.meta,null));\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (coll,k){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (!((coll__$1.entry_at(k) == null)));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nreturn cljs.core.create_tree_map_seq(self__.tree,true,self__.cnt);\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeMap(self__.comp,self__.tree,self__.cnt,new_meta,self__.__hash));\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nif(cljs.core.vector_QMARK_(entry)){\nreturn coll__$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(entry,(1)));\n} else {\nvar ret = coll__$1;\nvar es = cljs.core.seq(entry);\nwhile(true){\nif((es == null)){\nreturn ret;\n} else {\nvar e = cljs.core.first(es);\nif(cljs.core.vector_QMARK_(e)){\nvar G__2557 = cljs.core._assoc(ret,cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(0)),cljs.core._nth.cljs$core$IFn$_invoke$arity$2(e,(1)));\nvar G__2558 = cljs.core.next(es);\nret = G__2557;\nes = G__2558;\ncontinue;\n} else {\nthrow (new Error(\"conj on a map takes map entries or seqables of map entries\"));\n}\n}\nbreak;\n}\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.call = (function() {\nvar G__2559 = null;\nvar G__2559__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2559__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2559 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2559__2.call(this,self__,k);\ncase 3:\nreturn G__2559__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2559.cljs$core$IFn$_invoke$arity$2 = G__2559__2;\nG__2559.cljs$core$IFn$_invoke$arity$3 = G__2559__3;\nreturn G__2559;\n})()\n;\n\ncljs.core.PersistentTreeMap.prototype.apply = (function (self__,args2520){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2520)));\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_sorted_seq$arity$2 = (function (coll,ascending_QMARK_){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nreturn cljs.core.create_tree_map_seq(self__.tree,ascending_QMARK_,self__.cnt);\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_sorted_seq_from$arity$3 = (function (coll,k,ascending_QMARK_){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.cnt > (0))){\nvar stack = null;\nvar t = self__.tree;\nwhile(true){\nif((!((t == null)))){\nvar c = (function (){var G__2541 = k;\nvar G__2542 = t.key;\nreturn (self__.comp.cljs$core$IFn$_invoke$arity$2 ? self__.comp.cljs$core$IFn$_invoke$arity$2(G__2541,G__2542) : self__.comp.call(null,G__2541,G__2542));\n})();\nif((c === (0))){\nreturn (new cljs.core.PersistentTreeMapSeq(null,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,t),ascending_QMARK_,(-1),null));\n} else {\nif(cljs.core.truth_(ascending_QMARK_)){\nif((c < (0))){\nvar G__2560 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,t);\nvar G__2561 = t.left;\nstack = G__2560;\nt = G__2561;\ncontinue;\n} else {\nvar G__2562 = stack;\nvar G__2563 = t.right;\nstack = G__2562;\nt = G__2563;\ncontinue;\n}\n} else {\nif((c > (0))){\nvar G__2564 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack,t);\nvar G__2565 = t.right;\nstack = G__2564;\nt = G__2565;\ncontinue;\n} else {\nvar G__2566 = stack;\nvar G__2567 = t.left;\nstack = G__2566;\nt = G__2567;\ncontinue;\n}\n\n}\n}\n} else {\nif((stack == null)){\nreturn null;\n} else {\nreturn (new cljs.core.PersistentTreeMapSeq(null,stack,ascending_QMARK_,(-1),null));\n}\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_entry_key$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.key(entry);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$ISorted$_comparator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.comp;\n});\n\ncljs.core.PersistentTreeMap.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"comp\",\"comp\",-1462482139,null),new cljs.core.Symbol(null,\"tree\",\"tree\",1444219499,null),new cljs.core.Symbol(null,\"cnt\",\"cnt\",1924510325,null),new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentTreeMap.cljs$lang$type = true;\n\ncljs.core.PersistentTreeMap.cljs$lang$ctorStr = \"cljs.core/PersistentTreeMap\";\n\ncljs.core.PersistentTreeMap.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentTreeMap\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentTreeMap.\n */\ncljs.core.__GT_PersistentTreeMap = (function cljs$core$__GT_PersistentTreeMap(comp,tree,cnt,meta,__hash){\nreturn (new cljs.core.PersistentTreeMap(comp,tree,cnt,meta,__hash));\n});\n\ncljs.core.PersistentTreeMap.EMPTY = (new cljs.core.PersistentTreeMap(cljs.core.compare,null,(0),null,cljs.core.empty_unordered_hash));\nvar G__2568_2571 = cljs.core.PersistentTreeMap.prototype;\nvar G__2569_2572 = cljs.core.ITER_SYMBOL;\nvar G__2570_2573 = ((function (G__2568_2571,G__2569_2572){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2568_2571,G__2569_2572))\n;\ngoog.object.set(G__2568_2571,G__2569_2572,G__2570_2573);\n/**\n * keyval => key val\n *   Returns a new hash map with supplied mappings.\n */\ncljs.core.hash_map = (function cljs$core$hash_map(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2575 = arguments.length;\nvar i__4731__auto___2576 = (0);\nwhile(true){\nif((i__4731__auto___2576 < len__4730__auto___2575)){\nargs__4736__auto__.push((arguments[i__4731__auto___2576]));\n\nvar G__2577 = (i__4731__auto___2576 + (1));\ni__4731__auto___2576 = G__2577;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.hash_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.hash_map.cljs$core$IFn$_invoke$arity$variadic = (function (keyvals){\nvar in$ = cljs.core.seq(keyvals);\nvar out = cljs.core.transient$(cljs.core.PersistentHashMap.EMPTY);\nwhile(true){\nif(in$){\nvar G__2578 = cljs.core.nnext(in$);\nvar G__2579 = cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(out,cljs.core.first(in$),cljs.core.second(in$));\nin$ = G__2578;\nout = G__2579;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n});\n\ncljs.core.hash_map.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.hash_map.cljs$lang$applyTo = (function (seq2574){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2574));\n});\n\n/**\n * keyval => key val\n *   Returns a new array map with supplied mappings.\n */\ncljs.core.array_map = (function cljs$core$array_map(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2581 = arguments.length;\nvar i__4731__auto___2582 = (0);\nwhile(true){\nif((i__4731__auto___2582 < len__4730__auto___2581)){\nargs__4736__auto__.push((arguments[i__4731__auto___2582]));\n\nvar G__2583 = (i__4731__auto___2582 + (1));\ni__4731__auto___2582 = G__2583;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.array_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.array_map.cljs$core$IFn$_invoke$arity$variadic = (function (keyvals){\nvar arr = (((((keyvals instanceof cljs.core.IndexedSeq)) && ((keyvals.i === (0)))))?keyvals.arr:cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(keyvals));\nreturn cljs.core.PersistentArrayMap.createAsIfByAssoc(arr);\n});\n\ncljs.core.array_map.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.array_map.cljs$lang$applyTo = (function (seq2580){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2580));\n});\n\n/**\n * keyval => key val\n *   Returns a new object map with supplied mappings.\n */\ncljs.core.obj_map = (function cljs$core$obj_map(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2590 = arguments.length;\nvar i__4731__auto___2591 = (0);\nwhile(true){\nif((i__4731__auto___2591 < len__4730__auto___2590)){\nargs__4736__auto__.push((arguments[i__4731__auto___2591]));\n\nvar G__2592 = (i__4731__auto___2591 + (1));\ni__4731__auto___2591 = G__2592;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.obj_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.obj_map.cljs$core$IFn$_invoke$arity$variadic = (function (keyvals){\nvar ks = [];\nvar obj = ({});\nvar kvs = cljs.core.seq(keyvals);\nwhile(true){\nif(kvs){\nks.push(cljs.core.first(kvs));\n\nvar G__2587_2593 = obj;\nvar G__2588_2594 = cljs.core.first(kvs);\nvar G__2589_2595 = cljs.core.second(kvs);\ngoog.object.set(G__2587_2593,G__2588_2594,G__2589_2595);\n\nvar G__2596 = cljs.core.nnext(kvs);\nkvs = G__2596;\ncontinue;\n} else {\nreturn cljs.core.ObjMap.fromObject(ks,obj);\n}\nbreak;\n}\n});\n\ncljs.core.obj_map.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.obj_map.cljs$lang$applyTo = (function (seq2584){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2584));\n});\n\n/**\n * keyval => key val\n *   Returns a new sorted map with supplied mappings.\n */\ncljs.core.sorted_map = (function cljs$core$sorted_map(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2598 = arguments.length;\nvar i__4731__auto___2599 = (0);\nwhile(true){\nif((i__4731__auto___2599 < len__4730__auto___2598)){\nargs__4736__auto__.push((arguments[i__4731__auto___2599]));\n\nvar G__2600 = (i__4731__auto___2599 + (1));\ni__4731__auto___2599 = G__2600;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.sorted_map.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.sorted_map.cljs$core$IFn$_invoke$arity$variadic = (function (keyvals){\nvar in$ = cljs.core.seq(keyvals);\nvar out = cljs.core.PersistentTreeMap.EMPTY;\nwhile(true){\nif(in$){\nvar G__2601 = cljs.core.nnext(in$);\nvar G__2602 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(out,cljs.core.first(in$),cljs.core.second(in$));\nin$ = G__2601;\nout = G__2602;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\ncljs.core.sorted_map.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.sorted_map.cljs$lang$applyTo = (function (seq2597){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2597));\n});\n\n/**\n * keyval => key val\n *   Returns a new sorted map with supplied mappings, using the supplied comparator.\n */\ncljs.core.sorted_map_by = (function cljs$core$sorted_map_by(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2605 = arguments.length;\nvar i__4731__auto___2606 = (0);\nwhile(true){\nif((i__4731__auto___2606 < len__4730__auto___2605)){\nargs__4736__auto__.push((arguments[i__4731__auto___2606]));\n\nvar G__2607 = (i__4731__auto___2606 + (1));\ni__4731__auto___2606 = G__2607;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.sorted_map_by.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.sorted_map_by.cljs$core$IFn$_invoke$arity$variadic = (function (comparator,keyvals){\nvar in$ = cljs.core.seq(keyvals);\nvar out = (new cljs.core.PersistentTreeMap(cljs.core.fn__GT_comparator(comparator),null,(0),null,(0)));\nwhile(true){\nif(in$){\nvar G__2608 = cljs.core.nnext(in$);\nvar G__2609 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(out,cljs.core.first(in$),cljs.core.second(in$));\nin$ = G__2608;\nout = G__2609;\ncontinue;\n} else {\nreturn out;\n}\nbreak;\n}\n});\n\ncljs.core.sorted_map_by.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\ncljs.core.sorted_map_by.cljs$lang$applyTo = (function (seq2603){\nvar G__2604 = cljs.core.first(seq2603);\nvar seq2603__$1 = cljs.core.next(seq2603);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2604,seq2603__$1);\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.KeySeq = (function (mseq,_meta){\nthis.mseq = mseq;\nthis._meta = _meta;\nthis.cljs$lang$protocol_mask$partition0$ = 32374988;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.KeySeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.KeySeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.KeySeq.prototype.indexOf = (function() {\nvar G__2612 = null;\nvar G__2612__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2612__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2612 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2612__1.call(this,x);\ncase 2:\nreturn G__2612__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2612.cljs$core$IFn$_invoke$arity$1 = G__2612__1;\nG__2612.cljs$core$IFn$_invoke$arity$2 = G__2612__2;\nreturn G__2612;\n})()\n;\n\ncljs.core.KeySeq.prototype.lastIndexOf = (function() {\nvar G__2613 = null;\nvar G__2613__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2613__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2613 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2613__1.call(this,x);\ncase 2:\nreturn G__2613__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2613.cljs$core$IFn$_invoke$arity$1 = G__2613__1;\nG__2613.cljs$core$IFn$_invoke$arity$2 = G__2613__2;\nreturn G__2613;\n})()\n;\n\ncljs.core.KeySeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__._meta;\n});\n\ncljs.core.KeySeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar nseq = (((((!((self__.mseq == null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ & (128))) || ((cljs.core.PROTOCOL_SENTINEL === self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((nseq == null)){\nreturn null;\n} else {\nreturn (new cljs.core.KeySeq(nseq,null));\n}\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar me = self__.mseq.cljs$core$ISeq$_first$arity$1(null);\nreturn me.cljs$core$IMapEntry$_key$arity$1(null);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar nseq = (((((!((self__.mseq == null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ & (128))) || ((cljs.core.PROTOCOL_SENTINEL === self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((!((nseq == null)))){\nreturn (new cljs.core.KeySeq(nseq,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__._meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.KeySeq(self__.mseq,new_meta));\n}\n});\n\ncljs.core.KeySeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.KeySeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"mseq\",\"mseq\",1602647196,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"not-native\",\"not-native\",-236392494,null)], null)),new cljs.core.Symbol(null,\"_meta\",\"_meta\",-1716892533,null)], null);\n});\n\ncljs.core.KeySeq.cljs$lang$type = true;\n\ncljs.core.KeySeq.cljs$lang$ctorStr = \"cljs.core/KeySeq\";\n\ncljs.core.KeySeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/KeySeq\");\n});\n\n/**\n * Positional factory function for cljs.core/KeySeq.\n */\ncljs.core.__GT_KeySeq = (function cljs$core$__GT_KeySeq(mseq,_meta){\nreturn (new cljs.core.KeySeq(mseq,_meta));\n});\n\nvar G__2614_2617 = cljs.core.KeySeq.prototype;\nvar G__2615_2618 = cljs.core.ITER_SYMBOL;\nvar G__2616_2619 = ((function (G__2614_2617,G__2615_2618){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2614_2617,G__2615_2618))\n;\ngoog.object.set(G__2614_2617,G__2615_2618,G__2616_2619);\n/**\n * Returns a sequence of the map's keys, in the same order as (seq map).\n */\ncljs.core.keys = (function cljs$core$keys(map){\nvar temp__5720__auto__ = cljs.core.seq(map);\nif(temp__5720__auto__){\nvar mseq = temp__5720__auto__;\nreturn (new cljs.core.KeySeq(mseq,null));\n} else {\nreturn null;\n}\n});\n/**\n * Returns the key of the map entry.\n */\ncljs.core.key = (function cljs$core$key(map_entry){\nreturn cljs.core._key(map_entry);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.ValSeq = (function (mseq,_meta){\nthis.mseq = mseq;\nthis._meta = _meta;\nthis.cljs$lang$protocol_mask$partition0$ = 32374988;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.ValSeq.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.ValSeq.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.ValSeq.prototype.indexOf = (function() {\nvar G__2622 = null;\nvar G__2622__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2622__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2622 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2622__1.call(this,x);\ncase 2:\nreturn G__2622__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2622.cljs$core$IFn$_invoke$arity$1 = G__2622__1;\nG__2622.cljs$core$IFn$_invoke$arity$2 = G__2622__2;\nreturn G__2622;\n})()\n;\n\ncljs.core.ValSeq.prototype.lastIndexOf = (function() {\nvar G__2623 = null;\nvar G__2623__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2623__2 = (function (x,start){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start);\n});\nG__2623 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__2623__1.call(this,x);\ncase 2:\nreturn G__2623__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2623.cljs$core$IFn$_invoke$arity$1 = G__2623__1;\nG__2623.cljs$core$IFn$_invoke$arity$2 = G__2623__2;\nreturn G__2623;\n})()\n;\n\ncljs.core.ValSeq.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__._meta;\n});\n\ncljs.core.ValSeq.prototype.cljs$core$INext$_next$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar nseq = (((((!((self__.mseq == null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ & (128))) || ((cljs.core.PROTOCOL_SENTINEL === self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((nseq == null)){\nreturn null;\n} else {\nreturn (new cljs.core.ValSeq(nseq,null));\n}\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.hash_ordered_coll(coll__$1);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.equiv_sequential(coll__$1,other);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (coll,f){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$2(f,coll__$1);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (coll,f,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3(f,start,coll__$1);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar me = self__.mseq.cljs$core$ISeq$_first$arity$1(null);\nreturn me.cljs$core$IMapEntry$_val$arity$1(null);\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ISeq$_rest$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar nseq = (((((!((self__.mseq == null))))?(((((self__.mseq.cljs$lang$protocol_mask$partition0$ & (128))) || ((cljs.core.PROTOCOL_SENTINEL === self__.mseq.cljs$core$INext$))))?true:(((!self__.mseq.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq):false)):cljs.core.native_satisfies_QMARK_(cljs.core.INext,self__.mseq)))?self__.mseq.cljs$core$INext$_next$arity$1(null):cljs.core.next(self__.mseq));\nif((!((nseq == null)))){\nreturn (new cljs.core.ValSeq(nseq,null));\n} else {\nreturn cljs.core.List.EMPTY;\n}\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1;\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__._meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.ValSeq(self__.mseq,new_meta));\n}\n});\n\ncljs.core.ValSeq.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.cons(o,coll__$1);\n});\n\ncljs.core.ValSeq.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"mseq\",\"mseq\",1602647196,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223),new cljs.core.Symbol(null,\"not-native\",\"not-native\",-236392494,null)], null)),new cljs.core.Symbol(null,\"_meta\",\"_meta\",-1716892533,null)], null);\n});\n\ncljs.core.ValSeq.cljs$lang$type = true;\n\ncljs.core.ValSeq.cljs$lang$ctorStr = \"cljs.core/ValSeq\";\n\ncljs.core.ValSeq.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ValSeq\");\n});\n\n/**\n * Positional factory function for cljs.core/ValSeq.\n */\ncljs.core.__GT_ValSeq = (function cljs$core$__GT_ValSeq(mseq,_meta){\nreturn (new cljs.core.ValSeq(mseq,_meta));\n});\n\nvar G__2624_2627 = cljs.core.ValSeq.prototype;\nvar G__2625_2628 = cljs.core.ITER_SYMBOL;\nvar G__2626_2629 = ((function (G__2624_2627,G__2625_2628){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2624_2627,G__2625_2628))\n;\ngoog.object.set(G__2624_2627,G__2625_2628,G__2626_2629);\n/**\n * Returns a sequence of the map's values, in the same order as (seq map).\n */\ncljs.core.vals = (function cljs$core$vals(map){\nvar temp__5720__auto__ = cljs.core.seq(map);\nif(temp__5720__auto__){\nvar mseq = temp__5720__auto__;\nreturn (new cljs.core.ValSeq(mseq,null));\n} else {\nreturn null;\n}\n});\n/**\n * Returns the value in the map entry.\n */\ncljs.core.val = (function cljs$core$val(map_entry){\nreturn cljs.core._val(map_entry);\n});\n/**\n * Returns a map that consists of the rest of the maps conj-ed onto\n *   the first.  If a key occurs in more than one map, the mapping from\n *   the latter (left-to-right) will be the mapping in the result.\n */\ncljs.core.merge = (function cljs$core$merge(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2633 = arguments.length;\nvar i__4731__auto___2634 = (0);\nwhile(true){\nif((i__4731__auto___2634 < len__4730__auto___2633)){\nargs__4736__auto__.push((arguments[i__4731__auto___2634]));\n\nvar G__2635 = (i__4731__auto___2634 + (1));\ni__4731__auto___2634 = G__2635;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.merge.cljs$core$IFn$_invoke$arity$variadic = (function (maps){\nif(cljs.core.truth_(cljs.core.some(cljs.core.identity,maps))){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2((function (p1__2630_SHARP_,p2__2631_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2((function (){var or__4131__auto__ = p1__2630_SHARP_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentArrayMap.EMPTY;\n}\n})(),p2__2631_SHARP_);\n}),maps);\n} else {\nreturn null;\n}\n});\n\ncljs.core.merge.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.merge.cljs$lang$applyTo = (function (seq2632){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2632));\n});\n\n/**\n * Returns a map that consists of the rest of the maps conj-ed onto\n *   the first.  If a key occurs in more than one map, the mapping(s)\n *   from the latter (left-to-right) will be combined with the mapping in\n *   the result by calling (f val-in-result val-in-latter).\n */\ncljs.core.merge_with = (function cljs$core$merge_with(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2640 = arguments.length;\nvar i__4731__auto___2641 = (0);\nwhile(true){\nif((i__4731__auto___2641 < len__4730__auto___2640)){\nargs__4736__auto__.push((arguments[i__4731__auto___2641]));\n\nvar G__2642 = (i__4731__auto___2641 + (1));\ni__4731__auto___2641 = G__2642;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic = (function (f,maps){\nif(cljs.core.truth_(cljs.core.some(cljs.core.identity,maps))){\nvar merge_entry = (function (m,e){\nvar k = cljs.core.key(e);\nvar v = cljs.core.val(e);\nif(cljs.core.contains_QMARK_(m,k)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,(function (){var G__2638 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(m,k);\nvar G__2639 = v;\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__2638,G__2639) : f.call(null,G__2638,G__2639));\n})());\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,k,v);\n}\n});\nvar merge2 = ((function (merge_entry){\nreturn (function (m1,m2){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(merge_entry,(function (){var or__4131__auto__ = m1;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.PersistentArrayMap.EMPTY;\n}\n})(),cljs.core.seq(m2));\n});})(merge_entry))\n;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(merge2,maps);\n} else {\nreturn null;\n}\n});\n\ncljs.core.merge_with.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\ncljs.core.merge_with.cljs$lang$applyTo = (function (seq2636){\nvar G__2637 = cljs.core.first(seq2636);\nvar seq2636__$1 = cljs.core.next(seq2636);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2637,seq2636__$1);\n});\n\n/**\n * Returns a map containing only those entries in map whose key is in keys\n */\ncljs.core.select_keys = (function cljs$core$select_keys(map,keyseq){\nvar ret = cljs.core.PersistentArrayMap.EMPTY;\nvar keys = cljs.core.seq(keyseq);\nwhile(true){\nif(keys){\nvar key = cljs.core.first(keys);\nvar entry = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map,key,new cljs.core.Keyword(\"cljs.core\",\"not-found\",\"cljs.core/not-found\",-1572889185));\nvar G__2643 = ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(entry,new cljs.core.Keyword(\"cljs.core\",\"not-found\",\"cljs.core/not-found\",-1572889185)))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ret,key,entry):ret);\nvar G__2644 = cljs.core.next(keys);\nret = G__2643;\nkeys = G__2644;\ncontinue;\n} else {\nreturn cljs.core._with_meta(ret,cljs.core.meta(map));\n}\nbreak;\n}\n});\n\n/**\n* @constructor\n*/\ncljs.core.HashSetIter = (function (iter){\nthis.iter = iter;\n});\ncljs.core.HashSetIter.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.iter.hasNext();\n});\n\ncljs.core.HashSetIter.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nif(self__.iter.hasNext()){\nreturn self__.iter.next().key;\n} else {\nthrow (new Error(\"No such element\"));\n}\n});\n\ncljs.core.HashSetIter.prototype.remove = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (new Error(\"Unsupported operation\"));\n});\n\ncljs.core.HashSetIter.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"iter\",\"iter\",-1346195486,null)], null);\n});\n\ncljs.core.HashSetIter.cljs$lang$type = true;\n\ncljs.core.HashSetIter.cljs$lang$ctorStr = \"cljs.core/HashSetIter\";\n\ncljs.core.HashSetIter.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/HashSetIter\");\n});\n\n/**\n * Positional factory function for cljs.core/HashSetIter.\n */\ncljs.core.__GT_HashSetIter = (function cljs$core$__GT_HashSetIter(iter){\nreturn (new cljs.core.HashSetIter(iter));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IEditableCollection}\n * @implements {cljs.core.ISet}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentHashSet = (function (meta,hash_map,__hash){\nthis.meta = meta;\nthis.hash_map = hash_map;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 15077647;\nthis.cljs$lang$protocol_mask$partition1$ = 139268;\n});\ncljs.core.PersistentHashSet.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentHashSet.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentHashSet.prototype.keys = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashSet.prototype.entries = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_set_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashSet.prototype.values = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentHashSet.prototype.has = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentHashSet.prototype.forEach = (function (f){\nvar self__ = this;\nvar coll = this;\nvar seq__2648 = cljs.core.seq(coll);\nvar chunk__2649 = null;\nvar count__2650 = (0);\nvar i__2651 = (0);\nwhile(true){\nif((i__2651 < count__2650)){\nvar vec__2658 = chunk__2649.cljs$core$IIndexed$_nth$arity$2(null,i__2651);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2658,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2658,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2667 = seq__2648;\nvar G__2668 = chunk__2649;\nvar G__2669 = count__2650;\nvar G__2670 = (i__2651 + (1));\nseq__2648 = G__2667;\nchunk__2649 = G__2668;\ncount__2650 = G__2669;\ni__2651 = G__2670;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2648);\nif(temp__5720__auto__){\nvar seq__2648__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2648__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2648__$1);\nvar G__2671 = cljs.core.chunk_rest(seq__2648__$1);\nvar G__2672 = c__4550__auto__;\nvar G__2673 = cljs.core.count(c__4550__auto__);\nvar G__2674 = (0);\nseq__2648 = G__2671;\nchunk__2649 = G__2672;\ncount__2650 = G__2673;\ni__2651 = G__2674;\ncontinue;\n} else {\nvar vec__2661 = cljs.core.first(seq__2648__$1);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2661,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2661,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2675 = cljs.core.next(seq__2648__$1);\nvar G__2676 = null;\nvar G__2677 = (0);\nvar G__2678 = (0);\nseq__2648 = G__2675;\nchunk__2649 = G__2676;\ncount__2650 = G__2677;\ni__2651 = G__2678;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,v){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,v,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nvar temp__5718__auto__ = cljs.core._find(self__.hash_map,v);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar entry = temp__5718__auto__;\nreturn cljs.core.key(entry);\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.HashSetIter(cljs.core._iterator(self__.hash_map)));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.PersistentHashSet(self__.meta,self__.hash_map,self__.__hash));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._count(self__.hash_map);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nvar and__4120__auto__ = cljs.core.set_QMARK_(other);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = (cljs.core.count(coll__$1) === cljs.core.count(other));\nif(and__4120__auto____$1){\ntry{return cljs.core.reduce_kv(((function (and__4120__auto____$1,and__4120__auto__,coll__$1){\nreturn (function (p1__2646_SHARP_,p2__2645_SHARP_){\nvar or__4131__auto__ = cljs.core.contains_QMARK_(other,p2__2645_SHARP_);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.reduced(false);\n}\n});})(and__4120__auto____$1,and__4120__auto__,coll__$1))\n,true,self__.hash_map);\n}catch (e2666){if((e2666 instanceof Error)){\nvar ex = e2666;\nreturn false;\n} else {\nthrow e2666;\n\n}\n}} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IEditableCollection$_as_transient$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.TransientHashSet(cljs.core._as_transient(self__.hash_map)));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._with_meta(cljs.core.PersistentHashSet.EMPTY,self__.meta);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ISet$_disjoin$arity$2 = (function (coll,v){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentHashSet(self__.meta,cljs.core._dissoc(self__.hash_map,v),null));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.keys(self__.hash_map);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentHashSet(new_meta,self__.hash_map,self__.__hash));\n}\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentHashSet(self__.meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.hash_map,o,null),null));\n});\n\ncljs.core.PersistentHashSet.prototype.call = (function() {\nvar G__2679 = null;\nvar G__2679__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2679__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2679 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2679__2.call(this,self__,k);\ncase 3:\nreturn G__2679__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2679.cljs$core$IFn$_invoke$arity$2 = G__2679__2;\nG__2679.cljs$core$IFn$_invoke$arity$3 = G__2679__3;\nreturn G__2679;\n})()\n;\n\ncljs.core.PersistentHashSet.prototype.apply = (function (self__,args2647){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2647)));\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentHashSet.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"hash-map\",\"hash-map\",-439030950,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentHashSet.cljs$lang$type = true;\n\ncljs.core.PersistentHashSet.cljs$lang$ctorStr = \"cljs.core/PersistentHashSet\";\n\ncljs.core.PersistentHashSet.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentHashSet\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentHashSet.\n */\ncljs.core.__GT_PersistentHashSet = (function cljs$core$__GT_PersistentHashSet(meta,hash_map,__hash){\nreturn (new cljs.core.PersistentHashSet(meta,hash_map,__hash));\n});\n\ncljs.core.PersistentHashSet.EMPTY = (new cljs.core.PersistentHashSet(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.empty_unordered_hash));\ncljs.core.PersistentHashSet.fromArray = (function (items,no_clone){\nvar len = items.length;\nif((len <= cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD)){\nvar arr = ((no_clone)?items:cljs.core.aclone(items));\nvar i = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY);\nwhile(true){\nif((i < len)){\nvar G__2680 = (i + (1));\nvar G__2681 = cljs.core._assoc_BANG_(out,(items[i]),null);\ni = G__2680;\nout = G__2681;\ncontinue;\n} else {\nreturn (new cljs.core.PersistentHashSet(null,cljs.core._persistent_BANG_(out),null));\n}\nbreak;\n}\n} else {\nvar i = (0);\nvar out = cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY);\nwhile(true){\nif((i < len)){\nvar G__2682 = (i + (1));\nvar G__2683 = cljs.core._conj_BANG_(out,(items[i]));\ni = G__2682;\nout = G__2683;\ncontinue;\n} else {\nreturn cljs.core._persistent_BANG_(out);\n}\nbreak;\n}\n}\n});\ncljs.core.PersistentHashSet.createWithCheck = (function (items){\nvar len = items.length;\nvar t = cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nvar n__4607__auto___2684 = len;\nvar i_2685 = (0);\nwhile(true){\nif((i_2685 < n__4607__auto___2684)){\ncljs.core._conj_BANG_(t,(items[i_2685]));\n\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(t),(i_2685 + (1)))){\n} else {\nthrow (new Error([\"Duplicate key: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1((items[i_2685]))].join('')));\n}\n\nvar G__2686 = (i_2685 + (1));\ni_2685 = G__2686;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core._persistent_BANG_(t);\n});\ncljs.core.PersistentHashSet.createAsIfByAssoc = (function (items){\nvar len = items.length;\nvar t = cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nvar n__4607__auto___2687 = len;\nvar i_2688 = (0);\nwhile(true){\nif((i_2688 < n__4607__auto___2687)){\ncljs.core._conj_BANG_(t,(items[i_2688]));\n\nvar G__2689 = (i_2688 + (1));\ni_2688 = G__2689;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn cljs.core._persistent_BANG_(t);\n});\nvar G__2690_2693 = cljs.core.PersistentHashSet.prototype;\nvar G__2691_2694 = cljs.core.ITER_SYMBOL;\nvar G__2692_2695 = ((function (G__2690_2693,G__2691_2694){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2690_2693,G__2691_2694))\n;\ngoog.object.set(G__2690_2693,G__2691_2694,G__2692_2695);\n\n/**\n* @constructor\n * @implements {cljs.core.ITransientSet}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ITransientCollection}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TransientHashSet = (function (transient_map){\nthis.transient_map = transient_map;\nthis.cljs$lang$protocol_mask$partition1$ = 136;\nthis.cljs$lang$protocol_mask$partition0$ = 259;\n});\ncljs.core.TransientHashSet.prototype.cljs$core$ITransientCollection$_conj_BANG_$arity$2 = (function (tcoll,o){\nvar self__ = this;\nvar tcoll__$1 = this;\nself__.transient_map = cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(self__.transient_map,o,null);\n\nreturn tcoll__$1;\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ITransientCollection$_persistent_BANG_$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn (new cljs.core.PersistentHashSet(null,cljs.core.persistent_BANG_(self__.transient_map),null));\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ITransientSet$_disjoin_BANG_$arity$2 = (function (tcoll,v){\nvar self__ = this;\nvar tcoll__$1 = this;\nself__.transient_map = cljs.core.dissoc_BANG_.cljs$core$IFn$_invoke$arity$2(self__.transient_map,v);\n\nreturn tcoll__$1;\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ICounted$_count$arity$1 = (function (tcoll){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn cljs.core.count(self__.transient_map);\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (tcoll,v){\nvar self__ = this;\nvar tcoll__$1 = this;\nreturn tcoll__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (tcoll,v,not_found){\nvar self__ = this;\nvar tcoll__$1 = this;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,v,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)){\nreturn not_found;\n} else {\nreturn v;\n}\n});\n\ncljs.core.TransientHashSet.prototype.call = (function() {\nvar G__2697 = null;\nvar G__2697__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar tcoll = self____$1;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)){\nreturn null;\n} else {\nreturn k;\n}\n});\nvar G__2697__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar tcoll = self____$1;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)){\nreturn not_found;\n} else {\nreturn k;\n}\n});\nG__2697 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2697__2.call(this,self__,k);\ncase 3:\nreturn G__2697__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2697.cljs$core$IFn$_invoke$arity$2 = G__2697__2;\nG__2697.cljs$core$IFn$_invoke$arity$3 = G__2697__3;\nreturn G__2697;\n})()\n;\n\ncljs.core.TransientHashSet.prototype.apply = (function (self__,args2696){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2696)));\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar tcoll = this;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)){\nreturn null;\n} else {\nreturn k;\n}\n});\n\ncljs.core.TransientHashSet.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar tcoll = this;\nif((cljs.core._lookup.cljs$core$IFn$_invoke$arity$3(self__.transient_map,k,cljs.core.lookup_sentinel) === cljs.core.lookup_sentinel)){\nreturn not_found;\n} else {\nreturn k;\n}\n});\n\ncljs.core.TransientHashSet.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"transient-map\",\"transient-map\",351764893,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.TransientHashSet.cljs$lang$type = true;\n\ncljs.core.TransientHashSet.cljs$lang$ctorStr = \"cljs.core/TransientHashSet\";\n\ncljs.core.TransientHashSet.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/TransientHashSet\");\n});\n\n/**\n * Positional factory function for cljs.core/TransientHashSet.\n */\ncljs.core.__GT_TransientHashSet = (function cljs$core$__GT_TransientHashSet(transient_map){\nreturn (new cljs.core.TransientHashSet(transient_map));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IReversible}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ISet}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISorted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.PersistentTreeSet = (function (meta,tree_map,__hash){\nthis.meta = meta;\nthis.tree_map = tree_map;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 417730831;\nthis.cljs$lang$protocol_mask$partition1$ = 8192;\n});\ncljs.core.PersistentTreeSet.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.PersistentTreeSet.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.PersistentTreeSet.prototype.keys = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeSet.prototype.entries = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_set_entries_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeSet.prototype.values = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.es6_iterator(cljs.core.seq(coll));\n});\n\ncljs.core.PersistentTreeSet.prototype.has = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.contains_QMARK_(coll,k);\n});\n\ncljs.core.PersistentTreeSet.prototype.forEach = (function (f){\nvar self__ = this;\nvar coll = this;\nvar seq__2701 = cljs.core.seq(coll);\nvar chunk__2702 = null;\nvar count__2703 = (0);\nvar i__2704 = (0);\nwhile(true){\nif((i__2704 < count__2703)){\nvar vec__2711 = chunk__2702.cljs$core$IIndexed$_nth$arity$2(null,i__2704);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2711,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2711,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2720 = seq__2701;\nvar G__2721 = chunk__2702;\nvar G__2722 = count__2703;\nvar G__2723 = (i__2704 + (1));\nseq__2701 = G__2720;\nchunk__2702 = G__2721;\ncount__2703 = G__2722;\ni__2704 = G__2723;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2701);\nif(temp__5720__auto__){\nvar seq__2701__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2701__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2701__$1);\nvar G__2724 = cljs.core.chunk_rest(seq__2701__$1);\nvar G__2725 = c__4550__auto__;\nvar G__2726 = cljs.core.count(c__4550__auto__);\nvar G__2727 = (0);\nseq__2701 = G__2724;\nchunk__2702 = G__2725;\ncount__2703 = G__2726;\ni__2704 = G__2727;\ncontinue;\n} else {\nvar vec__2714 = cljs.core.first(seq__2701__$1);\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2714,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2714,(1),null);\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(v,k) : f.call(null,v,k));\n\n\nvar G__2728 = cljs.core.next(seq__2701__$1);\nvar G__2729 = null;\nvar G__2730 = (0);\nvar G__2731 = (0);\nseq__2701 = G__2728;\nchunk__2702 = G__2729;\ncount__2703 = G__2730;\ni__2704 = G__2731;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (coll,v){\nvar self__ = this;\nvar coll__$1 = this;\nreturn coll__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (coll,v,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nvar n = self__.tree_map.entry_at(v);\nif((!((n == null)))){\nreturn n.key;\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IMeta$_meta$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,self__.tree_map,self__.__hash));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.count(self__.tree_map);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IReversible$_rseq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((cljs.core.count(self__.tree_map) > (0))){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.key,cljs.core.rseq(self__.tree_map));\n} else {\nreturn null;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IHash$_hash$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_unordered_coll(coll__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (coll,other){\nvar self__ = this;\nvar coll__$1 = this;\nvar and__4120__auto__ = cljs.core.set_QMARK_(other);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = (cljs.core.count(coll__$1) === cljs.core.count(other));\nif(and__4120__auto____$1){\ntry{return cljs.core.reduce_kv(((function (and__4120__auto____$1,and__4120__auto__,coll__$1){\nreturn (function (p1__2699_SHARP_,p2__2698_SHARP_){\nvar or__4131__auto__ = cljs.core.contains_QMARK_(other,p2__2698_SHARP_);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.reduced(false);\n}\n});})(and__4120__auto____$1,and__4120__auto__,coll__$1))\n,true,self__.tree_map);\n}catch (e2719){if((e2719 instanceof Error)){\nvar ex = e2719;\nreturn false;\n} else {\nthrow e2719;\n\n}\n}} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,cljs.core._empty(self__.tree_map),(0)));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISet$_disjoin$arity$2 = (function (coll,v){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.tree_map,v),null));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.keys(self__.tree_map);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (coll,new_meta){\nvar self__ = this;\nvar coll__$1 = this;\nif((new_meta === self__.meta)){\nreturn coll__$1;\n} else {\nreturn (new cljs.core.PersistentTreeSet(new_meta,self__.tree_map,self__.__hash));\n}\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ICollection$_conj$arity$2 = (function (coll,o){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (new cljs.core.PersistentTreeSet(self__.meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.tree_map,o,null),null));\n});\n\ncljs.core.PersistentTreeSet.prototype.call = (function() {\nvar G__2732 = null;\nvar G__2732__2 = (function (self__,k){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\nvar G__2732__3 = (function (self__,k,not_found){\nvar self__ = this;\nvar self____$1 = this;\nvar coll = self____$1;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\nG__2732 = function(self__,k,not_found){\nswitch(arguments.length){\ncase 2:\nreturn G__2732__2.call(this,self__,k);\ncase 3:\nreturn G__2732__3.call(this,self__,k,not_found);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__2732.cljs$core$IFn$_invoke$arity$2 = G__2732__2;\nG__2732.cljs$core$IFn$_invoke$arity$3 = G__2732__3;\nreturn G__2732;\n})()\n;\n\ncljs.core.PersistentTreeSet.prototype.apply = (function (self__,args2700){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args2700)));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IFn$_invoke$arity$1 = (function (k){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$2(null,k);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IFn$_invoke$arity$2 = (function (k,not_found){\nvar self__ = this;\nvar coll = this;\nreturn coll.cljs$core$ILookup$_lookup$arity$3(null,k,not_found);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_sorted_seq$arity$2 = (function (coll,ascending_QMARK_){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.key,cljs.core._sorted_seq(self__.tree_map,ascending_QMARK_));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_sorted_seq_from$arity$3 = (function (coll,k,ascending_QMARK_){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.key,cljs.core._sorted_seq_from(self__.tree_map,k,ascending_QMARK_));\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_entry_key$arity$2 = (function (coll,entry){\nvar self__ = this;\nvar coll__$1 = this;\nreturn entry;\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$ISorted$_comparator$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._comparator(self__.tree_map);\n});\n\ncljs.core.PersistentTreeSet.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"tree-map\",\"tree-map\",1373073049,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.PersistentTreeSet.cljs$lang$type = true;\n\ncljs.core.PersistentTreeSet.cljs$lang$ctorStr = \"cljs.core/PersistentTreeSet\";\n\ncljs.core.PersistentTreeSet.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/PersistentTreeSet\");\n});\n\n/**\n * Positional factory function for cljs.core/PersistentTreeSet.\n */\ncljs.core.__GT_PersistentTreeSet = (function cljs$core$__GT_PersistentTreeSet(meta,tree_map,__hash){\nreturn (new cljs.core.PersistentTreeSet(meta,tree_map,__hash));\n});\n\ncljs.core.PersistentTreeSet.EMPTY = (new cljs.core.PersistentTreeSet(null,cljs.core.PersistentTreeMap.EMPTY,cljs.core.empty_unordered_hash));\nvar G__2733_2736 = cljs.core.PersistentTreeSet.prototype;\nvar G__2734_2737 = cljs.core.ITER_SYMBOL;\nvar G__2735_2738 = ((function (G__2733_2736,G__2734_2737){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2733_2736,G__2734_2737))\n;\ngoog.object.set(G__2733_2736,G__2734_2737,G__2735_2738);\ncljs.core.set_from_indexed_seq = (function cljs$core$set_from_indexed_seq(iseq){\nvar arr = iseq.arr;\nvar ret = (function (){var a__4604__auto__ = arr;\nvar l__4605__auto__ = a__4604__auto__.length;\nvar i = (0);\nvar res = cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nwhile(true){\nif((i < l__4605__auto__)){\nvar G__2739 = (i + (1));\nvar G__2740 = cljs.core._conj_BANG_(res,(arr[i]));\ni = G__2739;\nres = G__2740;\ncontinue;\n} else {\nreturn res;\n}\nbreak;\n}\n})();\nreturn ret.cljs$core$ITransientCollection$_persistent_BANG_$arity$1(null);\n});\n/**\n * Returns a set of the distinct elements of coll.\n */\ncljs.core.set = (function cljs$core$set(coll){\nif(cljs.core.set_QMARK_(coll)){\nreturn cljs.core.with_meta(coll,null);\n} else {\nvar in$ = cljs.core.seq(coll);\nif((in$ == null)){\nreturn cljs.core.PersistentHashSet.EMPTY;\n} else {\nif((((in$ instanceof cljs.core.IndexedSeq)) && ((in$.i === (0))))){\nreturn cljs.core.PersistentHashSet.createAsIfByAssoc(in$.arr);\n} else {\nvar in$__$1 = in$;\nvar out = cljs.core._as_transient(cljs.core.PersistentHashSet.EMPTY);\nwhile(true){\nif((!((in$__$1 == null)))){\nvar G__2741 = cljs.core.next(in$__$1);\nvar G__2742 = cljs.core._conj_BANG_(out,cljs.core._first(in$__$1));\nin$__$1 = G__2741;\nout = G__2742;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(out);\n}\nbreak;\n}\n\n}\n}\n}\n});\n/**\n * Returns a new hash set with supplied keys.  Any equal keys are\n *   handled as if by repeated uses of conj.\n */\ncljs.core.hash_set = (function cljs$core$hash_set(var_args){\nvar G__2745 = arguments.length;\nswitch (G__2745) {\ncase 0:\nreturn cljs.core.hash_set.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___2747 = arguments.length;\nvar i__4731__auto___2748 = (0);\nwhile(true){\nif((i__4731__auto___2748 < len__4730__auto___2747)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___2748]));\n\nvar G__2749 = (i__4731__auto___2748 + (1));\ni__4731__auto___2748 = G__2749;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((0)),(0),null));\nreturn cljs.core.hash_set.cljs$core$IFn$_invoke$arity$variadic(argseq__4752__auto__);\n\n}\n});\n\ncljs.core.hash_set.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.PersistentHashSet.EMPTY;\n});\n\ncljs.core.hash_set.cljs$core$IFn$_invoke$arity$variadic = (function (keys){\nreturn cljs.core.set(keys);\n});\n\n/** @this {Function} */\ncljs.core.hash_set.cljs$lang$applyTo = (function (seq2744){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2744));\n});\n\ncljs.core.hash_set.cljs$lang$maxFixedArity = (0);\n\n/**\n * Returns a new sorted set with supplied keys.\n */\ncljs.core.sorted_set = (function cljs$core$sorted_set(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2751 = arguments.length;\nvar i__4731__auto___2752 = (0);\nwhile(true){\nif((i__4731__auto___2752 < len__4730__auto___2751)){\nargs__4736__auto__.push((arguments[i__4731__auto___2752]));\n\nvar G__2753 = (i__4731__auto___2752 + (1));\ni__4731__auto___2752 = G__2753;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.sorted_set.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.sorted_set.cljs$core$IFn$_invoke$arity$variadic = (function (keys){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,cljs.core.PersistentTreeSet.EMPTY,keys);\n});\n\ncljs.core.sorted_set.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.sorted_set.cljs$lang$applyTo = (function (seq2750){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq2750));\n});\n\n/**\n * Returns a new sorted set with supplied keys, using the supplied comparator.\n */\ncljs.core.sorted_set_by = (function cljs$core$sorted_set_by(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2756 = arguments.length;\nvar i__4731__auto___2757 = (0);\nwhile(true){\nif((i__4731__auto___2757 < len__4730__auto___2756)){\nargs__4736__auto__.push((arguments[i__4731__auto___2757]));\n\nvar G__2758 = (i__4731__auto___2757 + (1));\ni__4731__auto___2757 = G__2758;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.sorted_set_by.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.sorted_set_by.cljs$core$IFn$_invoke$arity$variadic = (function (comparator,keys){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,(new cljs.core.PersistentTreeSet(null,cljs.core.sorted_map_by(comparator),(0))),keys);\n});\n\ncljs.core.sorted_set_by.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\ncljs.core.sorted_set_by.cljs$lang$applyTo = (function (seq2754){\nvar G__2755 = cljs.core.first(seq2754);\nvar seq2754__$1 = cljs.core.next(seq2754);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2755,seq2754__$1);\n});\n\n/**\n * Given a map of replacement pairs and a vector/collection, returns a\n *   vector/seq with any elements = a key in smap replaced with the\n *   corresponding val in smap.  Returns a transducer when no collection\n *   is provided.\n */\ncljs.core.replace = (function cljs$core$replace(var_args){\nvar G__2762 = arguments.length;\nswitch (G__2762) {\ncase 1:\nreturn cljs.core.replace.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.replace.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.replace.cljs$core$IFn$_invoke$arity$1 = (function (smap){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$1((function (p1__2759_SHARP_){\nvar temp__5718__auto__ = cljs.core.find(smap,p1__2759_SHARP_);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e = temp__5718__auto__;\nreturn cljs.core.val(e);\n} else {\nreturn p1__2759_SHARP_;\n}\n}));\n});\n\ncljs.core.replace.cljs$core$IFn$_invoke$arity$2 = (function (smap,coll){\nif(cljs.core.vector_QMARK_(coll)){\nvar n = cljs.core.count(coll);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (n){\nreturn (function (v,i){\nvar temp__5718__auto__ = cljs.core.find(smap,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(v,i));\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e = temp__5718__auto__;\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(v,i,cljs.core.second(e));\n} else {\nreturn v;\n}\n});})(n))\n,coll,cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,cljs.core.iterate(cljs.core.inc,(0))));\n} else {\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__2760_SHARP_){\nvar temp__5718__auto__ = cljs.core.find(smap,p1__2760_SHARP_);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar e = temp__5718__auto__;\nreturn cljs.core.second(e);\n} else {\nreturn p1__2760_SHARP_;\n}\n}),coll);\n}\n});\n\ncljs.core.replace.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a lazy sequence of the elements of coll with duplicates removed.\n *   Returns a stateful transducer when no collection is provided.\n */\ncljs.core.distinct = (function cljs$core$distinct(var_args){\nvar G__2765 = arguments.length;\nswitch (G__2765) {\ncase 0:\nreturn cljs.core.distinct.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.distinct.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.distinct.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (function (rf){\nvar seen = cljs.core.volatile_BANG_(cljs.core.PersistentHashSet.EMPTY);\nreturn ((function (seen){\nreturn (function() {\nvar G__2776 = null;\nvar G__2776__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__2776__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__2776__2 = (function (result,input){\nif(cljs.core.contains_QMARK_(cljs.core.deref(seen),input)){\nreturn result;\n} else {\nseen.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen.cljs$core$IDeref$_deref$arity$1(null),input));\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__2776 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__2776__0.call(this);\ncase 1:\nreturn G__2776__1.call(this,result);\ncase 2:\nreturn G__2776__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2776.cljs$core$IFn$_invoke$arity$0 = G__2776__0;\nG__2776.cljs$core$IFn$_invoke$arity$1 = G__2776__1;\nG__2776.cljs$core$IFn$_invoke$arity$2 = G__2776__2;\nreturn G__2776;\n})()\n;})(seen))\n});\n});\n\ncljs.core.distinct.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nvar step = (function cljs$core$step(xs,seen){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar fexpr__2770 = (function (p__2771,seen__$1){\nwhile(true){\nvar vec__2772 = p__2771;\nvar f = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2772,(0),null);\nvar xs__$1 = vec__2772;\nvar temp__5720__auto__ = cljs.core.seq(xs__$1);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.contains_QMARK_(seen__$1,f)){\nvar G__2777 = cljs.core.rest(s);\nvar G__2778 = seen__$1;\np__2771 = G__2777;\nseen__$1 = G__2778;\ncontinue;\n} else {\nreturn cljs.core.cons(f,cljs$core$step(cljs.core.rest(s),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen__$1,f)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\nreturn fexpr__2770(xs,seen);\n}),null,null));\n});\nreturn step(coll,cljs.core.PersistentHashSet.EMPTY);\n});\n\ncljs.core.distinct.cljs$lang$maxFixedArity = 1;\n\n/**\n * Return a seq of all but the last item in coll, in linear time\n */\ncljs.core.butlast = (function cljs$core$butlast(s){\nvar ret = cljs.core.PersistentVector.EMPTY;\nvar s__$1 = s;\nwhile(true){\nif(cljs.core.next(s__$1)){\nvar G__2779 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ret,cljs.core.first(s__$1));\nvar G__2780 = cljs.core.next(s__$1);\nret = G__2779;\ns__$1 = G__2780;\ncontinue;\n} else {\nreturn cljs.core.seq(ret);\n}\nbreak;\n}\n});\n/**\n * Returns the name String of a string, symbol or keyword.\n */\ncljs.core.name = (function cljs$core$name(x){\nif((((!((x == null))))?(((((x.cljs$lang$protocol_mask$partition1$ & (4096))) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$INamed$))))?true:false):false)){\nreturn cljs.core._name(x);\n} else {\nif(typeof x === 'string'){\nreturn x;\n} else {\nthrow (new Error([\"Doesn't support name: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x)].join('')));\n}\n}\n});\n/**\n * Returns a map with the keys mapped to the corresponding vals.\n */\ncljs.core.zipmap = (function cljs$core$zipmap(keys,vals){\nvar map = cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY);\nvar ks = cljs.core.seq(keys);\nvar vs = cljs.core.seq(vals);\nwhile(true){\nif(((ks) && (vs))){\nvar G__2782 = cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(map,cljs.core.first(ks),cljs.core.first(vs));\nvar G__2783 = cljs.core.next(ks);\nvar G__2784 = cljs.core.next(vs);\nmap = G__2782;\nks = G__2783;\nvs = G__2784;\ncontinue;\n} else {\nreturn cljs.core.persistent_BANG_(map);\n}\nbreak;\n}\n});\n/**\n * Returns the x for which (k x), a number, is greatest.\n *   \n *   If there are multiple such xs, the last one is returned.\n */\ncljs.core.max_key = (function cljs$core$max_key(var_args){\nvar G__2792 = arguments.length;\nswitch (G__2792) {\ncase 2:\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___2794 = arguments.length;\nvar i__4731__auto___2795 = (0);\nwhile(true){\nif((i__4731__auto___2795 < len__4730__auto___2794)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___2795]));\n\nvar G__2796 = (i__4731__auto___2795 + (1));\ni__4731__auto___2795 = G__2796;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.max_key.cljs$core$IFn$_invoke$arity$2 = (function (k,x){\nreturn x;\n});\n\ncljs.core.max_key.cljs$core$IFn$_invoke$arity$3 = (function (k,x,y){\nif(((k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(x) : k.call(null,x)) > (k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(y) : k.call(null,y)))){\nreturn x;\n} else {\nreturn y;\n}\n});\n\ncljs.core.max_key.cljs$core$IFn$_invoke$arity$variadic = (function (k,x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__2785_SHARP_,p2__2786_SHARP_){\nreturn cljs.core.max_key.cljs$core$IFn$_invoke$arity$3(k,p1__2785_SHARP_,p2__2786_SHARP_);\n}),cljs.core.max_key.cljs$core$IFn$_invoke$arity$3(k,x,y),more);\n});\n\n/** @this {Function} */\ncljs.core.max_key.cljs$lang$applyTo = (function (seq2788){\nvar G__2789 = cljs.core.first(seq2788);\nvar seq2788__$1 = cljs.core.next(seq2788);\nvar G__2790 = cljs.core.first(seq2788__$1);\nvar seq2788__$2 = cljs.core.next(seq2788__$1);\nvar G__2791 = cljs.core.first(seq2788__$2);\nvar seq2788__$3 = cljs.core.next(seq2788__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2789,G__2790,G__2791,seq2788__$3);\n});\n\ncljs.core.max_key.cljs$lang$maxFixedArity = (3);\n\n/**\n * Returns the x for which (k x), a number, is least.\n * \n *   If there are multiple such xs, the last one is returned.\n */\ncljs.core.min_key = (function cljs$core$min_key(var_args){\nvar G__2804 = arguments.length;\nswitch (G__2804) {\ncase 2:\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___2806 = arguments.length;\nvar i__4731__auto___2807 = (0);\nwhile(true){\nif((i__4731__auto___2807 < len__4730__auto___2806)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___2807]));\n\nvar G__2808 = (i__4731__auto___2807 + (1));\ni__4731__auto___2807 = G__2808;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.min_key.cljs$core$IFn$_invoke$arity$2 = (function (k,x){\nreturn x;\n});\n\ncljs.core.min_key.cljs$core$IFn$_invoke$arity$3 = (function (k,x,y){\nif(((k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(x) : k.call(null,x)) < (k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(y) : k.call(null,y)))){\nreturn x;\n} else {\nreturn y;\n}\n});\n\ncljs.core.min_key.cljs$core$IFn$_invoke$arity$variadic = (function (k,x,y,more){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__2797_SHARP_,p2__2798_SHARP_){\nreturn cljs.core.min_key.cljs$core$IFn$_invoke$arity$3(k,p1__2797_SHARP_,p2__2798_SHARP_);\n}),cljs.core.min_key.cljs$core$IFn$_invoke$arity$3(k,x,y),more);\n});\n\n/** @this {Function} */\ncljs.core.min_key.cljs$lang$applyTo = (function (seq2800){\nvar G__2801 = cljs.core.first(seq2800);\nvar seq2800__$1 = cljs.core.next(seq2800);\nvar G__2802 = cljs.core.first(seq2800__$1);\nvar seq2800__$2 = cljs.core.next(seq2800__$1);\nvar G__2803 = cljs.core.first(seq2800__$2);\nvar seq2800__$3 = cljs.core.next(seq2800__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2801,G__2802,G__2803,seq2800__$3);\n});\n\ncljs.core.min_key.cljs$lang$maxFixedArity = (3);\n\n\n/**\n* @constructor\n*/\ncljs.core.ArrayList = (function (arr){\nthis.arr = arr;\n});\ncljs.core.ArrayList.prototype.add = (function (x){\nvar self__ = this;\nvar _ = this;\nreturn self__.arr.push(x);\n});\n\ncljs.core.ArrayList.prototype.size = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.arr.length;\n});\n\ncljs.core.ArrayList.prototype.clear = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.arr = [];\n});\n\ncljs.core.ArrayList.prototype.isEmpty = (function (){\nvar self__ = this;\nvar _ = this;\nreturn (self__.arr.length === (0));\n});\n\ncljs.core.ArrayList.prototype.toArray = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.arr;\n});\n\ncljs.core.ArrayList.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"arr\",\"arr\",2115492975,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.ArrayList.cljs$lang$type = true;\n\ncljs.core.ArrayList.cljs$lang$ctorStr = \"cljs.core/ArrayList\";\n\ncljs.core.ArrayList.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/ArrayList\");\n});\n\n/**\n * Positional factory function for cljs.core/ArrayList.\n */\ncljs.core.__GT_ArrayList = (function cljs$core$__GT_ArrayList(arr){\nreturn (new cljs.core.ArrayList(arr));\n});\n\ncljs.core.array_list = (function cljs$core$array_list(){\nreturn (new cljs.core.ArrayList([]));\n});\n/**\n * Returns a lazy sequence of lists like partition, but may include\n *   partitions with fewer than n items at the end.  Returns a stateful\n *   transducer when no collection is provided.\n */\ncljs.core.partition_all = (function cljs$core$partition_all(var_args){\nvar G__2810 = arguments.length;\nswitch (G__2810) {\ncase 1:\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.partition_all.cljs$core$IFn$_invoke$arity$1 = (function (n){\nreturn (function (rf){\nvar a = cljs.core.array_list();\nreturn ((function (a){\nreturn (function() {\nvar G__2812 = null;\nvar G__2812__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__2812__1 = (function (result){\nvar result__$1 = (cljs.core.truth_(a.isEmpty())?result:(function (){var v = cljs.core.vec(a.toArray());\na.clear();\n\nreturn cljs.core.unreduced((rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v)));\n})());\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result__$1) : rf.call(null,result__$1));\n});\nvar G__2812__2 = (function (result,input){\na.add(input);\n\nif((n === a.size())){\nvar v = cljs.core.vec(a.toArray());\na.clear();\n\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\n} else {\nreturn result;\n}\n});\nG__2812 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__2812__0.call(this);\ncase 1:\nreturn G__2812__1.call(this,result);\ncase 2:\nreturn G__2812__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2812.cljs$core$IFn$_invoke$arity$0 = G__2812__0;\nG__2812.cljs$core$IFn$_invoke$arity$1 = G__2812__1;\nG__2812.cljs$core$IFn$_invoke$arity$2 = G__2812__2;\nreturn G__2812;\n})()\n;})(a))\n});\n});\n\ncljs.core.partition_all.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nreturn cljs.core.partition_all.cljs$core$IFn$_invoke$arity$3(n,n,coll);\n});\n\ncljs.core.partition_all.cljs$core$IFn$_invoke$arity$3 = (function (n,step,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nreturn cljs.core.cons(cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,s),cljs.core.partition_all.cljs$core$IFn$_invoke$arity$3(n,step,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(step,s)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition_all.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns a lazy sequence of successive items from coll while\n *   (pred item) returns logical true. pred must be free of side-effects.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.take_while = (function cljs$core$take_while(var_args){\nvar G__2814 = arguments.length;\nswitch (G__2814) {\ncase 1:\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.take_while.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn (function (rf){\nreturn (function() {\nvar G__2817 = null;\nvar G__2817__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__2817__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__2817__2 = (function (result,input){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input)))){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n} else {\nreturn cljs.core.reduced(result);\n}\n});\nG__2817 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__2817__0.call(this);\ncase 1:\nreturn G__2817__1.call(this,result);\ncase 2:\nreturn G__2817__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2817.cljs$core$IFn$_invoke$arity$0 = G__2817__0;\nG__2817.cljs$core$IFn$_invoke$arity$1 = G__2817__1;\nG__2817.cljs$core$IFn$_invoke$arity$2 = G__2817__2;\nreturn G__2817;\n})()\n});\n});\n\ncljs.core.take_while.cljs$core$IFn$_invoke$arity$2 = (function (pred,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nif(cljs.core.truth_((function (){var G__2815 = cljs.core.first(s);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__2815) : pred.call(null,G__2815));\n})())){\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(pred,cljs.core.rest(s)));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.take_while.cljs$lang$maxFixedArity = 2;\n\ncljs.core.mk_bound_fn = (function cljs$core$mk_bound_fn(sc,test,key){\nreturn (function (e){\nvar comp = cljs.core._comparator(sc);\nvar G__2818 = (function (){var G__2820 = cljs.core._entry_key(sc,e);\nvar G__2821 = key;\nreturn (comp.cljs$core$IFn$_invoke$arity$2 ? comp.cljs$core$IFn$_invoke$arity$2(G__2820,G__2821) : comp.call(null,G__2820,G__2821));\n})();\nvar G__2819 = (0);\nreturn (test.cljs$core$IFn$_invoke$arity$2 ? test.cljs$core$IFn$_invoke$arity$2(G__2818,G__2819) : test.call(null,G__2818,G__2819));\n});\n});\n/**\n * sc must be a sorted collection, test(s) one of <, <=, > or\n *   >=. Returns a seq of those entries with keys ek for\n *   which (test (.. sc comparator (compare ek key)) 0) is true\n */\ncljs.core.subseq = (function cljs$core$subseq(var_args){\nvar G__2823 = arguments.length;\nswitch (G__2823) {\ncase 3:\nreturn cljs.core.subseq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 5:\nreturn cljs.core.subseq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.subseq.cljs$core$IFn$_invoke$arity$3 = (function (sc,test,key){\nvar include = cljs.core.mk_bound_fn(sc,test,key);\nif(cljs.core.truth_((function (){var fexpr__2824 = cljs.core.PersistentHashSet.createAsIfByAssoc([cljs.core._GT_,cljs.core._GT__EQ_]);\nreturn (fexpr__2824.cljs$core$IFn$_invoke$arity$1 ? fexpr__2824.cljs$core$IFn$_invoke$arity$1(test) : fexpr__2824.call(null,test));\n})())){\nvar temp__5720__auto__ = cljs.core._sorted_seq_from(sc,key,true);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__2825 = temp__5720__auto__;\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2825,(0),null);\nvar s = vec__2825;\nif(cljs.core.truth_((include.cljs$core$IFn$_invoke$arity$1 ? include.cljs$core$IFn$_invoke$arity$1(e) : include.call(null,e)))){\nreturn s;\n} else {\nreturn cljs.core.next(s);\n}\n} else {\nreturn null;\n}\n} else {\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(include,cljs.core._sorted_seq(sc,true));\n}\n});\n\ncljs.core.subseq.cljs$core$IFn$_invoke$arity$5 = (function (sc,start_test,start_key,end_test,end_key){\nvar temp__5720__auto__ = cljs.core._sorted_seq_from(sc,start_key,true);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__2828 = temp__5720__auto__;\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2828,(0),null);\nvar s = vec__2828;\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(cljs.core.mk_bound_fn(sc,end_test,end_key),(cljs.core.truth_((function (){var fexpr__2831 = cljs.core.mk_bound_fn(sc,start_test,start_key);\nreturn (fexpr__2831.cljs$core$IFn$_invoke$arity$1 ? fexpr__2831.cljs$core$IFn$_invoke$arity$1(e) : fexpr__2831.call(null,e));\n})())?s:cljs.core.next(s)));\n} else {\nreturn null;\n}\n});\n\ncljs.core.subseq.cljs$lang$maxFixedArity = 5;\n\n/**\n * sc must be a sorted collection, test(s) one of <, <=, > or\n *   >=. Returns a reverse seq of those entries with keys ek for\n *   which (test (.. sc comparator (compare ek key)) 0) is true\n */\ncljs.core.rsubseq = (function cljs$core$rsubseq(var_args){\nvar G__2834 = arguments.length;\nswitch (G__2834) {\ncase 3:\nreturn cljs.core.rsubseq.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 5:\nreturn cljs.core.rsubseq.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.rsubseq.cljs$core$IFn$_invoke$arity$3 = (function (sc,test,key){\nvar include = cljs.core.mk_bound_fn(sc,test,key);\nif(cljs.core.truth_((function (){var fexpr__2835 = cljs.core.PersistentHashSet.createAsIfByAssoc([cljs.core._LT_,cljs.core._LT__EQ_]);\nreturn (fexpr__2835.cljs$core$IFn$_invoke$arity$1 ? fexpr__2835.cljs$core$IFn$_invoke$arity$1(test) : fexpr__2835.call(null,test));\n})())){\nvar temp__5720__auto__ = cljs.core._sorted_seq_from(sc,key,false);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__2836 = temp__5720__auto__;\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2836,(0),null);\nvar s = vec__2836;\nif(cljs.core.truth_((include.cljs$core$IFn$_invoke$arity$1 ? include.cljs$core$IFn$_invoke$arity$1(e) : include.call(null,e)))){\nreturn s;\n} else {\nreturn cljs.core.next(s);\n}\n} else {\nreturn null;\n}\n} else {\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(include,cljs.core._sorted_seq(sc,false));\n}\n});\n\ncljs.core.rsubseq.cljs$core$IFn$_invoke$arity$5 = (function (sc,start_test,start_key,end_test,end_key){\nvar temp__5720__auto__ = cljs.core._sorted_seq_from(sc,end_key,false);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar vec__2839 = temp__5720__auto__;\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2839,(0),null);\nvar s = vec__2839;\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(cljs.core.mk_bound_fn(sc,start_test,start_key),(cljs.core.truth_((function (){var fexpr__2842 = cljs.core.mk_bound_fn(sc,end_test,end_key);\nreturn (fexpr__2842.cljs$core$IFn$_invoke$arity$1 ? fexpr__2842.cljs$core$IFn$_invoke$arity$1(e) : fexpr__2842.call(null,e));\n})())?s:cljs.core.next(s)));\n} else {\nreturn null;\n}\n});\n\ncljs.core.rsubseq.cljs$lang$maxFixedArity = 5;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.IChunk}\n*/\ncljs.core.RangeChunk = (function (start,step,count){\nthis.start = start;\nthis.step = step;\nthis.count = count;\nthis.cljs$lang$protocol_mask$partition0$ = 82;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.RangeChunk.prototype.cljs$core$ICounted$_count$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.count;\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$ISeq$_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nreturn self__.start;\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (coll,i){\nvar self__ = this;\nvar coll__$1 = this;\nreturn (self__.start + (i * self__.step));\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (coll,i,not_found){\nvar self__ = this;\nvar coll__$1 = this;\nif((((i >= (0))) && ((i < self__.count)))){\nreturn (self__.start + (i * self__.step));\n} else {\nreturn not_found;\n}\n});\n\ncljs.core.RangeChunk.prototype.cljs$core$IChunk$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RangeChunk.prototype.cljs$core$IChunk$_drop_first$arity$1 = (function (coll){\nvar self__ = this;\nvar coll__$1 = this;\nif((self__.count <= (1))){\nthrow (new Error(\"-drop-first of empty chunk\"));\n} else {\nreturn (new cljs.core.RangeChunk((self__.start + self__.step),self__.step,(self__.count - (1))));\n}\n});\n\ncljs.core.RangeChunk.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"start\",\"start\",1285322546,null),new cljs.core.Symbol(null,\"step\",\"step\",-1365547645,null),new cljs.core.Symbol(null,\"count\",\"count\",-514511684,null)], null);\n});\n\ncljs.core.RangeChunk.cljs$lang$type = true;\n\ncljs.core.RangeChunk.cljs$lang$ctorStr = \"cljs.core/RangeChunk\";\n\ncljs.core.RangeChunk.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/RangeChunk\");\n});\n\n/**\n * Positional factory function for cljs.core/RangeChunk.\n */\ncljs.core.__GT_RangeChunk = (function cljs$core$__GT_RangeChunk(start,step,count){\nreturn (new cljs.core.RangeChunk(start,step,count));\n});\n\n\n/**\n* @constructor\n*/\ncljs.core.RangeIterator = (function (i,end,step){\nthis.i = i;\nthis.end = end;\nthis.step = step;\n});\ncljs.core.RangeIterator.prototype.hasNext = (function (){\nvar self__ = this;\nvar _ = this;\nif((self__.step > (0))){\nreturn (self__.i < self__.end);\n} else {\nreturn (self__.i > self__.end);\n}\n});\n\ncljs.core.RangeIterator.prototype.next = (function (){\nvar self__ = this;\nvar _ = this;\nvar ret = self__.i;\nself__.i = (self__.i + self__.step);\n\nreturn ret;\n});\n\ncljs.core.RangeIterator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"i\",\"i\",253690212,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),new cljs.core.Symbol(null,\"end\",\"end\",1372345569,null),new cljs.core.Symbol(null,\"step\",\"step\",-1365547645,null)], null);\n});\n\ncljs.core.RangeIterator.cljs$lang$type = true;\n\ncljs.core.RangeIterator.cljs$lang$ctorStr = \"cljs.core/RangeIterator\";\n\ncljs.core.RangeIterator.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/RangeIterator\");\n});\n\n/**\n * Positional factory function for cljs.core/RangeIterator.\n */\ncljs.core.__GT_RangeIterator = (function cljs$core$__GT_RangeIterator(i,end,step){\nreturn (new cljs.core.RangeIterator(i,end,step));\n});\n\n\n/**\n* @constructor\n * @implements {cljs.core.IIndexed}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.IChunkedNext}\n * @implements {cljs.core.IEmptyableCollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeq}\n * @implements {cljs.core.INext}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IChunkedSeq}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Range = (function (meta,start,end,step,chunk,chunk_next,__hash){\nthis.meta = meta;\nthis.start = start;\nthis.end = end;\nthis.step = step;\nthis.chunk = chunk;\nthis.chunk_next = chunk_next;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 32375006;\nthis.cljs$lang$protocol_mask$partition1$ = 140800;\n});\ncljs.core.Range.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.Range.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.Range.prototype.indexOf = (function() {\nvar G__2845 = null;\nvar G__2845__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,(0));\n});\nvar G__2845__2 = (function (x,start__$1){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__2845 = function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__2845__1.call(this,x);\ncase 2:\nreturn G__2845__2.call(this,x,start__$1);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2845.cljs$core$IFn$_invoke$arity$1 = G__2845__1;\nG__2845.cljs$core$IFn$_invoke$arity$2 = G__2845__2;\nreturn G__2845;\n})()\n;\n\ncljs.core.Range.prototype.lastIndexOf = (function() {\nvar G__2846 = null;\nvar G__2846__1 = (function (x){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,cljs.core.count(coll));\n});\nvar G__2846__2 = (function (x,start__$1){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll,x,start__$1);\n});\nG__2846 = function(x,start__$1){\nswitch(arguments.length){\ncase 1:\nreturn G__2846__1.call(this,x);\ncase 2:\nreturn G__2846__2.call(this,x,start__$1);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2846.cljs$core$IFn$_invoke$arity$1 = G__2846__1;\nG__2846.cljs$core$IFn$_invoke$arity$2 = G__2846__2;\nreturn G__2846;\n})()\n;\n\ncljs.core.Range.prototype.forceChunk = (function (){\nvar self__ = this;\nvar coll = this;\nif((self__.chunk == null)){\nvar count = coll.cljs$core$ICounted$_count$arity$1(null);\nif((count > (32))){\nself__.chunk_next = (new cljs.core.Range(null,(self__.start + (self__.step * (32))),self__.end,self__.step,null,null,null));\n\nreturn self__.chunk = (new cljs.core.RangeChunk(self__.start,self__.step,(32)));\n} else {\nreturn self__.chunk = (new cljs.core.RangeChunk(self__.start,self__.step,count));\n}\n} else {\nreturn null;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IIndexed$_nth$arity$2 = (function (rng,n){\nvar self__ = this;\nvar rng__$1 = this;\nif(((((0) <= n)) && ((n < rng__$1.cljs$core$ICounted$_count$arity$1(null))))){\nreturn (self__.start + (n * self__.step));\n} else {\nif(((((0) <= n)) && ((self__.start > self__.end)) && ((self__.step === (0))))){\nreturn self__.start;\n} else {\nthrow (new Error(\"Index out of bounds\"));\n}\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IIndexed$_nth$arity$3 = (function (rng,n,not_found){\nvar self__ = this;\nvar rng__$1 = this;\nif(((((0) <= n)) && ((n < rng__$1.cljs$core$ICounted$_count$arity$1(null))))){\nreturn (self__.start + (n * self__.step));\n} else {\nif(((((0) <= n)) && ((self__.start > self__.end)) && ((self__.step === (0))))){\nreturn self__.start;\n} else {\nreturn not_found;\n}\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.RangeIterator(self__.start,self__.end,self__.step));\n});\n\ncljs.core.Range.prototype.cljs$core$IMeta$_meta$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nreturn self__.meta;\n});\n\ncljs.core.Range.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn (new cljs.core.Range(self__.meta,self__.start,self__.end,self__.step,self__.chunk,self__.chunk_next,self__.__hash));\n});\n\ncljs.core.Range.prototype.cljs$core$INext$_next$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nif((self__.step > (0))){\nif(((self__.start + self__.step) < self__.end)){\nreturn (new cljs.core.Range(null,(self__.start + self__.step),self__.end,self__.step,null,null,null));\n} else {\nreturn null;\n}\n} else {\nif(((self__.start + self__.step) > self__.end)){\nreturn (new cljs.core.Range(null,(self__.start + self__.step),self__.end,self__.step,null,null,null));\n} else {\nreturn null;\n}\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ICounted$_count$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nvar G__2844 = ((self__.end - self__.start) / self__.step);\nreturn Math.ceil(G__2844);\n});\n\ncljs.core.Range.prototype.cljs$core$IHash$_hash$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nvar h__4243__auto__ = self__.__hash;\nif((!((h__4243__auto__ == null)))){\nreturn h__4243__auto__;\n} else {\nvar h__4243__auto____$1 = cljs.core.hash_ordered_coll(rng__$1);\nself__.__hash = h__4243__auto____$1;\n\nreturn h__4243__auto____$1;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (rng,other){\nvar self__ = this;\nvar rng__$1 = this;\nreturn cljs.core.equiv_sequential(rng__$1,other);\n});\n\ncljs.core.Range.prototype.cljs$core$IEmptyableCollection$_empty$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nreturn cljs.core.List.EMPTY;\n});\n\ncljs.core.Range.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (rng,f){\nvar self__ = this;\nvar rng__$1 = this;\nreturn cljs.core.ci_reduce.cljs$core$IFn$_invoke$arity$2(rng__$1,f);\n});\n\ncljs.core.Range.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (rng,f,init){\nvar self__ = this;\nvar rng__$1 = this;\nvar i = self__.start;\nvar ret = init;\nwhile(true){\nif((((self__.step > (0)))?(i < self__.end):(i > self__.end))){\nvar ret__$1 = (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(ret,i) : f.call(null,ret,i));\nif(cljs.core.reduced_QMARK_(ret__$1)){\nreturn cljs.core.deref(ret__$1);\n} else {\nvar G__2847 = (i + self__.step);\nvar G__2848 = ret__$1;\ni = G__2847;\nret = G__2848;\ncontinue;\n}\n} else {\nreturn ret;\n}\nbreak;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ISeq$_first$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nreturn self__.start;\n});\n\ncljs.core.Range.prototype.cljs$core$ISeq$_rest$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nvar s = rng__$1.cljs$core$INext$_next$arity$1(null);\nif((s == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn s;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nreturn rng__$1;\n});\n\ncljs.core.Range.prototype.cljs$core$IChunkedSeq$_chunked_first$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nrng__$1.forceChunk();\n\nreturn self__.chunk;\n});\n\ncljs.core.Range.prototype.cljs$core$IChunkedSeq$_chunked_rest$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nrng__$1.forceChunk();\n\nif((self__.chunk_next == null)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn self__.chunk_next;\n}\n});\n\ncljs.core.Range.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (rng,new_meta){\nvar self__ = this;\nvar rng__$1 = this;\nif((new_meta === self__.meta)){\nreturn rng__$1;\n} else {\nreturn (new cljs.core.Range(new_meta,self__.start,self__.end,self__.step,self__.chunk,self__.chunk_next,self__.__hash));\n}\n});\n\ncljs.core.Range.prototype.cljs$core$ICollection$_conj$arity$2 = (function (rng,o){\nvar self__ = this;\nvar rng__$1 = this;\nreturn cljs.core.cons(o,rng__$1);\n});\n\ncljs.core.Range.prototype.cljs$core$IChunkedNext$_chunked_next$arity$1 = (function (rng){\nvar self__ = this;\nvar rng__$1 = this;\nreturn cljs.core.seq(rng__$1.cljs$core$IChunkedSeq$_chunked_rest$arity$1(null));\n});\n\ncljs.core.Range.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"meta\",\"meta\",-1154898805,null),new cljs.core.Symbol(null,\"start\",\"start\",1285322546,null),new cljs.core.Symbol(null,\"end\",\"end\",1372345569,null),new cljs.core.Symbol(null,\"step\",\"step\",-1365547645,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"chunk\",\"chunk\",449371907,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"chunk-next\",\"chunk-next\",-547810434,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Range.cljs$lang$type = true;\n\ncljs.core.Range.cljs$lang$ctorStr = \"cljs.core/Range\";\n\ncljs.core.Range.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Range\");\n});\n\n/**\n * Positional factory function for cljs.core/Range.\n */\ncljs.core.__GT_Range = (function cljs$core$__GT_Range(meta,start,end,step,chunk,chunk_next,__hash){\nreturn (new cljs.core.Range(meta,start,end,step,chunk,chunk_next,__hash));\n});\n\nvar G__2849_2852 = cljs.core.Range.prototype;\nvar G__2850_2853 = cljs.core.ITER_SYMBOL;\nvar G__2851_2854 = ((function (G__2849_2852,G__2850_2853){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__2849_2852,G__2850_2853))\n;\ngoog.object.set(G__2849_2852,G__2850_2853,G__2851_2854);\n/**\n * Returns a lazy seq of nums from start (inclusive) to end\n * (exclusive), by step, where start defaults to 0, step to 1,\n * and end to infinity.\n */\ncljs.core.range = (function cljs$core$range(var_args){\nvar G__2856 = arguments.length;\nswitch (G__2856) {\ncase 0:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3((0),Number.MAX_VALUE,(1));\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$1 = (function (end){\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3((0),end,(1));\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$2 = (function (start,end){\nreturn cljs.core.range.cljs$core$IFn$_invoke$arity$3(start,end,(1));\n});\n\ncljs.core.range.cljs$core$IFn$_invoke$arity$3 = (function (start,end,step){\nif((step > (0))){\nif((end <= start)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn (new cljs.core.Range(null,start,end,step,null,null,null));\n}\n} else {\nif((step < (0))){\nif((end >= start)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn (new cljs.core.Range(null,start,end,step,null,null,null));\n}\n} else {\nif((end === start)){\nreturn cljs.core.List.EMPTY;\n} else {\nreturn cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(start);\n}\n\n}\n}\n});\n\ncljs.core.range.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns a lazy seq of every nth item in coll.  Returns a stateful\n *   transducer when no collection is provided.\n */\ncljs.core.take_nth = (function cljs$core$take_nth(var_args){\nvar G__2859 = arguments.length;\nswitch (G__2859) {\ncase 1:\nreturn cljs.core.take_nth.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.take_nth.cljs$core$IFn$_invoke$arity$1 = (function (n){\nif(typeof n === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? n)\"));\n}\n\nreturn (function (rf){\nvar ia = cljs.core.volatile_BANG_((-1));\nreturn ((function (ia){\nreturn (function() {\nvar G__2861 = null;\nvar G__2861__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__2861__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__2861__2 = (function (result,input){\nvar i = ia.cljs$core$IVolatile$_vreset_BANG_$arity$2(null,(ia.cljs$core$IDeref$_deref$arity$1(null) + (1)));\nif((cljs.core.rem(i,n) === (0))){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n} else {\nreturn result;\n}\n});\nG__2861 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__2861__0.call(this);\ncase 1:\nreturn G__2861__1.call(this,result);\ncase 2:\nreturn G__2861__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2861.cljs$core$IFn$_invoke$arity$0 = G__2861__0;\nG__2861.cljs$core$IFn$_invoke$arity$1 = G__2861__1;\nG__2861.cljs$core$IFn$_invoke$arity$2 = G__2861__2;\nreturn G__2861;\n})()\n;})(ia))\n});\n});\n\ncljs.core.take_nth.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nif(typeof n === 'number'){\n} else {\nthrow (new Error(\"Assert failed: (number? n)\"));\n}\n\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nreturn cljs.core.cons(cljs.core.first(s),cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2(n,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(n,s)));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.take_nth.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a vector of [(take-while pred coll) (drop-while pred coll)]\n */\ncljs.core.split_with = (function cljs$core$split_with(pred,coll){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(pred,coll),cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2(pred,coll)], null);\n});\n/**\n * Applies f to each value in coll, splitting it each time f returns a\n * new value.  Returns a lazy seq of partitions.  Returns a stateful\n * transducer when no collection is provided.\n */\ncljs.core.partition_by = (function cljs$core$partition_by(var_args){\nvar G__2864 = arguments.length;\nswitch (G__2864) {\ncase 1:\nreturn cljs.core.partition_by.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.partition_by.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function (rf){\nvar a = cljs.core.array_list();\nvar pa = cljs.core.volatile_BANG_(new cljs.core.Keyword(\"cljs.core\",\"none\",\"cljs.core/none\",926646439));\nreturn ((function (a,pa){\nreturn (function() {\nvar G__2866 = null;\nvar G__2866__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__2866__1 = (function (result){\nvar result__$1 = (cljs.core.truth_(a.isEmpty())?result:(function (){var v = cljs.core.vec(a.toArray());\na.clear();\n\nreturn cljs.core.unreduced((rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v)));\n})());\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result__$1) : rf.call(null,result__$1));\n});\nvar G__2866__2 = (function (result,input){\nvar pval = cljs.core.deref(pa);\nvar val = (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(input) : f.call(null,input));\ncljs.core.vreset_BANG_(pa,val);\n\nif(((cljs.core.keyword_identical_QMARK_(pval,new cljs.core.Keyword(\"cljs.core\",\"none\",\"cljs.core/none\",926646439))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(val,pval)))){\na.add(input);\n\nreturn result;\n} else {\nvar v = cljs.core.vec(a.toArray());\na.clear();\n\nvar ret = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,v) : rf.call(null,result,v));\nif(cljs.core.reduced_QMARK_(ret)){\n} else {\na.add(input);\n}\n\nreturn ret;\n}\n});\nG__2866 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__2866__0.call(this);\ncase 1:\nreturn G__2866__1.call(this,result);\ncase 2:\nreturn G__2866__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2866.cljs$core$IFn$_invoke$arity$0 = G__2866__0;\nG__2866.cljs$core$IFn$_invoke$arity$1 = G__2866__1;\nG__2866.cljs$core$IFn$_invoke$arity$2 = G__2866__2;\nreturn G__2866;\n})()\n;})(a,pa))\n});\n});\n\ncljs.core.partition_by.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nvar fst = cljs.core.first(s);\nvar fv = (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(fst) : f.call(null,fst));\nvar run = cljs.core.cons(fst,cljs.core.take_while.cljs$core$IFn$_invoke$arity$2(((function (fst,fv,s,temp__5720__auto__){\nreturn (function (p1__2862_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fv,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(p1__2862_SHARP_) : f.call(null,p1__2862_SHARP_)));\n});})(fst,fv,s,temp__5720__auto__))\n,cljs.core.next(s)));\nreturn cljs.core.cons(run,cljs.core.partition_by.cljs$core$IFn$_invoke$arity$2(f,(new cljs.core.LazySeq(null,((function (fst,fv,run,s,temp__5720__auto__){\nreturn (function (){\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2(cljs.core.count(run),s);\n});})(fst,fv,run,s,temp__5720__auto__))\n,null,null))));\n} else {\nreturn null;\n}\n}),null,null));\n});\n\ncljs.core.partition_by.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a map from distinct items in coll to the number of times\n *   they appear.\n */\ncljs.core.frequencies = (function cljs$core$frequencies(coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (counts,x){\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(counts,x,(cljs.core.get.cljs$core$IFn$_invoke$arity$3(counts,x,(0)) + (1)));\n}),cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY),coll));\n});\n/**\n * Returns a lazy seq of the intermediate values of the reduction (as\n *   per reduce) of coll by f, starting with init.\n */\ncljs.core.reductions = (function cljs$core$reductions(var_args){\nvar G__2868 = arguments.length;\nswitch (G__2868) {\ncase 2:\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.reductions.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar temp__5718__auto__ = cljs.core.seq(coll);\nif(temp__5718__auto__){\nvar s = temp__5718__auto__;\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(f,cljs.core.first(s),cljs.core.rest(s));\n} else {\nreturn (new cljs.core.List(null,(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),null,(1),null));\n}\n}),null,null));\n});\n\ncljs.core.reductions.cljs$core$IFn$_invoke$arity$3 = (function (f,init,coll){\nif(cljs.core.reduced_QMARK_(init)){\nreturn (new cljs.core.List(null,cljs.core.deref(init),null,(1),null));\n} else {\nreturn cljs.core.cons(init,(new cljs.core.LazySeq(null,(function (){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nreturn cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(f,(function (){var G__2869 = init;\nvar G__2870 = cljs.core.first(s);\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__2869,G__2870) : f.call(null,G__2869,G__2870));\n})(),cljs.core.rest(s));\n} else {\nreturn null;\n}\n}),null,null)));\n}\n});\n\ncljs.core.reductions.cljs$lang$maxFixedArity = 3;\n\n/**\n * Takes a set of functions and returns a fn that is the juxtaposition\n *   of those fns.  The returned fn takes a variable number of args, and\n *   returns a vector containing the result of applying each fn to the\n *   args (left-to-right).\n *   ((juxt a b c) x) => [(a x) (b x) (c x)]\n */\ncljs.core.juxt = (function cljs$core$juxt(var_args){\nvar G__2887 = arguments.length;\nswitch (G__2887) {\ncase 1:\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___2889 = arguments.length;\nvar i__4731__auto___2890 = (0);\nwhile(true){\nif((i__4731__auto___2890 < len__4730__auto___2889)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___2890]));\n\nvar G__2891 = (i__4731__auto___2890 + (1));\ni__4731__auto___2890 = G__2891;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((3)),(0),null));\nreturn cljs.core.juxt.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn (function() {\nvar G__2892 = null;\nvar G__2892__0 = (function (){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null))],null));\n});\nvar G__2892__1 = (function (x){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x))],null));\n});\nvar G__2892__2 = (function (x,y){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y))],null));\n});\nvar G__2892__3 = (function (x,y,z){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(x,y,z) : f.call(null,x,y,z))],null));\n});\nvar G__2892__4 = (function() { \nvar G__2893__delegate = function (x,y,z,args){\nreturn (new cljs.core.PersistentVector(null,1,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,x,y,z,args)],null));\n};\nvar G__2893 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__2894__i = 0, G__2894__a = new Array(arguments.length -  3);\nwhile (G__2894__i < G__2894__a.length) {G__2894__a[G__2894__i] = arguments[G__2894__i + 3]; ++G__2894__i;}\n  args = new cljs.core.IndexedSeq(G__2894__a,0,null);\n} \nreturn G__2893__delegate.call(this,x,y,z,args);};\nG__2893.cljs$lang$maxFixedArity = 3;\nG__2893.cljs$lang$applyTo = (function (arglist__2895){\nvar x = cljs.core.first(arglist__2895);\narglist__2895 = cljs.core.next(arglist__2895);\nvar y = cljs.core.first(arglist__2895);\narglist__2895 = cljs.core.next(arglist__2895);\nvar z = cljs.core.first(arglist__2895);\nvar args = cljs.core.rest(arglist__2895);\nreturn G__2893__delegate(x,y,z,args);\n});\nG__2893.cljs$core$IFn$_invoke$arity$variadic = G__2893__delegate;\nreturn G__2893;\n})()\n;\nG__2892 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__2892__0.call(this);\ncase 1:\nreturn G__2892__1.call(this,x);\ncase 2:\nreturn G__2892__2.call(this,x,y);\ncase 3:\nreturn G__2892__3.call(this,x,y,z);\ndefault:\nvar G__2896 = null;\nif (arguments.length > 3) {\nvar G__2897__i = 0, G__2897__a = new Array(arguments.length -  3);\nwhile (G__2897__i < G__2897__a.length) {G__2897__a[G__2897__i] = arguments[G__2897__i + 3]; ++G__2897__i;}\nG__2896 = new cljs.core.IndexedSeq(G__2897__a,0,null);\n}\nreturn G__2892__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__2896);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2892.cljs$lang$maxFixedArity = 3;\nG__2892.cljs$lang$applyTo = G__2892__4.cljs$lang$applyTo;\nG__2892.cljs$core$IFn$_invoke$arity$0 = G__2892__0;\nG__2892.cljs$core$IFn$_invoke$arity$1 = G__2892__1;\nG__2892.cljs$core$IFn$_invoke$arity$2 = G__2892__2;\nG__2892.cljs$core$IFn$_invoke$arity$3 = G__2892__3;\nG__2892.cljs$core$IFn$_invoke$arity$variadic = G__2892__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__2892;\n})()\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$2 = (function (f,g){\nreturn (function() {\nvar G__2898 = null;\nvar G__2898__0 = (function (){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),(g.cljs$core$IFn$_invoke$arity$0 ? g.cljs$core$IFn$_invoke$arity$0() : g.call(null))],null));\n});\nvar G__2898__1 = (function (x){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x)),(g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(x) : g.call(null,x))],null));\n});\nvar G__2898__2 = (function (x,y){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y)),(g.cljs$core$IFn$_invoke$arity$2 ? g.cljs$core$IFn$_invoke$arity$2(x,y) : g.call(null,x,y))],null));\n});\nvar G__2898__3 = (function (x,y,z){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(x,y,z) : f.call(null,x,y,z)),(g.cljs$core$IFn$_invoke$arity$3 ? g.cljs$core$IFn$_invoke$arity$3(x,y,z) : g.call(null,x,y,z))],null));\n});\nvar G__2898__4 = (function() { \nvar G__2899__delegate = function (x,y,z,args){\nreturn (new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,x,y,z,args),cljs.core.apply.cljs$core$IFn$_invoke$arity$5(g,x,y,z,args)],null));\n};\nvar G__2899 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__2900__i = 0, G__2900__a = new Array(arguments.length -  3);\nwhile (G__2900__i < G__2900__a.length) {G__2900__a[G__2900__i] = arguments[G__2900__i + 3]; ++G__2900__i;}\n  args = new cljs.core.IndexedSeq(G__2900__a,0,null);\n} \nreturn G__2899__delegate.call(this,x,y,z,args);};\nG__2899.cljs$lang$maxFixedArity = 3;\nG__2899.cljs$lang$applyTo = (function (arglist__2901){\nvar x = cljs.core.first(arglist__2901);\narglist__2901 = cljs.core.next(arglist__2901);\nvar y = cljs.core.first(arglist__2901);\narglist__2901 = cljs.core.next(arglist__2901);\nvar z = cljs.core.first(arglist__2901);\nvar args = cljs.core.rest(arglist__2901);\nreturn G__2899__delegate(x,y,z,args);\n});\nG__2899.cljs$core$IFn$_invoke$arity$variadic = G__2899__delegate;\nreturn G__2899;\n})()\n;\nG__2898 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__2898__0.call(this);\ncase 1:\nreturn G__2898__1.call(this,x);\ncase 2:\nreturn G__2898__2.call(this,x,y);\ncase 3:\nreturn G__2898__3.call(this,x,y,z);\ndefault:\nvar G__2902 = null;\nif (arguments.length > 3) {\nvar G__2903__i = 0, G__2903__a = new Array(arguments.length -  3);\nwhile (G__2903__i < G__2903__a.length) {G__2903__a[G__2903__i] = arguments[G__2903__i + 3]; ++G__2903__i;}\nG__2902 = new cljs.core.IndexedSeq(G__2903__a,0,null);\n}\nreturn G__2898__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__2902);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2898.cljs$lang$maxFixedArity = 3;\nG__2898.cljs$lang$applyTo = G__2898__4.cljs$lang$applyTo;\nG__2898.cljs$core$IFn$_invoke$arity$0 = G__2898__0;\nG__2898.cljs$core$IFn$_invoke$arity$1 = G__2898__1;\nG__2898.cljs$core$IFn$_invoke$arity$2 = G__2898__2;\nG__2898.cljs$core$IFn$_invoke$arity$3 = G__2898__3;\nG__2898.cljs$core$IFn$_invoke$arity$variadic = G__2898__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__2898;\n})()\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$3 = (function (f,g,h){\nreturn (function() {\nvar G__2904 = null;\nvar G__2904__0 = (function (){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)),(g.cljs$core$IFn$_invoke$arity$0 ? g.cljs$core$IFn$_invoke$arity$0() : g.call(null)),(h.cljs$core$IFn$_invoke$arity$0 ? h.cljs$core$IFn$_invoke$arity$0() : h.call(null))],null));\n});\nvar G__2904__1 = (function (x){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x)),(g.cljs$core$IFn$_invoke$arity$1 ? g.cljs$core$IFn$_invoke$arity$1(x) : g.call(null,x)),(h.cljs$core$IFn$_invoke$arity$1 ? h.cljs$core$IFn$_invoke$arity$1(x) : h.call(null,x))],null));\n});\nvar G__2904__2 = (function (x,y){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(x,y) : f.call(null,x,y)),(g.cljs$core$IFn$_invoke$arity$2 ? g.cljs$core$IFn$_invoke$arity$2(x,y) : g.call(null,x,y)),(h.cljs$core$IFn$_invoke$arity$2 ? h.cljs$core$IFn$_invoke$arity$2(x,y) : h.call(null,x,y))],null));\n});\nvar G__2904__3 = (function (x,y,z){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[(f.cljs$core$IFn$_invoke$arity$3 ? f.cljs$core$IFn$_invoke$arity$3(x,y,z) : f.call(null,x,y,z)),(g.cljs$core$IFn$_invoke$arity$3 ? g.cljs$core$IFn$_invoke$arity$3(x,y,z) : g.call(null,x,y,z)),(h.cljs$core$IFn$_invoke$arity$3 ? h.cljs$core$IFn$_invoke$arity$3(x,y,z) : h.call(null,x,y,z))],null));\n});\nvar G__2904__4 = (function() { \nvar G__2905__delegate = function (x,y,z,args){\nreturn (new cljs.core.PersistentVector(null,3,(5),cljs.core.PersistentVector.EMPTY_NODE,[cljs.core.apply.cljs$core$IFn$_invoke$arity$5(f,x,y,z,args),cljs.core.apply.cljs$core$IFn$_invoke$arity$5(g,x,y,z,args),cljs.core.apply.cljs$core$IFn$_invoke$arity$5(h,x,y,z,args)],null));\n};\nvar G__2905 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__2906__i = 0, G__2906__a = new Array(arguments.length -  3);\nwhile (G__2906__i < G__2906__a.length) {G__2906__a[G__2906__i] = arguments[G__2906__i + 3]; ++G__2906__i;}\n  args = new cljs.core.IndexedSeq(G__2906__a,0,null);\n} \nreturn G__2905__delegate.call(this,x,y,z,args);};\nG__2905.cljs$lang$maxFixedArity = 3;\nG__2905.cljs$lang$applyTo = (function (arglist__2907){\nvar x = cljs.core.first(arglist__2907);\narglist__2907 = cljs.core.next(arglist__2907);\nvar y = cljs.core.first(arglist__2907);\narglist__2907 = cljs.core.next(arglist__2907);\nvar z = cljs.core.first(arglist__2907);\nvar args = cljs.core.rest(arglist__2907);\nreturn G__2905__delegate(x,y,z,args);\n});\nG__2905.cljs$core$IFn$_invoke$arity$variadic = G__2905__delegate;\nreturn G__2905;\n})()\n;\nG__2904 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__2904__0.call(this);\ncase 1:\nreturn G__2904__1.call(this,x);\ncase 2:\nreturn G__2904__2.call(this,x,y);\ncase 3:\nreturn G__2904__3.call(this,x,y,z);\ndefault:\nvar G__2908 = null;\nif (arguments.length > 3) {\nvar G__2909__i = 0, G__2909__a = new Array(arguments.length -  3);\nwhile (G__2909__i < G__2909__a.length) {G__2909__a[G__2909__i] = arguments[G__2909__i + 3]; ++G__2909__i;}\nG__2908 = new cljs.core.IndexedSeq(G__2909__a,0,null);\n}\nreturn G__2904__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__2908);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2904.cljs$lang$maxFixedArity = 3;\nG__2904.cljs$lang$applyTo = G__2904__4.cljs$lang$applyTo;\nG__2904.cljs$core$IFn$_invoke$arity$0 = G__2904__0;\nG__2904.cljs$core$IFn$_invoke$arity$1 = G__2904__1;\nG__2904.cljs$core$IFn$_invoke$arity$2 = G__2904__2;\nG__2904.cljs$core$IFn$_invoke$arity$3 = G__2904__3;\nG__2904.cljs$core$IFn$_invoke$arity$variadic = G__2904__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__2904;\n})()\n});\n\ncljs.core.juxt.cljs$core$IFn$_invoke$arity$variadic = (function (f,g,h,fs){\nvar fs__$1 = cljs.core.list_STAR_.cljs$core$IFn$_invoke$arity$4(f,g,h,fs);\nreturn ((function (fs__$1){\nreturn (function() {\nvar G__2910 = null;\nvar G__2910__0 = (function (){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__2872_SHARP_,p2__2873_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__2872_SHARP_,(p2__2873_SHARP_.cljs$core$IFn$_invoke$arity$0 ? p2__2873_SHARP_.cljs$core$IFn$_invoke$arity$0() : p2__2873_SHARP_.call(null)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__2910__1 = (function (x){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__2874_SHARP_,p2__2875_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__2874_SHARP_,(p2__2875_SHARP_.cljs$core$IFn$_invoke$arity$1 ? p2__2875_SHARP_.cljs$core$IFn$_invoke$arity$1(x) : p2__2875_SHARP_.call(null,x)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__2910__2 = (function (x,y){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__2876_SHARP_,p2__2877_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__2876_SHARP_,(p2__2877_SHARP_.cljs$core$IFn$_invoke$arity$2 ? p2__2877_SHARP_.cljs$core$IFn$_invoke$arity$2(x,y) : p2__2877_SHARP_.call(null,x,y)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__2910__3 = (function (x,y,z){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__2878_SHARP_,p2__2879_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__2878_SHARP_,(p2__2879_SHARP_.cljs$core$IFn$_invoke$arity$3 ? p2__2879_SHARP_.cljs$core$IFn$_invoke$arity$3(x,y,z) : p2__2879_SHARP_.call(null,x,y,z)));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n});\nvar G__2910__4 = (function() { \nvar G__2911__delegate = function (x,y,z,args){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (fs__$1){\nreturn (function (p1__2880_SHARP_,p2__2881_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__2880_SHARP_,cljs.core.apply.cljs$core$IFn$_invoke$arity$5(p2__2881_SHARP_,x,y,z,args));\n});})(fs__$1))\n,cljs.core.PersistentVector.EMPTY,fs__$1);\n};\nvar G__2911 = function (x,y,z,var_args){\nvar args = null;\nif (arguments.length > 3) {\nvar G__2912__i = 0, G__2912__a = new Array(arguments.length -  3);\nwhile (G__2912__i < G__2912__a.length) {G__2912__a[G__2912__i] = arguments[G__2912__i + 3]; ++G__2912__i;}\n  args = new cljs.core.IndexedSeq(G__2912__a,0,null);\n} \nreturn G__2911__delegate.call(this,x,y,z,args);};\nG__2911.cljs$lang$maxFixedArity = 3;\nG__2911.cljs$lang$applyTo = (function (arglist__2913){\nvar x = cljs.core.first(arglist__2913);\narglist__2913 = cljs.core.next(arglist__2913);\nvar y = cljs.core.first(arglist__2913);\narglist__2913 = cljs.core.next(arglist__2913);\nvar z = cljs.core.first(arglist__2913);\nvar args = cljs.core.rest(arglist__2913);\nreturn G__2911__delegate(x,y,z,args);\n});\nG__2911.cljs$core$IFn$_invoke$arity$variadic = G__2911__delegate;\nreturn G__2911;\n})()\n;\nG__2910 = function(x,y,z,var_args){\nvar args = var_args;\nswitch(arguments.length){\ncase 0:\nreturn G__2910__0.call(this);\ncase 1:\nreturn G__2910__1.call(this,x);\ncase 2:\nreturn G__2910__2.call(this,x,y);\ncase 3:\nreturn G__2910__3.call(this,x,y,z);\ndefault:\nvar G__2914 = null;\nif (arguments.length > 3) {\nvar G__2915__i = 0, G__2915__a = new Array(arguments.length -  3);\nwhile (G__2915__i < G__2915__a.length) {G__2915__a[G__2915__i] = arguments[G__2915__i + 3]; ++G__2915__i;}\nG__2914 = new cljs.core.IndexedSeq(G__2915__a,0,null);\n}\nreturn G__2910__4.cljs$core$IFn$_invoke$arity$variadic(x,y,z, G__2914);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__2910.cljs$lang$maxFixedArity = 3;\nG__2910.cljs$lang$applyTo = G__2910__4.cljs$lang$applyTo;\nG__2910.cljs$core$IFn$_invoke$arity$0 = G__2910__0;\nG__2910.cljs$core$IFn$_invoke$arity$1 = G__2910__1;\nG__2910.cljs$core$IFn$_invoke$arity$2 = G__2910__2;\nG__2910.cljs$core$IFn$_invoke$arity$3 = G__2910__3;\nG__2910.cljs$core$IFn$_invoke$arity$variadic = G__2910__4.cljs$core$IFn$_invoke$arity$variadic;\nreturn G__2910;\n})()\n;})(fs__$1))\n});\n\n/** @this {Function} */\ncljs.core.juxt.cljs$lang$applyTo = (function (seq2883){\nvar G__2884 = cljs.core.first(seq2883);\nvar seq2883__$1 = cljs.core.next(seq2883);\nvar G__2885 = cljs.core.first(seq2883__$1);\nvar seq2883__$2 = cljs.core.next(seq2883__$1);\nvar G__2886 = cljs.core.first(seq2883__$2);\nvar seq2883__$3 = cljs.core.next(seq2883__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2884,G__2885,G__2886,seq2883__$3);\n});\n\ncljs.core.juxt.cljs$lang$maxFixedArity = (3);\n\n/**\n * When lazy sequences are produced via functions that have side\n *   effects, any effects other than those needed to produce the first\n *   element in the seq do not occur until the seq is consumed. dorun can\n *   be used to force any effects. Walks through the successive nexts of\n *   the seq, does not retain the head and returns nil.\n */\ncljs.core.dorun = (function cljs$core$dorun(var_args){\nvar G__2917 = arguments.length;\nswitch (G__2917) {\ncase 1:\nreturn cljs.core.dorun.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.dorun.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nwhile(true){\nvar temp__5720__auto__ = cljs.core.seq(coll);\nif(temp__5720__auto__){\nvar s = temp__5720__auto__;\nvar G__2919 = cljs.core.next(s);\ncoll = G__2919;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n});\n\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\nwhile(true){\nif(((cljs.core.seq(coll)) && ((n > (0))))){\nvar G__2920 = (n - (1));\nvar G__2921 = cljs.core.next(coll);\nn = G__2920;\ncoll = G__2921;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n});\n\ncljs.core.dorun.cljs$lang$maxFixedArity = 2;\n\n/**\n * When lazy sequences are produced via functions that have side\n *   effects, any effects other than those needed to produce the first\n *   element in the seq do not occur until the seq is consumed. doall can\n *   be used to force any effects. Walks through the successive nexts of\n *   the seq, retains the head and returns it, thus causing the entire\n *   seq to reside in memory at one time.\n */\ncljs.core.doall = (function cljs$core$doall(var_args){\nvar G__2923 = arguments.length;\nswitch (G__2923) {\ncase 1:\nreturn cljs.core.doall.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.doall.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.doall.cljs$core$IFn$_invoke$arity$1 = (function (coll){\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$1(coll);\n\nreturn coll;\n});\n\ncljs.core.doall.cljs$core$IFn$_invoke$arity$2 = (function (n,coll){\ncljs.core.dorun.cljs$core$IFn$_invoke$arity$2(n,coll);\n\nreturn coll;\n});\n\ncljs.core.doall.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns true if x is a JavaScript RegExp instance.\n */\ncljs.core.regexp_QMARK_ = (function cljs$core$regexp_QMARK_(x){\nreturn (x instanceof RegExp);\n});\n/**\n * Returns the result of (re-find re s) if re fully matches s.\n */\ncljs.core.re_matches = (function cljs$core$re_matches(re,s){\nif(typeof s === 'string'){\nvar matches = re.exec(s);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(matches),s)){\nif((cljs.core.count(matches) === (1))){\nreturn cljs.core.first(matches);\n} else {\nreturn cljs.core.vec(matches);\n}\n} else {\nreturn null;\n}\n} else {\nthrow (new TypeError(\"re-matches must match against a string.\"));\n}\n});\n/**\n * Returns the first regex match, if any, of s to re, using\n *   re.exec(s). Returns a vector, containing first the matching\n *   substring, then any capturing groups if the regular expression contains\n *   capturing groups.\n */\ncljs.core.re_find = (function cljs$core$re_find(re,s){\nif(typeof s === 'string'){\nvar matches = re.exec(s);\nif((matches == null)){\nreturn null;\n} else {\nif((cljs.core.count(matches) === (1))){\nreturn cljs.core.first(matches);\n} else {\nreturn cljs.core.vec(matches);\n}\n}\n} else {\nthrow (new TypeError(\"re-find must match against a string.\"));\n}\n});\ncljs.core.re_seq_STAR_ = (function cljs$core$re_seq_STAR_(re,s){\nvar temp__5724__auto__ = re.exec(s);\nif((temp__5724__auto__ == null)){\nreturn null;\n} else {\nvar matches = temp__5724__auto__;\nvar match_str = (matches[(0)]);\nvar match_vals = (((matches.length === (1)))?match_str:cljs.core.vec(matches));\nreturn cljs.core.cons(match_vals,(new cljs.core.LazySeq(null,((function (match_str,match_vals,matches,temp__5724__auto__){\nreturn (function (){\nvar post_idx = (matches.index + (function (){var x__4219__auto__ = (1);\nvar y__4220__auto__ = match_str.length;\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})());\nif((post_idx <= s.length)){\nvar G__2925 = re;\nvar G__2926 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,post_idx);\nreturn (cljs.core.re_seq_STAR_.cljs$core$IFn$_invoke$arity$2 ? cljs.core.re_seq_STAR_.cljs$core$IFn$_invoke$arity$2(G__2925,G__2926) : cljs.core.re_seq_STAR_.call(null,G__2925,G__2926));\n} else {\nreturn null;\n}\n});})(match_str,match_vals,matches,temp__5724__auto__))\n,null,null)));\n}\n});\n/**\n * Returns a lazy sequence of successive matches of re in s.\n */\ncljs.core.re_seq = (function cljs$core$re_seq(re,s){\nif(typeof s === 'string'){\nreturn cljs.core.re_seq_STAR_(re,s);\n} else {\nthrow (new TypeError(\"re-seq must match against a string.\"));\n}\n});\n/**\n * Returns an instance of RegExp which has compiled the provided string.\n */\ncljs.core.re_pattern = (function cljs$core$re_pattern(s){\nif((s instanceof RegExp)){\nreturn s;\n} else {\nvar vec__2927 = cljs.core.re_find(/^\\(\\?([idmsux]*)\\)/,s);\nvar prefix = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2927,(0),null);\nvar flags = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__2927,(1),null);\nvar pattern = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,cljs.core.count(prefix));\nreturn (new RegExp(pattern,(function (){var or__4131__auto__ = flags;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn \"\";\n}\n})()));\n}\n});\ncljs.core.pr_sequential_writer = (function cljs$core$pr_sequential_writer(writer,print_one,begin,sep,end,opts,coll){\nvar _STAR_print_level_STAR__orig_val__2930 = cljs.core._STAR_print_level_STAR_;\nvar _STAR_print_level_STAR__temp_val__2931 = (((cljs.core._STAR_print_level_STAR_ == null))?null:(cljs.core._STAR_print_level_STAR_ - (1)));\ncljs.core._STAR_print_level_STAR_ = _STAR_print_level_STAR__temp_val__2931;\n\ntry{if((((!((cljs.core._STAR_print_level_STAR_ == null)))) && ((cljs.core._STAR_print_level_STAR_ < (0))))){\nreturn cljs.core._write(writer,\"#\");\n} else {\ncljs.core._write(writer,begin);\n\nif((new cljs.core.Keyword(null,\"print-length\",\"print-length\",1931866356).cljs$core$IFn$_invoke$arity$1(opts) === (0))){\nif(cljs.core.seq(coll)){\ncljs.core._write(writer,(function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"more-marker\",\"more-marker\",-14717935).cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn \"...\";\n}\n})());\n} else {\n}\n} else {\nif(cljs.core.seq(coll)){\nvar G__2932_2938 = cljs.core.first(coll);\nvar G__2933_2939 = writer;\nvar G__2934_2940 = opts;\n(print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__2932_2938,G__2933_2939,G__2934_2940) : print_one.call(null,G__2932_2938,G__2933_2939,G__2934_2940));\n} else {\n}\n\nvar coll_2941__$1 = cljs.core.next(coll);\nvar n_2942 = (new cljs.core.Keyword(null,\"print-length\",\"print-length\",1931866356).cljs$core$IFn$_invoke$arity$1(opts) - (1));\nwhile(true){\nif(((coll_2941__$1) && ((((n_2942 == null)) || ((!((n_2942 === (0))))))))){\ncljs.core._write(writer,sep);\n\nvar G__2935_2943 = cljs.core.first(coll_2941__$1);\nvar G__2936_2944 = writer;\nvar G__2937_2945 = opts;\n(print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__2935_2943,G__2936_2944,G__2937_2945) : print_one.call(null,G__2935_2943,G__2936_2944,G__2937_2945));\n\nvar G__2946 = cljs.core.next(coll_2941__$1);\nvar G__2947 = (n_2942 - (1));\ncoll_2941__$1 = G__2946;\nn_2942 = G__2947;\ncontinue;\n} else {\nif(((cljs.core.seq(coll_2941__$1)) && ((n_2942 === (0))))){\ncljs.core._write(writer,sep);\n\ncljs.core._write(writer,(function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"more-marker\",\"more-marker\",-14717935).cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn \"...\";\n}\n})());\n} else {\n}\n}\nbreak;\n}\n}\n\nreturn cljs.core._write(writer,end);\n}\n}finally {cljs.core._STAR_print_level_STAR_ = _STAR_print_level_STAR__orig_val__2930;\n}});\ncljs.core.write_all = (function cljs$core$write_all(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___2954 = arguments.length;\nvar i__4731__auto___2955 = (0);\nwhile(true){\nif((i__4731__auto___2955 < len__4730__auto___2954)){\nargs__4736__auto__.push((arguments[i__4731__auto___2955]));\n\nvar G__2956 = (i__4731__auto___2955 + (1));\ni__4731__auto___2955 = G__2956;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic = (function (writer,ss){\nvar seq__2950 = cljs.core.seq(ss);\nvar chunk__2951 = null;\nvar count__2952 = (0);\nvar i__2953 = (0);\nwhile(true){\nif((i__2953 < count__2952)){\nvar s = chunk__2951.cljs$core$IIndexed$_nth$arity$2(null,i__2953);\ncljs.core._write(writer,s);\n\n\nvar G__2957 = seq__2950;\nvar G__2958 = chunk__2951;\nvar G__2959 = count__2952;\nvar G__2960 = (i__2953 + (1));\nseq__2950 = G__2957;\nchunk__2951 = G__2958;\ncount__2952 = G__2959;\ni__2953 = G__2960;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2950);\nif(temp__5720__auto__){\nvar seq__2950__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2950__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2950__$1);\nvar G__2961 = cljs.core.chunk_rest(seq__2950__$1);\nvar G__2962 = c__4550__auto__;\nvar G__2963 = cljs.core.count(c__4550__auto__);\nvar G__2964 = (0);\nseq__2950 = G__2961;\nchunk__2951 = G__2962;\ncount__2952 = G__2963;\ni__2953 = G__2964;\ncontinue;\n} else {\nvar s = cljs.core.first(seq__2950__$1);\ncljs.core._write(writer,s);\n\n\nvar G__2965 = cljs.core.next(seq__2950__$1);\nvar G__2966 = null;\nvar G__2967 = (0);\nvar G__2968 = (0);\nseq__2950 = G__2965;\nchunk__2951 = G__2966;\ncount__2952 = G__2967;\ni__2953 = G__2968;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\n\ncljs.core.write_all.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\ncljs.core.write_all.cljs$lang$applyTo = (function (seq2948){\nvar G__2949 = cljs.core.first(seq2948);\nvar seq2948__$1 = cljs.core.next(seq2948);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__2949,seq2948__$1);\n});\n\ncljs.core.string_print = (function cljs$core$string_print(x){\nif((cljs.core._STAR_print_fn_STAR_ == null)){\nthrow (new Error(\"No *print-fn* fn set for evaluation environment\"));\n} else {\n}\n\n(cljs.core._STAR_print_fn_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_print_fn_STAR_.cljs$core$IFn$_invoke$arity$1(x) : cljs.core._STAR_print_fn_STAR_.call(null,x));\n\nreturn null;\n});\ncljs.core.flush = (function cljs$core$flush(){\nreturn null;\n});\ncljs.core.char_escapes = (function (){var obj2970 = ({\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",\"\\b\":\"\\\\b\",\"\\f\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\"});\nreturn obj2970;\n})();\ncljs.core.quote_string = (function cljs$core$quote_string(s){\nreturn [\"\\\"\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(s.replace(RegExp(\"[\\\\\\\\\\\"\\b\\f\\n\\r\\t]\",\"g\"),(function (match){\nreturn (cljs.core.char_escapes[match]);\n}))),\"\\\"\"].join('');\n});\ncljs.core.print_meta_QMARK_ = (function cljs$core$print_meta_QMARK_(opts,obj){\nvar and__4120__auto__ = cljs.core.boolean$(cljs.core.get.cljs$core$IFn$_invoke$arity$2(opts,new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964)));\nif(and__4120__auto__){\nvar and__4120__auto____$1 = (((!((obj == null))))?(((((obj.cljs$lang$protocol_mask$partition0$ & (131072))) || ((cljs.core.PROTOCOL_SENTINEL === obj.cljs$core$IMeta$))))?true:false):false);\nif(and__4120__auto____$1){\nreturn (!((cljs.core.meta(obj) == null)));\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n});\ncljs.core.pr_writer_impl = (function cljs$core$pr_writer_impl(obj,writer,opts){\nif((obj == null)){\nreturn cljs.core._write(writer,\"nil\");\n} else {\nif(cljs.core.print_meta_QMARK_(opts,obj)){\ncljs.core._write(writer,\"^\");\n\ncljs.core.pr_writer(cljs.core.meta(obj),writer,opts);\n\ncljs.core._write(writer,\" \");\n} else {\n}\n\nif(obj.cljs$lang$type){\nreturn obj.cljs$lang$ctorPrWriter(obj,writer,opts);\n} else {\nif((((!((obj == null))))?(((((obj.cljs$lang$protocol_mask$partition0$ & (2147483648))) || ((cljs.core.PROTOCOL_SENTINEL === obj.cljs$core$IPrintWithWriter$))))?true:(((!obj.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IPrintWithWriter,obj):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IPrintWithWriter,obj))){\nreturn cljs.core._pr_writer(obj,writer,opts);\n} else {\nif(((obj === true) || (obj === false))){\nreturn cljs.core._write(writer,cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj));\n} else {\nif(typeof obj === 'number'){\nreturn cljs.core._write(writer,((isNaN(obj))?\"##NaN\":(((obj === Number.POSITIVE_INFINITY))?\"##Inf\":(((obj === Number.NEGATIVE_INFINITY))?\"##-Inf\":cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj)\n))));\n} else {\nif(cljs.core.object_QMARK_(obj)){\ncljs.core._write(writer,\"#js \");\n\nreturn cljs.core.print_map(cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (k){\nreturn (new cljs.core.MapEntry((function (){var G__2975 = k;\nif((!((cljs.core.re_matches(/[A-Za-z_\\*\\+\\?!\\-'][\\w\\*\\+\\?!\\-']*/,k) == null)))){\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$1(G__2975);\n} else {\nreturn G__2975;\n}\n})(),(obj[k]),null));\n}),cljs.core.js_keys(obj)),cljs.core.pr_writer,writer,opts);\n} else {\nif(cljs.core.array_QMARK_(obj)){\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"#js [\",\" \",\"]\",opts,obj);\n} else {\nif(goog.isString(obj)){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"readably\",\"readably\",1129599760).cljs$core$IFn$_invoke$arity$1(opts))){\nreturn cljs.core._write(writer,cljs.core.quote_string(obj));\n} else {\nreturn cljs.core._write(writer,obj);\n}\n} else {\nif(goog.isFunction(obj)){\nvar name = obj.name;\nvar name__$1 = (cljs.core.truth_((function (){var or__4131__auto__ = (name == null);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.string.isEmpty(name);\n}\n})())?\"Function\":name);\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"#object[\",name__$1,((cljs.core._STAR_print_fn_bodies_STAR_)?[\" \\\"\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj),\"\\\"\"].join(''):\"\"),\"]\"], 0));\n} else {\nif((obj instanceof Date)){\nvar normalize = (function (n,len){\nvar ns = cljs.core.str.cljs$core$IFn$_invoke$arity$1(n);\nwhile(true){\nif((cljs.core.count(ns) < len)){\nvar G__2978 = [\"0\",ns].join('');\nns = G__2978;\ncontinue;\n} else {\nreturn ns;\n}\nbreak;\n}\n});\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"#inst \\\"\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj.getUTCFullYear()),\"-\",normalize((obj.getUTCMonth() + (1)),(2)),\"-\",normalize(obj.getUTCDate(),(2)),\"T\",normalize(obj.getUTCHours(),(2)),\":\",normalize(obj.getUTCMinutes(),(2)),\":\",normalize(obj.getUTCSeconds(),(2)),\".\",normalize(obj.getUTCMilliseconds(),(3)),\"-\",\"00:00\\\"\"], 0));\n} else {\nif(cljs.core.regexp_QMARK_(obj)){\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"#\\\"\",obj.source,\"\\\"\"], 0));\n} else {\nif(cljs.core.truth_((function (){var G__2976 = obj;\nvar G__2976__$1 = (((G__2976 == null))?null:G__2976.constructor);\nif((G__2976__$1 == null)){\nreturn null;\n} else {\nreturn G__2976__$1.cljs$lang$ctorStr;\n}\n})())){\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"#object[\",obj.constructor.cljs$lang$ctorStr.replace((new RegExp(\"/\",\"g\")),\".\"),\"]\"], 0));\n} else {\nvar name = (function (){var G__2977 = obj;\nvar G__2977__$1 = (((G__2977 == null))?null:G__2977.constructor);\nif((G__2977__$1 == null)){\nreturn null;\n} else {\nreturn G__2977__$1.name;\n}\n})();\nvar name__$1 = (cljs.core.truth_((function (){var or__4131__auto__ = (name == null);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nreturn goog.string.isEmpty(name);\n}\n})())?\"Object\":name);\nif((obj.constructor == null)){\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"#object[\",name__$1,\"]\"], 0));\n} else {\nreturn cljs.core.write_all.cljs$core$IFn$_invoke$arity$variadic(writer,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"#object[\",name__$1,\" \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(obj),\"]\"], 0));\n}\n}\n\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n}\n});\n/**\n * Prefer this to pr-seq, because it makes the printing function\n * configurable, allowing efficient implementations such as appending\n * to a StringBuffer.\n */\ncljs.core.pr_writer = (function cljs$core$pr_writer(obj,writer,opts){\nvar temp__5718__auto__ = new cljs.core.Keyword(null,\"alt-impl\",\"alt-impl\",670969595).cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar alt_impl = temp__5718__auto__;\nvar G__2979 = obj;\nvar G__2980 = writer;\nvar G__2981 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(opts,new cljs.core.Keyword(null,\"fallback-impl\",\"fallback-impl\",-1501286995),cljs.core.pr_writer_impl);\nreturn (alt_impl.cljs$core$IFn$_invoke$arity$3 ? alt_impl.cljs$core$IFn$_invoke$arity$3(G__2979,G__2980,G__2981) : alt_impl.call(null,G__2979,G__2980,G__2981));\n} else {\nreturn cljs.core.pr_writer_impl(obj,writer,opts);\n}\n});\ncljs.core.pr_seq_writer = (function cljs$core$pr_seq_writer(objs,writer,opts){\ncljs.core.pr_writer(cljs.core.first(objs),writer,opts);\n\nvar seq__2982 = cljs.core.seq(cljs.core.next(objs));\nvar chunk__2983 = null;\nvar count__2984 = (0);\nvar i__2985 = (0);\nwhile(true){\nif((i__2985 < count__2984)){\nvar obj = chunk__2983.cljs$core$IIndexed$_nth$arity$2(null,i__2985);\ncljs.core._write(writer,\" \");\n\ncljs.core.pr_writer(obj,writer,opts);\n\n\nvar G__2986 = seq__2982;\nvar G__2987 = chunk__2983;\nvar G__2988 = count__2984;\nvar G__2989 = (i__2985 + (1));\nseq__2982 = G__2986;\nchunk__2983 = G__2987;\ncount__2984 = G__2988;\ni__2985 = G__2989;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__2982);\nif(temp__5720__auto__){\nvar seq__2982__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__2982__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__2982__$1);\nvar G__2990 = cljs.core.chunk_rest(seq__2982__$1);\nvar G__2991 = c__4550__auto__;\nvar G__2992 = cljs.core.count(c__4550__auto__);\nvar G__2993 = (0);\nseq__2982 = G__2990;\nchunk__2983 = G__2991;\ncount__2984 = G__2992;\ni__2985 = G__2993;\ncontinue;\n} else {\nvar obj = cljs.core.first(seq__2982__$1);\ncljs.core._write(writer,\" \");\n\ncljs.core.pr_writer(obj,writer,opts);\n\n\nvar G__2994 = cljs.core.next(seq__2982__$1);\nvar G__2995 = null;\nvar G__2996 = (0);\nvar G__2997 = (0);\nseq__2982 = G__2994;\nchunk__2983 = G__2995;\ncount__2984 = G__2996;\ni__2985 = G__2997;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\ncljs.core.pr_sb_with_opts = (function cljs$core$pr_sb_with_opts(objs,opts){\nvar sb = (new goog.string.StringBuffer());\nvar writer = (new cljs.core.StringBufferWriter(sb));\ncljs.core.pr_seq_writer(objs,writer,opts);\n\nwriter.cljs$core$IWriter$_flush$arity$1(null);\n\nreturn sb;\n});\n/**\n * Prints a sequence of objects to a string, observing all the\n *   options given in opts\n */\ncljs.core.pr_str_with_opts = (function cljs$core$pr_str_with_opts(objs,opts){\nif(cljs.core.empty_QMARK_(objs)){\nreturn \"\";\n} else {\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.pr_sb_with_opts(objs,opts));\n}\n});\n/**\n * Same as pr-str-with-opts followed by (newline)\n */\ncljs.core.prn_str_with_opts = (function cljs$core$prn_str_with_opts(objs,opts){\nif(cljs.core.empty_QMARK_(objs)){\nreturn \"\\n\";\n} else {\nvar sb = cljs.core.pr_sb_with_opts(objs,opts);\nsb.append(\"\\n\");\n\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(sb);\n}\n});\n/**\n * Prints a sequence of objects using string-print, observing all\n *   the options given in opts\n */\ncljs.core.pr_with_opts = (function cljs$core$pr_with_opts(objs,opts){\nreturn cljs.core.string_print(cljs.core.pr_str_with_opts(objs,opts));\n});\n/**\n * Prints a newline using *print-fn*\n */\ncljs.core.newline = (function cljs$core$newline(var_args){\nvar G__2999 = arguments.length;\nswitch (G__2999) {\ncase 0:\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.newline.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1(null);\n});\n\ncljs.core.newline.cljs$core$IFn$_invoke$arity$1 = (function (opts){\ncljs.core.string_print(\"\\n\");\n\nif(cljs.core.truth_(cljs.core.get.cljs$core$IFn$_invoke$arity$2(opts,new cljs.core.Keyword(null,\"flush-on-newline\",\"flush-on-newline\",-151457939)))){\nreturn cljs.core.flush();\n} else {\nreturn null;\n}\n});\n\ncljs.core.newline.cljs$lang$maxFixedArity = 1;\n\n/**\n * pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.\n */\ncljs.core.pr_str = (function cljs$core$pr_str(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3002 = arguments.length;\nvar i__4731__auto___3003 = (0);\nwhile(true){\nif((i__4731__auto___3003 < len__4730__auto___3002)){\nargs__4736__auto__.push((arguments[i__4731__auto___3003]));\n\nvar G__3004 = (i__4731__auto___3003 + (1));\ni__4731__auto___3003 = G__3004;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\nreturn cljs.core.pr_str_with_opts(objs,cljs.core.pr_opts());\n});\n\ncljs.core.pr_str.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.pr_str.cljs$lang$applyTo = (function (seq3001){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3001));\n});\n\n/**\n * Same as pr-str followed by (newline)\n */\ncljs.core.prn_str = (function cljs$core$prn_str(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3006 = arguments.length;\nvar i__4731__auto___3007 = (0);\nwhile(true){\nif((i__4731__auto___3007 < len__4730__auto___3006)){\nargs__4736__auto__.push((arguments[i__4731__auto___3007]));\n\nvar G__3008 = (i__4731__auto___3007 + (1));\ni__4731__auto___3007 = G__3008;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.prn_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.prn_str.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\nreturn cljs.core.prn_str_with_opts(objs,cljs.core.pr_opts());\n});\n\ncljs.core.prn_str.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.prn_str.cljs$lang$applyTo = (function (seq3005){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3005));\n});\n\n/**\n * Prints the object(s) using string-print.  Prints the\n *   object(s), separated by spaces if there is more than one.\n *   By default, pr and prn print in a way that objects can be\n *   read by the reader\n */\ncljs.core.pr = (function cljs$core$pr(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3010 = arguments.length;\nvar i__4731__auto___3011 = (0);\nwhile(true){\nif((i__4731__auto___3011 < len__4730__auto___3010)){\nargs__4736__auto__.push((arguments[i__4731__auto___3011]));\n\nvar G__3012 = (i__4731__auto___3011 + (1));\ni__4731__auto___3011 = G__3012;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.pr.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.pr.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\nreturn cljs.core.pr_with_opts(objs,cljs.core.pr_opts());\n});\n\ncljs.core.pr.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.pr.cljs$lang$applyTo = (function (seq3009){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3009));\n});\n\n/**\n * Prints the object(s) using string-print.\n *   print and println produce output for human consumption.\n * @param {...*} var_args\n */\ncljs.core.print = (function() { \nvar cljs$core$cljs_core_print__delegate = function (objs){\nreturn cljs.core.pr_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),new cljs.core.Keyword(null,\"readably\",\"readably\",1129599760),false));\n};\nvar cljs$core$cljs_core_print = function (var_args){\nvar objs = null;\nif (arguments.length > 0) {\nvar G__3013__i = 0, G__3013__a = new Array(arguments.length -  0);\nwhile (G__3013__i < G__3013__a.length) {G__3013__a[G__3013__i] = arguments[G__3013__i + 0]; ++G__3013__i;}\n  objs = new cljs.core.IndexedSeq(G__3013__a,0,null);\n} \nreturn cljs$core$cljs_core_print__delegate.call(this,objs);};\ncljs$core$cljs_core_print.cljs$lang$maxFixedArity = 0;\ncljs$core$cljs_core_print.cljs$lang$applyTo = (function (arglist__3014){\nvar objs = cljs.core.seq(arglist__3014);\nreturn cljs$core$cljs_core_print__delegate(objs);\n});\ncljs$core$cljs_core_print.cljs$core$IFn$_invoke$arity$variadic = cljs$core$cljs_core_print__delegate;\nreturn cljs$core$cljs_core_print;\n})()\n;\n/**\n * print to a string, returning it\n */\ncljs.core.print_str = (function cljs$core$print_str(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3016 = arguments.length;\nvar i__4731__auto___3017 = (0);\nwhile(true){\nif((i__4731__auto___3017 < len__4730__auto___3016)){\nargs__4736__auto__.push((arguments[i__4731__auto___3017]));\n\nvar G__3018 = (i__4731__auto___3017 + (1));\ni__4731__auto___3017 = G__3018;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.print_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.print_str.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\nreturn cljs.core.pr_str_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),new cljs.core.Keyword(null,\"readably\",\"readably\",1129599760),false));\n});\n\ncljs.core.print_str.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.print_str.cljs$lang$applyTo = (function (seq3015){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3015));\n});\n\n/**\n * Same as print followed by (newline)\n */\ncljs.core.println = (function cljs$core$println(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3020 = arguments.length;\nvar i__4731__auto___3021 = (0);\nwhile(true){\nif((i__4731__auto___3021 < len__4730__auto___3020)){\nargs__4736__auto__.push((arguments[i__4731__auto___3021]));\n\nvar G__3022 = (i__4731__auto___3021 + (1));\ni__4731__auto___3021 = G__3022;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\ncljs.core.pr_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),new cljs.core.Keyword(null,\"readably\",\"readably\",1129599760),false));\n\nif(cljs.core._STAR_print_newline_STAR_){\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1(cljs.core.pr_opts());\n} else {\nreturn null;\n}\n});\n\ncljs.core.println.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.println.cljs$lang$applyTo = (function (seq3019){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3019));\n});\n\n/**\n * println to a string, returning it\n */\ncljs.core.println_str = (function cljs$core$println_str(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3024 = arguments.length;\nvar i__4731__auto___3025 = (0);\nwhile(true){\nif((i__4731__auto___3025 < len__4730__auto___3024)){\nargs__4736__auto__.push((arguments[i__4731__auto___3025]));\n\nvar G__3026 = (i__4731__auto___3025 + (1));\ni__4731__auto___3025 = G__3026;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.println_str.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.println_str.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\nreturn cljs.core.prn_str_with_opts(objs,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.pr_opts(),new cljs.core.Keyword(null,\"readably\",\"readably\",1129599760),false));\n});\n\ncljs.core.println_str.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.println_str.cljs$lang$applyTo = (function (seq3023){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3023));\n});\n\n/**\n * Same as pr followed by (newline).\n */\ncljs.core.prn = (function cljs$core$prn(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3028 = arguments.length;\nvar i__4731__auto___3029 = (0);\nwhile(true){\nif((i__4731__auto___3029 < len__4730__auto___3028)){\nargs__4736__auto__.push((arguments[i__4731__auto___3029]));\n\nvar G__3030 = (i__4731__auto___3029 + (1));\ni__4731__auto___3029 = G__3030;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic = (function (objs){\ncljs.core.pr_with_opts(objs,cljs.core.pr_opts());\n\nif(cljs.core._STAR_print_newline_STAR_){\nreturn cljs.core.newline.cljs$core$IFn$_invoke$arity$1(cljs.core.pr_opts());\n} else {\nreturn null;\n}\n});\n\ncljs.core.prn.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.prn.cljs$lang$applyTo = (function (seq3027){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3027));\n});\n\ncljs.core.strip_ns = (function cljs$core$strip_ns(named){\nif((named instanceof cljs.core.Symbol)){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(null,cljs.core.name(named));\n} else {\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$2(null,cljs.core.name(named));\n}\n});\n/**\n * Returns [lifted-ns lifted-map] or nil if m can't be lifted.\n */\ncljs.core.lift_ns = (function cljs$core$lift_ns(m){\nif(cljs.core._STAR_print_namespace_maps_STAR_){\nvar ns = null;\nvar G__3037 = cljs.core.seq(m);\nvar vec__3038 = G__3037;\nvar seq__3039 = cljs.core.seq(vec__3038);\nvar first__3040 = cljs.core.first(seq__3039);\nvar seq__3039__$1 = cljs.core.next(seq__3039);\nvar vec__3041 = first__3040;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3041,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3041,(1),null);\nvar entry = vec__3041;\nvar entries = seq__3039__$1;\nvar lm = cljs.core.empty(m);\nvar ns__$1 = ns;\nvar G__3037__$1 = G__3037;\nvar lm__$1 = lm;\nwhile(true){\nvar ns__$2 = ns__$1;\nvar vec__3050 = G__3037__$1;\nvar seq__3051 = cljs.core.seq(vec__3050);\nvar first__3052 = cljs.core.first(seq__3051);\nvar seq__3051__$1 = cljs.core.next(seq__3051);\nvar vec__3053 = first__3052;\nvar k__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3053,(0),null);\nvar v__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3053,(1),null);\nvar entry__$1 = vec__3053;\nvar entries__$1 = seq__3051__$1;\nvar lm__$2 = lm__$1;\nif(cljs.core.truth_(entry__$1)){\nif((((k__$1 instanceof cljs.core.Keyword)) || ((k__$1 instanceof cljs.core.Symbol)))){\nif(cljs.core.truth_(ns__$2)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ns__$2,cljs.core.namespace(k__$1))){\nvar G__3056 = ns__$2;\nvar G__3057 = entries__$1;\nvar G__3058 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(lm__$2,cljs.core.strip_ns(k__$1),v__$1);\nns__$1 = G__3056;\nG__3037__$1 = G__3057;\nlm__$1 = G__3058;\ncontinue;\n} else {\nreturn null;\n}\n} else {\nvar temp__5720__auto__ = cljs.core.namespace(k__$1);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar new_ns = temp__5720__auto__;\nvar G__3059 = new_ns;\nvar G__3060 = entries__$1;\nvar G__3061 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(lm__$2,cljs.core.strip_ns(k__$1),v__$1);\nns__$1 = G__3059;\nG__3037__$1 = G__3060;\nlm__$1 = G__3061;\ncontinue;\n} else {\nreturn null;\n}\n}\n} else {\nreturn null;\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns__$2,lm__$2], null);\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\ncljs.core.print_prefix_map = (function cljs$core$print_prefix_map(prefix,m,print_one,writer,opts){\nreturn cljs.core.pr_sequential_writer(writer,(function (e,w,opts__$1){\nvar G__3062_3068 = cljs.core.key(e);\nvar G__3063_3069 = w;\nvar G__3064_3070 = opts__$1;\n(print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__3062_3068,G__3063_3069,G__3064_3070) : print_one.call(null,G__3062_3068,G__3063_3069,G__3064_3070));\n\ncljs.core._write(w,\" \");\n\nvar G__3065 = cljs.core.val(e);\nvar G__3066 = w;\nvar G__3067 = opts__$1;\nreturn (print_one.cljs$core$IFn$_invoke$arity$3 ? print_one.cljs$core$IFn$_invoke$arity$3(G__3065,G__3066,G__3067) : print_one.call(null,G__3065,G__3066,G__3067));\n}),[cljs.core.str.cljs$core$IFn$_invoke$arity$1(prefix),\"{\"].join(''),\", \",\"}\",opts,cljs.core.seq(m));\n});\ncljs.core.print_map = (function cljs$core$print_map(m,print_one,writer,opts){\nvar vec__3071 = ((cljs.core.map_QMARK_(m))?cljs.core.lift_ns(m):null);\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3071,(0),null);\nvar lift_map = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3071,(1),null);\nif(cljs.core.truth_(ns)){\nreturn cljs.core.print_prefix_map([\"#:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns)].join(''),lift_map,print_one,writer,opts);\n} else {\nreturn cljs.core.print_prefix_map(null,m,print_one,writer,opts);\n}\n});\ncljs.core.Volatile.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Volatile.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (a,writer,opts){\nvar a__$1 = this;\ncljs.core._write(writer,\"#object[cljs.core.Volatile \");\n\ncljs.core.pr_writer(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"val\",\"val\",128701612),a__$1.state], null),writer,opts);\n\nreturn cljs.core._write(writer,\"]\");\n});\n\ncljs.core.Var.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Var.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (a,writer,opts){\nvar a__$1 = this;\ncljs.core._write(writer,\"#'\");\n\nreturn cljs.core.pr_writer(a__$1.sym,writer,opts);\n});\n\ncljs.core.IndexedSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.IndexedSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.LazySeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.LazySeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MapEntry.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,coll__$1);\n});\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeMapSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.NodeSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.NodeSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.BlackNode.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,coll__$1);\n});\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentArrayMapSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ES6IteratorSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeSet.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"#{\",\" \",\"}\",opts,coll__$1);\n});\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ChunkedSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.ObjMap.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ObjMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.Cons.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Cons.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.Iterate.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Iterate.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.RSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentHashMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ArrayNodeSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.Subvec.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Subvec.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,coll__$1);\n});\n\ncljs.core.Cycle.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Cycle.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentTreeMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentHashSet.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"#{\",\" \",\"}\",opts,coll__$1);\n});\n\ncljs.core.ChunkedCons.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ChunkedCons.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.Atom.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Atom.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (a,writer,opts){\nvar a__$1 = this;\ncljs.core._write(writer,\"#object[cljs.core.Atom \");\n\ncljs.core.pr_writer(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"val\",\"val\",128701612),a__$1.state], null),writer,opts);\n\nreturn cljs.core._write(writer,\"]\");\n});\n\ncljs.core.ValSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ValSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.RedNode.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RedNode.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,coll__$1);\n});\n\ncljs.core.Repeat.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Repeat.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"[\",\" \",\"]\",opts,coll__$1);\n});\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentQueueSeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.EmptyList.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.EmptyList.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core._write(writer,\"()\");\n});\n\ncljs.core.PersistentQueue.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentQueue.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"#queue [\",\" \",\"]\",opts,cljs.core.seq(coll__$1));\n});\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentArrayMap.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.print_map(coll__$1,cljs.core.pr_writer,writer,opts);\n});\n\ncljs.core.Range.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Range.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.TransformerIterator.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.TransformerIterator.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.KeySeq.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.KeySeq.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\n\ncljs.core.List.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.List.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll,writer,opts){\nvar coll__$1 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$1);\n});\ncljs.core.Symbol.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Symbol.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif((y instanceof cljs.core.Symbol)){\nreturn cljs.core.compare_symbols(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n\ncljs.core.Keyword.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Keyword.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif((y instanceof cljs.core.Keyword)){\nreturn cljs.core.compare_keywords(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n\ncljs.core.Subvec.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.Subvec.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n\ncljs.core.PersistentVector.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.PersistentVector.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n\ncljs.core.MapEntry.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.MapEntry.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n\ncljs.core.BlackNode.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.BlackNode.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n\ncljs.core.RedNode.prototype.cljs$core$IComparable$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.RedNode.prototype.cljs$core$IComparable$_compare$arity$2 = (function (x,y){\nvar x__$1 = this;\nif(cljs.core.vector_QMARK_(y)){\nreturn cljs.core.compare_indexed.cljs$core$IFn$_invoke$arity$2(x__$1,y);\n} else {\nthrow (new Error([\"Cannot compare \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1),\" to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(y)].join('')));\n}\n});\n/**\n * Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n * \n *   (apply f its-current-meta args)\n * \n *   f must be free of side-effects\n */\ncljs.core.alter_meta_BANG_ = (function cljs$core$alter_meta_BANG_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3077 = arguments.length;\nvar i__4731__auto___3078 = (0);\nwhile(true){\nif((i__4731__auto___3078 < len__4730__auto___3077)){\nargs__4736__auto__.push((arguments[i__4731__auto___3078]));\n\nvar G__3079 = (i__4731__auto___3078 + (1));\ni__4731__auto___3078 = G__3079;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((2) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((2)),(0),null)):null);\nreturn cljs.core.alter_meta_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4737__auto__);\n});\n\ncljs.core.alter_meta_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (iref,f,args){\nreturn iref.meta = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(f,iref.meta,args);\n});\n\ncljs.core.alter_meta_BANG_.cljs$lang$maxFixedArity = (2);\n\n/** @this {Function} */\ncljs.core.alter_meta_BANG_.cljs$lang$applyTo = (function (seq3074){\nvar G__3075 = cljs.core.first(seq3074);\nvar seq3074__$1 = cljs.core.next(seq3074);\nvar G__3076 = cljs.core.first(seq3074__$1);\nvar seq3074__$2 = cljs.core.next(seq3074__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__3075,G__3076,seq3074__$2);\n});\n\n/**\n * Atomically resets the metadata for an atom\n */\ncljs.core.reset_meta_BANG_ = (function cljs$core$reset_meta_BANG_(iref,m){\nreturn iref.meta = m;\n});\n/**\n * Adds a watch function to an atom reference. The watch fn must be a\n *   fn of 4 args: a key, the reference, its old-state, its\n *   new-state. Whenever the reference's state might have been changed,\n *   any registered watches will have their functions called. The watch\n *   fn will be called synchronously. Note that an atom's state\n *   may have changed again prior to the fn call, so use old/new-state\n *   rather than derefing the reference. Keys must be unique per\n *   reference, and can be used to remove the watch with remove-watch,\n *   but are otherwise considered opaque by the watch mechanism.  Bear in\n *   mind that regardless of the result or action of the watch fns the\n *   atom's value will change.  Example:\n * \n *    (def a (atom 0))\n *    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n *    (swap! a inc)\n *    ;; Assertion Error\n *    (deref a)\n *    ;=> 1\n */\ncljs.core.add_watch = (function cljs$core$add_watch(iref,key,f){\ncljs.core._add_watch(iref,key,f);\n\nreturn iref;\n});\n/**\n * Removes a watch (set by add-watch) from a reference\n */\ncljs.core.remove_watch = (function cljs$core$remove_watch(iref,key){\ncljs.core._remove_watch(iref,key);\n\nreturn iref;\n});\n/**\n * @type {*}\n */\ncljs.core.gensym_counter = null;\n/**\n * Returns a new symbol with a unique name. If a prefix string is\n *   supplied, the name is prefix# where # is some unique number. If\n *   prefix is not supplied, the prefix is 'G__'.\n */\ncljs.core.gensym = (function cljs$core$gensym(var_args){\nvar G__3081 = arguments.length;\nswitch (G__3081) {\ncase 0:\nreturn cljs.core.gensym.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.gensym.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.gensym.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.gensym.cljs$core$IFn$_invoke$arity$1(\"G__\");\n});\n\ncljs.core.gensym.cljs$core$IFn$_invoke$arity$1 = (function (prefix_string){\nif((cljs.core.gensym_counter == null)){\ncljs.core.gensym_counter = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0));\n} else {\n}\n\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1([cljs.core.str.cljs$core$IFn$_invoke$arity$1(prefix_string),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.gensym_counter,cljs.core.inc))].join(''));\n});\n\ncljs.core.gensym.cljs$lang$maxFixedArity = 1;\n\n\n/**\n* @constructor\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IPrintWithWriter}\n*/\ncljs.core.Delay = (function (f,value){\nthis.f = f;\nthis.value = value;\nthis.cljs$lang$protocol_mask$partition0$ = 2147516416;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\ncljs.core.Delay.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nif(cljs.core.truth_(self__.f)){\nself__.value = (self__.f.cljs$core$IFn$_invoke$arity$0 ? self__.f.cljs$core$IFn$_invoke$arity$0() : self__.f.call(null));\n\nself__.f = null;\n} else {\n}\n\nreturn self__.value;\n});\n\ncljs.core.Delay.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (x){\nvar self__ = this;\nvar x__$1 = this;\nreturn cljs.core.not(self__.f);\n});\n\ncljs.core.Delay.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (x,writer,opts){\nvar self__ = this;\nvar x__$1 = this;\ncljs.core._write(writer,\"#object[cljs.core.Delay \");\n\ncljs.core.pr_writer(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"status\",\"status\",-1997798413),(((self__.f == null))?new cljs.core.Keyword(null,\"ready\",\"ready\",1086465795):new cljs.core.Keyword(null,\"pending\",\"pending\",-220036727)),new cljs.core.Keyword(null,\"val\",\"val\",128701612),self__.value], null),writer,opts);\n\nreturn cljs.core._write(writer,\"]\");\n});\n\ncljs.core.Delay.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.with_meta(new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null)),cljs.core.with_meta(new cljs.core.Symbol(null,\"value\",\"value\",1946509744,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.Delay.cljs$lang$type = true;\n\ncljs.core.Delay.cljs$lang$ctorStr = \"cljs.core/Delay\";\n\ncljs.core.Delay.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Delay\");\n});\n\n/**\n * Positional factory function for cljs.core/Delay.\n */\ncljs.core.__GT_Delay = (function cljs$core$__GT_Delay(f,value){\nreturn (new cljs.core.Delay(f,value));\n});\n\n/**\n * returns true if x is a Delay created with delay\n */\ncljs.core.delay_QMARK_ = (function cljs$core$delay_QMARK_(x){\nreturn (x instanceof cljs.core.Delay);\n});\n/**\n * If x is a Delay, returns the (possibly cached) value of its expression, else returns x\n */\ncljs.core.force = (function cljs$core$force(x){\nif(cljs.core.delay_QMARK_(x)){\nreturn cljs.core.deref(x);\n} else {\nreturn x;\n}\n});\n/**\n * Returns true if a value has been produced for a delay or lazy sequence.\n */\ncljs.core.realized_QMARK_ = (function cljs$core$realized_QMARK_(x){\nreturn cljs.core._realized_QMARK_(x);\n});\ncljs.core.preserving_reduced = (function cljs$core$preserving_reduced(rf){\nreturn (function (p1__3083_SHARP_,p2__3084_SHARP_){\nvar ret = (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(p1__3083_SHARP_,p2__3084_SHARP_) : rf.call(null,p1__3083_SHARP_,p2__3084_SHARP_));\nif(cljs.core.reduced_QMARK_(ret)){\nreturn cljs.core.reduced(ret);\n} else {\nreturn ret;\n}\n});\n});\n/**\n * A transducer which concatenates the contents of each input, which must be a\n *   collection, into the reduction.\n */\ncljs.core.cat = (function cljs$core$cat(rf){\nvar rf1 = cljs.core.preserving_reduced(rf);\nreturn ((function (rf1){\nreturn (function() {\nvar G__3085 = null;\nvar G__3085__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__3085__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__3085__2 = (function (result,input){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(rf1,result,input);\n});\nG__3085 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__3085__0.call(this);\ncase 1:\nreturn G__3085__1.call(this,result);\ncase 2:\nreturn G__3085__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__3085.cljs$core$IFn$_invoke$arity$0 = G__3085__0;\nG__3085.cljs$core$IFn$_invoke$arity$1 = G__3085__1;\nG__3085.cljs$core$IFn$_invoke$arity$2 = G__3085__2;\nreturn G__3085;\n})()\n;})(rf1))\n});\n/**\n * Returns a transducer that ends transduction when pred returns true\n *   for an input. When retf is supplied it must be a fn of 2 arguments -\n *   it will be passed the (completed) result so far and the input that\n *   triggered the predicate, and its return value (if it does not throw\n *   an exception) will be the return value of the transducer. If retf\n *   is not supplied, the input that triggered the predicate will be\n *   returned. If the predicate never returns true the transduction is\n *   unaffected.\n */\ncljs.core.halt_when = (function cljs$core$halt_when(var_args){\nvar G__3087 = arguments.length;\nswitch (G__3087) {\ncase 1:\nreturn cljs.core.halt_when.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.halt_when.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.halt_when.cljs$core$IFn$_invoke$arity$1 = (function (pred){\nreturn cljs.core.halt_when.cljs$core$IFn$_invoke$arity$2(pred,null);\n});\n\ncljs.core.halt_when.cljs$core$IFn$_invoke$arity$2 = (function (pred,retf){\nreturn (function (rf){\nreturn (function() {\nvar G__3091 = null;\nvar G__3091__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__3091__1 = (function (result){\nif(((cljs.core.map_QMARK_(result)) && (cljs.core.contains_QMARK_(result,new cljs.core.Keyword(\"cljs.core\",\"halt\",\"cljs.core/halt\",-1049036715))))){\nreturn new cljs.core.Keyword(\"cljs.core\",\"halt\",\"cljs.core/halt\",-1049036715).cljs$core$IFn$_invoke$arity$1(result);\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n}\n});\nvar G__3091__2 = (function (result,input){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(input) : pred.call(null,input)))){\nreturn cljs.core.reduced(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"cljs.core\",\"halt\",\"cljs.core/halt\",-1049036715),(cljs.core.truth_(retf)?(function (){var G__3088 = (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\nvar G__3089 = input;\nreturn (retf.cljs$core$IFn$_invoke$arity$2 ? retf.cljs$core$IFn$_invoke$arity$2(G__3088,G__3089) : retf.call(null,G__3088,G__3089));\n})():input)], null));\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__3091 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__3091__0.call(this);\ncase 1:\nreturn G__3091__1.call(this,result);\ncase 2:\nreturn G__3091__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__3091.cljs$core$IFn$_invoke$arity$0 = G__3091__0;\nG__3091.cljs$core$IFn$_invoke$arity$1 = G__3091__1;\nG__3091.cljs$core$IFn$_invoke$arity$2 = G__3091__2;\nreturn G__3091;\n})()\n});\n});\n\ncljs.core.halt_when.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a lazy sequence removing consecutive duplicates in coll.\n *   Returns a transducer when no collection is provided.\n */\ncljs.core.dedupe = (function cljs$core$dedupe(var_args){\nvar G__3093 = arguments.length;\nswitch (G__3093) {\ncase 0:\nreturn cljs.core.dedupe.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.dedupe.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.dedupe.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (function (rf){\nvar pa = cljs.core.volatile_BANG_(new cljs.core.Keyword(\"cljs.core\",\"none\",\"cljs.core/none\",926646439));\nreturn ((function (pa){\nreturn (function() {\nvar G__3095 = null;\nvar G__3095__0 = (function (){\nreturn (rf.cljs$core$IFn$_invoke$arity$0 ? rf.cljs$core$IFn$_invoke$arity$0() : rf.call(null));\n});\nvar G__3095__1 = (function (result){\nreturn (rf.cljs$core$IFn$_invoke$arity$1 ? rf.cljs$core$IFn$_invoke$arity$1(result) : rf.call(null,result));\n});\nvar G__3095__2 = (function (result,input){\nvar prior = cljs.core.deref(pa);\ncljs.core.vreset_BANG_(pa,input);\n\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(prior,input)){\nreturn result;\n} else {\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(result,input) : rf.call(null,result,input));\n}\n});\nG__3095 = function(result,input){\nswitch(arguments.length){\ncase 0:\nreturn G__3095__0.call(this);\ncase 1:\nreturn G__3095__1.call(this,result);\ncase 2:\nreturn G__3095__2.call(this,result,input);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__3095.cljs$core$IFn$_invoke$arity$0 = G__3095__0;\nG__3095.cljs$core$IFn$_invoke$arity$1 = G__3095__1;\nG__3095.cljs$core$IFn$_invoke$arity$2 = G__3095__2;\nreturn G__3095;\n})()\n;})(pa))\n});\n});\n\ncljs.core.dedupe.cljs$core$IFn$_invoke$arity$1 = (function (coll){\nreturn cljs.core.sequence.cljs$core$IFn$_invoke$arity$2(cljs.core.dedupe.cljs$core$IFn$_invoke$arity$0(),coll);\n});\n\ncljs.core.dedupe.cljs$lang$maxFixedArity = 1;\n\n/**\n * Returns items from coll with random probability of prob (0.0 -\n *   1.0).  Returns a transducer when no collection is provided.\n */\ncljs.core.random_sample = (function cljs$core$random_sample(var_args){\nvar G__3097 = arguments.length;\nswitch (G__3097) {\ncase 1:\nreturn cljs.core.random_sample.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.random_sample.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.random_sample.cljs$core$IFn$_invoke$arity$1 = (function (prob){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$1((function (_){\nreturn (cljs.core.rand.cljs$core$IFn$_invoke$arity$0() < prob);\n}));\n});\n\ncljs.core.random_sample.cljs$core$IFn$_invoke$arity$2 = (function (prob,coll){\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (_){\nreturn (cljs.core.rand.cljs$core$IFn$_invoke$arity$0() < prob);\n}),coll);\n});\n\ncljs.core.random_sample.cljs$lang$maxFixedArity = 2;\n\n\n/**\n* @constructor\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.ISequential}\n * @implements {cljs.core.IReduce}\n*/\ncljs.core.Eduction = (function (xform,coll){\nthis.xform = xform;\nthis.coll = coll;\nthis.cljs$lang$protocol_mask$partition0$ = 2173173760;\nthis.cljs$lang$protocol_mask$partition1$ = 131072;\n});\ncljs.core.Eduction.prototype.indexOf = (function() {\nvar G__3099 = null;\nvar G__3099__1 = (function (x){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,(0));\n});\nvar G__3099__2 = (function (x,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._indexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,start);\n});\nG__3099 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__3099__1.call(this,x);\ncase 2:\nreturn G__3099__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__3099.cljs$core$IFn$_invoke$arity$1 = G__3099__1;\nG__3099.cljs$core$IFn$_invoke$arity$2 = G__3099__2;\nreturn G__3099;\n})()\n;\n\ncljs.core.Eduction.prototype.lastIndexOf = (function() {\nvar G__3100 = null;\nvar G__3100__1 = (function (x){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,cljs.core.count(coll__$1));\n});\nvar G__3100__2 = (function (x,start){\nvar self__ = this;\nvar coll__$1 = this;\nreturn cljs.core._lastIndexOf.cljs$core$IFn$_invoke$arity$3(coll__$1,x,start);\n});\nG__3100 = function(x,start){\nswitch(arguments.length){\ncase 1:\nreturn G__3100__1.call(this,x);\ncase 2:\nreturn G__3100__2.call(this,x,start);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__3100.cljs$core$IFn$_invoke$arity$1 = G__3100__1;\nG__3100.cljs$core$IFn$_invoke$arity$2 = G__3100__2;\nreturn G__3100;\n})()\n;\n\ncljs.core.Eduction.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.TransformerIterator.create(self__.xform,cljs.core.iter(self__.coll));\n});\n\ncljs.core.Eduction.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.seq(cljs.core.sequence.cljs$core$IFn$_invoke$arity$2(self__.xform,self__.coll));\n});\n\ncljs.core.Eduction.prototype.cljs$core$IReduce$_reduce$arity$2 = (function (_,f){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$3(self__.xform,cljs.core.completing.cljs$core$IFn$_invoke$arity$1(f),self__.coll);\n});\n\ncljs.core.Eduction.prototype.cljs$core$IReduce$_reduce$arity$3 = (function (_,f,init){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.transduce.cljs$core$IFn$_invoke$arity$4(self__.xform,cljs.core.completing.cljs$core$IFn$_invoke$arity$1(f),init,self__.coll);\n});\n\ncljs.core.Eduction.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (coll__$1,writer,opts){\nvar self__ = this;\nvar coll__$2 = this;\nreturn cljs.core.pr_sequential_writer(writer,cljs.core.pr_writer,\"(\",\" \",\")\",opts,coll__$2);\n});\n\ncljs.core.Eduction.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"xform\",\"xform\",-85179481,null),new cljs.core.Symbol(null,\"coll\",\"coll\",-1006698606,null)], null);\n});\n\ncljs.core.Eduction.cljs$lang$type = true;\n\ncljs.core.Eduction.cljs$lang$ctorStr = \"cljs.core/Eduction\";\n\ncljs.core.Eduction.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Eduction\");\n});\n\n/**\n * Positional factory function for cljs.core/Eduction.\n */\ncljs.core.__GT_Eduction = (function cljs$core$__GT_Eduction(xform,coll){\nreturn (new cljs.core.Eduction(xform,coll));\n});\n\nvar G__3101_3104 = cljs.core.Eduction.prototype;\nvar G__3102_3105 = cljs.core.ITER_SYMBOL;\nvar G__3103_3106 = ((function (G__3101_3104,G__3102_3105){\nreturn (function (){\nvar this__4669__auto__ = this;\nreturn cljs.core.es6_iterator(this__4669__auto__);\n});})(G__3101_3104,G__3102_3105))\n;\ngoog.object.set(G__3101_3104,G__3102_3105,G__3103_3106);\n/**\n * Returns a reducible/iterable application of the transducers\n *   to the items in coll. Transducers are applied in order as if\n *   combined with comp. Note that these applications will be\n *   performed every time reduce/iterator is called.\n */\ncljs.core.eduction = (function cljs$core$eduction(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3108 = arguments.length;\nvar i__4731__auto___3109 = (0);\nwhile(true){\nif((i__4731__auto___3109 < len__4730__auto___3108)){\nargs__4736__auto__.push((arguments[i__4731__auto___3109]));\n\nvar G__3110 = (i__4731__auto___3109 + (1));\ni__4731__auto___3109 = G__3110;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn cljs.core.eduction.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\ncljs.core.eduction.cljs$core$IFn$_invoke$arity$variadic = (function (xforms){\nreturn (new cljs.core.Eduction(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.comp,cljs.core.butlast(xforms)),cljs.core.last(xforms)));\n});\n\ncljs.core.eduction.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\ncljs.core.eduction.cljs$lang$applyTo = (function (seq3107){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq3107));\n});\n\n/**\n * Runs the supplied procedure (via reduce), for purposes of side\n *   effects, on successive items in the collection. Returns nil\n */\ncljs.core.run_BANG_ = (function cljs$core$run_BANG_(proc,coll){\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__3112_SHARP_,p2__3111_SHARP_){\nreturn (proc.cljs$core$IFn$_invoke$arity$1 ? proc.cljs$core$IFn$_invoke$arity$1(p2__3111_SHARP_) : proc.call(null,p2__3111_SHARP_));\n}),null,coll);\n\nreturn null;\n});\n\n/**\n * @interface\n */\ncljs.core.IEncodeJS = function(){};\n\n/**\n * Recursively transforms clj values to JavaScript\n */\ncljs.core._clj__GT_js = (function cljs$core$_clj__GT_js(x){\nif((((!((x == null)))) && ((!((x.cljs$core$IEncodeJS$_clj__GT_js$arity$1 == null)))))){\nreturn x.cljs$core$IEncodeJS$_clj__GT_js$arity$1(x);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._clj__GT_js[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ = (cljs.core._clj__GT_js[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol(\"IEncodeJS.-clj->js\",x);\n}\n}\n}\n});\n\n/**\n * Transforms map keys to valid JavaScript keys. Arbitrary keys are\n *   encoded to their string representation via (pr-str x)\n */\ncljs.core._key__GT_js = (function cljs$core$_key__GT_js(x){\nif((((!((x == null)))) && ((!((x.cljs$core$IEncodeJS$_key__GT_js$arity$1 == null)))))){\nreturn x.cljs$core$IEncodeJS$_key__GT_js$arity$1(x);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._key__GT_js[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4434__auto__.call(null,x));\n} else {\nvar m__4431__auto__ = (cljs.core._key__GT_js[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(x) : m__4431__auto__.call(null,x));\n} else {\nthrow cljs.core.missing_protocol(\"IEncodeJS.-key->js\",x);\n}\n}\n}\n});\n\ncljs.core.key__GT_js = (function cljs$core$key__GT_js(var_args){\nvar G__3114 = arguments.length;\nswitch (G__3114) {\ncase 1:\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$1 = (function (k){\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2(k,cljs.core.clj__GT_js);\n});\n\ncljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2 = (function (k,primitive_fn){\nif((((!((k == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === k.cljs$core$IEncodeJS$))))?true:(((!k.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,k):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,k))){\nreturn cljs.core._clj__GT_js(k);\n} else {\nif(((typeof k === 'string') || (typeof k === 'number') || ((k instanceof cljs.core.Keyword)) || ((k instanceof cljs.core.Symbol)))){\nreturn (primitive_fn.cljs$core$IFn$_invoke$arity$1 ? primitive_fn.cljs$core$IFn$_invoke$arity$1(k) : primitive_fn.call(null,k));\n} else {\nreturn cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([k], 0));\n\n}\n}\n});\n\ncljs.core.key__GT_js.cljs$lang$maxFixedArity = 2;\n\n/**\n * Recursively transforms ClojureScript values to JavaScript.\n *   sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n *   Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n *   Options is a key-value pair, where the only valid key is\n *   :keyword-fn, which should point to a single-argument function to be\n *   called on keyword keys. Default to `name`.\n */\ncljs.core.clj__GT_js = (function cljs$core$clj__GT_js(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3192 = arguments.length;\nvar i__4731__auto___3193 = (0);\nwhile(true){\nif((i__4731__auto___3193 < len__4730__auto___3192)){\nargs__4736__auto__.push((arguments[i__4731__auto___3193]));\n\nvar G__3194 = (i__4731__auto___3193 + (1));\ni__4731__auto___3193 = G__3194;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.clj__GT_js.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.clj__GT_js.cljs$core$IFn$_invoke$arity$variadic = (function (x,p__3119){\nvar map__3120 = p__3119;\nvar map__3120__$1 = (((((!((map__3120 == null))))?(((((map__3120.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__3120.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__3120):map__3120);\nvar options = map__3120__$1;\nvar keyword_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__3120__$1,new cljs.core.Keyword(null,\"keyword-fn\",\"keyword-fn\",-64566675),cljs.core.name);\nvar keyfn = ((function (map__3120,map__3120__$1,options,keyword_fn){\nreturn (function cljs$core$keyfn(k){\nreturn cljs.core.key__GT_js.cljs$core$IFn$_invoke$arity$2(k,thisfn);\n});})(map__3120,map__3120__$1,options,keyword_fn))\n;\nvar thisfn = ((function (map__3120,map__3120__$1,options,keyword_fn){\nreturn (function cljs$core$thisfn(x__$1){\nif((x__$1 == null)){\nreturn null;\n} else {\nif((((!((x__$1 == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === x__$1.cljs$core$IEncodeJS$))))?true:(((!x__$1.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,x__$1):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeJS,x__$1))){\nreturn cljs.core._clj__GT_js(x__$1);\n} else {\nif((x__$1 instanceof cljs.core.Keyword)){\nreturn (keyword_fn.cljs$core$IFn$_invoke$arity$1 ? keyword_fn.cljs$core$IFn$_invoke$arity$1(x__$1) : keyword_fn.call(null,x__$1));\n} else {\nif((x__$1 instanceof cljs.core.Symbol)){\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(x__$1);\n} else {\nif(cljs.core.map_QMARK_(x__$1)){\nvar m = ({});\nvar seq__3160_3195 = cljs.core.seq(x__$1);\nvar chunk__3161_3196 = null;\nvar count__3162_3197 = (0);\nvar i__3163_3198 = (0);\nwhile(true){\nif((i__3163_3198 < count__3162_3197)){\nvar vec__3176_3199 = chunk__3161_3196.cljs$core$IIndexed$_nth$arity$2(null,i__3163_3198);\nvar k_3200 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3176_3199,(0),null);\nvar v_3201 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3176_3199,(1),null);\nvar G__3179_3202 = m;\nvar G__3180_3203 = keyfn(k_3200);\nvar G__3181_3204 = cljs$core$thisfn(v_3201);\ngoog.object.set(G__3179_3202,G__3180_3203,G__3181_3204);\n\n\nvar G__3205 = seq__3160_3195;\nvar G__3206 = chunk__3161_3196;\nvar G__3207 = count__3162_3197;\nvar G__3208 = (i__3163_3198 + (1));\nseq__3160_3195 = G__3205;\nchunk__3161_3196 = G__3206;\ncount__3162_3197 = G__3207;\ni__3163_3198 = G__3208;\ncontinue;\n} else {\nvar temp__5720__auto___3209 = cljs.core.seq(seq__3160_3195);\nif(temp__5720__auto___3209){\nvar seq__3160_3210__$1 = temp__5720__auto___3209;\nif(cljs.core.chunked_seq_QMARK_(seq__3160_3210__$1)){\nvar c__4550__auto___3211 = cljs.core.chunk_first(seq__3160_3210__$1);\nvar G__3212 = cljs.core.chunk_rest(seq__3160_3210__$1);\nvar G__3213 = c__4550__auto___3211;\nvar G__3214 = cljs.core.count(c__4550__auto___3211);\nvar G__3215 = (0);\nseq__3160_3195 = G__3212;\nchunk__3161_3196 = G__3213;\ncount__3162_3197 = G__3214;\ni__3163_3198 = G__3215;\ncontinue;\n} else {\nvar vec__3182_3216 = cljs.core.first(seq__3160_3210__$1);\nvar k_3217 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3182_3216,(0),null);\nvar v_3218 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3182_3216,(1),null);\nvar G__3185_3219 = m;\nvar G__3186_3220 = keyfn(k_3217);\nvar G__3187_3221 = cljs$core$thisfn(v_3218);\ngoog.object.set(G__3185_3219,G__3186_3220,G__3187_3221);\n\n\nvar G__3222 = cljs.core.next(seq__3160_3210__$1);\nvar G__3223 = null;\nvar G__3224 = (0);\nvar G__3225 = (0);\nseq__3160_3195 = G__3222;\nchunk__3161_3196 = G__3223;\ncount__3162_3197 = G__3224;\ni__3163_3198 = G__3225;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn m;\n} else {\nif(cljs.core.coll_QMARK_(x__$1)){\nvar arr = [];\nvar seq__3188_3226 = cljs.core.seq(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs$core$thisfn,x__$1));\nvar chunk__3189_3227 = null;\nvar count__3190_3228 = (0);\nvar i__3191_3229 = (0);\nwhile(true){\nif((i__3191_3229 < count__3190_3228)){\nvar x_3230__$2 = chunk__3189_3227.cljs$core$IIndexed$_nth$arity$2(null,i__3191_3229);\narr.push(x_3230__$2);\n\n\nvar G__3231 = seq__3188_3226;\nvar G__3232 = chunk__3189_3227;\nvar G__3233 = count__3190_3228;\nvar G__3234 = (i__3191_3229 + (1));\nseq__3188_3226 = G__3231;\nchunk__3189_3227 = G__3232;\ncount__3190_3228 = G__3233;\ni__3191_3229 = G__3234;\ncontinue;\n} else {\nvar temp__5720__auto___3235 = cljs.core.seq(seq__3188_3226);\nif(temp__5720__auto___3235){\nvar seq__3188_3236__$1 = temp__5720__auto___3235;\nif(cljs.core.chunked_seq_QMARK_(seq__3188_3236__$1)){\nvar c__4550__auto___3237 = cljs.core.chunk_first(seq__3188_3236__$1);\nvar G__3238 = cljs.core.chunk_rest(seq__3188_3236__$1);\nvar G__3239 = c__4550__auto___3237;\nvar G__3240 = cljs.core.count(c__4550__auto___3237);\nvar G__3241 = (0);\nseq__3188_3226 = G__3238;\nchunk__3189_3227 = G__3239;\ncount__3190_3228 = G__3240;\ni__3191_3229 = G__3241;\ncontinue;\n} else {\nvar x_3242__$2 = cljs.core.first(seq__3188_3236__$1);\narr.push(x_3242__$2);\n\n\nvar G__3243 = cljs.core.next(seq__3188_3236__$1);\nvar G__3244 = null;\nvar G__3245 = (0);\nvar G__3246 = (0);\nseq__3188_3226 = G__3243;\nchunk__3189_3227 = G__3244;\ncount__3190_3228 = G__3245;\ni__3191_3229 = G__3246;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn arr;\n} else {\nreturn x__$1;\n\n}\n}\n}\n}\n}\n}\n});})(map__3120,map__3120__$1,options,keyword_fn))\n;\nreturn thisfn(x);\n});\n\ncljs.core.clj__GT_js.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\ncljs.core.clj__GT_js.cljs$lang$applyTo = (function (seq3117){\nvar G__3118 = cljs.core.first(seq3117);\nvar seq3117__$1 = cljs.core.next(seq3117);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__3118,seq3117__$1);\n});\n\n\n/**\n * @interface\n */\ncljs.core.IEncodeClojure = function(){};\n\n/**\n * Transforms JavaScript values to Clojure\n */\ncljs.core._js__GT_clj = (function cljs$core$_js__GT_clj(x,options){\nif((((!((x == null)))) && ((!((x.cljs$core$IEncodeClojure$_js__GT_clj$arity$2 == null)))))){\nreturn x.cljs$core$IEncodeClojure$_js__GT_clj$arity$2(x,options);\n} else {\nvar x__4433__auto__ = (((x == null))?null:x);\nvar m__4434__auto__ = (cljs.core._js__GT_clj[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(x,options) : m__4434__auto__.call(null,x,options));\n} else {\nvar m__4431__auto__ = (cljs.core._js__GT_clj[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(x,options) : m__4431__auto__.call(null,x,options));\n} else {\nthrow cljs.core.missing_protocol(\"IEncodeClojure.-js->clj\",x);\n}\n}\n}\n});\n\n/**\n * Recursively transforms JavaScript arrays into ClojureScript\n *   vectors, and JavaScript objects into ClojureScript maps.  With\n *   option ':keywordize-keys true' will convert object fields from\n *   strings to keywords.\n */\ncljs.core.js__GT_clj = (function cljs$core$js__GT_clj(var_args){\nvar G__3252 = arguments.length;\nswitch (G__3252) {\ncase 1:\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___3257 = arguments.length;\nvar i__4731__auto___3258 = (0);\nwhile(true){\nif((i__4731__auto___3258 < len__4730__auto___3257)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___3258]));\n\nvar G__3259 = (i__4731__auto___3258 + (1));\ni__4731__auto___3258 = G__3259;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn cljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic(x,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"keywordize-keys\",\"keywordize-keys\",1310784252),false], 0));\n});\n\ncljs.core.js__GT_clj.cljs$core$IFn$_invoke$arity$variadic = (function (x,opts){\nvar map__3253 = opts;\nvar map__3253__$1 = (((((!((map__3253 == null))))?(((((map__3253.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__3253.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__3253):map__3253);\nvar keywordize_keys = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__3253__$1,new cljs.core.Keyword(null,\"keywordize-keys\",\"keywordize-keys\",1310784252));\nvar keyfn = (cljs.core.truth_(keywordize_keys)?cljs.core.keyword:cljs.core.str);\nvar f = ((function (map__3253,map__3253__$1,keywordize_keys,keyfn){\nreturn (function cljs$core$thisfn(x__$1){\nif((((!((x__$1 == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === x__$1.cljs$core$IEncodeClojure$))))?true:(((!x__$1.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeClojure,x__$1):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IEncodeClojure,x__$1))){\nreturn cljs.core._js__GT_clj(x__$1,cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.array_map,opts));\n} else {\nif(cljs.core.seq_QMARK_(x__$1)){\nreturn cljs.core.doall.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs$core$thisfn,x__$1));\n} else {\nif(cljs.core.map_entry_QMARK_(x__$1)){\nreturn (new cljs.core.MapEntry(cljs$core$thisfn(cljs.core.key(x__$1)),cljs$core$thisfn(cljs.core.val(x__$1)),null));\n} else {\nif(cljs.core.coll_QMARK_(x__$1)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.empty(x__$1),cljs.core.map.cljs$core$IFn$_invoke$arity$1(cljs$core$thisfn),x__$1);\n} else {\nif(cljs.core.array_QMARK_(x__$1)){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__3253,map__3253__$1,keywordize_keys,keyfn){\nreturn (function (p1__3247_SHARP_,p2__3248_SHARP_){\nreturn cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(p1__3247_SHARP_,cljs$core$thisfn(p2__3248_SHARP_));\n});})(map__3253,map__3253__$1,keywordize_keys,keyfn))\n,cljs.core.transient$(cljs.core.PersistentVector.EMPTY),x__$1));\n} else {\nif((cljs.core.type(x__$1) === Object)){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (map__3253,map__3253__$1,keywordize_keys,keyfn){\nreturn (function (r,k){\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(r,(keyfn.cljs$core$IFn$_invoke$arity$1 ? keyfn.cljs$core$IFn$_invoke$arity$1(k) : keyfn.call(null,k)),cljs$core$thisfn(goog.object.get(x__$1,k)));\n});})(map__3253,map__3253__$1,keywordize_keys,keyfn))\n,cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY),cljs.core.js_keys(x__$1)));\n} else {\nreturn x__$1;\n\n}\n}\n}\n}\n}\n}\n});})(map__3253,map__3253__$1,keywordize_keys,keyfn))\n;\nreturn f(x);\n});\n\n/** @this {Function} */\ncljs.core.js__GT_clj.cljs$lang$applyTo = (function (seq3250){\nvar G__3251 = cljs.core.first(seq3250);\nvar seq3250__$1 = cljs.core.next(seq3250);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__3251,seq3250__$1);\n});\n\ncljs.core.js__GT_clj.cljs$lang$maxFixedArity = (1);\n\n/**\n * Returns a memoized version of a referentially transparent function. The\n *   memoized version of the function keeps a cache of the mapping from arguments\n *   to results and, when calls with the same arguments are repeated often, has\n *   higher performance at the expense of higher memory use.\n */\ncljs.core.memoize = (function cljs$core$memoize(f){\nvar mem = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nreturn ((function (mem){\nreturn (function() { \nvar G__3260__delegate = function (args){\nvar v = cljs.core.get.cljs$core$IFn$_invoke$arity$3(cljs.core.deref(mem),args,cljs.core.lookup_sentinel);\nif((v === cljs.core.lookup_sentinel)){\nvar ret = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,args);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(mem,cljs.core.assoc,args,ret);\n\nreturn ret;\n} else {\nreturn v;\n}\n};\nvar G__3260 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__3261__i = 0, G__3261__a = new Array(arguments.length -  0);\nwhile (G__3261__i < G__3261__a.length) {G__3261__a[G__3261__i] = arguments[G__3261__i + 0]; ++G__3261__i;}\n  args = new cljs.core.IndexedSeq(G__3261__a,0,null);\n} \nreturn G__3260__delegate.call(this,args);};\nG__3260.cljs$lang$maxFixedArity = 0;\nG__3260.cljs$lang$applyTo = (function (arglist__3262){\nvar args = cljs.core.seq(arglist__3262);\nreturn G__3260__delegate(args);\n});\nG__3260.cljs$core$IFn$_invoke$arity$variadic = G__3260__delegate;\nreturn G__3260;\n})()\n;\n;})(mem))\n});\n/**\n * trampoline can be used to convert algorithms requiring mutual\n *   recursion without stack consumption. Calls f with supplied args, if\n *   any. If f returns a fn, calls that fn with no arguments, and\n *   continues to repeat, until the return value is not a fn, then\n *   returns that non-fn value. Note that if you want to return a fn as a\n *   final value, you must wrap it in some data structure and unpack it\n *   after trampoline returns.\n */\ncljs.core.trampoline = (function cljs$core$trampoline(var_args){\nvar G__3266 = arguments.length;\nswitch (G__3266) {\ncase 1:\nreturn cljs.core.trampoline.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___3268 = arguments.length;\nvar i__4731__auto___3269 = (0);\nwhile(true){\nif((i__4731__auto___3269 < len__4730__auto___3268)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___3269]));\n\nvar G__3270 = (i__4731__auto___3269 + (1));\ni__4731__auto___3269 = G__3270;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((1)),(0),null));\nreturn cljs.core.trampoline.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4752__auto__);\n\n}\n});\n\ncljs.core.trampoline.cljs$core$IFn$_invoke$arity$1 = (function (f){\nwhile(true){\nvar ret = (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\nif(cljs.core.fn_QMARK_(ret)){\nvar G__3271 = ret;\nf = G__3271;\ncontinue;\n} else {\nreturn ret;\n}\nbreak;\n}\n});\n\ncljs.core.trampoline.cljs$core$IFn$_invoke$arity$variadic = (function (f,args){\nreturn cljs.core.trampoline.cljs$core$IFn$_invoke$arity$1((function (){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(f,args);\n}));\n});\n\n/** @this {Function} */\ncljs.core.trampoline.cljs$lang$applyTo = (function (seq3264){\nvar G__3265 = cljs.core.first(seq3264);\nvar seq3264__$1 = cljs.core.next(seq3264);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__3265,seq3264__$1);\n});\n\ncljs.core.trampoline.cljs$lang$maxFixedArity = (1);\n\n/**\n * Returns a random floating point number between 0 (inclusive) and\n *   n (default 1) (exclusive).\n */\ncljs.core.rand = (function cljs$core$rand(var_args){\nvar G__3273 = arguments.length;\nswitch (G__3273) {\ncase 0:\nreturn cljs.core.rand.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.core.rand.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.rand.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.rand.cljs$core$IFn$_invoke$arity$1((1));\n});\n\ncljs.core.rand.cljs$core$IFn$_invoke$arity$1 = (function (n){\nreturn (Math.random() * n);\n});\n\ncljs.core.rand.cljs$lang$maxFixedArity = 1;\n\n/**\n * Returns a random integer between 0 (inclusive) and n (exclusive).\n */\ncljs.core.rand_int = (function cljs$core$rand_int(n){\nvar G__3275 = (Math.random() * n);\nreturn Math.floor(G__3275);\n});\n/**\n * Return a random element of the (sequential) collection. Will have\n *   the same performance characteristics as nth for the given\n *   collection.\n */\ncljs.core.rand_nth = (function cljs$core$rand_nth(coll){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(coll,cljs.core.rand_int(cljs.core.count(coll)));\n});\n/**\n * Returns a map of the elements of coll keyed by the result of\n *   f on each element. The value at each key will be a vector of the\n *   corresponding elements, in the order they appeared in coll.\n */\ncljs.core.group_by = (function cljs$core$group_by(f,coll){\nreturn cljs.core.persistent_BANG_(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (ret,x){\nvar k = (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(x) : f.call(null,x));\nreturn cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3(ret,k,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(ret,k,cljs.core.PersistentVector.EMPTY),x));\n}),cljs.core.transient$(cljs.core.PersistentArrayMap.EMPTY),coll));\n});\n/**\n * Creates a hierarchy object for use with derive, isa? etc.\n */\ncljs.core.make_hierarchy = (function cljs$core$make_hierarchy(){\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"parents\",\"parents\",-2027538891),cljs.core.PersistentArrayMap.EMPTY,new cljs.core.Keyword(null,\"descendants\",\"descendants\",1824886031),cljs.core.PersistentArrayMap.EMPTY,new cljs.core.Keyword(null,\"ancestors\",\"ancestors\",-776045424),cljs.core.PersistentArrayMap.EMPTY], null);\n});\n/**\n * @type {*}\n */\ncljs.core._global_hierarchy = null;\ncljs.core.get_global_hierarchy = (function cljs$core$get_global_hierarchy(){\nif((cljs.core._global_hierarchy == null)){\ncljs.core._global_hierarchy = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.make_hierarchy());\n} else {\n}\n\nreturn cljs.core._global_hierarchy;\n});\ncljs.core.swap_global_hierarchy_BANG_ = (function cljs$core$swap_global_hierarchy_BANG_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___3278 = arguments.length;\nvar i__4731__auto___3279 = (0);\nwhile(true){\nif((i__4731__auto___3279 < len__4730__auto___3278)){\nargs__4736__auto__.push((arguments[i__4731__auto___3279]));\n\nvar G__3280 = (i__4731__auto___3279 + (1));\ni__4731__auto___3279 = G__3280;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn cljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\ncljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (f,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(cljs.core.swap_BANG_,cljs.core.get_global_hierarchy(),f,args);\n});\n\ncljs.core.swap_global_hierarchy_BANG_.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\ncljs.core.swap_global_hierarchy_BANG_.cljs$lang$applyTo = (function (seq3276){\nvar G__3277 = cljs.core.first(seq3276);\nvar seq3276__$1 = cljs.core.next(seq3276);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__3277,seq3276__$1);\n});\n\n/**\n * Returns true if (= child parent), or child is directly or indirectly derived from\n *   parent, either via a JavaScript type inheritance relationship or a\n *   relationship established via derive. h must be a hierarchy obtained\n *   from make-hierarchy, if not supplied defaults to the global\n *   hierarchy\n */\ncljs.core.isa_QMARK_ = (function cljs$core$isa_QMARK_(var_args){\nvar G__3282 = arguments.length;\nswitch (G__3282) {\ncase 2:\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$2 = (function (child,parent){\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(cljs.core.deref(cljs.core.get_global_hierarchy()),child,parent);\n});\n\ncljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3 = (function (h,child,parent){\nvar or__4131__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(child,parent);\nif(or__4131__auto__){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = cljs.core.contains_QMARK_((function (){var fexpr__3285 = new cljs.core.Keyword(null,\"ancestors\",\"ancestors\",-776045424).cljs$core$IFn$_invoke$arity$1(h);\nreturn (fexpr__3285.cljs$core$IFn$_invoke$arity$1 ? fexpr__3285.cljs$core$IFn$_invoke$arity$1(child) : fexpr__3285.call(null,child));\n})(),parent);\nif(or__4131__auto____$1){\nreturn or__4131__auto____$1;\n} else {\nvar and__4120__auto__ = cljs.core.vector_QMARK_(parent);\nif(and__4120__auto__){\nvar and__4120__auto____$1 = cljs.core.vector_QMARK_(child);\nif(and__4120__auto____$1){\nvar and__4120__auto____$2 = (cljs.core.count(parent) === cljs.core.count(child));\nif(and__4120__auto____$2){\nvar ret = true;\nvar i = (0);\nwhile(true){\nif((((!(ret))) || ((i === cljs.core.count(parent))))){\nreturn ret;\n} else {\nvar G__3287 = cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(h,(child.cljs$core$IFn$_invoke$arity$1 ? child.cljs$core$IFn$_invoke$arity$1(i) : child.call(null,i)),(parent.cljs$core$IFn$_invoke$arity$1 ? parent.cljs$core$IFn$_invoke$arity$1(i) : parent.call(null,i)));\nvar G__3288 = (i + (1));\nret = G__3287;\ni = G__3288;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn and__4120__auto____$2;\n}\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n}\n}\n});\n\ncljs.core.isa_QMARK_.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns the immediate parents of tag, either via a JavaScript type\n *   inheritance relationship or a relationship established via derive. h\n *   must be a hierarchy obtained from make-hierarchy, if not supplied\n *   defaults to the global hierarchy\n */\ncljs.core.parents = (function cljs$core$parents(var_args){\nvar G__3290 = arguments.length;\nswitch (G__3290) {\ncase 1:\nreturn cljs.core.parents.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.parents.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.parents.cljs$core$IFn$_invoke$arity$1 = (function (tag){\nreturn cljs.core.parents.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.get_global_hierarchy()),tag);\n});\n\ncljs.core.parents.cljs$core$IFn$_invoke$arity$2 = (function (h,tag){\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"parents\",\"parents\",-2027538891).cljs$core$IFn$_invoke$arity$1(h),tag));\n});\n\ncljs.core.parents.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns the immediate and indirect parents of tag, either via a JavaScript type\n *   inheritance relationship or a relationship established via derive. h\n *   must be a hierarchy obtained from make-hierarchy, if not supplied\n *   defaults to the global hierarchy\n */\ncljs.core.ancestors = (function cljs$core$ancestors(var_args){\nvar G__3293 = arguments.length;\nswitch (G__3293) {\ncase 1:\nreturn cljs.core.ancestors.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.ancestors.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.ancestors.cljs$core$IFn$_invoke$arity$1 = (function (tag){\nreturn cljs.core.ancestors.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.get_global_hierarchy()),tag);\n});\n\ncljs.core.ancestors.cljs$core$IFn$_invoke$arity$2 = (function (h,tag){\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ancestors\",\"ancestors\",-776045424).cljs$core$IFn$_invoke$arity$1(h),tag));\n});\n\ncljs.core.ancestors.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns the immediate and indirect children of tag, through a\n *   relationship established via derive. h must be a hierarchy obtained\n *   from make-hierarchy, if not supplied defaults to the global\n *   hierarchy. Note: does not work on JavaScript type inheritance\n *   relationships.\n */\ncljs.core.descendants = (function cljs$core$descendants(var_args){\nvar G__3296 = arguments.length;\nswitch (G__3296) {\ncase 1:\nreturn cljs.core.descendants.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.descendants.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.descendants.cljs$core$IFn$_invoke$arity$1 = (function (tag){\nreturn cljs.core.descendants.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.get_global_hierarchy()),tag);\n});\n\ncljs.core.descendants.cljs$core$IFn$_invoke$arity$2 = (function (h,tag){\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"descendants\",\"descendants\",1824886031).cljs$core$IFn$_invoke$arity$1(h),tag));\n});\n\ncljs.core.descendants.cljs$lang$maxFixedArity = 2;\n\n/**\n * Establishes a parent/child relationship between parent and\n *   tag. Parent must be a namespace-qualified symbol or keyword and\n *   child can be either a namespace-qualified symbol or keyword or a\n *   class. h must be a hierarchy obtained from make-hierarchy, if not\n *   supplied defaults to, and modifies, the global hierarchy.\n */\ncljs.core.derive = (function cljs$core$derive(var_args){\nvar G__3299 = arguments.length;\nswitch (G__3299) {\ncase 2:\nreturn cljs.core.derive.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.derive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.derive.cljs$core$IFn$_invoke$arity$2 = (function (tag,parent){\nif(cljs.core.truth_(cljs.core.namespace(parent))){\n} else {\nthrow (new Error(\"Assert failed: (namespace parent)\"));\n}\n\ncljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.derive,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([tag,parent], 0));\n\nreturn null;\n});\n\ncljs.core.derive.cljs$core$IFn$_invoke$arity$3 = (function (h,tag,parent){\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(tag,parent)){\n} else {\nthrow (new Error(\"Assert failed: (not= tag parent)\"));\n}\n\nvar tp = new cljs.core.Keyword(null,\"parents\",\"parents\",-2027538891).cljs$core$IFn$_invoke$arity$1(h);\nvar td = new cljs.core.Keyword(null,\"descendants\",\"descendants\",1824886031).cljs$core$IFn$_invoke$arity$1(h);\nvar ta = new cljs.core.Keyword(null,\"ancestors\",\"ancestors\",-776045424).cljs$core$IFn$_invoke$arity$1(h);\nvar tf = ((function (tp,td,ta){\nreturn (function (m,source,sources,target,targets){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (tp,td,ta){\nreturn (function (ret,k){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ret,k,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.get.cljs$core$IFn$_invoke$arity$3(targets,k,cljs.core.PersistentHashSet.EMPTY),cljs.core.cons(target,(targets.cljs$core$IFn$_invoke$arity$1 ? targets.cljs$core$IFn$_invoke$arity$1(target) : targets.call(null,target)))));\n});})(tp,td,ta))\n,m,cljs.core.cons(source,(sources.cljs$core$IFn$_invoke$arity$1 ? sources.cljs$core$IFn$_invoke$arity$1(source) : sources.call(null,source))));\n});})(tp,td,ta))\n;\nvar or__4131__auto__ = ((cljs.core.contains_QMARK_((tp.cljs$core$IFn$_invoke$arity$1 ? tp.cljs$core$IFn$_invoke$arity$1(tag) : tp.call(null,tag)),parent))?null:(function (){\nif(cljs.core.contains_QMARK_((ta.cljs$core$IFn$_invoke$arity$1 ? ta.cljs$core$IFn$_invoke$arity$1(tag) : ta.call(null,tag)),parent)){\nthrow (new Error([cljs.core.str.cljs$core$IFn$_invoke$arity$1(tag),\"already has\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(parent),\"as ancestor\"].join('')));\n} else {\n}\n\nif(cljs.core.contains_QMARK_((ta.cljs$core$IFn$_invoke$arity$1 ? ta.cljs$core$IFn$_invoke$arity$1(parent) : ta.call(null,parent)),tag)){\nthrow (new Error([\"Cyclic derivation:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(parent),\"has\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(tag),\"as ancestor\"].join('')));\n} else {\n}\n\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"parents\",\"parents\",-2027538891),cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(new cljs.core.Keyword(null,\"parents\",\"parents\",-2027538891).cljs$core$IFn$_invoke$arity$1(h),tag,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(tp,tag,cljs.core.PersistentHashSet.EMPTY),parent)),new cljs.core.Keyword(null,\"ancestors\",\"ancestors\",-776045424),tf(new cljs.core.Keyword(null,\"ancestors\",\"ancestors\",-776045424).cljs$core$IFn$_invoke$arity$1(h),tag,td,parent,ta),new cljs.core.Keyword(null,\"descendants\",\"descendants\",1824886031),tf(new cljs.core.Keyword(null,\"descendants\",\"descendants\",1824886031).cljs$core$IFn$_invoke$arity$1(h),parent,ta,tag,td)], null);\n})()\n);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn h;\n}\n});\n\ncljs.core.derive.cljs$lang$maxFixedArity = 3;\n\n/**\n * Removes a parent/child relationship between parent and\n *   tag. h must be a hierarchy obtained from make-hierarchy, if not\n *   supplied defaults to, and modifies, the global hierarchy.\n */\ncljs.core.underive = (function cljs$core$underive(var_args){\nvar G__3305 = arguments.length;\nswitch (G__3305) {\ncase 2:\nreturn cljs.core.underive.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.underive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.underive.cljs$core$IFn$_invoke$arity$2 = (function (tag,parent){\ncljs.core.swap_global_hierarchy_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.underive,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([tag,parent], 0));\n\nreturn null;\n});\n\ncljs.core.underive.cljs$core$IFn$_invoke$arity$3 = (function (h,tag,parent){\nvar parentMap = new cljs.core.Keyword(null,\"parents\",\"parents\",-2027538891).cljs$core$IFn$_invoke$arity$1(h);\nvar childsParents = (cljs.core.truth_((parentMap.cljs$core$IFn$_invoke$arity$1 ? parentMap.cljs$core$IFn$_invoke$arity$1(tag) : parentMap.call(null,tag)))?cljs.core.disj.cljs$core$IFn$_invoke$arity$2((parentMap.cljs$core$IFn$_invoke$arity$1 ? parentMap.cljs$core$IFn$_invoke$arity$1(tag) : parentMap.call(null,tag)),parent):cljs.core.PersistentHashSet.EMPTY);\nvar newParents = (cljs.core.truth_(cljs.core.not_empty(childsParents))?cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(parentMap,tag,childsParents):cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(parentMap,tag));\nvar deriv_seq = cljs.core.flatten(cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (parentMap,childsParents,newParents){\nreturn (function (p1__3301_SHARP_){\nreturn cljs.core.cons(cljs.core.first(p1__3301_SHARP_),cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__3301_SHARP_),cljs.core.second(p1__3301_SHARP_)));\n});})(parentMap,childsParents,newParents))\n,cljs.core.seq(newParents)));\nif(cljs.core.contains_QMARK_((parentMap.cljs$core$IFn$_invoke$arity$1 ? parentMap.cljs$core$IFn$_invoke$arity$1(tag) : parentMap.call(null,tag)),parent)){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (parentMap,childsParents,newParents,deriv_seq){\nreturn (function (p1__3302_SHARP_,p2__3303_SHARP_){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.derive,p1__3302_SHARP_,p2__3303_SHARP_);\n});})(parentMap,childsParents,newParents,deriv_seq))\n,cljs.core.make_hierarchy(),cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),deriv_seq));\n} else {\nreturn h;\n}\n});\n\ncljs.core.underive.cljs$lang$maxFixedArity = 3;\n\ncljs.core.reset_cache = (function cljs$core$reset_cache(method_cache,method_table,cached_hierarchy,hierarchy){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(method_cache,(function (_){\nreturn cljs.core.deref(method_table);\n}));\n\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(cached_hierarchy,(function (_){\nreturn cljs.core.deref(hierarchy);\n}));\n});\ncljs.core.prefers_STAR_ = (function cljs$core$prefers_STAR_(x,y,prefer_table){\nvar xprefs = (function (){var fexpr__3307 = cljs.core.deref(prefer_table);\nreturn (fexpr__3307.cljs$core$IFn$_invoke$arity$1 ? fexpr__3307.cljs$core$IFn$_invoke$arity$1(x) : fexpr__3307.call(null,x));\n})();\nvar or__4131__auto__ = (cljs.core.truth_((function (){var and__4120__auto__ = xprefs;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (xprefs.cljs$core$IFn$_invoke$arity$1 ? xprefs.cljs$core$IFn$_invoke$arity$1(y) : xprefs.call(null,y));\n} else {\nreturn and__4120__auto__;\n}\n})())?true:null);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = (function (){var ps = cljs.core.parents.cljs$core$IFn$_invoke$arity$1(y);\nwhile(true){\nif((cljs.core.count(ps) > (0))){\nif(cljs.core.truth_((function (){var G__3311 = x;\nvar G__3312 = cljs.core.first(ps);\nvar G__3313 = prefer_table;\nreturn (cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3 ? cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3(G__3311,G__3312,G__3313) : cljs.core.prefers_STAR_.call(null,G__3311,G__3312,G__3313));\n})())){\n} else {\n}\n\nvar G__3320 = cljs.core.rest(ps);\nps = G__3320;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n})();\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nvar or__4131__auto____$2 = (function (){var ps = cljs.core.parents.cljs$core$IFn$_invoke$arity$1(x);\nwhile(true){\nif((cljs.core.count(ps) > (0))){\nif(cljs.core.truth_((function (){var G__3317 = cljs.core.first(ps);\nvar G__3318 = y;\nvar G__3319 = prefer_table;\nreturn (cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3 ? cljs.core.prefers_STAR_.cljs$core$IFn$_invoke$arity$3(G__3317,G__3318,G__3319) : cljs.core.prefers_STAR_.call(null,G__3317,G__3318,G__3319));\n})())){\n} else {\n}\n\nvar G__3321 = cljs.core.rest(ps);\nps = G__3321;\ncontinue;\n} else {\nreturn null;\n}\nbreak;\n}\n})();\nif(cljs.core.truth_(or__4131__auto____$2)){\nreturn or__4131__auto____$2;\n} else {\nreturn false;\n}\n}\n}\n});\ncljs.core.dominates = (function cljs$core$dominates(x,y,prefer_table,hierarchy){\nvar or__4131__auto__ = cljs.core.prefers_STAR_(x,y,prefer_table);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(hierarchy,x,y);\n}\n});\ncljs.core.find_and_cache_best_method = (function cljs$core$find_and_cache_best_method(name,dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy,default_dispatch_val){\nvar best_entry = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (be,p__3322){\nvar vec__3323 = p__3322;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3323,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3323,(1),null);\nvar e = vec__3323;\nif(cljs.core.isa_QMARK_.cljs$core$IFn$_invoke$arity$3(cljs.core.deref(hierarchy),dispatch_val,k)){\nvar be2 = (((((be == null)) || (cljs.core.dominates(k,cljs.core.first(be),prefer_table,cljs.core.deref(hierarchy)))))?e:be);\nif(cljs.core.dominates(cljs.core.first(be2),k,prefer_table,cljs.core.deref(hierarchy))){\n} else {\nthrow (new Error([\"Multiple methods in multimethod '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(name),\"' match dispatch value: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val),\" -> \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(k),\" and \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(be2)),\", and neither is preferred\"].join('')));\n}\n\nreturn be2;\n} else {\nreturn be;\n}\n}),null,cljs.core.deref(method_table));\nvar best_entry__$1 = (function (){var temp__5718__auto__ = (function (){var and__4120__auto__ = (best_entry == null);\nif(and__4120__auto__){\nvar fexpr__3327 = cljs.core.deref(method_table);\nreturn (fexpr__3327.cljs$core$IFn$_invoke$arity$1 ? fexpr__3327.cljs$core$IFn$_invoke$arity$1(default_dispatch_val) : fexpr__3327.call(null,default_dispatch_val));\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(temp__5718__auto__)){\nvar entry = temp__5718__auto__;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [default_dispatch_val,entry], null);\n} else {\nreturn best_entry;\n}\n})();\nif(cljs.core.truth_(best_entry__$1)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cached_hierarchy),cljs.core.deref(hierarchy))){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(method_cache,cljs.core.assoc,dispatch_val,cljs.core.second(best_entry__$1));\n\nreturn cljs.core.second(best_entry__$1);\n} else {\ncljs.core.reset_cache(method_cache,method_table,cached_hierarchy,hierarchy);\n\nreturn (cljs.core.find_and_cache_best_method.cljs$core$IFn$_invoke$arity$8 ? cljs.core.find_and_cache_best_method.cljs$core$IFn$_invoke$arity$8(name,dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy,default_dispatch_val) : cljs.core.find_and_cache_best_method.call(null,name,dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy,default_dispatch_val));\n}\n} else {\nreturn null;\n}\n});\n\n/**\n * @interface\n */\ncljs.core.IMultiFn = function(){};\n\ncljs.core._reset = (function cljs$core$_reset(mf){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_reset$arity$1 == null)))))){\nreturn mf.cljs$core$IMultiFn$_reset$arity$1(mf);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._reset[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ = (cljs.core._reset[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-reset\",mf);\n}\n}\n}\n});\n\ncljs.core._add_method = (function cljs$core$_add_method(mf,dispatch_val,method){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_add_method$arity$3 == null)))))){\nreturn mf.cljs$core$IMultiFn$_add_method$arity$3(mf,dispatch_val,method);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._add_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,method) : m__4434__auto__.call(null,mf,dispatch_val,method));\n} else {\nvar m__4431__auto__ = (cljs.core._add_method[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,method) : m__4431__auto__.call(null,mf,dispatch_val,method));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-add-method\",mf);\n}\n}\n}\n});\n\ncljs.core._remove_method = (function cljs$core$_remove_method(mf,dispatch_val){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_remove_method$arity$2 == null)))))){\nreturn mf.cljs$core$IMultiFn$_remove_method$arity$2(mf,dispatch_val);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._remove_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4434__auto__.call(null,mf,dispatch_val));\n} else {\nvar m__4431__auto__ = (cljs.core._remove_method[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4431__auto__.call(null,mf,dispatch_val));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-remove-method\",mf);\n}\n}\n}\n});\n\ncljs.core._prefer_method = (function cljs$core$_prefer_method(mf,dispatch_val,dispatch_val_y){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_prefer_method$arity$3 == null)))))){\nreturn mf.cljs$core$IMultiFn$_prefer_method$arity$3(mf,dispatch_val,dispatch_val_y);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._prefer_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,dispatch_val_y) : m__4434__auto__.call(null,mf,dispatch_val,dispatch_val_y));\n} else {\nvar m__4431__auto__ = (cljs.core._prefer_method[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(mf,dispatch_val,dispatch_val_y) : m__4431__auto__.call(null,mf,dispatch_val,dispatch_val_y));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-prefer-method\",mf);\n}\n}\n}\n});\n\ncljs.core._get_method = (function cljs$core$_get_method(mf,dispatch_val){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_get_method$arity$2 == null)))))){\nreturn mf.cljs$core$IMultiFn$_get_method$arity$2(mf,dispatch_val);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._get_method[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4434__auto__.call(null,mf,dispatch_val));\n} else {\nvar m__4431__auto__ = (cljs.core._get_method[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(mf,dispatch_val) : m__4431__auto__.call(null,mf,dispatch_val));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-get-method\",mf);\n}\n}\n}\n});\n\ncljs.core._methods = (function cljs$core$_methods(mf){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_methods$arity$1 == null)))))){\nreturn mf.cljs$core$IMultiFn$_methods$arity$1(mf);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._methods[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ = (cljs.core._methods[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-methods\",mf);\n}\n}\n}\n});\n\ncljs.core._prefers = (function cljs$core$_prefers(mf){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_prefers$arity$1 == null)))))){\nreturn mf.cljs$core$IMultiFn$_prefers$arity$1(mf);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._prefers[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ = (cljs.core._prefers[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-prefers\",mf);\n}\n}\n}\n});\n\ncljs.core._default_dispatch_val = (function cljs$core$_default_dispatch_val(mf){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_default_dispatch_val$arity$1 == null)))))){\nreturn mf.cljs$core$IMultiFn$_default_dispatch_val$arity$1(mf);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._default_dispatch_val[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ = (cljs.core._default_dispatch_val[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-default-dispatch-val\",mf);\n}\n}\n}\n});\n\ncljs.core._dispatch_fn = (function cljs$core$_dispatch_fn(mf){\nif((((!((mf == null)))) && ((!((mf.cljs$core$IMultiFn$_dispatch_fn$arity$1 == null)))))){\nreturn mf.cljs$core$IMultiFn$_dispatch_fn$arity$1(mf);\n} else {\nvar x__4433__auto__ = (((mf == null))?null:mf);\nvar m__4434__auto__ = (cljs.core._dispatch_fn[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4434__auto__.call(null,mf));\n} else {\nvar m__4431__auto__ = (cljs.core._dispatch_fn[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mf) : m__4431__auto__.call(null,mf));\n} else {\nthrow cljs.core.missing_protocol(\"IMultiFn.-dispatch-fn\",mf);\n}\n}\n}\n});\n\ncljs.core.throw_no_method_error = (function cljs$core$throw_no_method_error(name,dispatch_val){\nthrow (new Error([\"No method in multimethod '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(name),\"' for dispatch value: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val)].join('')));\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IFn}\n * @implements {cljs.core.IMultiFn}\n * @implements {cljs.core.INamed}\n*/\ncljs.core.MultiFn = (function (name,dispatch_fn,default_dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy){\nthis.name = name;\nthis.dispatch_fn = dispatch_fn;\nthis.default_dispatch_val = default_dispatch_val;\nthis.hierarchy = hierarchy;\nthis.method_table = method_table;\nthis.prefer_table = prefer_table;\nthis.method_cache = method_cache;\nthis.cached_hierarchy = cached_hierarchy;\nthis.cljs$lang$protocol_mask$partition0$ = 4194305;\nthis.cljs$lang$protocol_mask$partition1$ = 4352;\n});\ncljs.core.MultiFn.prototype.call = (function() {\nvar G__3330 = null;\nvar G__3330__1 = (function (self__){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0() : self__.dispatch_fn.call(null));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$0 ? target_fn.cljs$core$IFn$_invoke$arity$0() : target_fn.call(null));\n});\nvar G__3330__2 = (function (self__,a){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1(a) : self__.dispatch_fn.call(null,a));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$1 ? target_fn.cljs$core$IFn$_invoke$arity$1(a) : target_fn.call(null,a));\n});\nvar G__3330__3 = (function (self__,a,b){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.dispatch_fn.call(null,a,b));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$2 ? target_fn.cljs$core$IFn$_invoke$arity$2(a,b) : target_fn.call(null,a,b));\n});\nvar G__3330__4 = (function (self__,a,b,c){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.dispatch_fn.call(null,a,b,c));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$3 ? target_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : target_fn.call(null,a,b,c));\n});\nvar G__3330__5 = (function (self__,a,b,c,d){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.dispatch_fn.call(null,a,b,c,d));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$4 ? target_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : target_fn.call(null,a,b,c,d));\n});\nvar G__3330__6 = (function (self__,a,b,c,d,e){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.dispatch_fn.call(null,a,b,c,d,e));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$5 ? target_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : target_fn.call(null,a,b,c,d,e));\n});\nvar G__3330__7 = (function (self__,a,b,c,d,e,f){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.dispatch_fn.call(null,a,b,c,d,e,f));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$6 ? target_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : target_fn.call(null,a,b,c,d,e,f));\n});\nvar G__3330__8 = (function (self__,a,b,c,d,e,f,g){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$7 ? target_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : target_fn.call(null,a,b,c,d,e,f,g));\n});\nvar G__3330__9 = (function (self__,a,b,c,d,e,f,g,h){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$8 ? target_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : target_fn.call(null,a,b,c,d,e,f,g,h));\n});\nvar G__3330__10 = (function (self__,a,b,c,d,e,f,g,h,i){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$9 ? target_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : target_fn.call(null,a,b,c,d,e,f,g,h,i));\n});\nvar G__3330__11 = (function (self__,a,b,c,d,e,f,g,h,i,j){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$10 ? target_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\nvar G__3330__12 = (function (self__,a,b,c,d,e,f,g,h,i,j,k){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$11 ? target_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\nvar G__3330__13 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$12 ? target_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\nvar G__3330__14 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$13 ? target_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\nvar G__3330__15 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$14 ? target_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\nvar G__3330__16 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$15 ? target_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\nvar G__3330__17 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$16 ? target_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\nvar G__3330__18 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$17 ? target_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\nvar G__3330__19 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$18 ? target_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\nvar G__3330__20 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$19 ? target_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\nvar G__3330__21 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$20 ? target_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\nvar G__3330__22 = (function (self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ = this;\nvar self____$1 = this;\nvar mf = self____$1;\nvar dispatch_val = cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.dispatch_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(target_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\nG__3330 = function(self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nswitch(arguments.length){\ncase 1:\nreturn G__3330__1.call(this,self__);\ncase 2:\nreturn G__3330__2.call(this,self__,a);\ncase 3:\nreturn G__3330__3.call(this,self__,a,b);\ncase 4:\nreturn G__3330__4.call(this,self__,a,b,c);\ncase 5:\nreturn G__3330__5.call(this,self__,a,b,c,d);\ncase 6:\nreturn G__3330__6.call(this,self__,a,b,c,d,e);\ncase 7:\nreturn G__3330__7.call(this,self__,a,b,c,d,e,f);\ncase 8:\nreturn G__3330__8.call(this,self__,a,b,c,d,e,f,g);\ncase 9:\nreturn G__3330__9.call(this,self__,a,b,c,d,e,f,g,h);\ncase 10:\nreturn G__3330__10.call(this,self__,a,b,c,d,e,f,g,h,i);\ncase 11:\nreturn G__3330__11.call(this,self__,a,b,c,d,e,f,g,h,i,j);\ncase 12:\nreturn G__3330__12.call(this,self__,a,b,c,d,e,f,g,h,i,j,k);\ncase 13:\nreturn G__3330__13.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l);\ncase 14:\nreturn G__3330__14.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m);\ncase 15:\nreturn G__3330__15.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n);\ncase 16:\nreturn G__3330__16.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);\ncase 17:\nreturn G__3330__17.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);\ncase 18:\nreturn G__3330__18.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);\ncase 19:\nreturn G__3330__19.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);\ncase 20:\nreturn G__3330__20.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);\ncase 21:\nreturn G__3330__21.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);\ncase 22:\nreturn G__3330__22.call(this,self__,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest);\n}\nthrow(new Error('Invalid arity: ' + (arguments.length - 1)));\n};\nG__3330.cljs$core$IFn$_invoke$arity$1 = G__3330__1;\nG__3330.cljs$core$IFn$_invoke$arity$2 = G__3330__2;\nG__3330.cljs$core$IFn$_invoke$arity$3 = G__3330__3;\nG__3330.cljs$core$IFn$_invoke$arity$4 = G__3330__4;\nG__3330.cljs$core$IFn$_invoke$arity$5 = G__3330__5;\nG__3330.cljs$core$IFn$_invoke$arity$6 = G__3330__6;\nG__3330.cljs$core$IFn$_invoke$arity$7 = G__3330__7;\nG__3330.cljs$core$IFn$_invoke$arity$8 = G__3330__8;\nG__3330.cljs$core$IFn$_invoke$arity$9 = G__3330__9;\nG__3330.cljs$core$IFn$_invoke$arity$10 = G__3330__10;\nG__3330.cljs$core$IFn$_invoke$arity$11 = G__3330__11;\nG__3330.cljs$core$IFn$_invoke$arity$12 = G__3330__12;\nG__3330.cljs$core$IFn$_invoke$arity$13 = G__3330__13;\nG__3330.cljs$core$IFn$_invoke$arity$14 = G__3330__14;\nG__3330.cljs$core$IFn$_invoke$arity$15 = G__3330__15;\nG__3330.cljs$core$IFn$_invoke$arity$16 = G__3330__16;\nG__3330.cljs$core$IFn$_invoke$arity$17 = G__3330__17;\nG__3330.cljs$core$IFn$_invoke$arity$18 = G__3330__18;\nG__3330.cljs$core$IFn$_invoke$arity$19 = G__3330__19;\nG__3330.cljs$core$IFn$_invoke$arity$20 = G__3330__20;\nG__3330.cljs$core$IFn$_invoke$arity$21 = G__3330__21;\nG__3330.cljs$core$IFn$_invoke$arity$22 = G__3330__22;\nreturn G__3330;\n})()\n;\n\ncljs.core.MultiFn.prototype.apply = (function (self__,args3328){\nvar self__ = this;\nvar self____$1 = this;\nreturn self____$1.call.apply(self____$1,[self____$1].concat(cljs.core.aclone(args3328)));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$0 = (function (){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$0() : self__.dispatch_fn.call(null));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$0 ? target_fn.cljs$core$IFn$_invoke$arity$0() : target_fn.call(null));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$1 = (function (a){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$1(a) : self__.dispatch_fn.call(null,a));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$1 ? target_fn.cljs$core$IFn$_invoke$arity$1(a) : target_fn.call(null,a));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$2(a,b) : self__.dispatch_fn.call(null,a,b));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$2 ? target_fn.cljs$core$IFn$_invoke$arity$2(a,b) : target_fn.call(null,a,b));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : self__.dispatch_fn.call(null,a,b,c));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$3 ? target_fn.cljs$core$IFn$_invoke$arity$3(a,b,c) : target_fn.call(null,a,b,c));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$4 = (function (a,b,c,d){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : self__.dispatch_fn.call(null,a,b,c,d));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$4 ? target_fn.cljs$core$IFn$_invoke$arity$4(a,b,c,d) : target_fn.call(null,a,b,c,d));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$5 = (function (a,b,c,d,e){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : self__.dispatch_fn.call(null,a,b,c,d,e));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$5 ? target_fn.cljs$core$IFn$_invoke$arity$5(a,b,c,d,e) : target_fn.call(null,a,b,c,d,e));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$6 = (function (a,b,c,d,e,f){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : self__.dispatch_fn.call(null,a,b,c,d,e,f));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$6 ? target_fn.cljs$core$IFn$_invoke$arity$6(a,b,c,d,e,f) : target_fn.call(null,a,b,c,d,e,f));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$7 = (function (a,b,c,d,e,f,g){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$7 ? target_fn.cljs$core$IFn$_invoke$arity$7(a,b,c,d,e,f,g) : target_fn.call(null,a,b,c,d,e,f,g));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$8 = (function (a,b,c,d,e,f,g,h){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$8 ? target_fn.cljs$core$IFn$_invoke$arity$8(a,b,c,d,e,f,g,h) : target_fn.call(null,a,b,c,d,e,f,g,h));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$9 = (function (a,b,c,d,e,f,g,h,i){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$9 ? target_fn.cljs$core$IFn$_invoke$arity$9(a,b,c,d,e,f,g,h,i) : target_fn.call(null,a,b,c,d,e,f,g,h,i));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$10 = (function (a,b,c,d,e,f,g,h,i,j){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$10 ? target_fn.cljs$core$IFn$_invoke$arity$10(a,b,c,d,e,f,g,h,i,j) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$11 = (function (a,b,c,d,e,f,g,h,i,j,k){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$11 ? target_fn.cljs$core$IFn$_invoke$arity$11(a,b,c,d,e,f,g,h,i,j,k) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$12 = (function (a,b,c,d,e,f,g,h,i,j,k,l){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$12 ? target_fn.cljs$core$IFn$_invoke$arity$12(a,b,c,d,e,f,g,h,i,j,k,l) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$13 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$13 ? target_fn.cljs$core$IFn$_invoke$arity$13(a,b,c,d,e,f,g,h,i,j,k,l,m) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$14 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$14 ? target_fn.cljs$core$IFn$_invoke$arity$14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$15 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$15 ? target_fn.cljs$core$IFn$_invoke$arity$15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$16 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$16 ? target_fn.cljs$core$IFn$_invoke$arity$16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$17 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$17 ? target_fn.cljs$core$IFn$_invoke$arity$17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$18 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$18 ? target_fn.cljs$core$IFn$_invoke$arity$18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$19 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$19 ? target_fn.cljs$core$IFn$_invoke$arity$19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$20 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = (self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20 ? self__.dispatch_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : self__.dispatch_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn (target_fn.cljs$core$IFn$_invoke$arity$20 ? target_fn.cljs$core$IFn$_invoke$arity$20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) : target_fn.call(null,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IFn$_invoke$arity$21 = (function (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest){\nvar self__ = this;\nvar mf = this;\nvar dispatch_val = cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(self__.dispatch_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\nvar target_fn = mf.cljs$core$IMultiFn$_get_method$arity$2(null,dispatch_val);\nif(cljs.core.truth_(target_fn)){\n} else {\ncljs.core.throw_no_method_error(self__.name,dispatch_val);\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$variadic(target_fn,a,b,c,d,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,rest], 0));\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_prefer_method$arity$3 = (function (mf,dispatch_val_x,dispatch_val_y){\nvar self__ = this;\nvar mf__$1 = this;\nif(cljs.core.truth_(cljs.core.prefers_STAR_(dispatch_val_x,dispatch_val_y,self__.prefer_table))){\nthrow (new Error([\"Preference conflict in multimethod '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.name),\"': \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val_y),\" is already preferred to \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(dispatch_val_x)].join('')));\n} else {\n}\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.prefer_table,((function (mf__$1){\nreturn (function (old){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(old,dispatch_val_x,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.get.cljs$core$IFn$_invoke$arity$3(old,dispatch_val_x,cljs.core.PersistentHashSet.EMPTY),dispatch_val_y));\n});})(mf__$1))\n);\n\nreturn cljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_default_dispatch_val$arity$1 = (function (mf){\nvar self__ = this;\nvar mf__$1 = this;\nreturn self__.default_dispatch_val;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_remove_method$arity$2 = (function (mf,dispatch_val){\nvar self__ = this;\nvar mf__$1 = this;\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(self__.method_table,cljs.core.dissoc,dispatch_val);\n\ncljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n\nreturn mf__$1;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_methods$arity$1 = (function (mf){\nvar self__ = this;\nvar mf__$1 = this;\nreturn cljs.core.deref(self__.method_table);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_prefers$arity$1 = (function (mf){\nvar self__ = this;\nvar mf__$1 = this;\nreturn cljs.core.deref(self__.prefer_table);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_dispatch_fn$arity$1 = (function (mf){\nvar self__ = this;\nvar mf__$1 = this;\nreturn self__.dispatch_fn;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_add_method$arity$3 = (function (mf,dispatch_val,method){\nvar self__ = this;\nvar mf__$1 = this;\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(self__.method_table,cljs.core.assoc,dispatch_val,method);\n\ncljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n\nreturn mf__$1;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_reset$arity$1 = (function (mf){\nvar self__ = this;\nvar mf__$1 = this;\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.method_table,((function (mf__$1){\nreturn (function (mf__$2){\nreturn cljs.core.PersistentArrayMap.EMPTY;\n});})(mf__$1))\n);\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.method_cache,((function (mf__$1){\nreturn (function (mf__$2){\nreturn cljs.core.PersistentArrayMap.EMPTY;\n});})(mf__$1))\n);\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.prefer_table,((function (mf__$1){\nreturn (function (mf__$2){\nreturn cljs.core.PersistentArrayMap.EMPTY;\n});})(mf__$1))\n);\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(self__.cached_hierarchy,((function (mf__$1){\nreturn (function (mf__$2){\nreturn null;\n});})(mf__$1))\n);\n\nreturn mf__$1;\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IMultiFn$_get_method$arity$2 = (function (mf,dispatch_val){\nvar self__ = this;\nvar mf__$1 = this;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(self__.cached_hierarchy),cljs.core.deref(self__.hierarchy))){\n} else {\ncljs.core.reset_cache(self__.method_cache,self__.method_table,self__.cached_hierarchy,self__.hierarchy);\n}\n\nvar temp__5718__auto__ = (function (){var fexpr__3329 = cljs.core.deref(self__.method_cache);\nreturn (fexpr__3329.cljs$core$IFn$_invoke$arity$1 ? fexpr__3329.cljs$core$IFn$_invoke$arity$1(dispatch_val) : fexpr__3329.call(null,dispatch_val));\n})();\nif(cljs.core.truth_(temp__5718__auto__)){\nvar target_fn = temp__5718__auto__;\nreturn target_fn;\n} else {\nreturn cljs.core.find_and_cache_best_method(self__.name,dispatch_val,self__.hierarchy,self__.method_table,self__.prefer_table,self__.method_cache,self__.cached_hierarchy,self__.default_dispatch_val);\n}\n});\n\ncljs.core.MultiFn.prototype.cljs$core$INamed$_name$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core._name(self__.name);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$INamed$_namespace$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn cljs.core._namespace(self__.name);\n});\n\ncljs.core.MultiFn.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn goog.getUid(this$__$1);\n});\n\ncljs.core.MultiFn.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 8, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"name\",\"name\",-810760592,null),new cljs.core.Symbol(null,\"dispatch-fn\",\"dispatch-fn\",-1401088155,null),new cljs.core.Symbol(null,\"default-dispatch-val\",\"default-dispatch-val\",-1231201266,null),new cljs.core.Symbol(null,\"hierarchy\",\"hierarchy\",587061186,null),new cljs.core.Symbol(null,\"method-table\",\"method-table\",-1878263165,null),new cljs.core.Symbol(null,\"prefer-table\",\"prefer-table\",462168584,null),new cljs.core.Symbol(null,\"method-cache\",\"method-cache\",1230193905,null),new cljs.core.Symbol(null,\"cached-hierarchy\",\"cached-hierarchy\",-1085460203,null)], null);\n});\n\ncljs.core.MultiFn.cljs$lang$type = true;\n\ncljs.core.MultiFn.cljs$lang$ctorStr = \"cljs.core/MultiFn\";\n\ncljs.core.MultiFn.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/MultiFn\");\n});\n\n/**\n * Positional factory function for cljs.core/MultiFn.\n */\ncljs.core.__GT_MultiFn = (function cljs$core$__GT_MultiFn(name,dispatch_fn,default_dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy){\nreturn (new cljs.core.MultiFn(name,dispatch_fn,default_dispatch_val,hierarchy,method_table,prefer_table,method_cache,cached_hierarchy));\n});\n\n/**\n * Removes all of the methods of multimethod.\n */\ncljs.core.remove_all_methods = (function cljs$core$remove_all_methods(multifn){\nreturn cljs.core._reset(multifn);\n});\n/**\n * Removes the method of multimethod associated with dispatch-value.\n */\ncljs.core.remove_method = (function cljs$core$remove_method(multifn,dispatch_val){\nreturn cljs.core._remove_method(multifn,dispatch_val);\n});\n/**\n * Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n * when there is a conflict\n */\ncljs.core.prefer_method = (function cljs$core$prefer_method(multifn,dispatch_val_x,dispatch_val_y){\nreturn cljs.core._prefer_method(multifn,dispatch_val_x,dispatch_val_y);\n});\n/**\n * Given a multimethod, returns a map of dispatch values -> dispatch fns\n */\ncljs.core.methods$ = (function cljs$core$methods(multifn){\nreturn cljs.core._methods(multifn);\n});\n/**\n * Given a multimethod and a dispatch value, returns the dispatch fn\n *   that would apply to that value, or nil if none apply and no default\n */\ncljs.core.get_method = (function cljs$core$get_method(multifn,dispatch_val){\nreturn cljs.core._get_method(multifn,dispatch_val);\n});\n/**\n * Given a multimethod, returns a map of preferred value -> set of other values\n */\ncljs.core.prefers = (function cljs$core$prefers(multifn){\nreturn cljs.core._prefers(multifn);\n});\n/**\n * Given a multimethod, return it's default-dispatch-val.\n */\ncljs.core.default_dispatch_val = (function cljs$core$default_dispatch_val(multifn){\nreturn cljs.core._default_dispatch_val(multifn);\n});\n/**\n * Given a multimethod, return it's dispatch-fn.\n */\ncljs.core.dispatch_fn = (function cljs$core$dispatch_fn(multifn){\nreturn cljs.core._dispatch_fn(multifn);\n});\n\n/**\n * A marker protocol for UUIDs\n * @interface\n */\ncljs.core.IUUID = function(){};\n\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IComparable}\n * @implements {cljs.core.IUUID}\n*/\ncljs.core.UUID = (function (uuid,__hash){\nthis.uuid = uuid;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2153775104;\nthis.cljs$lang$protocol_mask$partition1$ = 2048;\n});\ncljs.core.UUID.prototype.cljs$core$IUUID$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.UUID.prototype.toString = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.uuid;\n});\n\ncljs.core.UUID.prototype.equiv = (function (other){\nvar self__ = this;\nvar this$ = this;\nreturn this$.cljs$core$IEquiv$_equiv$arity$2(null,other);\n});\n\ncljs.core.UUID.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (_,other){\nvar self__ = this;\nvar ___$1 = this;\nreturn (((other instanceof cljs.core.UUID)) && ((self__.uuid === other.uuid)));\n});\n\ncljs.core.UUID.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (_,writer,___$1){\nvar self__ = this;\nvar ___$2 = this;\nreturn cljs.core._write(writer,[\"#uuid \\\"\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.uuid),\"\\\"\"].join(''));\n});\n\ncljs.core.UUID.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nif((self__.__hash == null)){\nself__.__hash = cljs.core.hash(self__.uuid);\n} else {\n}\n\nreturn self__.__hash;\n});\n\ncljs.core.UUID.prototype.cljs$core$IComparable$_compare$arity$2 = (function (_,other){\nvar self__ = this;\nvar ___$1 = this;\nvar G__3331 = self__.uuid;\nvar G__3332 = other.uuid;\nreturn goog.array.defaultCompare(G__3331,G__3332);\n});\n\ncljs.core.UUID.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"uuid\",\"uuid\",-504564192,null),cljs.core.with_meta(new cljs.core.Symbol(null,\"__hash\",\"__hash\",-1328796629,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"mutable\",\"mutable\",875778266),true], null))], null);\n});\n\ncljs.core.UUID.cljs$lang$type = true;\n\ncljs.core.UUID.cljs$lang$ctorStr = \"cljs.core/UUID\";\n\ncljs.core.UUID.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/UUID\");\n});\n\n/**\n * Positional factory function for cljs.core/UUID.\n */\ncljs.core.__GT_UUID = (function cljs$core$__GT_UUID(uuid,__hash){\nreturn (new cljs.core.UUID(uuid,__hash));\n});\n\ncljs.core.uuid = (function cljs$core$uuid(s){\nif(typeof s === 'string'){\n} else {\nthrow (new Error(\"Assert failed: (string? s)\"));\n}\n\nreturn (new cljs.core.UUID(s.toLowerCase(),null));\n});\ncljs.core.random_uuid = (function cljs$core$random_uuid(){\nvar hex = (function cljs$core$random_uuid_$_hex(){\nreturn cljs.core.rand_int((16)).toString((16));\n});\nvar rhex = ((8) | ((3) & cljs.core.rand_int((16)))).toString((16));\nreturn cljs.core.uuid([cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),\"-\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),\"-\",\"4\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),\"-\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(rhex),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),\"-\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex()),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex())].join(''));\n});\ncljs.core.uuid_QMARK_ = (function cljs$core$uuid_QMARK_(x){\nif((!((x == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$core$IUUID$)))){\nreturn true;\n} else {\nreturn false;\n}\n} else {\nreturn false;\n}\n});\ncljs.core.pr_writer_ex_info = (function cljs$core$pr_writer_ex_info(obj,writer,opts){\ncljs.core._write(writer,\"#error {:message \");\n\ncljs.core.pr_writer(obj.message,writer,opts);\n\nif(cljs.core.truth_(obj.data)){\ncljs.core._write(writer,\", :data \");\n\ncljs.core.pr_writer(obj.data,writer,opts);\n} else {\n}\n\nif(cljs.core.truth_(obj.cause)){\ncljs.core._write(writer,\", :cause \");\n\ncljs.core.pr_writer(obj.cause,writer,opts);\n} else {\n}\n\nreturn cljs.core._write(writer,\"}\");\n});\n/**\n * @constructor\n */\ncljs.core.ExceptionInfo = (function cljs$core$ExceptionInfo(message,data,cause){\nvar e = (new Error(message));\nvar this$ = this;\nthis$.message = message;\n\nthis$.data = data;\n\nthis$.cause = cause;\n\nthis$.name = e.name;\n\nthis$.description = e.description;\n\nthis$.number = e.number;\n\nthis$.fileName = e.fileName;\n\nthis$.lineNumber = e.lineNumber;\n\nthis$.columnNumber = e.columnNumber;\n\nthis$.stack = e.stack;\n\nreturn this$;\n});\ncljs.core.ExceptionInfo.prototype.__proto__ = Error.prototype;\ncljs.core.ExceptionInfo.prototype.cljs$core$IPrintWithWriter$ = cljs.core.PROTOCOL_SENTINEL;\n\ncljs.core.ExceptionInfo.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (obj,writer,opts){\nvar obj__$1 = this;\nreturn cljs.core.pr_writer_ex_info(obj__$1,writer,opts);\n});\ncljs.core.ExceptionInfo.prototype.toString = (function (){\nvar this$ = this;\nreturn cljs.core.pr_str_STAR_(this$);\n});\n/**\n * Create an instance of ExceptionInfo, an Error type that carries a\n *   map of additional data.\n */\ncljs.core.ex_info = (function cljs$core$ex_info(var_args){\nvar G__3335 = arguments.length;\nswitch (G__3335) {\ncase 2:\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.ex_info.cljs$core$IFn$_invoke$arity$2 = (function (msg,data){\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3(msg,data,null);\n});\n\ncljs.core.ex_info.cljs$core$IFn$_invoke$arity$3 = (function (msg,data,cause){\nreturn (new cljs.core.ExceptionInfo(msg,data,cause));\n});\n\ncljs.core.ex_info.cljs$lang$maxFixedArity = 3;\n\n/**\n * Returns exception data (a map) if ex is an ExceptionInfo.\n *   Otherwise returns nil.\n */\ncljs.core.ex_data = (function cljs$core$ex_data(ex){\nif((ex instanceof cljs.core.ExceptionInfo)){\nreturn ex.data;\n} else {\nreturn null;\n}\n});\n/**\n * Returns the message attached to the given Error / ExceptionInfo object.\n *   For non-Errors returns nil.\n */\ncljs.core.ex_message = (function cljs$core$ex_message(ex){\nif((ex instanceof Error)){\nreturn ex.message;\n} else {\nreturn null;\n}\n});\n/**\n * Returns exception cause (an Error / ExceptionInfo) if ex is an\n *   ExceptionInfo.\n *   Otherwise returns nil.\n */\ncljs.core.ex_cause = (function cljs$core$ex_cause(ex){\nif((ex instanceof cljs.core.ExceptionInfo)){\nreturn ex.cause;\n} else {\nreturn null;\n}\n});\n/**\n * Returns an JavaScript compatible comparator based upon pred.\n */\ncljs.core.comparator = (function cljs$core$comparator(pred){\nreturn (function (x,y){\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(x,y) : pred.call(null,x,y)))){\nreturn (-1);\n} else {\nif(cljs.core.truth_((pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(y,x) : pred.call(null,y,x)))){\nreturn (1);\n} else {\nreturn (0);\n\n}\n}\n});\n});\n/**\n * Returns true if x names a special form\n */\ncljs.core.special_symbol_QMARK_ = (function cljs$core$special_symbol_QMARK_(x){\nreturn cljs.core.contains_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 24, [new cljs.core.Symbol(null,\"&\",\"&\",-2144855648,null),\"null\",new cljs.core.Symbol(null,\"case*\",\"case*\",-1938255072,null),\"null\",new cljs.core.Symbol(null,\"defrecord*\",\"defrecord*\",-1936366207,null),\"null\",new cljs.core.Symbol(null,\"try\",\"try\",-1273693247,null),\"null\",new cljs.core.Symbol(null,\"ns*\",\"ns*\",1840949383,null),\"null\",new cljs.core.Symbol(null,\"finally\",\"finally\",-1065347064,null),\"null\",new cljs.core.Symbol(null,\"loop*\",\"loop*\",615029416,null),\"null\",new cljs.core.Symbol(null,\"do\",\"do\",1686842252,null),\"null\",new cljs.core.Symbol(null,\"letfn*\",\"letfn*\",-110097810,null),\"null\",new cljs.core.Symbol(null,\"if\",\"if\",1181717262,null),\"null\",new cljs.core.Symbol(null,\"new\",\"new\",-444906321,null),\"null\",new cljs.core.Symbol(null,\"ns\",\"ns\",2082130287,null),\"null\",new cljs.core.Symbol(null,\"deftype*\",\"deftype*\",962659890,null),\"null\",new cljs.core.Symbol(null,\"let*\",\"let*\",1920721458,null),\"null\",new cljs.core.Symbol(null,\"js*\",\"js*\",-1134233646,null),\"null\",new cljs.core.Symbol(null,\"fn*\",\"fn*\",-752876845,null),\"null\",new cljs.core.Symbol(null,\"recur\",\"recur\",1202958259,null),\"null\",new cljs.core.Symbol(null,\"set!\",\"set!\",250714521,null),\"null\",new cljs.core.Symbol(null,\".\",\".\",1975675962,null),\"null\",new cljs.core.Symbol(null,\"var\",\"var\",870848730,null),\"null\",new cljs.core.Symbol(null,\"quote\",\"quote\",1377916282,null),\"null\",new cljs.core.Symbol(null,\"catch\",\"catch\",-1616370245,null),\"null\",new cljs.core.Symbol(null,\"throw\",\"throw\",595905694,null),\"null\",new cljs.core.Symbol(null,\"def\",\"def\",597100991,null),\"null\"], null), null),x);\n});\n/**\n * test [v] finds fn at key :test in var metadata and calls it,\n *   presuming failure will throw exception\n */\ncljs.core.test = (function cljs$core$test(v){\nvar f = v.cljs$lang$test;\nif(cljs.core.truth_(f)){\n(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n\nreturn new cljs.core.Keyword(null,\"ok\",\"ok\",967785236);\n} else {\nreturn new cljs.core.Keyword(null,\"no-test\",\"no-test\",-1679482642);\n}\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.ILookup}\n*/\ncljs.core.TaggedLiteral = (function (tag,form){\nthis.tag = tag;\nthis.form = form;\nthis.cljs$lang$protocol_mask$partition0$ = 2153775360;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.TaggedLiteral.prototype.toString = (function (){\nvar self__ = this;\nvar coll = this;\nreturn cljs.core.pr_str_STAR_(coll);\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this$,other){\nvar self__ = this;\nvar this$__$1 = this;\nreturn (((other instanceof cljs.core.TaggedLiteral)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(self__.tag,other.tag)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(self__.form,other.form)));\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$IHash$_hash$arity$1 = (function (this$){\nvar self__ = this;\nvar this$__$1 = this;\nreturn (((31) * cljs.core.hash(self__.tag)) + cljs.core.hash(self__.form));\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this$,v){\nvar self__ = this;\nvar this$__$1 = this;\nreturn this$__$1.cljs$core$ILookup$_lookup$arity$3(null,v,null);\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this$,v,not_found){\nvar self__ = this;\nvar this$__$1 = this;\nvar G__3337 = v;\nvar G__3337__$1 = (((G__3337 instanceof cljs.core.Keyword))?G__3337.fqn:null);\nswitch (G__3337__$1) {\ncase \"tag\":\nreturn self__.tag;\n\nbreak;\ncase \"form\":\nreturn self__.form;\n\nbreak;\ndefault:\nreturn not_found;\n\n}\n});\n\ncljs.core.TaggedLiteral.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (o,writer,opts){\nvar self__ = this;\nvar o__$1 = this;\ncljs.core._write(writer,[\"#\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.tag),\" \"].join(''));\n\nreturn cljs.core.pr_writer(self__.form,writer,opts);\n});\n\ncljs.core.TaggedLiteral.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"tag\",\"tag\",350170304,null),new cljs.core.Symbol(null,\"form\",\"form\",16469056,null)], null);\n});\n\ncljs.core.TaggedLiteral.cljs$lang$type = true;\n\ncljs.core.TaggedLiteral.cljs$lang$ctorStr = \"cljs.core/TaggedLiteral\";\n\ncljs.core.TaggedLiteral.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/TaggedLiteral\");\n});\n\n/**\n * Positional factory function for cljs.core/TaggedLiteral.\n */\ncljs.core.__GT_TaggedLiteral = (function cljs$core$__GT_TaggedLiteral(tag,form){\nreturn (new cljs.core.TaggedLiteral(tag,form));\n});\n\n/**\n * Return true if the value is the data representation of a tagged literal\n */\ncljs.core.tagged_literal_QMARK_ = (function cljs$core$tagged_literal_QMARK_(value){\nreturn (value instanceof cljs.core.TaggedLiteral);\n});\n/**\n * Construct a data representation of a tagged literal from a\n *   tag symbol and a form.\n */\ncljs.core.tagged_literal = (function cljs$core$tagged_literal(tag,form){\nif((tag instanceof cljs.core.Symbol)){\n} else {\nthrow (new Error(\"Assert failed: (symbol? tag)\"));\n}\n\nreturn (new cljs.core.TaggedLiteral(tag,form));\n});\n/**\n * @type {*}\n */\ncljs.core.js_reserved_arr = [\"arguments\",\"abstract\",\"await\",\"boolean\",\"break\",\"byte\",\"case\",\"catch\",\"char\",\"class\",\"const\",\"continue\",\"debugger\",\"default\",\"delete\",\"do\",\"double\",\"else\",\"enum\",\"export\",\"extends\",\"final\",\"finally\",\"float\",\"for\",\"function\",\"goto\",\"if\",\"implements\",\"import\",\"in\",\"instanceof\",\"int\",\"interface\",\"let\",\"long\",\"native\",\"new\",\"package\",\"private\",\"protected\",\"public\",\"return\",\"short\",\"static\",\"super\",\"switch\",\"synchronized\",\"this\",\"throw\",\"throws\",\"transient\",\"try\",\"typeof\",\"var\",\"void\",\"volatile\",\"while\",\"with\",\"yield\",\"methods\",\"null\",\"constructor\"];\n/**\n * @type {null|Object}\n */\ncljs.core.js_reserved = null;\ncljs.core.js_reserved_QMARK_ = (function cljs$core$js_reserved_QMARK_(x){\nif((cljs.core.js_reserved == null)){\ncljs.core.js_reserved = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__3339_SHARP_,p2__3340_SHARP_){\ngoog.object.set(p1__3339_SHARP_,p2__3340_SHARP_,true);\n\nreturn p1__3339_SHARP_;\n}),({}),cljs.core.js_reserved_arr);\n} else {\n}\n\nreturn cljs.core.js_reserved.hasOwnProperty(x);\n});\ncljs.core.demunge_pattern = (function cljs$core$demunge_pattern(){\nif(cljs.core.truth_(cljs.core.DEMUNGE_PATTERN)){\n} else {\ncljs.core.DEMUNGE_PATTERN = (function (){var ks = cljs.core.sort.cljs$core$IFn$_invoke$arity$2((function (a,b){\nreturn (b.length - a.length);\n}),cljs.core.js_keys(cljs.core.DEMUNGE_MAP));\nvar ks__$1 = ks;\nvar ret = \"\";\nwhile(true){\nif(cljs.core.seq(ks__$1)){\nvar G__3343 = cljs.core.next(ks__$1);\nvar G__3344 = [(function (){var G__3342 = ret;\nif((!((ret === \"\")))){\nreturn [G__3342,\"|\"].join('');\n} else {\nreturn G__3342;\n}\n})(),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(ks__$1))].join('');\nks__$1 = G__3343;\nret = G__3344;\ncontinue;\n} else {\nreturn [ret,\"|\\\\$\"].join('');\n}\nbreak;\n}\n})();\n}\n\nreturn cljs.core.DEMUNGE_PATTERN;\n});\ncljs.core.munge_str = (function cljs$core$munge_str(name){\nvar sb = (new goog.string.StringBuffer());\nvar i_3345 = (0);\nwhile(true){\nif((i_3345 < name.length)){\nvar c_3346 = name.charAt(i_3345);\nvar sub_3347 = goog.object.get(cljs.core.CHAR_MAP,c_3346);\nif((!((sub_3347 == null)))){\nsb.append(sub_3347);\n} else {\nsb.append(c_3346);\n}\n\nvar G__3348 = (i_3345 + (1));\ni_3345 = G__3348;\ncontinue;\n} else {\n}\nbreak;\n}\n\nreturn sb.toString();\n});\ncljs.core.munge = (function cljs$core$munge(name){\nvar name_SINGLEQUOTE_ = cljs.core.munge_str(cljs.core.str.cljs$core$IFn$_invoke$arity$1(name));\nvar name_SINGLEQUOTE___$1 = (((name_SINGLEQUOTE_ === \"..\"))?\"_DOT__DOT_\":(cljs.core.truth_(cljs.core.js_reserved_QMARK_(name_SINGLEQUOTE_))?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(name_SINGLEQUOTE_),\"$\"].join(''):name_SINGLEQUOTE_\n));\nif((name instanceof cljs.core.Symbol)){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1(name_SINGLEQUOTE___$1);\n} else {\nreturn name_SINGLEQUOTE___$1;\n}\n});\ncljs.core.demunge_str = (function cljs$core$demunge_str(munged_name){\nvar r = (new RegExp(cljs.core.demunge_pattern(),\"g\"));\nvar munged_name__$1 = (cljs.core.truth_(goog.string.endsWith(munged_name,\"$\"))?munged_name.substring((0),(munged_name.length - (1))):munged_name);\nvar ret = \"\";\nvar last_match_end = (0);\nwhile(true){\nvar temp__5718__auto__ = r.exec(munged_name__$1);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar match = temp__5718__auto__;\nvar vec__3352 = match;\nvar x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__3352,(0),null);\nvar G__3355 = [ret,cljs.core.str.cljs$core$IFn$_invoke$arity$1(munged_name__$1.substring(last_match_end,(r.lastIndex - x.length))),cljs.core.str.cljs$core$IFn$_invoke$arity$1((((x === \"$\"))?\"/\":goog.object.get(cljs.core.DEMUNGE_MAP,x)))].join('');\nvar G__3356 = r.lastIndex;\nret = G__3355;\nlast_match_end = G__3356;\ncontinue;\n} else {\nreturn [ret,cljs.core.str.cljs$core$IFn$_invoke$arity$1(munged_name__$1.substring(last_match_end,munged_name__$1.length))].join('');\n}\nbreak;\n}\n});\ncljs.core.demunge = (function cljs$core$demunge(name){\nvar G__3358 = (function (){var name_SINGLEQUOTE_ = cljs.core.str.cljs$core$IFn$_invoke$arity$1(name);\nif((name_SINGLEQUOTE_ === \"_DOT__DOT_\")){\nreturn \"..\";\n} else {\nreturn cljs.core.demunge_str(name_SINGLEQUOTE_);\n}\n})();\nvar fexpr__3357 = (((name instanceof cljs.core.Symbol))?cljs.core.symbol:cljs.core.str);\nreturn (fexpr__3357.cljs$core$IFn$_invoke$arity$1 ? fexpr__3357.cljs$core$IFn$_invoke$arity$1(G__3358) : fexpr__3357.call(null,G__3358));\n});\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core.tapset !== 'undefined')){\n} else {\n/**\n * @type {*}\n */\ncljs.core.tapset = null;\n}\ncljs.core.maybe_init_tapset = (function cljs$core$maybe_init_tapset(){\nif((cljs.core.tapset == null)){\nreturn cljs.core.tapset = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentHashSet.EMPTY);\n} else {\nreturn null;\n}\n});\n/**\n * Adds f, a fn of one argument, to the tap set. This function will be called with\n *   anything sent via tap>. Remember f in order to remove-tap\n */\ncljs.core.add_tap = (function cljs$core$add_tap(f){\ncljs.core.maybe_init_tapset();\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(cljs.core.tapset,cljs.core.conj,f);\n\nreturn null;\n});\n/**\n * Remove f from the tap set.\n */\ncljs.core.remove_tap = (function cljs$core$remove_tap(f){\ncljs.core.maybe_init_tapset();\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(cljs.core.tapset,cljs.core.disj,f);\n\nreturn null;\n});\n/**\n * Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.\n */\ncljs.core.tap_GT_ = (function cljs$core$tap_GT_(x){\ncljs.core.maybe_init_tapset();\n\nreturn (cljs.core._STAR_exec_tap_fn_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_exec_tap_fn_STAR_.cljs$core$IFn$_invoke$arity$1((function (){\nvar seq__3359 = cljs.core.seq(cljs.core.deref(cljs.core.tapset));\nvar chunk__3360 = null;\nvar count__3361 = (0);\nvar i__3362 = (0);\nwhile(true){\nif((i__3362 < count__3361)){\nvar tap = chunk__3360.cljs$core$IIndexed$_nth$arity$2(null,i__3362);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e3365){if((e3365 instanceof Error)){\nvar ex_3367 = e3365;\n} else {\nthrow e3365;\n\n}\n}\n\nvar G__3368 = seq__3359;\nvar G__3369 = chunk__3360;\nvar G__3370 = count__3361;\nvar G__3371 = (i__3362 + (1));\nseq__3359 = G__3368;\nchunk__3360 = G__3369;\ncount__3361 = G__3370;\ni__3362 = G__3371;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__3359);\nif(temp__5720__auto__){\nvar seq__3359__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__3359__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__3359__$1);\nvar G__3372 = cljs.core.chunk_rest(seq__3359__$1);\nvar G__3373 = c__4550__auto__;\nvar G__3374 = cljs.core.count(c__4550__auto__);\nvar G__3375 = (0);\nseq__3359 = G__3372;\nchunk__3360 = G__3373;\ncount__3361 = G__3374;\ni__3362 = G__3375;\ncontinue;\n} else {\nvar tap = cljs.core.first(seq__3359__$1);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e3366){if((e3366 instanceof Error)){\nvar ex_3376 = e3366;\n} else {\nthrow e3366;\n\n}\n}\n\nvar G__3377 = cljs.core.next(seq__3359__$1);\nvar G__3378 = null;\nvar G__3379 = (0);\nvar G__3380 = (0);\nseq__3359 = G__3377;\nchunk__3360 = G__3378;\ncount__3361 = G__3379;\ni__3362 = G__3380;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n})) : cljs.core._STAR_exec_tap_fn_STAR_.call(null,(function (){\nvar seq__3359 = cljs.core.seq(cljs.core.deref(cljs.core.tapset));\nvar chunk__3360 = null;\nvar count__3361 = (0);\nvar i__3362 = (0);\nwhile(true){\nif((i__3362 < count__3361)){\nvar tap = chunk__3360.cljs$core$IIndexed$_nth$arity$2(null,i__3362);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e3365){if((e3365 instanceof Error)){\nvar ex_3381 = e3365;\n} else {\nthrow e3365;\n\n}\n}\n\nvar G__3382 = seq__3359;\nvar G__3383 = chunk__3360;\nvar G__3384 = count__3361;\nvar G__3385 = (i__3362 + (1));\nseq__3359 = G__3382;\nchunk__3360 = G__3383;\ncount__3361 = G__3384;\ni__3362 = G__3385;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__3359);\nif(temp__5720__auto__){\nvar seq__3359__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__3359__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__3359__$1);\nvar G__3386 = cljs.core.chunk_rest(seq__3359__$1);\nvar G__3387 = c__4550__auto__;\nvar G__3388 = cljs.core.count(c__4550__auto__);\nvar G__3389 = (0);\nseq__3359 = G__3386;\nchunk__3360 = G__3387;\ncount__3361 = G__3388;\ni__3362 = G__3389;\ncontinue;\n} else {\nvar tap = cljs.core.first(seq__3359__$1);\ntry{(tap.cljs$core$IFn$_invoke$arity$1 ? tap.cljs$core$IFn$_invoke$arity$1(x) : tap.call(null,x));\n}catch (e3366){if((e3366 instanceof Error)){\nvar ex_3390 = e3366;\n} else {\nthrow e3366;\n\n}\n}\n\nvar G__3391 = cljs.core.next(seq__3359__$1);\nvar G__3392 = null;\nvar G__3393 = (0);\nvar G__3394 = (0);\nseq__3359 = G__3391;\nchunk__3360 = G__3392;\ncount__3361 = G__3393;\ni__3362 = G__3394;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n})));\n});\n/**\n * Bootstrap only.\n */\ncljs.core.ns_lookup = (function cljs$core$ns_lookup(ns_obj,k){\nreturn (function (){\nreturn goog.object.get(ns_obj,k);\n});\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n*/\ncljs.core.Namespace = (function (obj,name){\nthis.obj = obj;\nthis.name = name;\nthis.cljs$lang$protocol_mask$partition0$ = 6291456;\nthis.cljs$lang$protocol_mask$partition1$ = 0;\n});\ncljs.core.Namespace.prototype.findInternedVar = (function (sym){\nvar self__ = this;\nvar this$ = this;\nvar k = cljs.core.munge(cljs.core.str.cljs$core$IFn$_invoke$arity$1(sym));\nif(goog.object.containsKey(self__.obj,k)){\nvar var_sym = cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.name),cljs.core.str.cljs$core$IFn$_invoke$arity$1(sym));\nvar var_meta = new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),this$], null);\nreturn (new cljs.core.Var(cljs.core.ns_lookup(self__.obj,k),var_sym,var_meta));\n} else {\nreturn null;\n}\n});\n\ncljs.core.Namespace.prototype.getName = (function (){\nvar self__ = this;\nvar _ = this;\nreturn self__.name;\n});\n\ncljs.core.Namespace.prototype.toString = (function (){\nvar self__ = this;\nvar _ = this;\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(self__.name);\n});\n\ncljs.core.Namespace.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (_,other){\nvar self__ = this;\nvar ___$1 = this;\nif((other instanceof cljs.core.Namespace)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(self__.name,other.name);\n} else {\nreturn false;\n}\n});\n\ncljs.core.Namespace.prototype.cljs$core$IHash$_hash$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.hash(self__.name);\n});\n\ncljs.core.Namespace.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"obj\",\"obj\",-1672671807,null),new cljs.core.Symbol(null,\"name\",\"name\",-810760592,null)], null);\n});\n\ncljs.core.Namespace.cljs$lang$type = true;\n\ncljs.core.Namespace.cljs$lang$ctorStr = \"cljs.core/Namespace\";\n\ncljs.core.Namespace.cljs$lang$ctorPrWriter = (function (this__4374__auto__,writer__4375__auto__,opt__4376__auto__){\nreturn cljs.core._write(writer__4375__auto__,\"cljs.core/Namespace\");\n});\n\n/**\n * Positional factory function for cljs.core/Namespace.\n */\ncljs.core.__GT_Namespace = (function cljs$core$__GT_Namespace(obj,name){\nreturn (new cljs.core.Namespace(obj,name));\n});\n\n/**\n * Bootstrap only.\n * @type {*}\n */\ncljs.core.NS_CACHE = null;\n/**\n * Bootstrap only.\n */\ncljs.core.find_ns_obj_STAR_ = (function cljs$core$find_ns_obj_STAR_(ctxt,xs){\nwhile(true){\nif((ctxt == null)){\nreturn null;\n} else {\nif((xs == null)){\nreturn ctxt;\n} else {\nvar G__3397 = (function (){var G__3395 = ctxt;\nvar G__3396 = cljs.core.first(xs);\nreturn goog.object.get(G__3395,G__3396);\n})();\nvar G__3398 = cljs.core.next(xs);\nctxt = G__3397;\nxs = G__3398;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n/**\n * Bootstrap only.\n */\ncljs.core.find_ns_obj = (function cljs$core$find_ns_obj(ns){\nvar munged_ns = cljs.core.munge(cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns));\nvar segs = munged_ns.split(\".\");\nvar G__3399 = cljs.core._STAR_target_STAR_;\nswitch (G__3399) {\ncase \"nodejs\":\nif(COMPILED){\nreturn cljs.core.find_ns_obj_STAR_((function (){try{var ctxt = eval(cljs.core.first(segs));\nif(cljs.core.truth_((function (){var and__4120__auto__ = ctxt;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core.object_QMARK_(ctxt);\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn ctxt;\n} else {\nreturn null;\n}\n}catch (e3400){if((e3400 instanceof ReferenceError)){\nvar e = e3400;\nreturn null;\n} else {\nthrow e3400;\n\n}\n}})(),cljs.core.next(segs));\n} else {\nreturn cljs.core.find_ns_obj_STAR_(goog.global,segs);\n}\n\nbreak;\ncase \"default\":\ncase \"webworker\":\nreturn cljs.core.find_ns_obj_STAR_(goog.global,segs);\n\nbreak;\ndefault:\nthrow (new Error([\"find-ns-obj not supported for target \",cljs.core._STAR_target_STAR_].join('')));\n\n}\n});\n/**\n * Returns a map of the intern mappings for the namespace.\n *   Bootstrap only.\n */\ncljs.core.ns_interns_STAR_ = (function cljs$core$ns_interns_STAR_(sym){\nvar ns_obj = cljs.core.find_ns_obj(sym);\nvar ns = (new cljs.core.Namespace(ns_obj,sym));\nvar step = ((function (ns_obj,ns){\nreturn (function cljs$core$ns_interns_STAR__$_step(ret,k){\nvar var_sym = cljs.core.symbol.cljs$core$IFn$_invoke$arity$1(cljs.core.demunge(k));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ret,var_sym,(new cljs.core.Var(((function (var_sym,ns_obj,ns){\nreturn (function (){\nreturn goog.object.get(ns_obj,k);\n});})(var_sym,ns_obj,ns))\n,cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(cljs.core.str.cljs$core$IFn$_invoke$arity$1(sym),cljs.core.str.cljs$core$IFn$_invoke$arity$1(var_sym)),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns], null))));\n});})(ns_obj,ns))\n;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(step,cljs.core.PersistentArrayMap.EMPTY,cljs.core.js_keys(ns_obj));\n});\n/**\n * Create a new namespace named by the symbol. Bootstrap only.\n */\ncljs.core.create_ns = (function cljs$core$create_ns(var_args){\nvar G__3403 = arguments.length;\nswitch (G__3403) {\ncase 1:\nreturn cljs.core.create_ns.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.core.create_ns.cljs$core$IFn$_invoke$arity$1 = (function (sym){\nreturn cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2(sym,cljs.core.find_ns_obj(sym));\n});\n\ncljs.core.create_ns.cljs$core$IFn$_invoke$arity$2 = (function (sym,ns_obj){\nreturn (new cljs.core.Namespace(ns_obj,sym));\n});\n\ncljs.core.create_ns.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns the namespace named by the symbol or nil if it doesn't exist.\n *   Bootstrap only.\n */\ncljs.core.find_ns = (function cljs$core$find_ns(ns){\nif((cljs.core.NS_CACHE == null)){\ncljs.core.NS_CACHE = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\n} else {\n}\n\nvar the_ns = cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.NS_CACHE),ns);\nif((!((the_ns == null)))){\nreturn the_ns;\n} else {\nvar ns_obj = cljs.core.find_ns_obj(ns);\nif((ns_obj == null)){\nreturn null;\n} else {\nvar new_ns = cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2(ns,ns_obj);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(cljs.core.NS_CACHE,cljs.core.assoc,ns,new_ns);\n\nreturn new_ns;\n}\n}\n});\n/**\n * Returns the macros namespace named by the symbol or nil if it doesn't exist.\n *   Bootstrap only.\n */\ncljs.core.find_macros_ns = (function cljs$core$find_macros_ns(ns){\nif((cljs.core.NS_CACHE == null)){\ncljs.core.NS_CACHE = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\n} else {\n}\n\nvar ns_str = cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns);\nvar ns__$1 = (((!(goog.string.contains(ns_str,\"$macros\"))))?cljs.core.symbol.cljs$core$IFn$_invoke$arity$1([ns_str,\"$macros\"].join('')):ns);\nvar the_ns = cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(cljs.core.NS_CACHE),ns__$1);\nif((!((the_ns == null)))){\nreturn the_ns;\n} else {\nvar ns_obj = cljs.core.find_ns_obj(ns__$1);\nif((ns_obj == null)){\nreturn null;\n} else {\nvar new_ns = cljs.core.create_ns.cljs$core$IFn$_invoke$arity$2(ns__$1,ns_obj);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(cljs.core.NS_CACHE,cljs.core.assoc,ns__$1,new_ns);\n\nreturn new_ns;\n}\n}\n});\n/**\n * Returns the name of the namespace, a Namespace object.\n *   Bootstrap only.\n */\ncljs.core.ns_name = (function cljs$core$ns_name(ns_obj){\nreturn ns_obj.name;\n});\n/**\n * Returns true x is a goog.Uri instance.\n */\ncljs.core.uri_QMARK_ = (function cljs$core$uri_QMARK_(x){\nreturn (x instanceof goog.Uri);\n});\ncljs.core.maybe_enable_print_BANG_ = (function cljs$core$maybe_enable_print_BANG_(){\nif((typeof console !== 'undefined')){\nreturn cljs.core.enable_console_print_BANG_();\n} else {\nif((((cljs.core._STAR_target_STAR_ === \"nashorn\")) || ((cljs.core._STAR_target_STAR_ === \"graaljs\")))){\nvar system = Java.type(\"java.lang.System\");\ncljs.core._STAR_print_newline_STAR_ = false;\n\ncljs.core.set_print_fn_BANG_(((function (system){\nreturn (function (){\nvar xs = arguments;\nvar s = goog.array.clone(xs).join(\"\");\nreturn system.out.println(s);\n});})(system))\n);\n\nreturn cljs.core.set_print_err_fn_BANG_(((function (system){\nreturn (function (){\nvar xs = arguments;\nvar s = goog.array.clone(xs).join(\"\");\nreturn system.error.println(s);\n});})(system))\n);\n} else {\nreturn null;\n}\n}\n});\ncljs.core.maybe_enable_print_BANG_();\nif((typeof cljs !== 'undefined') && (typeof cljs.core !== 'undefined') && (typeof cljs.core._STAR_eval_STAR_ !== 'undefined')){\n} else {\n/**\n * Runtime environments may provide a way to evaluate ClojureScript\n *   forms. Whatever function *eval* is bound to will be passed any forms which\n *   should be evaluated.\n */\ncljs.core._STAR_eval_STAR_ = (function cljs$core$_STAR_eval_STAR_(_){\nthrow (new Error(\"cljs.core/*eval* not bound\"));\n});\n}\n/**\n * Evaluates the form data structure (not text!) and returns the result.\n *   Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n *   which sets up an implementation of cljs.core/*eval* for that environment.\n */\ncljs.core.eval = (function cljs$core$eval(form){\nreturn (cljs.core._STAR_eval_STAR_.cljs$core$IFn$_invoke$arity$1 ? cljs.core._STAR_eval_STAR_.cljs$core$IFn$_invoke$arity$1(form) : cljs.core._STAR_eval_STAR_.call(null,form));\n});\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/spec/test/alpha.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.spec.test.alpha",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.test.alpha\n  (:require-macros [cljs.spec.test.alpha :as m :refer [with-instrument-disabled setup-static-dispatches]])\n  (:require\n    [goog.object :as gobj]\n    [goog.userAgent.product :as product]\n    [clojure.string :as string]\n    [cljs.stacktrace :as st]\n    [cljs.pprint :as pp]\n    [cljs.spec.alpha :as s]\n    [cljs.spec.gen.alpha :as gen]))\n\n(defn distinct-by\n  ([f coll]\n   (let [step (fn step [xs seen]\n                (lazy-seq\n                  ((fn [[x :as xs] seen]\n                     (when-let [s (seq xs)]\n                       (let [v (f x)]\n                         (if (contains? seen v)\n                           (recur (rest s) seen)\n                           (cons x (step (rest s) (conj seen v)))))))\n                    xs seen)))]\n     (step coll #{}))))\n\n(defn ->sym\n  [x]\n  (@#'s/->sym x))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; instrument ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^:private ^:dynamic *instrument-enabled*\n  \"if false, instrumented fns call straight through\"\n  true)\n\n(defn get-host-port []\n  (if (not= \"browser\" *target*)\n    {}\n    {:host (.. js/window -location -host)\n     :port (.. js/window -location -port)}))\n\n(defn get-ua-product []\n  (if (not= \"browser\" *target*)\n    (keyword *target*)\n    (cond\n      product/SAFARI :safari\n      product/CHROME :chrome\n      product/FIREFOX :firefox\n      product/IE :ie)))\n\n(defn get-env []\n  {:ua-product (get-ua-product)})\n\n(defn- fn-spec?\n  \"Fn-spec must include at least :args or :ret specs.\"\n  [m]\n  (or (:args m) (:ret m)))\n\n;; wrap spec/explain-data until specs always return nil for ok data\n(defn- explain-data*\n  [spec v]\n  (when-not (s/valid? spec v nil)\n    (s/explain-data spec v)))\n\n(defn- find-caller [st]\n  (letfn [(search-spec-fn [frame]\n            (when frame\n              (let [s (:function frame)]\n                (and (string? s) (not (string/blank? s))\n                     (re-find #\"cljs\\.spec\\.test\\.spec_checking_fn\" s)))))]\n    (->> st\n         (drop-while #(not (search-spec-fn %)))\n         (drop-while search-spec-fn)\n         first)))\n\n;; TODO: check ::caller result in other browsers - David\n\n(defn- spec-checking-fn\n  [v f fn-spec]\n  (let [fn-spec (@#'s/maybe-spec fn-spec)\n        args-spec (:args fn-spec)\n        conform! (fn [v role spec data args]\n                   (let [conformed (s/conform spec data)]\n                     (if (= ::s/invalid conformed)\n                       (let [caller (find-caller\n                                      (st/parse-stacktrace\n                                        (get-host-port)\n                                        (.-stack (js/Error.))\n                                        (get-env) nil))\n                             ed (merge (assoc (s/explain-data* spec [] [] [] data)\n                                         ::s/fn (->sym v)\n                                         ::s/args args\n                                         ::s/failure :instrument)\n                                  (when caller\n                                    {::caller caller}))]\n                         (throw (ex-info\n                                  (str \"Call to \" v \" did not conform to spec.\" )\n                                  ed)))\n                       conformed)))\n        pure-variadic? (and (-> (meta v) :top-fn :variadic?)\n                            (zero? (-> (meta v) :top-fn :max-fixed-arity)))\n        apply' (fn [f args]\n                 (if (and (nil? args)\n                          pure-variadic?)\n                   (.cljs$core$IFn$_invoke$arity$variadic f)\n                   (apply f args)))\n        conform!* #(conform! v :args args-spec % %)\n        ret (if args-spec\n              (fn [& args]\n                (if *instrument-enabled*\n                  (with-instrument-disabled\n                    (conform!* args)\n                    (binding [*instrument-enabled* true]\n                      (apply' f args)))\n                  (apply' f args)))\n              f)]\n    (when (and (not pure-variadic?) args-spec)\n      (setup-static-dispatches f ret conform!* 20)\n      (when-some [variadic (.-cljs$core$IFn$_invoke$arity$variadic f)]\n        (set! (.-cljs$core$IFn$_invoke$arity$variadic ret)\n          (fn [& args]\n            (if *instrument-enabled*\n              (with-instrument-disabled\n                (conform!* (apply list* args))\n                (binding [*instrument-enabled* true]\n                  (apply' variadic args)))\n              (apply' variadic args))))))\n    ret))\n\n(defn- no-fspec\n  [v spec]\n  (ex-info (str \"Fn at \" v \" is not spec'ed.\")\n    {:var v :spec spec ::s/failure :no-fspec}))\n\n(defonce ^:private instrumented-vars (atom {}))\n\n(defn- instrument-choose-fn\n  \"Helper for instrument.\"\n  [f spec sym {over :gen :keys [stub replace]}]\n  (if (some #{sym} stub)\n    (-> spec (s/gen over) gen/generate)\n    (get replace sym f)))\n\n(defn- instrument-choose-spec\n  \"Helper for instrument\"\n  [spec sym {overrides :spec}]\n  (get overrides sym spec))\n\n(defn- instrument-1*\n  [s v opts]\n  (let [spec (s/get-spec v)\n        {:keys [raw wrapped]} (get @instrumented-vars v)\n        current @v\n        to-wrap (if (= wrapped current) raw current)\n        ospec (or (instrument-choose-spec spec s opts)\n                (throw (no-fspec v spec)))\n        ofn (instrument-choose-fn to-wrap ospec s opts)\n        checked (spec-checking-fn v ofn ospec)]\n    (swap! instrumented-vars assoc v {:raw to-wrap :wrapped checked})\n    checked))\n\n(defn- unstrument-1*\n  [s v]\n  (when v\n    (when-let [{:keys [raw wrapped]} (get @instrumented-vars v)]\n      (swap! instrumented-vars dissoc v)\n      (let [current @v]\n        (when (= wrapped current)\n          raw)))))\n\n(defn- fn-spec-name?\n  [s]\n  (symbol? s))\n\n(defn- collectionize\n  [x]\n  (if (symbol? x)\n    (list x)\n    x))\n\n(defn instrumentable-syms\n  \"Given an opts map as per instrument, returns the set of syms\nthat can be instrumented.\"\n  ([] (instrumentable-syms nil))\n  ([opts]\n   (assert (every? ident? (keys (:gen opts))) \"instrument :gen expects ident keys\")\n   (reduce into #{} [(filter fn-spec-name? (keys (s/registry)))\n                     (keys (:spec opts))\n                     (:stub opts)\n                     (keys (:replace opts))])))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; testing  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- explain-check\n  [args spec v role]\n  (ex-info\n    \"Specification-based check failed\"\n    (when-not (s/valid? spec v nil)\n      (assoc (s/explain-data* spec [role] [] [] v)\n        ::args args\n        ::val v\n        ::s/failure :check-failed))))\n\n(defn- check-call\n  \"Returns true if call passes specs, otherwise *returns* an exception\nwith explain-data + ::s/failure.\"\n  [f specs args]\n  (let [cargs (when (:args specs) (s/conform (:args specs) args))]\n    (if (= cargs ::s/invalid)\n      (explain-check args (:args specs) args :args)\n      (let [ret (apply f args)\n            cret (when (:ret specs) (s/conform (:ret specs) ret))]\n        (if (= cret ::s/invalid)\n          (explain-check args (:ret specs) ret :ret)\n          (if (and (:args specs) (:ret specs) (:fn specs))\n            (if (s/valid? (:fn specs) {:args cargs :ret cret})\n              true\n              (explain-check args (:fn specs) {:args cargs :ret cret} :fn))\n            true))))))\n\n(defn- quick-check\n  [f specs {gen :gen opts :clojure.spec.test.check/opts}]\n  (let [{:keys [num-tests] :or {num-tests 1000}} opts\n        g (try (s/gen (:args specs) gen) (catch js/Error t t))]\n    (if (instance? js/Error g)\n      {:result g}\n      (let [prop (gen/for-all* [g] #(check-call f specs %))]\n        (apply gen/quick-check num-tests prop (mapcat identity opts))))))\n\n(defn- make-check-result\n  \"Builds spec result map.\"\n  [check-sym spec test-check-ret tc-ret-key]\n  (merge {:spec spec\n          tc-ret-key test-check-ret}\n    (when check-sym\n      {:sym check-sym})\n    (when-let [result (-> test-check-ret :result)]\n      (when-not (true? result) {:failure result}))\n    (when-let [shrunk (-> test-check-ret :shrunk)]\n      {:failure (:result shrunk)})))\n\n(defn validate-check-opts\n  [opts]\n  (assert (every? ident? (keys (:gen opts))) \"check :gen expects ident keys\"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; check reporting  ;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn- failure-type\n  [x]\n  (::s/failure (ex-data x)))\n\n(defn- unwrap-failure\n  [x]\n  (if (failure-type x)\n    (ex-data x)\n    x))\n\n(defn- result-type\n  \"Returns the type of the check result. This can be any of the\n::s/failure keywords documented in 'check', or:\n\n  :check-passed   all checked fn returns conformed\n  :check-threw    checked fn threw an exception\"\n  [ret]\n  (let [failure (:failure ret)]\n    (cond\n      (nil? failure) :check-passed\n      (failure-type failure) (failure-type failure)\n      :default :check-threw)))\n\n(defn abbrev-result\n  \"Given a check result, returns an abbreviated version\nsuitable for summary use.\"\n  [x]\n  (if (:failure x)\n    (-> (dissoc x :clojure.spec.test.check/ret)\n      (update :spec s/describe)\n      (update :failure unwrap-failure))\n    (dissoc x :spec :clojure.spec.test.check/opts)))\n\n(defn summarize-results\n  \"Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result.\"\n  ([check-results] (summarize-results check-results abbrev-result))\n  ([check-results summary-result]\n   (reduce\n     (fn [summary result]\n       (pp/pprint (summary-result result))\n       (-> summary\n         (update :total inc)\n         (update (result-type result) (fnil inc 0))))\n     {:total 0}\n     check-results)))\n\n(comment\n  (require\n    '[cljs.pprint :as pp]\n    '[cljs.spec :as s]\n    '[cljs.spec.gen :as gen]\n    '[cljs.test :as ctest])\n\n  (require :reload '[cljs.spec.test :as test])\n\n  ;; discover speced vars for your own test runner\n  (s/speced-vars)\n\n  ;; check a single var\n  (test/check-var #'-)\n  (test/check-var #'+)\n  (test/check-var #'clojure.spec.broken-specs/throwing-fn)\n\n  ;; old style example tests\n  (ctest/run-all-tests)\n\n  (s/speced-vars 'clojure.spec.correct-specs)\n  ;; new style spec tests return same kind of map\n  (test/check-var #'subs)\n  (cljs.spec.test/run-tests 'clojure.core)\n  (test/run-all-tests)\n\n  ;; example evaluation\n  (defn ranged-rand\n    \"Returns random int in range start <= rand < end\"\n    [start end]\n    (+ start (long (rand (- end start)))))\n\n  (s/fdef ranged-rand\n    :args (s/and (s/cat :start int? :end int?)\n                 #(< (:start %) (:end %)))\n    :ret  int?\n    :fn   (s/and #(>= (:ret %) (-> % :args :start))\n                 #(< (:ret %) (-> % :args :end))))\n\n  (instrumentable-syms)\n\n  (m/instrument-1 `ranged-rand {})\n  (m/unstrument-1 `ranged-rand)\n\n  (m/instrument)\n  (m/instrument `ranged-rand)\n  (m/instrument `[ranged-rand])\n\n  (m/unstrument)\n  (m/unstrument `ranged-rand)\n  (m/unstrument `[ranged-rand])\n\n  (ranged-rand 8 5)\n  (defn foo\n    ([a])\n    ([a b]\n     (ranged-rand 8 5)))\n  (foo 1 2)\n  (m/unstrument-1 `ranged-rand)\n\n  (m/check-1 `ranged-rand nil nil {})\n\n  (m/check-fn inc\n    (s/fspec\n      :args (s/cat :x int?)\n      :ret  int?))\n\n  (m/checkable-syms)\n\n  (m/check `ranged-rand)\n  )\n\n\n\n\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/core$macros.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.core",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.core\n  (:refer-clojure :exclude [-> ->> .. amap and areduce alength aclone assert assert-args binding bound-fn case comment\n                            cond condp declare definline definterface defmethod defmulti defn defn- defonce\n                            defprotocol defrecord defstruct deftype delay destructure doseq dosync dotimes doto\n                            extend-protocol extend-type fn for future gen-class gen-interface\n                            if-let if-not import io! lazy-cat lazy-seq let letfn locking loop\n                            memfn ns or proxy proxy-super pvalues refer-clojure reify sync time\n                            when when-first when-let when-not while with-bindings with-in-str\n                            with-loading-context with-local-vars with-open with-out-str with-precision with-redefs\n                            satisfies? identical? true? false? number? nil? instance? symbol? keyword? string? str get\n                            make-array vector list hash-map array-map hash-set\n\n                            aget aset\n                            + - * / < <= > >= == zero? pos? neg? inc dec max min mod\n                            byte char short int long float double\n                            unchecked-byte unchecked-char unchecked-short unchecked-int\n                            unchecked-long unchecked-float unchecked-double\n                            unchecked-add unchecked-add-int unchecked-dec unchecked-dec-int\n                            unchecked-divide unchecked-divide-int unchecked-inc unchecked-inc-int\n                            unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int\n                            unchecked-subtract unchecked-subtract-int unchecked-remainder-int\n                            unsigned-bit-shift-right\n\n                            bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set\n                            bit-test bit-shift-left bit-shift-right bit-xor defmacro\n\n                            cond-> cond->> as-> some-> some->>\n\n                            require use refer-clojure\n\n                            if-some when-some test ns-publics ns-imports ns-interns\n                            ns-unmap var vswap! macroexpand-1 macroexpand\n                            some? resolve\n                            #?@(:cljs [alias coercive-not coercive-not= coercive-= coercive-boolean\n                                       truth_ js-arguments js-delete js-in js-debugger exists? divide js-mod\n                                       unsafe-bit-and bit-shift-right-zero-fill mask bitpos caching-hash\n                                       defcurried rfn specify! js-this this-as implements? array js-obj\n                                       simple-benchmark gen-apply-to js-str es6-iterable load-file* undefined?\n                                       specify copy-arguments goog-define js-comment js-inline-comment\n                                       unsafe-cast require-macros use-macros gen-apply-to-simple unchecked-get unchecked-set])])\n  #?(:cljs (:require-macros [cljs.core :as core]\n                            [cljs.support :refer [assert-args]]))\n  (:require clojure.walk\n            clojure.set\n            [clojure.string :as string]\n            [cljs.compiler :as comp]\n            [cljs.env :as env]\n            #?(:clj [cljs.support :refer [assert-args]])\n            #?(:cljs [cljs.core :as core])\n            #?(:cljs [cljs.analyzer :as ana])))\n\n#?(:clj (alias 'core 'clojure.core))\n#?(:clj (alias 'ana 'cljs.analyzer))\n\n#?(:clj\n   (core/defmacro import-macros [ns [& vars]]\n     (core/let [ns (find-ns ns)\n                vars (map #(ns-resolve ns %) vars)\n                syms (map\n                       (core/fn [^clojure.lang.Var v]\n                         (core/-> v .sym\n                           (with-meta\n                             (merge\n                               {:macro true}\n                               (update-in (select-keys (meta v) [:arglists :doc :file :line])\n                                 [:arglists] (core/fn [arglists] `(quote ~arglists)))))))\n                       vars)\n                defs (map\n                       (core/fn [sym var]\n                         (core/let [{:keys [arglists doc file line]} (meta sym)]\n                           `(do\n                              (def ~sym (deref ~var))\n                              ;for AOT compilation\n                              (alter-meta! (var ~sym) assoc\n                                :macro true\n                                :arglists ~arglists\n                                :doc ~doc\n                                :file ~file\n                                :line ~line))))\n                       syms vars)]\n       `(do ~@defs\n            :imported))))\n\n#?(:clj\n   (import-macros clojure.core\n     [-> ->> .. assert comment cond\n      declare defn-\n      extend-protocol fn for\n      if-let if-not letfn\n      memfn\n      when when-first when-let when-not while\n      cond-> cond->> as-> some-> some->>\n      if-some when-some]))\n\n#?(:cljs\n   (core/defmacro ->\n     \"Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.\"\n     [x & forms]\n     (core/loop [x x, forms forms]\n       (if forms\n         (core/let [form (first forms)\n                    threaded (if (seq? form)\n                               (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                               (core/list form x))]\n           (recur threaded (next forms)))\n         x))))\n\n#?(:cljs\n   (core/defmacro ->>\n     \"Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.\"\n     [x & forms]\n     (core/loop [x x, forms forms]\n       (if forms\n         (core/let [form (first forms)\n                    threaded (if (seq? form)\n                               (with-meta `(~(first form) ~@(next form) ~x) (meta form))\n                               (core/list form x))]\n           (recur threaded (next forms)))\n         x))))\n\n#?(:cljs\n   (core/defmacro ..\n     \"form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \\\"os.name\\\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \\\"os.name\\\"))\n\n     but is easier to write, read, and understand.\"\n     ([x form] `(. ~x ~form))\n     ([x form & more] `(.. (. ~x ~form) ~@more))))\n\n#?(:cljs\n   (core/defmacro comment\n     \"Ignores body, yields nil\"\n     [& body]))\n\n#?(:cljs\n   (core/defmacro cond\n     \"Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil.\"\n     {:added \"1.0\"}\n     [& clauses]\n     (core/when clauses\n       (core/list 'if (first clauses)\n         (if (next clauses)\n           (second clauses)\n           (throw (js/Error. \"cond requires an even number of forms\")))\n         (cons 'cljs.core/cond (next (next clauses)))))))\n\n#?(:cljs\n   (core/defmacro declare\n     \"defs the supplied var names with no bindings, useful for making forward declarations.\"\n     [& names] `(do ~@(map #(core/list 'def (vary-meta % assoc :declared true)) names))))\n\n(core/defmacro doto\n  \"Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \\\"a\\\" 1) (.set \\\"b\\\" 2))\"\n  [x & forms]\n  (core/let [gx (gensym)]\n    `(let [~gx ~x]\n       ~@(map (core/fn [f]\n                (if (seq? f)\n                  `(~(first f) ~gx ~@(next f))\n                  `(~f ~gx)))\n           forms)\n       ~gx)))\n\n#?(:cljs\n   (core/defn- parse-impls [specs]\n     (core/loop [ret {} s specs]\n       (if (seq s)\n         (recur (assoc ret (first s) (take-while seq? (next s)))\n           (drop-while seq? (next s)))\n         ret))))\n\n#?(:cljs\n   (core/defn- emit-extend-protocol [p specs]\n     (core/let [impls (parse-impls specs)]\n       `(do\n          ~@(map (core/fn [[t fs]]\n                   `(extend-type ~t ~p ~@fs))\n              impls)))))\n\n#?(:cljs\n   (core/defmacro extend-protocol\n     \"Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))\"\n     [p & specs]\n     (emit-extend-protocol p specs)))\n\n#?(:cljs\n   (core/defn ^{:private true}\n   maybe-destructured\n     [params body]\n     (if (every? core/symbol? params)\n       (cons params body)\n       (core/loop [params params\n                   new-params (with-meta [] (meta params))\n                   lets []]\n         (if params\n           (if (core/symbol? (first params))\n             (recur (next params) (conj new-params (first params)) lets)\n             (core/let [gparam (gensym \"p__\")]\n               (recur (next params) (conj new-params gparam)\n                 (core/-> lets (conj (first params)) (conj gparam)))))\n           `(~new-params\n              (let ~lets\n                ~@body)))))))\n\n#?(:cljs\n   (core/defmacro fn\n     \"params => positional-params* , or positional-params* & next-param\n     positional-param => binding-form\n     next-param => binding-form\n     name => symbol\n\n     Defines a function\"\n     {:forms '[(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}\n     [& sigs]\n     (core/let [name (if (core/symbol? (first sigs)) (first sigs) nil)\n                sigs (if name (next sigs) sigs)\n                sigs (if (vector? (first sigs))\n                       (core/list sigs)\n                       (if (seq? (first sigs))\n                         sigs\n                         ;; Assume single arity syntax\n                         (throw (js/Error.\n                                  (if (seq sigs)\n                                    (core/str \"Parameter declaration \"\n                                      (core/first sigs)\n                                      \" should be a vector\")\n                                    (core/str \"Parameter declaration missing\"))))))\n                psig (fn* [sig]\n                       ;; Ensure correct type before destructuring sig\n                       (core/when (not (seq? sig))\n                         (throw (js/Error.\n                                  (core/str \"Invalid signature \" sig\n                                    \" should be a list\"))))\n                       (core/let [[params & body] sig\n                                  _ (core/when (not (vector? params))\n                                      (throw (js/Error.\n                                               (if (seq? (first sigs))\n                                                 (core/str \"Parameter declaration \" params\n                                                   \" should be a vector\")\n                                                 (core/str \"Invalid signature \" sig\n                                                   \" should be a list\")))))\n                                  conds (core/when (core/and (next body) (map? (first body)))\n                                          (first body))\n                                  body (if conds (next body) body)\n                                  conds (core/or conds (meta params))\n                                  pre (:pre conds)\n                                  post (:post conds)\n                                  body (if post\n                                         `((let [~'% ~(if (core/< 1 (count body))\n                                                        `(do ~@body)\n                                                        (first body))]\n                                             ~@(map (fn* [c] `(assert ~c)) post)\n                                             ~'%))\n                                         body)\n                                  body (if pre\n                                         (concat (map (fn* [c] `(assert ~c)) pre)\n                                           body)\n                                         body)]\n                         (maybe-destructured params body)))\n                new-sigs (map psig sigs)]\n       (with-meta\n         (if name\n           (list* 'fn* name new-sigs)\n           (cons 'fn* new-sigs))\n         (meta &form)))))\n\n#?(:cljs\n   (core/defmacro defn-\n     \"same as defn, yielding non-public def\"\n     [name & decls]\n     (list* `defn (with-meta name (assoc (meta name) :private true)) decls)))\n\n#?(:cljs\n   (core/defmacro if-let\n     \"bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else\"\n     ([bindings then]\n      `(if-let ~bindings ~then nil))\n     ([bindings then else & oldform]\n      (assert-args if-let\n        (vector? bindings) \"a vector for its binding\"\n        (empty? oldform) \"1 or 2 forms after binding vector\"\n        (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n      (core/let [form (bindings 0) tst (bindings 1)]\n        `(let [temp# ~tst]\n           (if temp#\n             (let [~form temp#]\n               ~then)\n             ~else))))))\n\n#?(:cljs\n   (core/defmacro if-not\n     \"Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.\"\n     ([test then] `(if-not ~test ~then nil))\n     ([test then else]\n      `(if (not ~test) ~then ~else))))\n\n#?(:cljs\n   (core/defmacro letfn\n     \"fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.\"\n     {:forms '[(letfn [fnspecs*] exprs*)],\n      :special-form true, :url nil}\n     [fnspecs & body]\n     `(letfn* ~(vec (interleave (map first fnspecs)\n                      (map #(cons `fn %) fnspecs)))\n        ~@body)))\n\n(core/defmacro memfn\n  \"Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.\"\n  [name & args]\n  (core/let [t (with-meta (gensym \"target\")\n                 (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))\n\n#?(:cljs\n   (core/defmacro when\n     \"Evaluates test. If logical true, evaluates body in an implicit do.\"\n     [test & body]\n     (core/list 'if test (cons 'do body))))\n\n#?(:cljs\n   (core/defmacro when-first\n     \"bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once\"\n     [bindings & body]\n     (assert-args when-first\n       (vector? bindings) \"a vector for its binding\"\n       (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n     (core/let [[x xs] bindings]\n       `(when-let [xs# (seq ~xs)]\n          (let [~x (first xs#)]\n            ~@body)))))\n\n#?(:cljs\n   (core/defmacro when-let\n     \"bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test\"\n     [bindings & body]\n     (assert-args when-let\n       (vector? bindings) \"a vector for its binding\"\n       (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n     (core/let [form (bindings 0) tst (bindings 1)]\n       `(let [temp# ~tst]\n          (when temp#\n            (let [~form temp#]\n              ~@body))))))\n\n#?(:cljs\n   (core/defmacro when-not\n     \"Evaluates test. If logical false, evaluates body in an implicit do.\"\n     [test & body]\n     (core/list 'if test nil (cons 'do body))))\n\n#?(:cljs\n   (core/defmacro while\n     \"Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil\"\n     [test & body]\n     `(loop []\n        (when ~test\n          ~@body\n          (recur)))))\n\n#?(:cljs\n   (core/defmacro cond->\n     \"Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.\"\n     [expr & clauses]\n     (core/assert (even? (count clauses)))\n     (core/let [g (gensym)\n                steps (map (core/fn [[test step]] `(if ~test (-> ~g ~step) ~g))\n                        (partition 2 clauses))]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro cond->>\n     \"Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.\"\n     [expr & clauses]\n     (core/assert (even? (count clauses)))\n     (core/let [g (gensym)\n                steps (map (core/fn [[test step]] `(if ~test (->> ~g ~step) ~g))\n                        (partition 2 clauses))]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro as->\n     \"Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.\"\n     [expr name & forms]\n     `(let [~name ~expr\n            ~@(interleave (repeat name) (butlast forms))]\n        ~(if (empty? forms)\n           name\n           (last forms)))))\n\n#?(:cljs\n   (core/defmacro some->\n     \"When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc\"\n     [expr & forms]\n     (core/let [g (gensym)\n                steps (map (core/fn [step] `(if (nil? ~g) nil (-> ~g ~step)))\n                        forms)]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro some->>\n     \"When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc\"\n     [expr & forms]\n     (core/let [g (gensym)\n                steps (map (core/fn [step] `(if (nil? ~g) nil (->> ~g ~step)))\n                        forms)]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro if-some\n     \"bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else\"\n     ([bindings then]\n      `(if-some ~bindings ~then nil))\n     ([bindings then else & oldform]\n      (assert-args if-some\n        (vector? bindings) \"a vector for its binding\"\n        (empty? oldform) \"1 or 2 forms after binding vector\"\n        (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n      (core/let [form (bindings 0) tst (bindings 1)]\n        `(let [temp# ~tst]\n           (if (nil? temp#)\n             ~else\n             (let [~form temp#]\n               ~then)))))))\n\n#?(:cljs\n   (core/defmacro when-some\n     \"bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test\"\n     [bindings & body]\n     (assert-args when-some\n       (vector? bindings) \"a vector for its binding\"\n       (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n     (core/let [form (bindings 0) tst (bindings 1)]\n       `(let [temp# ~tst]\n          (if (nil? temp#)\n            nil\n            (let [~form temp#]\n              ~@body))))))\n\n(core/defn- ^{:dynamic true} assert-valid-fdecl\n  \"A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.\"\n  [fdecl]\n  (core/when (empty? fdecl)\n    (throw\n      #?(:clj  (IllegalArgumentException. \"Parameter declaration missing\")\n         :cljs (js/Error. \"Parameter declaration missing\"))))\n  (core/let [argdecls\n             (map\n               #(if (seq? %)\n                 (first %)\n                 (throw\n                   #?(:clj (IllegalArgumentException.\n                             (if (seq? (first fdecl))\n                               (core/str \"Invalid signature \\\"\"\n                                 %\n                                 \"\\\" should be a list\")\n                               (core/str \"Parameter declaration \\\"\"\n                                 %\n                                 \"\\\" should be a vector\")))\n                      :cljs (js/Error.\n                              (if (seq? (first fdecl))\n                                (core/str \"Invalid signature \\\"\"\n                                  %\n                                  \"\\\" should be a list\")\n                                (core/str \"Parameter declaration \\\"\"\n                                  %\n                                  \"\\\" should be a vector\"))))))\n               fdecl)\n             bad-args (seq (remove #(vector? %) argdecls))]\n    (core/when bad-args\n      (throw\n        #?(:clj (IllegalArgumentException.\n                  (core/str \"Parameter declaration \\\"\" (first bad-args)\n                    \"\\\" should be a vector\"))\n           :cljs (js/Error.\n                   (core/str \"Parameter declaration \\\"\" (first bad-args)\n                     \"\\\" should be a vector\")))))))\n\n(def\n  ^{:private true}\n  sigs\n  (core/fn [fdecl]\n    (assert-valid-fdecl fdecl)\n    (core/let [asig\n               (core/fn [fdecl]\n                 (core/let [arglist (first fdecl)\n                            ;elide implicit macro args\n                            arglist (if #?(:clj (clojure.lang.Util/equals '&form (first arglist))\n                                           :cljs (= '&form (first arglist)))\n                                      #?(:clj (clojure.lang.RT/subvec arglist 2 (clojure.lang.RT/count arglist))\n                                         :cljs (subvec arglist 2 (count arglist)))\n                                      arglist)\n                            body (next fdecl)]\n                   (if (map? (first body))\n                     (if (next body)\n                       (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))\n                       arglist)\n                     arglist)))]\n      (if (seq? (first fdecl))\n        (core/loop [ret [] fdecls fdecl]\n          (if fdecls\n            (recur (conj ret (asig (first fdecls))) (next fdecls))\n            (seq ret)))\n        (core/list (asig fdecl))))))\n\n(core/defmacro defonce\n  \"defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated\"\n  [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))\n\n(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym \"vec__\")\n                                          gseq (gensym \"seq__\")\n                                          gfirst (gensym \"first__\")\n                                          has-rest (some #{'&} b)]\n                                 (core/loop [ret (core/let [ret (conj bvec gvec val)]\n                                                   (if has-rest\n                                                     (conj ret gseq (core/list `seq gvec))\n                                                     ret))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                              n\n                                                              (nnext bs)\n                                                              true)\n                                         (= firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                           :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                                 (recur (pb (if has-rest\n                                                              (conj ret\n                                                                    gfirst `(first ~gseq)\n                                                                    gseq `(next ~gseq))\n                                                              ret)\n                                                            firstb\n                                                            (if has-rest\n                                                              gfirst\n                                                              (core/list `nth gvec n nil)))\n                                                        (core/inc n)\n                                                        (next bs)\n                                                        seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym \"map__\")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-> bvec (conj gmap) (conj v)\n                                                          (conj gmap) (conj `(if (implements? ISeq ~gmap) (apply cljs.core/hash-map ~gmap) ~gmap))\n                                                     ((core/fn [ret]\n                                                        (if (:as b)\n                                                          (conj ret (:as b) gmap)\n                                                          ret))))\n                                             bes (core/let [transforms\n                                                            (reduce\n                                                              (core/fn [transforms mk]\n                                                                (if (core/keyword? mk)\n                                                                  (core/let [mkns (namespace mk)\n                                                                        mkn (name mk)]\n                                                                    (core/cond (= mkn \"keys\") (assoc transforms mk #(keyword (core/or mkns (namespace %)) (name %)))\n                                                                               (= mkn \"syms\") (assoc transforms mk #(core/list `quote (symbol (core/or mkns (namespace %)) (name %))))\n                                                                               (= mkn \"strs\") (assoc transforms mk core/str)\n                                                                               :else transforms))\n                                                                  transforms))\n                                                              {}\n                                                              (keys b))]\n                                                   (reduce\n                                                     (core/fn [bes entry]\n                                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                                         (dissoc bes (key entry))\n                                                         ((key entry) bes)))\n                                                     (dissoc b :as :or)\n                                                     transforms))]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                local (if #?(:clj  (core/instance? clojure.lang.Named bb)\n                                                             :cljs (cljs.core/implements? INamed bb))\n                                                          (with-meta (symbol nil (name bb)) (meta bb))\n                                                        bb)\n                                                bv (if (contains? defaults local)\n                                                     (core/list 'cljs.core/get gmap bk (defaults local))\n                                                     (core/list 'cljs.core/get gmap bk))]\n                                       (recur\n                                         (if (core/or (core/keyword? bb) (core/symbol? bb)) ;(ident? bb)\n                                           (core/-> ret (conj local bv))\n                                           (pb ret bb bv))\n                                              (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                             #?(:clj (new Exception (core/str \"Unsupported binding form: \" b))\n                                :cljs (new js/Error (core/str \"Unsupported binding form: \" b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (core/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))\n\n(core/defmacro ^:private return-first\n  [& body]\n  `(let [ret# ~(first body)]\n     ~@(rest body)\n     ret#))\n\n(core/defmacro goog-define\n  \"Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\\\"your_app.core.DEBUG_BANG_\\\" true}\n    or\n    :closure-defines {'your-app.core/DEBUG! true}\"\n  [sym default]\n  (assert-args goog-define\n   (core/or (core/string? default)\n            (core/number? default)\n            (core/true? default)\n            (core/false? default)) \"a string, number or boolean as default value\")\n  (core/let [defname (comp/munge (core/str *ns* \"/\" sym))\n             type    (core/cond\n                       (core/string? default) \"string\"\n                       (core/number? default) \"number\"\n                       (core/or (core/true? default) (core/false? default)) \"boolean\")]\n    `(~(if (:def-emits-var &env) `return-first `do)\n       (declare ~(core/vary-meta sym\n                   (core/fn [m]\n                     (core/cond-> m\n                       (core/not (core/contains? m :tag))\n                       (core/assoc :tag (core/symbol type))\n                       ))))\n       (~'js* ~(core/str \"/** @define {\" type \"} */\"))\n       (goog/define ~defname ~default))))\n\n(core/defmacro let\n  \"binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\"\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))\n\n(core/defmacro loop\n  \"Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.\"\n  [bindings & body]\n  (assert-args loop\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (core/let [db (destructure bindings)]\n    (if (= db bindings)\n      `(loop* ~bindings ~@body)\n      (core/let [vs (take-nth 2 (drop 1 bindings))\n                 bs (take-nth 2 bindings)\n                 gs (map (core/fn [b] (if (core/symbol? b) b (gensym))) bs)\n                 bfs (reduce (core/fn [ret [b v g]]\n                               (if (core/symbol? b)\n                                 (conj ret g v)\n                                 (conj ret g v b g)))\n                       [] (map core/vector bs vs gs))]\n        `(let ~bfs\n           (loop* ~(vec (interleave gs gs))\n             (let ~(vec (interleave bs gs))\n               ~@body)))))))\n\n(def fast-path-protocols\n  \"protocol fqn -> [partition number, bit]\"\n  (zipmap (map #(symbol \"cljs.core\" (core/str %))\n               '[IFn ICounted IEmptyableCollection ICollection IIndexed ASeq ISeq INext\n                 ILookup IAssociative IMap IMapEntry ISet IStack IVector IDeref\n                 IDerefWithTimeout IMeta IWithMeta IReduce IKVReduce IEquiv IHash\n                 ISeqable ISequential IList IRecord IReversible ISorted IPrintWithWriter IWriter\n                 IPrintWithWriter IPending IWatchable IEditableCollection ITransientCollection\n                 ITransientAssociative ITransientMap ITransientVector ITransientSet\n                 IMultiFn IChunkedSeq IChunkedNext IComparable INamed ICloneable IAtom\n                 IReset ISwap IIterable])\n          (iterate (core/fn [[p b]]\n                     (if (core/== 2147483648 b)\n                       [(core/inc p) 1]\n                       [p #?(:clj  (core/bit-shift-left b 1)\n                             :cljs (core/* 2 b))]))\n                   [0 1])))\n\n(def fast-path-protocol-partitions-count\n  \"total number of partitions\"\n  (core/let [c (count fast-path-protocols)\n             m (core/mod c 32)]\n    (if (core/zero? m)\n      (core/quot c 32)\n      (core/inc (core/quot c 32)))))\n\n(core/defn- compatible? [inferred-tag allowed-tags]\n  (if (set? inferred-tag)\n    (clojure.set/subset? inferred-tag allowed-tags)\n    (contains? allowed-tags inferred-tag)))\n\n(core/defn- typed-expr? [env form allowed-tags]\n  (compatible? (cljs.analyzer/infer-tag env\n                 (cljs.analyzer/no-warn (cljs.analyzer/analyze env form)))\n    allowed-tags))\n\n(core/defn- string-expr [e]\n  (vary-meta e assoc :tag 'string))\n\n(core/defmacro str\n  ([] \"\")\n  ([x]\n   (if (typed-expr? &env x '#{string})\n     x\n     (string-expr (core/list 'js* \"cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})\" x))))\n  ([x & ys]\n   (core/let [interpolate (core/fn [x]\n                            (if (typed-expr? &env x '#{string clj-nil})\n                              \"~{}\"\n                              \"cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})\"))\n              strs        (core/->> (core/list* x ys)\n                            (map interpolate)\n                            (interpose \",\")\n                            (apply core/str))]\n     (string-expr (list* 'js* (core/str \"[\" strs \"].join('')\") x ys)))))\n\n(core/defn- bool-expr [e]\n  (vary-meta e assoc :tag 'boolean))\n\n(core/defn- simple-test-expr? [env ast]\n  (core/and\n    (#{:var :js-var :local :invoke :const :host-field :host-call :js :quote} (:op ast))\n    ('#{boolean seq} (cljs.analyzer/infer-tag env ast))))\n\n(core/defmacro and\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.\"\n  ([] true)\n  ([x] x)\n  ([x & next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? &env %)\n           (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) forms))\n       (core/let [and-str (core/->> (repeat (count forms) \"(~{})\")\n                            (interpose \" && \")\n                            (#(concat [\"(\"] % [\")\"]))\n                            (apply core/str))]\n         (bool-expr `(~'js* ~and-str ~@forms)))\n       `(let [and# ~x]\n          (if and# (and ~@next) and#))))))\n\n(core/defmacro or\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.\"\n  ([] nil)\n  ([x] x)\n  ([x & next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? &env %)\n           (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) forms))\n       (core/let [or-str (core/->> (repeat (count forms) \"(~{})\")\n                           (interpose \" || \")\n                           (#(concat [\"(\"] % [\")\"]))\n                           (apply core/str))]\n         (bool-expr `(~'js* ~or-str ~@forms)))\n       `(let [or# ~x]\n          (if or# or# (or ~@next)))))))\n\n(core/defmacro nil? [x]\n  `(coercive-= ~x nil))\n\n(core/defmacro some? [x]\n  `(not (nil? ~x)))\n\n(core/defmacro coercive-not [x]\n  (bool-expr (core/list 'js* \"(!~{})\" x)))\n\n(core/defmacro coercive-not= [x y]\n  (bool-expr (core/list 'js* \"(~{} != ~{})\" x y)))\n\n(core/defmacro coercive-= [x y]\n  (bool-expr (core/list 'js* \"(~{} == ~{})\" x y)))\n\n(core/defmacro coercive-boolean [x]\n  (with-meta (core/list 'js* \"~{}\" x)\n    {:tag 'boolean}))\n\n;; internal - do not use.\n(core/defmacro truth_ [x]\n  (core/assert (core/symbol? x) \"x is substituted twice\")\n  (core/list 'js* \"(~{} != null && ~{} !== false)\" x x))\n\n(core/defmacro js-arguments []\n  (core/list 'js* \"arguments\"))\n\n(core/defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))\n\n(core/defmacro js-in [key obj]\n  (core/list 'js* \"~{} in ~{}\" key obj))\n\n(core/defmacro js-debugger\n  \"Emit JavaScript \\\"debugger;\\\" statement\"\n  []\n  (core/list 'do\n             (core/list 'js* \"debugger\")\n             nil))\n\n(core/defmacro js-comment\n  \"Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline\"\n  [comment]\n  (core/let [[x & ys] (string/split comment #\"\\n\")]\n    (core/list 'js*\n      (core/str\n        \"\\n/**\\n\"\n        (core/str \" * \" x \"\\n\")\n        (core/->> ys\n          (map #(core/str \" * \" (string/replace % #\"^   \" \"\") \"\\n\"))\n          (reduce core/str \"\"))\n        \" */\\n\"))))\n\n(core/defmacro unsafe-cast\n  \"EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.\"\n  [t x]\n  (core/let [cast-expr (core/str \"~{} = /** @type {\" t \"} */ (~{})\")]\n    (core/list 'js* cast-expr x x)))\n\n(core/defmacro js-inline-comment\n  \"Emit an inline JavaScript comment.\"\n  [comment]\n  (core/list 'js* (core/str \"/**\" comment \"*/\")))\n\n(core/defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))\n\n(core/defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))\n\n(core/defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))\n\n(core/defmacro exists?\n  \"Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.\"\n  [x]\n  (if (core/symbol? x)\n    (core/let [x     (core/cond-> (:name (cljs.analyzer/resolve-var &env x))\n                       (= \"js\" (namespace x)) name)\n               segs  (string/split (core/str (string/replace (core/str x) \"/\" \".\")) #\"\\.\")\n               n     (count segs)\n               syms  (map\n                       #(vary-meta (symbol \"js\" (string/join \".\" %))\n                          assoc :cljs.analyzer/no-resolve true)\n                       (reverse (take n (iterate butlast segs))))\n               js    (string/join \" && \" (repeat n \"(typeof ~{} !== 'undefined')\"))]\n      (bool-expr (concat (core/list 'js* js) syms)))\n    `(some? ~x)))\n\n(core/defmacro undefined?\n  \"Return true if argument is identical to the JavaScript undefined value.\"\n  [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))\n\n(core/defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))\n\n(core/defmacro instance? [c x]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? c)\n               (core/list 'js* \"(~{} instanceof ~{})\" x c)\n               `(let [c# ~c x# ~x]\n                  (~'js* \"(~{} instanceof ~{})\" x# c#)))))\n\n(core/defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))\n\n(core/defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))\n\n(core/defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))\n\n(core/defmacro aget\n  ([array idx]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx)\n     :error `(checked-aget' ~array ~idx)\n     (core/list 'js* \"(~{}[~{}])\" array idx)))\n  ([array idx & idxs]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx ~@idxs)\n     :error `(checked-aget' ~array ~idx ~@idxs)\n     (core/let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n       `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~array ~idx ~@idxs)))))\n\n(core/defmacro aset\n  ([array idx val]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~val)\n     :error `(checked-aset' ~array ~idx ~val)\n     (core/list 'js* \"(~{}[~{}] = ~{})\" array idx val)))\n  ([array idx idx2 & idxv]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~idx2 ~@idxv)\n     :error `(checked-aset' ~array ~idx ~idx2 ~@idxv)\n     (core/let [n    (core/dec (count idxv))\n                astr (apply core/str (repeat n \"[~{}]\"))]\n       `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~array ~idx ~idx2 ~@idxv)))))\n\n(core/defmacro unchecked-get\n  \"INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.\"\n  [obj key]\n  (core/list 'js* \"(~{}[~{}])\" obj key))\n\n(core/defmacro unchecked-set\n  \"INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.\"\n  [obj key val]\n  (core/list 'js* \"(~{}[~{}] = ~{})\" obj key val))\n\n(core/defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))\n\n(core/defmacro byte [x] x)\n(core/defmacro short [x] x)\n(core/defmacro float [x] x)\n(core/defmacro double [x] x)\n\n(core/defmacro unchecked-byte [x] x)\n(core/defmacro unchecked-char [x] x)\n(core/defmacro unchecked-short [x] x)\n(core/defmacro unchecked-float [x] x)\n(core/defmacro unchecked-double [x] x)\n\n(core/defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(core/mod ~x ~n)))\n\n(core/defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))\n\n(core/defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))\n\n(core/defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))\n\n(core/defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))\n\n(core/defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))\n\n(core/defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))\n\n(core/defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))\n\n(core/defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))\n\n(core/defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))\n\n(core/defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))\n\n(core/defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))\n\n(core/defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))\n\n(core/defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))\n\n(core/defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))\n\n;; internal do not use\n(core/defmacro ^::ana/numeric unsafe-bit-and\n  ([x y] (bool-expr (core/list 'js* \"(~{} & ~{})\" x y)))\n  ([x y & more] `(unsafe-bit-and (unsafe-bit-and ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))\n\n(core/defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))\n\n(core/defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))\n\n(core/defmacro bit-test [x n]\n  (bool-expr (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n)))\n\n(core/defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))\n\n(core/defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))\n\n(core/defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))\n\n(core/defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))\n\n(core/defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))\n\n;; internal\n(core/defmacro mask [hash shift]\n  (core/list 'js* \"((~{} >>> ~{}) & 0x01f)\" hash shift))\n\n;; internal\n(core/defmacro bitpos [hash shift]\n  (core/list 'js* \"(1 << ~{})\" `(mask ~hash ~shift)))\n\n;; internal\n(core/defmacro caching-hash [coll hash-fn hash-key]\n  (core/assert (clojure.core/symbol? hash-key) \"hash-key is substituted twice\")\n  `(let [h# ~hash-key]\n     (if-not (nil? h#)\n       h#\n       (let [h# (~hash-fn ~coll)]\n         (set! ~hash-key h#)\n         h#))))\n\n;;; internal -- reducers-related macros\n\n(core/defn- do-curried\n  [name doc meta args body]\n  (core/let [cargs (vec (butlast args))]\n    `(defn ~name ~doc ~meta\n       (~cargs (fn [x#] (~name ~@cargs x#)))\n       (~args ~@body))))\n\n(core/defmacro ^:private defcurried\n  \"Builds another arity of the fn that returns a fn awaiting the last\n  param\"\n  [name doc meta args & body]\n  (do-curried name doc meta args body))\n\n(core/defn- do-rfn [f1 k fkv]\n  `(fn\n     ([] (~f1))\n     ~(clojure.walk/postwalk\n       #(if (sequential? %)\n          ((if (vector? %) vec identity)\n           (core/remove #{k} %))\n          %)\n       fkv)\n     ~fkv))\n\n(core/defmacro ^:private rfn\n  \"Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.\"\n  [[f1 k] fkv]\n  (do-rfn f1 k fkv))\n\n;;; end of reducers macros\n\n(core/defn- protocol-prefix [psym]\n  (core/str (core/-> (core/str psym)\n              (.replace #?(:clj \\. :cljs (js/RegExp. \"\\\\.\" \"g\")) \\$)\n              (.replace \\/ \\$))\n    \"$\"))\n\n(def ^:private base-type\n     {nil \"null\"\n      'object \"object\"\n      'string \"string\"\n      'number \"number\"\n      'array \"array\"\n      'function \"function\"\n      'boolean \"boolean\"\n      'default \"_\"})\n\n(def ^:private js-base-type\n     {'js/Boolean \"boolean\"\n      'js/String \"string\"\n      'js/Array \"array\"\n      'js/Object \"object\"\n      'js/Number \"number\"\n      'js/Function \"function\"})\n\n(core/defmacro reify\n  \"reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \\\"foo\\\"]\n       (reify Object\n         (toString [this] f))))\n  == \\\"foo\\\"\n\n  (seq (let [f \\\"foo\\\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\\\"f\\\" \\\"o\\\" \\\"o\\\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \\\"foo\\\")))\n  == {:k :v}\"\n  [& impls]\n  (core/let [t        (with-meta\n                        (gensym\n                          (core/str \"t_\"\n                            (string/replace (core/str (munge ana/*cljs-ns*)) \".\" \"$\")))\n                        {:anonymous true})\n             meta-sym (gensym \"meta\")\n             this-sym (gensym \"_\")\n             locals   (keys (:locals &env))\n             ns       (core/-> &env :ns :name)\n             munge    comp/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(ana/elide-reader-meta (meta &form))))))\n\n(core/defmacro specify!\n  \"Identical to reify but mutates its first argument.\"\n  [expr & impls]\n  (core/let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))\n\n(core/defmacro specify\n  \"Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.\"\n  [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))\n\n(core/defmacro ^:private js-this []\n  (core/list 'js* \"this\"))\n\n(core/defmacro this-as\n  \"Defines a scope where JavaScript's implicit \\\"this\\\" is bound to the name provided.\"\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))\n\n(core/defn- to-property [sym]\n  (symbol (core/str \"-\" sym)))\n\n(core/defn- warn-and-update-protocol [p type env]\n  (core/when-not (= 'Object p)\n    (core/if-let [var (cljs.analyzer/resolve-existing-var (dissoc env :locals) p)]\n      (do\n        (core/when-not (:protocol-symbol var)\n          (cljs.analyzer/warning :invalid-protocol-symbol env {:protocol p}))\n        (core/when (core/and (:protocol-deprecated cljs.analyzer/*cljs-warnings*)\n                (core/-> var :deprecated)\n                (not (core/-> p meta :deprecation-nowarn)))\n          (cljs.analyzer/warning :protocol-deprecated env {:protocol p}))\n        (core/when (:protocol-symbol var)\n          (swap! env/*compiler* update-in [:cljs.analyzer/namespaces]\n            (core/fn [ns]\n              (update-in ns [(:ns var) :defs (symbol (name p)) :impls]\n                conj type)))))\n      (core/when (:undeclared cljs.analyzer/*cljs-warnings*)\n        (cljs.analyzer/warning :undeclared-protocol-symbol env {:protocol p})))))\n\n(core/defn- resolve-var [env sym]\n  (core/let [ret (:name (cljs.analyzer/resolve-var env sym))]\n    (core/assert ret (core/str \"Can't resolve: \" sym))\n    ret))\n\n(core/defn- ->impl-map [impls]\n  (core/loop [ret {} s impls]\n    (if (seq s)\n      (recur (assoc ret (first s) (take-while seq? (next s)))\n        (drop-while seq? (next s)))\n      ret)))\n\n(core/defn- base-assign-impls [env resolve tsym type [p sigs]]\n  (warn-and-update-protocol p tsym env)\n  (core/let [psym       (resolve p)\n             pfn-prefix (subs (core/str psym) 0\n                          (clojure.core/inc (.indexOf (core/str psym) \"/\")))]\n    (cons `(goog.object/set ~psym ~type true)\n      (map (core/fn [[f & meths :as form]]\n             `(goog.object/set ~(symbol (core/str pfn-prefix f))\n                ~type ~(with-meta `(fn ~@meths) (meta form))))\n        sigs))))\n\n(core/defmulti ^:private extend-prefix (core/fn [tsym sym] (core/-> tsym meta :extend)))\n\n(core/defmethod extend-prefix :instance\n  [tsym sym] `(.. ~tsym ~(to-property sym)))\n\n(core/defmethod extend-prefix :default\n  [tsym sym] `(.. ~tsym ~'-prototype ~(to-property sym)))\n\n(core/defn- adapt-obj-params [type [[this & args :as sig] & body]]\n  (core/list (vec args)\n    (list* 'this-as (vary-meta this assoc :tag type) body)))\n\n(core/defn- adapt-ifn-params [type [[this & args :as sig] & body]]\n  (core/let [self-sym (with-meta 'self__ {:tag type})]\n    `(~(vec (cons self-sym args))\n       (this-as ~self-sym\n         (let [~this ~self-sym]\n           ~@body)))))\n\n;; for IFn invoke implementations, we need to drop first arg\n(core/defn- adapt-ifn-invoke-params [type [[this & args :as sig] & body]]\n  `(~(vec args)\n     (this-as ~(vary-meta this assoc :tag type)\n       ~@body)))\n\n(core/defn- adapt-proto-params [type [[this & args :as sig] & body]]\n  (core/let [this' (vary-meta this assoc :tag type)]\n    `(~(vec (cons this' args))\n      (this-as ~this'\n        ~@body))))\n\n(core/defn- add-obj-methods [type type-sym sigs]\n  (map (core/fn [[f & meths :as form]]\n         (core/let [[f meths] (if (vector? (first meths))\n                                [f [(rest form)]]\n                                [f meths])]\n           `(set! ~(extend-prefix type-sym f)\n              ~(with-meta `(fn ~@(map #(adapt-obj-params type %) meths)) (meta form)))))\n    sigs))\n\n(core/defn- ifn-invoke-methods [type type-sym [f & meths :as form]]\n  (map\n    (core/fn [meth]\n      (core/let [arity (count (first meth))]\n        `(set! ~(extend-prefix type-sym (symbol (core/str \"cljs$core$IFn$_invoke$arity$\" arity)))\n           ~(with-meta `(fn ~meth) (meta form)))))\n    (map #(adapt-ifn-invoke-params type %) meths)))\n\n(core/defn- add-ifn-methods [type type-sym [f & meths :as form]]\n  (core/let [meths    (map #(adapt-ifn-params type %) meths)\n             this-sym (with-meta 'self__ {:tag type})\n             argsym   (gensym \"args\")]\n    (concat\n      [`(set! ~(extend-prefix type-sym 'call) ~(with-meta `(fn ~@meths) (meta form)))\n       `(set! ~(extend-prefix type-sym 'apply)\n          ~(with-meta\n             `(fn ~[this-sym argsym]\n                (this-as ~this-sym\n                  (.apply (.-call ~this-sym) ~this-sym\n                    (.concat (array ~this-sym) (cljs.core/aclone ~argsym)))))\n             (meta form)))]\n      (ifn-invoke-methods type type-sym form))))\n\n(core/defn- add-proto-methods* [pprefix type type-sym [f & meths :as form]]\n  (core/let [pf (core/str pprefix (munge (name f)))]\n    (if (vector? (first meths))\n      ;; single method case\n      (core/let [meth meths]\n        [`(set! ~(extend-prefix type-sym (core/str pf \"$arity$\" (count (first meth))))\n            ~(with-meta `(fn ~@(adapt-proto-params type meth)) (meta form)))])\n      (map (core/fn [[sig & body :as meth]]\n             `(set! ~(extend-prefix type-sym (core/str pf \"$arity$\" (count sig)))\n                ~(with-meta `(fn ~(adapt-proto-params type meth)) (meta form))))\n        meths))))\n\n(core/defn- proto-assign-impls [env resolve type-sym type [p sigs]]\n  (warn-and-update-protocol p type env)\n  (core/let [psym      (resolve p)\n             pprefix   (protocol-prefix psym)\n             skip-flag (set (core/-> type-sym meta :skip-protocol-flag))]\n    (if (= p 'Object)\n      (add-obj-methods type type-sym sigs)\n      (concat\n        (core/when-not (skip-flag psym)\n          [`(set! ~(extend-prefix type-sym pprefix) cljs.core/PROTOCOL_SENTINEL)])\n        (mapcat\n          (core/fn [sig]\n            (if (= psym 'cljs.core/IFn)\n              (add-ifn-methods type type-sym sig)\n              (add-proto-methods* pprefix type type-sym sig)))\n          sigs)))))\n\n(core/defn- validate-impl-sigs [env p method]\n  (core/when-not (= p 'Object)\n    (core/let [var (ana/resolve-var (dissoc env :locals) p)\n               minfo (core/-> var :protocol-info :methods)\n               method-name (first method)\n               ->name (comp symbol name)\n               [fname sigs] (if (core/vector? (second method))\n                              [(->name method-name) [(second method)]]\n                              [(->name method-name) (map first (rest method))])\n               decmeths (core/get minfo fname ::not-found)]\n      (core/when (= decmeths ::not-found)\n        (ana/warning :protocol-invalid-method env {:protocol p :fname fname :no-such-method true}))\n      (core/when (namespace method-name)\n        (core/let [method-var (ana/resolve-var (dissoc env :locals) method-name\n                                ana/confirm-var-exist-warning)]\n          (core/when-not (= (:name var) (:protocol method-var))\n            (ana/warning :protocol-invalid-method env\n              {:protocol p :fname method-name :no-such-method true}))))\n      (core/loop [sigs sigs seen #{}]\n        (core/when (seq sigs)\n          (core/let [sig (first sigs)\n                     c   (count sig)]\n            (core/when (contains? seen c)\n              (ana/warning :protocol-duped-method env {:protocol p :fname fname}))\n            (core/when (some '#{&} sig)\n              (ana/warning :protocol-impl-with-variadic-method env {:protocol p :name fname}))\n            (core/when (core/and (not= decmeths ::not-found) (not (some #{c} (map count decmeths))))\n              (ana/warning :protocol-invalid-method env {:protocol p :fname fname :invalid-arity c}))\n            (recur (next sigs) (conj seen c))))))))\n\n(core/defn- validate-impls [env impls]\n  (core/loop [protos #{} impls impls]\n    (core/when (seq impls)\n      (core/let [proto   (first impls)\n                 methods (take-while seq? (next impls))\n                 impls   (drop-while seq? (next impls))]\n        (core/when (contains? protos proto)\n          (ana/warning :protocol-multiple-impls env {:protocol proto}))\n        (core/loop [seen #{} methods methods]\n          (core/when (seq methods)\n            (core/let [[fname :as method] (first methods)]\n              (core/when (contains? seen fname)\n                (ana/warning :extend-type-invalid-method-shape env\n                  {:protocol proto :method fname}))\n              (validate-impl-sigs env proto method)\n              (recur (conj seen fname) (next methods)))))\n        (recur (conj protos proto) impls)))))\n\n(core/defn- type-hint-first-arg\n  [type-sym argv]\n  (assoc argv 0 (vary-meta (argv 0) assoc :tag type-sym)))\n\n(core/defn- type-hint-single-arity-sig\n  [type-sym sig]\n  (list* (first sig) (type-hint-first-arg type-sym (second sig)) (nnext sig)))\n\n(core/defn- type-hint-multi-arity-sig\n  [type-sym sig]\n  (list* (type-hint-first-arg type-sym (first sig)) (next sig)))\n\n(core/defn- type-hint-multi-arity-sigs\n  [type-sym sigs]\n  (list* (first sigs) (map (partial type-hint-multi-arity-sig type-sym) (rest sigs))))\n\n(core/defn- type-hint-sigs\n  [type-sym sig]\n  (if (vector? (second sig))\n    (type-hint-single-arity-sig type-sym sig)\n    (type-hint-multi-arity-sigs type-sym sig)))\n\n(core/defn- type-hint-impl-map\n  [type-sym impl-map]\n  (reduce-kv (core/fn [m proto sigs]\n               (assoc m proto (map (partial type-hint-sigs type-sym) sigs)))\n    {} impl-map))\n\n(core/defmacro extend-type\n  \"Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)\"\n  [type-sym & impls]\n  (core/let [env &env\n             _ (validate-impls env impls)\n             resolve (partial resolve-var env)\n             impl-map (->impl-map impls)\n             impl-map (if ('#{boolean number} type-sym)\n                        (type-hint-impl-map type-sym impl-map)\n                        impl-map)\n             [type assign-impls] (core/if-let [type (base-type type-sym)]\n                                   [type base-assign-impls]\n                                   [(resolve type-sym) proto-assign-impls])]\n    (core/when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n            (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n        {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))\n\n(core/defn- prepare-protocol-masks [env impls]\n  (core/let [resolve  (partial resolve-var env)\n             impl-map (->impl-map impls)\n             fpp-pbs  (seq\n                        (keep fast-path-protocols\n                          (map resolve\n                            (keys impl-map))))]\n    (if fpp-pbs\n      (core/let [fpps  (into #{}\n                         (filter (partial contains? fast-path-protocols)\n                           (map resolve (keys impl-map))))\n                 parts (core/as-> (group-by first fpp-pbs) parts\n                         (into {}\n                           (map (juxt key (comp (partial map peek) val))\n                             parts))\n                         (into {}\n                           (map (juxt key (comp (partial reduce core/bit-or) val))\n                             parts)))]\n        [fpps (reduce (core/fn [ps p] (update-in ps [p] (core/fnil identity 0)))\n                parts\n                (range fast-path-protocol-partitions-count))]))))\n\n(core/defn- annotate-specs [annots v [f sigs]]\n  (conj v\n    (vary-meta (cons f (map #(cons (second %) (nnext %)) sigs))\n      merge annots)))\n\n(core/defn dt->et\n  ([type specs fields]\n   (dt->et type specs fields false))\n  ([type specs fields inline]\n   (core/let [annots {:cljs.analyzer/type type\n                      :cljs.analyzer/protocol-impl true\n                      :cljs.analyzer/protocol-inline inline}]\n     (core/loop [ret [] specs specs]\n       (if (seq specs)\n         (core/let [p     (first specs)\n                    ret   (core/-> (conj ret p)\n                            (into (reduce (partial annotate-specs annots) []\n                                    (group-by first (take-while seq? (next specs))))))\n                    specs (drop-while seq? (next specs))]\n           (recur ret specs))\n         ret)))))\n\n(core/defn- collect-protocols [impls env]\n  (core/->> impls\n      (filter core/symbol?)\n      (map #(:name (cljs.analyzer/resolve-var (dissoc env :locals) %)))\n      (into #{})))\n\n(core/defn- build-positional-factory\n  [rsym rname fields]\n  (core/let [fn-name (with-meta (symbol (core/str '-> rsym))\n                       (assoc (meta rsym) :factory :positional))\n             docstring (core/str \"Positional factory function for \" rname \".\")\n        field-values (if (core/-> rsym meta :internal-ctor) (conj fields nil nil nil) fields)]\n    `(defn ~fn-name\n       ~docstring\n       [~@fields]\n       (new ~rname ~@field-values))))\n\n(core/defn- validate-fields\n  [case name fields]\n  (core/when-not (vector? fields)\n    (throw\n      #?(:clj (AssertionError. (core/str case \" \" name \", no fields vector given.\"))\n         :cljs (js/Error. (core/str case \" \" name \", no fields vector given.\"))))))\n\n(core/defmacro deftype\n  \"(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields\"\n  [t fields & impls]\n  (validate-fields \"deftype\" t fields)\n  (core/let [env &env\n             r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n             [fpps pmasks] (prepare-protocol-masks env impls)\n             protocols (collect-protocols impls env)\n             t (vary-meta t assoc\n                 :protocols protocols\n                 :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt->et t impls fields))))\n       (set! (.-getBasis ~t) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))\n\n(core/defn- emit-defrecord\n  \"Do not use this directly - use defrecord\"\n  [env tagname rname fields impls]\n  (core/let [hinted-fields fields\n             fields (vec (map #(with-meta % nil) fields))\n             base-fields fields\n             pr-open (core/str \"#\" #?(:clj  (.getNamespace rname)\n                                      :cljs (namespace rname))\n                               \".\" #?(:clj  (.getName rname)\n                                      :cljs (name rname))\n                               \"{\")\n             fields (conj fields '__meta '__extmap (with-meta '__hash {:mutable true}))]\n    (core/let [gs (gensym)\n               ksym (gensym \"k\")\n               impls (concat\n                       impls\n                       ['IRecord\n                        'ICloneable\n                        `(~'-clone [this#] (new ~tagname ~@fields))\n                        'IHash\n                        `(~'-hash [this#]\n                           (caching-hash this#\n                             (fn [coll#]\n                               (bit-xor\n                                 ~(hash (core/-> rname comp/munge core/str))\n                                 (hash-unordered-coll coll#)))\n                             ~'__hash))\n                        'IEquiv\n                        (core/let [this (gensym 'this) other (gensym 'other)]\n                          `(~'-equiv [~this ~other]\n                             (and (some? ~other)\n                                  (identical? (.-constructor ~this)\n                                              (.-constructor ~other))\n                                  ~@(map (core/fn [field]\n                                           `(= (.. ~this ~(to-property field))\n                                               (.. ~(with-meta other {:tag tagname}) ~(to-property field))))\n                                         base-fields)\n                                  (= (.-__extmap ~this)\n                                     (.-__extmap ~(with-meta other {:tag tagname}))))))\n                        'IMeta\n                        `(~'-meta [this#] ~'__meta)\n                        'IWithMeta\n                        `(~'-with-meta [this# ~gs] (new ~tagname ~@(replace {'__meta gs} fields)))\n                        'ILookup\n                        `(~'-lookup [this# k#] (-lookup this# k# nil))\n                        `(~'-lookup [this# ~ksym else#]\n                           (case ~ksym\n                             ~@(mapcat (core/fn [f] [(keyword f) f]) base-fields)\n                             (cljs.core/get ~'__extmap ~ksym else#)))\n                        'ICounted\n                        `(~'-count [this#] (+ ~(count base-fields) (count ~'__extmap)))\n                        'ICollection\n                        `(~'-conj [this# entry#]\n                           (if (vector? entry#)\n                             (-assoc this# (-nth entry# 0) (-nth entry# 1))\n                             (reduce -conj\n                               this#\n                               entry#)))\n                        'IAssociative\n                        `(~'-assoc [this# k# ~gs]\n                           (condp keyword-identical? k#\n                             ~@(mapcat (core/fn [fld]\n                                         [(keyword fld) (list* `new tagname (replace {fld gs '__hash nil} fields))])\n                                 base-fields)\n                             (new ~tagname ~@(remove #{'__extmap '__hash} fields) (assoc ~'__extmap k# ~gs) nil)))\n                        'IMap\n                        `(~'-dissoc [this# k#] (if (contains? #{~@(map keyword base-fields)} k#)\n                                                 (dissoc (-with-meta (into {} this#) ~'__meta) k#)\n                                                 (new ~tagname ~@(remove #{'__extmap '__hash} fields)\n                                                   (not-empty (dissoc ~'__extmap k#))\n                                                   nil)))\n                        'ISeqable\n                        `(~'-seq [this#] (seq (concat [~@(map #(core/list 'cljs.core/MapEntry. (keyword %) % nil) base-fields)]\n                                                ~'__extmap)))\n\n                        'IIterable\n                        `(~'-iterator [~gs]\n                          (RecordIter. 0 ~gs ~(count base-fields) [~@(map keyword base-fields)] (if ~'__extmap\n                                                                                                  (-iterator ~'__extmap)\n                                                                                                  (core/nil-iter))))\n\n                        'IPrintWithWriter\n                        `(~'-pr-writer [this# writer# opts#]\n                           (let [pr-pair# (fn [keyval#] (pr-sequential-writer writer# (~'js* \"cljs.core.pr_writer\") \"\" \" \" \"\" opts# keyval#))]\n                             (pr-sequential-writer\n                               writer# pr-pair# ~pr-open \", \" \"}\" opts#\n                               (concat [~@(map #(core/list `vector (keyword %) %) base-fields)]\n                                 ~'__extmap))))\n                        'IKVReduce\n                        `(~'-kv-reduce [this# f# init#]\n                           (reduce (fn [ret# [k# v#]] (f# ret# k# v#)) init# this#))\n                        ])\n               [fpps pmasks] (prepare-protocol-masks env impls)\n               protocols (collect-protocols impls env)\n               tagname (vary-meta tagname assoc\n                         :protocols protocols\n                         :skip-protocol-flag fpps)]\n      `(do\n         (~'defrecord* ~tagname ~hinted-fields ~pmasks\n           (extend-type ~tagname ~@(dt->et tagname impls fields true)))))))\n\n(core/defn- build-map-factory [rsym rname fields]\n  (core/let [fn-name (with-meta (symbol (core/str 'map-> rsym))\n                       (assoc (meta rsym) :factory :map))\n             docstring (core/str \"Factory function for \" rname \", taking a map of keywords to field values.\")\n             ms (gensym)\n             ks (map keyword fields)\n             getters (map (core/fn [k] `(~k ~ms)) ks)]\n    `(defn ~fn-name ~docstring [~ms]\n       (let [extmap# (cond->> (dissoc ~ms ~@ks)\n                        (record? ~ms) (into {}))]\n         (new ~rname ~@getters nil (not-empty extmap#) nil)))))\n\n(core/defmacro defrecord\n  \"(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.\"\n  [rsym fields & impls]\n  (validate-fields \"defrecord\" rsym fields)\n  (core/let [rsym (vary-meta rsym assoc :internal-ctor true)\n             r    (vary-meta\n                    (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n                    assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-getBasis ~r) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (cljs.core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))\n\n(core/defmacro defprotocol\n  \"A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \\\"A doc string for AProtocol abstraction\\\"\n\n  ;method signatures\n    (bar [this a b] \\\"bar docs\\\")\n    (baz [this a] [this a b] [this a b c] \\\"baz docs\\\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17\"\n  [psym & doc+methods]\n  (core/let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n             [opts methods]\n             (core/loop [opts {:protocol-symbol true}\n                         methods []\n                         sigs doc+methods]\n               (core/if-not (seq sigs)\n                 [opts methods]\n                 (core/let [[head & tail] sigs]\n                   (core/cond\n                     (core/string? head)\n                     (recur (assoc opts :doc head) methods tail)\n                     (core/keyword? head)\n                     (recur (assoc opts head (first tail)) methods (rest tail))\n                     (core/list? head)\n                     (recur opts (conj methods head) tail)\n                     :else\n                     (throw #?(:clj  (Exception.\n                                       (core/str \"Invalid protocol, \" psym \" received unexpected argument\"))\n                               :cljs (js/Error.\n                                       (core/str \"Invalid protocol, \" psym \" received unexpected argument\"))))\n                     ))))\n             psym (vary-meta psym merge opts)\n             ns-name (core/-> &env :ns :name)\n             fqn (core/fn [n] (symbol (core/str ns-name) (core/str n)))\n             prefix (protocol-prefix p)\n             _ (core/doseq [[mname & arities] methods]\n                 (core/when (some #{0} (map count (filter vector? arities)))\n                   (throw\n                     #?(:clj (Exception.\n                               (core/str \"Invalid protocol, \" psym\n                                 \" defines method \" mname \" with arity 0\"))\n                        :cljs (js/Error.\n                                (core/str \"Invalid protocol, \" psym\n                                  \" defines method \" mname \" with arity 0\"))))))\n             expand-sig (core/fn [fname slot sig]\n                          (core/let [sig (core/if-not (every? core/symbol? sig)\n                                           (mapv (core/fn [arg]\n                                                   (core/cond\n                                                     (core/symbol? arg) arg\n                                                     (core/and (map? arg) (core/some? (:as arg))) (:as arg)\n                                                     :else (gensym))) sig)\n                                           sig)\n\n                                     fqn-fname (fqn fname)\n                                     fsig (first sig)\n\n                                     ;; construct protocol checks in reverse order\n                                     ;; check the.protocol/fn[\"_\"] for default impl last\n                                     check\n                                     `(let [m# (unchecked-get ~fqn-fname \"_\")]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          (throw\n                                            (missing-protocol\n                                              ~(core/str psym \".\" fname) ~fsig))))\n\n                                     ;; then check protocol fn in metadata (only when protocol is marked with :extend-via-metadata true)\n                                     check\n                                     (core/if-not (:extend-via-metadata opts)\n                                       check\n                                       `(if-let [meta-impl# (-> ~fsig (core/meta) (core/get '~fqn-fname))]\n                                          (meta-impl# ~@sig)\n                                          ~check))\n\n                                     ;; then check protocol on js string,function,array,object\n                                     check\n                                     `(let [x# (if (nil? ~fsig) nil ~fsig)\n                                            m# (unchecked-get ~fqn-fname (goog/typeOf x#))]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          ~check))\n\n                                     ;; then check protocol property on object (first check actually executed)\n                                     check\n                                     `(if (and (not (nil? ~fsig))\n                                               (not (nil? (. ~fsig ~(symbol (core/str \"-\" slot)))))) ;; Property access needed here.\n                                        (. ~fsig ~slot ~@sig)\n                                        ~check)]\n                            `(~sig ~check)))\n             psym (core/-> psym\n                    (vary-meta update-in [:jsdoc] conj\n                      \"@interface\")\n                    (vary-meta assoc-in [:protocol-info :methods]\n                      (into {}\n                        (map\n                          (core/fn [[fname & sigs]]\n                            (core/let [doc (core/as-> (last sigs) doc\n                                             (core/when (core/string? doc) doc))\n                                       sigs (take-while vector? sigs)]\n                              [(vary-meta fname assoc :doc doc)\n                               (vec sigs)]))\n                          methods))))\n             method (core/fn [[fname & sigs]]\n                      (core/let [doc (core/as-> (last sigs) doc\n                                       (core/when (core/string? doc) doc))\n                                 sigs (take-while vector? sigs)\n                                 amp (core/when (some #{'&} (apply concat sigs))\n                                       (cljs.analyzer/warning\n                                        :protocol-with-variadic-method\n                                        &env {:protocol psym :name fname}))\n                                 slot (symbol (core/str prefix (munge (name fname))))\n                                 fname (vary-meta fname assoc\n                                         :protocol p\n                                         :doc doc)]\n                        `(defn ~fname\n                           ~@(map (core/fn [sig]\n                                    (expand-sig fname\n                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                      sig))\n                               sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (~'js* \"function(){}\"))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))\n\n(core/defmacro implements?\n  \"EXPERIMENTAL\"\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if ~xsym\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false)\n           false))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           false)\n         false))))\n\n(core/defmacro satisfies?\n  \"Returns true if x satisfies the protocol\"\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if-not (nil? ~xsym)\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false))\n           (cljs.core/native-satisfies? ~psym ~xsym)))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           (if (coercive-not (. ~x ~msym))\n             (cljs.core/native-satisfies? ~psym ~x)\n             false))\n         (cljs.core/native-satisfies? ~psym ~x)))))\n\n(core/defmacro lazy-seq\n  \"Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.\"\n  [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))\n\n(core/defmacro delay\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  [& body]\n  `(new cljs.core/Delay (fn [] ~@body) nil))\n\n(core/defmacro with-redefs\n  \"binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.\"\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)\n             vals (take-nth 2 (drop 1 bindings))\n             orig-val-syms (map (comp gensym #(core/str % \"-orig-val__\") name) names)\n             temp-val-syms (map (comp gensym #(core/str % \"-temp-val__\") name) names)\n             binds (map core/vector names temp-val-syms)\n             resets (reverse (map core/vector names orig-val-syms))\n             bind-value (core/fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave orig-val-syms names)\n           ~@(interleave temp-val-syms vals)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n         (finally\n           ~@(map bind-value resets))))))\n\n(core/defmacro binding\n  \"binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.\"\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))\n\n(core/defmacro condp\n  \"Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.\"\n  {:added \"1.0\"}\n\n  [pred expr & clauses]\n  (core/let [gpred (gensym \"pred__\")\n             gexpr (gensym \"expr__\")\n             emit (core/fn emit [pred expr args]\n                    (core/let [[[a b c :as clause] more]\n                               (split-at (if (= :>> (second args)) 3 2) args)\n                               n (count clause)]\n                      (core/cond\n                        (= 0 n) `(throw (js/Error. (cljs.core/str \"No matching clause: \" ~expr)))\n                        (= 1 n) a\n                        (= 2 n) `(if (~pred ~a ~expr)\n                                   ~b\n                                   ~(emit pred expr more))\n                        :else `(if-let [p# (~pred ~a ~expr)]\n                                 (~c p#)\n                                 ~(emit pred expr more)))))\n             gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))\n\n(core/defn- assoc-test [m test expr env]\n  (if (contains? m test)\n    (throw\n      #?(:clj (clojure.core/IllegalArgumentException.\n                (core/str \"Duplicate case test constant '\"\n                  test \"'\"\n                  (core/when (:line env)\n                    (core/str \" on line \" (:line env) \" \"\n                      cljs.analyzer/*cljs-file*))))\n         :cljs (js/Error.\n                 (core/str \"Duplicate case test constant '\"\n                   test \"'\"\n                   (core/when (:line env)\n                     (core/str \" on line \" (:line env) \" \"\n                       cljs.analyzer/*cljs-file*))))))\n    (assoc m test expr)))\n\n(core/defn- const? [env x]\n  (core/let [m (core/and (core/list? x)\n                         (ana/resolve-var env (last x)))]\n    (core/when m (core/get m :const))))\n\n(core/defmacro case\n  \"Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.\"\n  [e & clauses]\n  (core/let [esym    (gensym)\n             default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (cljs.core/str \"No matching clause: \" ~esym))))\n             env     &env\n             pairs   (reduce\n                       (core/fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (core/fn [m test]\n                               (core/let [test (if (core/symbol? test)\n                                                 (core/list 'quote test)\n                                                 test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list 'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             tests   (keys pairs)]\n    (core/cond\n      (every? (some-fn core/number? core/string? #?(:clj core/char? :cljs (core/fnil core/char? :nonchar)) #(const? env %)) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 kw-str #(.substring (core/str %) 1)\n                 tests (mapv #(if (seq? %) (mapv kw-str %) [(kw-str %)]) (take-nth 2 no-default))\n                 thens (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e\n               ~esym (if (keyword? ~esym) (.-fqn ~(vary-meta esym assoc :tag 'cljs.core/Keyword)) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n\n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (core/fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n           :else ~default)))))\n\n(core/defmacro ^:private when-assert [x]\n  (core/when *assert* x))\n\n(core/defmacro assert\n  \"Evaluates expr and throws an exception if it does not evaluate to\n  logical true.\"\n  ([x]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error. ~(core/str \"Assert failed: \" (core/pr-str x)))))))\n  ([x message]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" ~(core/pr-str x))))))))\n\n(core/defmacro for\n  \"List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))\"\n  [seq-exprs body-expr]\n  (assert-args for\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [to-groups (core/fn [seq-exprs]\n                         (reduce (core/fn [groups [k v]]\n                                   (if (core/keyword? k)\n                                     (conj (pop groups) (conj (peek groups) [k v]))\n                                     (conj groups [k v])))\n                           [] (partition 2 seq-exprs)))\n             err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             emit-bind (core/fn emit-bind [[[bind expr & mod-pairs]\n                                       & [[_ next-expr] :as next-groups]]]\n                         (core/let [giter (gensym \"iter__\")\n                                    gxs (gensym \"s__\")\n                                    do-mod (core/fn do-mod [[[k v :as pair] & etc]]\n                                             (core/cond\n                                               (= k :let) `(let ~v ~(do-mod etc))\n                                               (= k :while) `(when ~v ~(do-mod etc))\n                                               (= k :when) `(if ~v\n                                                              ~(do-mod etc)\n                                                              (recur (rest ~gxs)))\n                                               (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                               next-groups\n                                               `(let [iterys# ~(emit-bind next-groups)\n                                                      fs# (seq (iterys# ~next-expr))]\n                                                  (if fs#\n                                                    (concat fs# (~giter (rest ~gxs)))\n                                                    (recur (rest ~gxs))))\n                                               :else `(cons ~body-expr\n                                                        (~giter (rest ~gxs)))))]\n                           (if next-groups\n                             #_ \"not the inner-most loop\"\n                             `(fn ~giter [~gxs]\n                                (lazy-seq\n                                  (loop [~gxs ~gxs]\n                                    (when-first [~bind ~gxs]\n                                      ~(do-mod mod-pairs)))))\n                             #_\"inner-most loop\"\n                             (core/let [gi (gensym \"i__\")\n                                        gb (gensym \"b__\")\n                                        do-cmod (core/fn do-cmod [[[k v :as pair] & etc]]\n                                                  (core/cond\n                                                    (= k :let) `(let ~v ~(do-cmod etc))\n                                                    (= k :while) `(when ~v ~(do-cmod etc))\n                                                    (= k :when) `(if ~v\n                                                                   ~(do-cmod etc)\n                                                                   (recur\n                                                                     (unchecked-inc ~gi)))\n                                                    (core/keyword? k)\n                                                    (err \"Invalid 'for' keyword \" k)\n                                                    :else\n                                                    `(do (chunk-append ~gb ~body-expr)\n                                                         (recur (unchecked-inc ~gi)))))]\n                               `(fn ~giter [~gxs]\n                                  (lazy-seq\n                                    (loop [~gxs ~gxs]\n                                      (when-let [~gxs (seq ~gxs)]\n                                        (if (chunked-seq? ~gxs)\n                                          (let [c# ^not-native (chunk-first ~gxs)\n                                                size# (count c#)\n                                                ~gb (chunk-buffer size#)]\n                                            (if (coercive-boolean\n                                                  (loop [~gi 0]\n                                                    (if (< ~gi size#)\n                                                      (let [~bind (-nth c# ~gi)]\n                                                        ~(do-cmod mod-pairs))\n                                                      true)))\n                                              (chunk-cons\n                                                (chunk ~gb)\n                                                (~giter (chunk-rest ~gxs)))\n                                              (chunk-cons (chunk ~gb) nil)))\n                                          (let [~bind (first ~gxs)]\n                                            ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))\n\n(core/defmacro doseq\n  \"Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \\\"for\\\".  Does not retain\n  the head of the sequence. Returns nil.\"\n  [seq-exprs & body]\n  (assert-args doseq\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             step (core/fn step [recform exprs]\n                    (core/if-not exprs\n                      [true `(do ~@body nil)]\n                      (core/let [k (first exprs)\n                                 v (second exprs)\n\n                                 seqsym (gensym \"seq__\")\n                                 recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                                 steppair (step recform (nnext exprs))\n                                 needrec (steppair 0)\n                                 subform (steppair 1)]\n                        (core/cond\n                          (= k :let) [needrec `(let ~v ~subform)]\n                          (= k :while) [false `(when ~v\n                                                 ~subform\n                                                 ~@(core/when needrec [recform]))]\n                          (= k :when) [false `(if ~v\n                                                (do\n                                                  ~subform\n                                                  ~@(core/when needrec [recform]))\n                                                ~recform)]\n                          (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                          :else (core/let [chunksym (with-meta (gensym \"chunk__\")\n                                                      {:tag 'not-native})\n                                           countsym (gensym \"count__\")\n                                           isym     (gensym \"i__\")\n                                           recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                           steppair-chunk (step recform-chunk (nnext exprs))\n                                           subform-chunk  (steppair-chunk 1)]\n                                  [true `(loop [~seqsym   (seq ~v)\n                                                ~chunksym nil\n                                                ~countsym 0\n                                                ~isym     0]\n                                           (if (coercive-boolean (< ~isym ~countsym))\n                                             (let [~k (-nth ~chunksym ~isym)]\n                                               ~subform-chunk\n                                               ~@(core/when needrec [recform-chunk]))\n                                             (when-let [~seqsym (seq ~seqsym)]\n                                               (if (chunked-seq? ~seqsym)\n                                                 (let [c# (chunk-first ~seqsym)]\n                                                   (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                                 (let [~k (first ~seqsym)]\n                                                   ~subform\n                                                   ~@(core/when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))\n\n(core/defmacro array [& rest]\n  (core/let [xs-str (core/->> (repeat \"~{}\")\n                      (take (count rest))\n                      (interpose \",\")\n                      (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))\n\n(core/defmacro make-array\n  ([size]\n   (vary-meta\n     (if (core/number? size)\n       `(array ~@(take size (repeat nil)))\n       `(js/Array. ~size))\n     assoc :tag 'array))\n  ([type size]\n   `(cljs.core/make-array ~size))\n  ([type size & more-sizes]\n   (vary-meta\n     `(let [dims#     (list ~@more-sizes)\n            dimarray# (cljs.core/make-array ~size)]\n        (dotimes [i# (alength dimarray#)]\n          (aset dimarray# i# (apply cljs.core/make-array nil dims#)))\n        dimarray#)\n     assoc :tag 'array)))\n\n(core/defmacro list\n  ([]\n   '(.-EMPTY cljs.core/List))\n  ([x]\n   `(cljs.core/List. nil ~x nil 1 nil))\n  ([x & xs]\n   (core/let [cnt (core/inc (count xs))]\n     `(cljs.core/List. nil ~x (list ~@xs) ~cnt nil))))\n\n(core/defmacro vector\n  ([] '(.-EMPTY cljs.core/PersistentVector))\n  ([& xs]\n   (core/let [cnt (count xs)]\n     (if (core/< cnt 32)\n       `(cljs.core/PersistentVector. nil ~cnt 5\n          (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n       (vary-meta\n         `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n         assoc :tag 'cljs.core/PersistentVector)))))\n\n(core/defmacro array-map\n  ([] '(.-EMPTY cljs.core/PersistentArrayMap))\n  ([& kvs]\n   (core/let [keys (map first (partition 2 kvs))]\n     (if (core/and (every? #(= (:op (cljs.analyzer/unwrap-quote %)) :const)\n                     (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) keys))\n           (= (count (into #{} keys)) (count keys)))\n       `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n       `(.createAsIfByAssoc cljs.core/PersistentArrayMap (array ~@kvs))))))\n\n(core/defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([& kvs]\n   (core/let [pairs (partition 2 kvs)\n              ks    (map first pairs)\n              vs    (map second pairs)]\n     (vary-meta\n       `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n       assoc :tag 'cljs.core/PersistentHashMap))))\n\n(core/defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op (cljs.analyzer/unwrap-quote %)) :const)\n                    (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.createAsIfByAssoc cljs.core/PersistentHashSet (array ~@xs))\n        assoc :tag 'cljs.core/PersistentHashSet))))\n\n(core/defn- js-obj* [kvs]\n  (core/let [kvs-str (core/->> (repeat \"~{}:~{}\")\n                       (take (count kvs))\n                       (interpose \",\")\n                       (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"({\" kvs-str \"})\") (apply concat kvs))\n      assoc :tag 'object)))\n\n(core/defmacro js-obj [& rest]\n  (core/let [sym-or-str? (core/fn [x] (core/or (core/symbol? x) (core/string? x)))\n             filter-on-keys (core/fn [f coll]\n                              (core/->> coll\n                                (filter (core/fn [[k _]] (f k)))\n                                (into {})))\n             kvs (into {} (map vec (partition 2 rest)))\n             sym-pairs (filter-on-keys core/symbol? kvs)\n             expr->local (zipmap\n                           (filter (complement sym-or-str?) (keys kvs))\n                           (repeatedly gensym))\n             obj (gensym \"obj\")]\n    (if (empty? rest)\n      (js-obj* '())\n      `(let [~@(apply concat (clojure.set/map-invert expr->local))\n            ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n        ~@(map (core/fn [[k v]] `(goog.object/set ~obj ~k ~v)) sym-pairs)\n        ~@(map (core/fn [[k v]] `(goog.object/set ~obj ~v ~(core/get kvs k))) expr->local)\n        ~obj))))\n\n(core/defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))\n\n(core/defmacro amap\n  \"Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.\"\n  [a idx ret expr]\n  `(let [a# ~a\n         l# (alength a#)\n         ~ret (cljs.core/aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx l#)\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))\n\n(core/defmacro areduce\n  \"Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.\"\n  [a idx ret init expr]\n  `(let [a# ~a\n         l# (alength a#)]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx l#)\n         (recur (inc ~idx) ~expr)\n         ~ret))))\n\n(core/defmacro dotimes\n  \"bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.\"\n  [bindings & body]\n  (core/let [i (first bindings)\n             n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))\n\n(core/defn- check-valid-options\n  \"Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.\"\n  [options & valid-keys]\n  (core/when (seq (apply disj (apply core/hash-set (keys options)) valid-keys))\n    (throw\n      (apply core/str \"Only these options are valid: \"\n        (first valid-keys)\n        (map #(core/str \", \" %) (rest valid-keys))))))\n\n(core/defmacro defmulti\n  \"Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy\"\n  {:arglists '([name docstring? attr-map? dispatch-fn & options])}\n  [mm-name & options]\n  (core/let [docstring   (if (core/string? (first options))\n                           (first options)\n                           nil)\n             options     (if (core/string? (first options))\n                           (next options)\n                           options)\n             m           (if (map? (first options))\n                           (first options)\n                           {})\n             options     (if (map? (first options))\n                           (next options)\n                           options)\n             dispatch-fn (first options)\n             options     (next options)\n             m           (if docstring\n                           (assoc m :doc docstring)\n                           m)\n             m           (if (meta mm-name)\n                           (conj (meta mm-name) m)\n                           m)\n             mm-ns (core/-> &env :ns :name core/str)]\n    (core/when (= (count options) 1)\n      (throw\n        #?(:clj (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")\n           :cljs (js/Error. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))))\n    (core/let [options (apply core/hash-map options)\n               default (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(defonce ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (cljs.core/get ~options :hierarchy ((~'js* \"cljs.core.get_global_hierarchy\")))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n             method-table# prefer-table# method-cache# cached-hierarchy#))))))\n\n(core/defmacro defmethod\n  \"Creates and installs a new method of multimethod associated with dispatch-value. \"\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))\n\n(core/defmacro time\n  \"Evaluates expr and prints the time it took. Returns the value of expr.\"\n  [expr]\n  `(let [start# (system-time)\n         ret# ~expr]\n     (prn (cljs.core/str \"Elapsed time: \"\n            (.toFixed (- (system-time) start#) 6)\n            \" msecs\"))\n     ret#))\n\n(core/defmacro simple-benchmark\n  \"Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.\"\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (core/let [bs-str   (pr-str bindings)\n             expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                      ~iterations \" runs, \" elapsed# \" msecs\"))))))\n\n(def ^:private cs (into [] (map (comp gensym core/str core/char) (range 97 118))))\n\n(core/defn- gen-apply-to-helper\n  ([] (gen-apply-to-helper 1))\n  ([n]\n   (if (core/<= n 20)\n     `(let [~(cs (core/dec n)) (-first ~'args)\n            ~'args (-rest ~'args)]\n        (if (== ~'argc ~n)\n          (~'f ~@(take n cs))\n          ~(gen-apply-to-helper (core/inc n))))\n     `(throw (js/Error. \"Only up to 20 arguments supported on functions\")))))\n\n(core/defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))\n\n(core/defn- gen-apply-to-simple-helper\n  [f num-args args]\n  (core/let [new-arg-sym (symbol (core/str \"a\" num-args))\n             proto-name (core/str \"cljs$core$IFn$_invoke$arity$\" (core/inc num-args))\n             proto-prop (symbol (core/str \".-\" proto-name))\n             proto-inv (symbol (core/str \".\" proto-name))\n             next-sym (symbol (core/str \"next_\" num-args))\n             all-args (mapv #(symbol (core/str \"a\" %)) (range (core/inc num-args)))]\n    `(let [~new-arg-sym (cljs.core/-first ~args)\n           ~next-sym (cljs.core/next ~args)]\n       (if (nil? ~next-sym)\n         (if (~proto-prop ~f)\n           (~proto-inv ~f ~@all-args)\n           (.call ~f ~f ~@all-args))\n         ~(if (core/<= 19 num-args)\n            ;; We've exhausted all protocols, fallback to .apply:\n            `(let [arr# (cljs.core/array ~@all-args)]\n               (loop [s# ~next-sym]\n                 (when s#\n                   (do (.push arr# (cljs.core/-first s#))\n                       (recur (cljs.core/next s#)))))\n               (.apply ~f ~f arr#))\n            (gen-apply-to-simple-helper f (core/inc num-args) next-sym))))))\n\n(core/defmacro gen-apply-to-simple\n  [f num-args args]\n  (gen-apply-to-simple-helper f num-args args))\n\n(core/defmacro with-out-str\n  \"Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.\"\n  [& body]\n  `(let [sb# (goog.string/StringBuffer.)]\n     (binding [cljs.core/*print-newline* true\n               cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))\n\n(core/defmacro lazy-cat\n  \"Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))\"\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))\n\n(core/defmacro js-str [s]\n  (core/list 'js* \"''+~{}\" s))\n\n(core/defmacro es6-iterable [ty]\n  `(goog.object/set (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))\n\n(core/defmacro ns-publics\n  \"Returns a map of the public intern mappings for the namespace.\"\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (= (first quoted-ns) 'quote)\n                         (core/symbol? (second quoted-ns)))\n    \"Argument to ns-publics must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (filter (core/fn [[_ info]]\n                      (not (core/-> info :meta :private)))\n              (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs])))])))\n\n(core/defmacro ns-imports\n  \"Returns a map of the import mappings for the namespace.\"\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (= (first quoted-ns) 'quote)\n                         (core/symbol? (second quoted-ns)))\n    \"Argument to ns-imports must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[ctor qualified-ctor]]\n              `[(symbol ~(name ctor)) ~(symbol qualified-ctor)])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :imports]))])))\n\n(core/defmacro ns-interns\n  \"Returns a map of the intern mappings for the namespace.\"\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                 (= (first quoted-ns) 'quote)\n                 (core/symbol? (second quoted-ns)))\n    \"Argument to ns-interns must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))])))\n\n(core/defmacro ns-unmap\n  \"Removes the mappings for the symbol from the namespace.\"\n  [quoted-ns quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-ns) (= (first quoted-ns) 'quote) (core/symbol? (second quoted-ns))\n              (seq? quoted-sym) (= (first quoted-sym) 'quote) (core/symbol? (second quoted-sym)))\n    \"Arguments to ns-unmap must be quoted symbols\")\n  (core/let [ns (second quoted-ns)\n             sym (second quoted-sym)]\n    (swap! env/*compiler* update-in [::ana/namespaces ns :defs] dissoc sym)\n    `(js-delete ~(comp/munge ns) ~(comp/munge (core/str sym)))))\n\n(core/defmacro vswap!\n  \"Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.\"\n  [vol f & args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))\n\n(core/defmacro locking\n  [x & forms]\n  `(do ~@forms))\n\n;; An internal-use Var for defining specs on the ns special form\n(core/defmacro ^:private ns-special-form [])\n\n(core/defmacro require\n  \"Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])\"\n  [& args]\n  `(~'ns* ~(cons :require args)))\n\n(core/defmacro require-macros\n  \"Similar to require but only for macros.\"\n  [& args]\n  `(~'ns* ~(cons :require-macros args)))\n\n(core/defmacro use\n  \"Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])\"\n  [& args]\n  `(~'ns* ~(cons :use args)))\n\n(core/defmacro use-macros\n  \"Similar to use but only for macros.\"\n  [& args]\n  `(~'ns* ~(cons :use-macros args)))\n\n(core/defmacro import\n  \"import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.\"\n  [& import-symbols-or-lists]\n  `(~'ns* ~(cons :import import-symbols-or-lists)))\n\n(core/defmacro refer-clojure\n  \"Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.\"\n  [& args]\n  `(~'ns* ~(cons :refer-clojure args)))\n\n;; INTERNAL - do not use, only for Node.js\n(core/defmacro load-file* [f]\n  `(goog/nodeGlobalRequire ~f))\n\n(core/defmacro macroexpand-1\n  \"If form represents a macro form, returns its expansion,\n  else returns form.\"\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand-1 must be quoted\")\n  (core/let [form (second quoted)]\n    (if (seq? form)\n      `(quote ~(ana/macroexpand-1 &env form))\n      form)))\n\n(core/defmacro macroexpand\n  \"Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.\"\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand must be quoted\")\n  (core/let [form (second quoted)\n             env &env]\n    (if (seq? form)\n      (core/loop [form form form' (ana/macroexpand-1 env form)]\n        (core/if-not (core/identical? form form')\n          (recur form' (ana/macroexpand-1 env form'))\n          `(quote ~form')))\n      form)))\n\n(core/defn- multi-arity-fn? [fdecl]\n  (core/< 1 (count fdecl)))\n\n(core/defn- variadic-fn? [fdecl]\n  (core/and (= 1 (count fdecl))\n            (some '#{&} (ffirst fdecl))))\n\n(core/defn- variadic-fn*\n  ([sym method]\n   (variadic-fn* sym method true))\n  ([sym [arglist & body :as method] solo]\n   (core/let [sig (remove '#{&} arglist)\n              restarg (gensym \"seq\")]\n     (core/letfn [(get-delegate []\n                    'cljs$core$IFn$_invoke$arity$variadic)\n                  (get-delegate-prop []\n                    (symbol (core/str \"-\" (get-delegate))))\n                  (param-bind [param]\n                    `[~param (^::ana/no-resolve first ~restarg)\n                      ~restarg (^::ana/no-resolve next ~restarg)])\n                  (apply-to []\n                    (if (core/< 1 (count sig))\n                      (core/let [params (repeatedly (core/dec (count sig)) gensym)]\n                        `(fn\n                           ([~restarg]\n                            (let [~@(mapcat param-bind params)]\n                              (this-as self#\n                                (. self# (~(get-delegate) ~@params ~restarg)))))))\n                      `(fn\n                         ([~restarg]\n                          (this-as self#\n                            (. self# (~(get-delegate) (seq ~restarg))))))))]\n       `(do\n          (set! (. ~sym ~(get-delegate-prop))\n            (fn (~(vec sig) ~@body)))\n          ~@(core/when solo\n              `[(set! (. ~sym ~'-cljs$lang$maxFixedArity)\n                  ~(core/dec (count sig)))])\n          (js-inline-comment \" @this {Function} \")\n          ;; dissoc :top-fn so this helper gets ignored in cljs.analyzer/parse 'set!\n          (set! (. ~(vary-meta sym dissoc :top-fn) ~'-cljs$lang$applyTo)\n            ~(apply-to)))))))\n\n(core/defmacro copy-arguments [dest]\n  `(let [len# (alength (js-arguments))]\n     (loop [i# 0]\n       (when (< i# len#)\n         (.push ~dest (unchecked-get (js-arguments) i#))\n         (recur (inc i#))))))\n\n(core/defn- elide-implicit-macro-args [arglists]\n  (core/map (core/fn [arglist]\n              (if (core/vector? arglist)\n                (core/subvec arglist 2)\n                (core/drop 2 arglist)))\n    arglists))\n\n(core/defn- variadic-fn [name meta [[arglist & body :as method] :as fdecl] emit-var?]\n  (core/letfn [(dest-args [c]\n                 (map (core/fn [n] `(unchecked-get (js-arguments) ~n))\n                   (range c)))]\n    (core/let [rname (symbol (core/str ana/*cljs-ns*) (core/str name))\n               sig   (remove '#{&} arglist)\n               c-1   (core/dec (count sig))\n               macro? (:macro meta)\n               mfa   (core/cond-> c-1 macro? (core/- 2))\n               meta  (assoc meta\n                       :top-fn\n                       {:variadic? true\n                        :fixed-arity mfa\n                        :max-fixed-arity mfa\n                        :method-params (core/cond-> [sig] macro? elide-implicit-macro-args)\n                        :arglists (core/cond-> (core/list arglist) macro? elide-implicit-macro-args)\n                        :arglists-meta (doall (map meta [arglist]))})\n               name  (with-meta name meta)]\n      `(do\n         (def ~name\n           (fn [~'var_args]\n             (let [args# (array)]\n               (copy-arguments args#)\n               (let [argseq# (when (< ~c-1 (alength args#))\n                               (new ^::ana/no-resolve cljs.core/IndexedSeq\n                                 (.slice args# ~c-1) 0 nil))]\n                 (. ~rname (~'cljs$core$IFn$_invoke$arity$variadic ~@(dest-args c-1) argseq#))))))\n         ~(variadic-fn* name method)\n         ~(core/when emit-var? `(var ~name))))))\n\n(core/comment\n  (require '[clojure.pprint :as pp])\n  (pp/pprint (variadic-fn 'foo {} '(([& xs]))))\n  (pp/pprint (variadic-fn 'foo {} '(([a & xs] xs))))\n  (pp/pprint (variadic-fn 'foo {} '(([a b & xs] xs))))\n  (pp/pprint (variadic-fn 'foo {} '(([a [b & cs] & xs] xs))))\n  )\n\n(core/defn- multi-arity-fn [name meta fdecl emit-var?]\n  (core/letfn [(dest-args [c]\n                 (map (core/fn [n] `(unchecked-get (js-arguments) ~n))\n                   (range c)))\n               (fixed-arity [rname sig]\n                 (core/let [c (count sig)]\n                   [c `(. ~rname\n                         (~(symbol\n                             (core/str \"cljs$core$IFn$_invoke$arity$\" c))\n                           ~@(dest-args c)))]))\n               (fn-method [name [sig & body :as method]]\n                 (if (some '#{&} sig)\n                   (variadic-fn* name method false)\n                   ;; fix up individual :fn-method meta for\n                   ;; cljs.analyzer/parse 'set! :top-fn handling\n                   `(set!\n                      (. ~(vary-meta name update :top-fn merge\n                            {:variadic? false :fixed-arity (count sig)})\n                        ~(symbol (core/str \"-cljs$core$IFn$_invoke$arity$\"\n                                   (count sig))))\n                      (fn ~method))))]\n    (core/let [rname    (symbol (core/str ana/*cljs-ns*) (core/str name))\n               arglists (map first fdecl)\n               varsig?  #(some '#{&} %)\n               variadic (boolean (some varsig? arglists))\n               sigs     (remove varsig? arglists)\n               maxfa    (apply core/max\n                          (concat\n                            (map count sigs)\n                            [(core/- (count (first (filter varsig? arglists))) 2)]))\n               macro?   (:macro meta)\n               mfa      (core/cond-> maxfa macro? (core/- 2))\n               meta     (assoc meta\n                          :top-fn\n                          {:variadic? variadic\n                           :fixed-arity mfa\n                           :max-fixed-arity mfa\n                           :method-params (core/cond-> sigs macro? elide-implicit-macro-args)\n                           :arglists (core/cond-> arglists macro? elide-implicit-macro-args)\n                           :arglists-meta (doall (map meta arglists))})\n               args-sym (gensym \"args\")\n               param-counts (map count arglists)\n               name     (with-meta name meta)]\n      (core/when (not= (distinct param-counts) param-counts)\n        (ana/warning :overload-arity {} {:name name}))\n      `(do\n         (def ~name\n           (fn [~'var_args]\n             (case (alength (js-arguments))\n               ~@(mapcat #(fixed-arity rname %) sigs)\n               ~(if variadic\n                  `(let [args-arr# (array)]\n                     (copy-arguments args-arr#)\n                     (let [argseq# (new ^::ana/no-resolve cljs.core/IndexedSeq\n                                        (.slice args-arr# ~maxfa) 0 nil)]\n                       (. ~rname\n                          (~'cljs$core$IFn$_invoke$arity$variadic\n                           ~@(dest-args maxfa)\n                           argseq#))))\n                  (if (:macro meta)\n                    `(throw (js/Error.\n                             (str \"Invalid arity: \" (- (alength (js-arguments)) 2))))\n                    `(throw (js/Error.\n                             (str \"Invalid arity: \" (alength (js-arguments))))))))))\n         ~@(map #(fn-method name %) fdecl)\n         ;; optimization properties\n         (set! (. ~name ~'-cljs$lang$maxFixedArity) ~maxfa)\n         ~(core/when emit-var? `(var ~name))))))\n\n(core/comment\n  (require '[clojure.pprint :as pp])\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a b]))))\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a & xs]))))\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a [b & cs] & xs]))))\n  ;; CLJS-1216\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a b & xs]))))\n  )\n\n(def\n  ^{:doc \"Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n    :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                 [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n    :macro true}\n  defn (core/fn defn [&form &env name & fdecl]\n         ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n         (if (core/instance? #?(:clj clojure.lang.Symbol :cljs Symbol) name)\n           nil\n           (throw\n             #?(:clj (IllegalArgumentException. \"First argument to defn must be a symbol\")\n                :cljs (js/Error. \"First argument to defn must be a symbol\"))))\n         (core/let [m (if (core/string? (first fdecl))\n                        {:doc (first fdecl)}\n                        {})\n                    fdecl (if (core/string? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    m (if (map? (first fdecl))\n                        (conj m (first fdecl))\n                        m)\n                    fdecl (if (map? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    fdecl (if (vector? (first fdecl))\n                            (core/list fdecl)\n                            fdecl)\n                    m (if (map? (last fdecl))\n                        (conj m (last fdecl))\n                        m)\n                    fdecl (if (map? (last fdecl))\n                            (butlast fdecl)\n                            fdecl)\n                    m (conj {:arglists (core/list 'quote (sigs fdecl))} m)\n                    ;; no support for :inline\n                    ;m (core/let [inline (:inline m)\n                    ;             ifn (first inline)\n                    ;             iname (second inline)]\n                    ;    ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                    ;    (if (if #?(:clj (clojure.lang.Util/equiv 'fn ifn)\n                    ;               :cljs (= 'fn ifn))\n                    ;          (if #?(:clj (core/instance? clojure.lang.Symbol iname)\n                    ;                 :cljs (core/instance? Symbol iname)) false true))\n                    ;      ;; inserts the same fn name to the inline fn if it does not have one\n                    ;      (assoc m\n                    ;        :inline (cons ifn\n                    ;                  (cons (clojure.lang.Symbol/intern\n                    ;                          (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                    ;                    (next inline))))\n                    ;      m))\n                    m (conj (if (meta name) (meta name) {}) m)]\n           (core/cond\n             (multi-arity-fn? fdecl)\n             (multi-arity-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl (:def-emits-var &env))\n\n             (variadic-fn? fdecl)\n             (variadic-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl (:def-emits-var &env))\n\n             :else\n             (core/list 'def (with-meta name m)\n               ;;todo - restore propagation of fn name\n               ;;must figure out how to convey primitive hints to self calls first\n               (cons `fn fdecl))))))\n\n#?(:clj  (. (var defn) (setMacro))\n   :cljs (set! (. defn -cljs$lang$macro) true))\n\n(core/defn defmacro\n  \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n  {:arglists '([name doc-string? attr-map? [params*] body]\n               [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :macro true}\n  [&form &env name & args]\n  (core/let [prefix (core/loop [p (core/list (vary-meta name assoc :macro true)) args args]\n                      (core/let [f (first args)]\n                        (if (core/string? f)\n                          (recur (cons f p) (next args))\n                          (if (map? f)\n                            (recur (cons f p) (next args))\n                            p))))\n             fdecl (core/loop [fd args]\n                     (if (core/string? (first fd))\n                       (recur (next fd))\n                       (if (map? (first fd))\n                         (recur (next fd))\n                         fd)))\n             fdecl (if (vector? (first fdecl))\n                     (core/list fdecl)\n                     fdecl)\n             add-implicit-args (core/fn [fd]\n                                 (core/let [args (first fd)]\n                                   (cons (vec (cons '&form (cons '&env args))) (next fd))))\n             add-args (core/fn [acc ds]\n                        (if (core/nil? ds)\n                          acc\n                          (core/let [d (first ds)]\n                            (if (map? d)\n                              (conj acc d)\n                              (recur (conj acc (add-implicit-args d)) (next ds))))))\n             fdecl (seq (add-args [] fdecl))\n             decl (core/loop [p prefix d fdecl]\n                    (if p\n                      (recur (next p) (cons (first p) d))\n                      d))]\n    `(let [ret# ~(cons `defn decl)]\n       (set! (. ~name ~'-cljs$lang$macro) true)\n       ret#)))\n\n#?(:clj  (. (var defmacro) (setMacro))\n   :cljs (set! (. defmacro -cljs$lang$macro) true))\n\n(core/defmacro resolve\n  \"Returns the var to which a symbol will be resolved in the namespace else nil.\"\n  [quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-sym)\n              (= 'quote (first quoted-sym)))\n    \"Argument to resolve must be a quoted symbol\")\n  (core/let [sym (second quoted-sym)\n             env &env\n             [var meta] (try\n                          (core/let [var (ana/resolve-var env sym (ana/confirm-var-exists-throw)) ]\n                            [var (ana/var-meta var)])\n                          (catch #?@(:clj [Throwable t] :cljs [:default e])\n                              [(ana/resolve-var env sym) nil]))\n             resolved (vary-meta (:name var) assoc ::ana/no-resolve true)]\n    `(when (exists? ~resolved)\n       (cljs.core/Var. (fn [] ~resolved) '~resolved ~meta))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/zip.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.zip",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;functional hierarchical zipper, with navigation, editing and enumeration\n;see Huet\n\n(ns ^{:doc \"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet\"\n       :author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))\n\n(defn zipper\n  \"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.\"\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])\n\n(defn seq-zip\n  \"Returns a zipper for nested sequences, given a root sequence\"\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))\n\n(defn vector-zip\n  \"Returns a zipper for nested vectors, given a root vector\"\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))\n\n(defn xml-zip\n  \"Returns a zipper for xml elements (as from xml/parse),\n  given a root element\"\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))\n\n(defn node\n  \"Returns the node at loc\"\n  [loc] (loc 0))\n\n(defn branch?\n  \"Returns true if the node at loc is a branch\"\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))\n\n(defn children\n  \"Returns a seq of the children of node at loc, which must be a branch\"\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))\n\n(defn make-node\n  \"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.\"\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))\n\n(defn path\n  \"Returns a seq of nodes leading to this loc\"\n  [loc]\n    (:pnodes (loc 1)))\n\n(defn lefts\n  \"Returns a seq of the left siblings of this loc\"\n  [loc]\n    (seq (:l (loc 1))))\n\n(defn rights\n  \"Returns a seq of the right siblings of this loc\"\n  [loc]\n    (:r (loc 1)))\n\n\n(defn down\n  \"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children\"\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))\n\n(defn up\n  \"Returns the loc of the parent of the node at this loc, or nil if at\n  the top\"\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))\n\n(defn root\n  \"zips all the way up and returns the root node, reflecting any\n changes.\"\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))\n\n(defn right\n  \"Returns the loc of the right sibling of the node at this loc, or nil\"\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))\n\n(defn rightmost\n  \"Returns the loc of the rightmost sibling of the node at this loc, or self\"\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))\n\n(defn left\n  \"Returns the loc of the left sibling of the node at this loc, or nil\"\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))\n\n(defn leftmost\n  \"Returns the loc of the leftmost sibling of the node at this loc, or self\"\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))\n\n(defn insert-left\n  \"Inserts the item as the left sibling of the node at this loc,\n without moving\"\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))\n\n(defn insert-right\n  \"Inserts the item as the right sibling of the node at this loc,\n  without moving\"\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))\n\n(defn replace\n  \"Replaces the node at this loc, without moving\"\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))\n\n(defn edit\n  \"Replaces the node at this loc with the value of (f node args)\"\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))\n\n(defn insert-child\n  \"Inserts the item as the leftmost child of the node at this loc,\n  without moving\"\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))\n\n(defn append-child\n  \"Inserts the item as the rightmost child of the node at this loc,\n  without moving\"\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))\n\n(defn next\n  \"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.\"\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))\n\n(defn prev\n  \"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.\"\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))\n\n(defn end?\n  \"Returns true if loc represents the end of a depth-first walk\"\n  [loc]\n    (= :end (loc 1)))\n\n(defn remove\n  \"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.\"\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))\n  \n(comment\n\n(load-file \"/Users/rich/dev/clojure/src/zip.clj\")\n(refer 'zip)\n(def data '[[a * b] + [c * d]])\n(def dz (vector-zip data))\n\n(right (down dz))\n(right (down (right (right (down dz)))))\n(lefts (right (down (right (right (down dz))))))\n(rights (right (down (right (right (down dz))))))\n(up (up (right (down (right (right (down dz)))))))\n(path (right (down (right (right (down dz))))))\n\n(-> dz down right right down right)\n(-> dz down right right down right (replace '/) root)\n(-> dz next next (edit str) next next next (replace '/) root)\n(-> dz next next next next next next next next next remove root)\n(-> dz next next next next next next next next next remove (insert-right 'e) root)\n(-> dz next next next next next next next next next remove up (append-child 'e) root)\n\n(end? (-> dz next next next next next next next next next remove next))\n\n(-> dz next remove next remove root)\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (= '* (node loc)) \n                   (replace loc '/)\n                   loc)))))\n\n(loop [loc dz]\n  (if (end? loc)\n    (root loc)\n    (recur (next (if (= '* (node loc)) \n                   (remove loc)\n                   loc)))))\n)\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader/impl/utils.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader.impl.utils",new cljs.core.Keyword(null,"source","source",-433931539),";;   Copyright (c) Nicola Mometto, Rich Hickey & contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.utils\n  (:refer-clojure :exclude [char])\n  (:require\n   [clojure.string :as string]\n   [goog.string :as gstring]))\n\n(defn char [x]\n  (when-not (nil? x)\n    (cljs.core/char x)))\n\n(defn ^boolean ex-info? [ex]\n  (instance? cljs.core.ExceptionInfo ex))\n\n(defrecord ReaderConditional [splicing? form])\n\n(defn ^boolean reader-conditional?\n  \"Return true if the value is the data representation of a reader conditional\"\n  [value]\n  (instance? ReaderConditional value))\n\n(defn reader-conditional\n  \"Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.\"\n  [form splicing?]\n  (ReaderConditional. splicing? form))\n\n(extend-protocol IPrintWithWriter\n  ReaderConditional\n  (-pr-writer [coll writer opts]\n    (-write writer (str \"#?\" (when (:splicing? coll) \"@\")))\n    (pr-writer (:form coll) writer opts)))\n\n(def ws-rx #\"[\\s]\")\n\n(defn ^boolean whitespace?\n  \"Checks whether a given character is whitespace\"\n  [ch]\n  (when-not (nil? ch)\n    (if (identical? ch \\,)\n      true\n      (.test ws-rx ch))))\n\n(defn ^boolean numeric?\n  \"Checks whether a given character is numeric\"\n  [ch]\n  (when-not (nil? ch)\n    (gstring/isNumeric ch)))\n\n(defn ^boolean newline?\n  \"Checks whether the character is a newline\"\n  [c]\n  (or (identical? \\newline c)\n      (identical? \"\\n\" c)\n      (nil? c)))\n\n(defn desugar-meta\n  \"Resolves syntactical sugar in metadata\" ;; could be combined with some other desugar?\n  [f]\n  (cond\n    (keyword? f) {f true}\n    (symbol? f)  {:tag f}\n    (string? f)  {:tag f}\n    :else        f))\n\n(def last-id (atom 0))\n\n(defn next-id\n  []\n  (swap! last-id inc))\n\n(defn namespace-keys [ns keys]\n  (for [key keys]\n    (if (or (symbol? key)\n            (keyword? key))\n      (let [[key-ns key-name] ((juxt namespace name) key)\n            ->key (if (symbol? key) symbol keyword)]\n        (cond\n          (nil? key-ns)\n          (->key ns key-name)\n\n          (= \"_\" key-ns)\n          (->key key-name)\n\n          :else\n          key))\n      key)))\n\n(defn second' [[a b]]\n  (when-not a b))\n\n(defn char-code [ch base]\n  (let [code (js/parseInt ch base)]\n    (if (js/isNaN code)\n      -1\n      code)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/test/check/properties.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.test.check.properties",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.properties\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.results :as results])\n  #?(:cljs (:require-macros [clojure.test.check.properties :refer [for-all]])))\n\n(defrecord ErrorResult [error]\n  results/Result\n  (pass? [_] false)\n  (result-data [_]\n    ;; spelling out the whole keyword here since `::error` is\n    ;; different in self-hosted cljs.\n    {:clojure.test.check.properties/error error}))\n\n(defn ^:private exception?\n  [x]\n  (instance? #?(:clj Throwable :cljs js/Error) x))\n\n(defn ^:private apply-gen\n  [function]\n  (fn [args]\n    (let [result (try\n                   (let [ret (apply function args)]\n                     ;; TCHECK-131: for backwards compatibility (mainly\n                     ;; for spec), treat returned exceptions like thrown\n                     ;; exceptions\n                     (if (exception? ret)\n                       (throw ret)\n                       ret))\n                   #?(:clj (catch java.lang.ThreadDeath t (throw t)))\n                   (catch #?(:clj Throwable :cljs :default) ex\n                     (->ErrorResult ex)))]\n      {:result result\n       :function function\n       :args args})))\n\n(defn for-all*\n  \"A function version of `for-all`. Takes a sequence of N generators\n  and a function of N args, and returns a property that calls the\n  function with generated values and tests the return value for\n  truthiness, like with `for-all`.\n\n  Example:\n\n  (for-all* [gen/large-integer gen/large-integer]\n            (fn [a b] (>= (+ a b) a)))\"\n  [args function]\n  (gen/fmap\n   (apply-gen function)\n   (apply gen/tuple args)))\n\n(defn- binding-vars\n  [bindings]\n  (map first (partition 2 bindings)))\n\n(defn- binding-gens\n  [bindings]\n  (map second (partition 2 bindings)))\n\n(defmacro for-all\n  \"Returns a property, which is the combination of some generators and\n  an assertion that should be true for all generated values. Properties\n  can be used with `quick-check` or `defspec`.\n\n  `for-all` takes a `let`-style bindings vector, where the right-hand\n  side of each binding is a generator.\n\n  The body should be an expression of the generated values that will\n  be tested for truthiness. Exceptions in the body will be caught and\n  treated as failures.\n\n  When there are multiple binding pairs, the earlier pairs are not\n  visible to the later pairs.\n\n  If there are multiple body expressions, all but the last one are\n  executed for side effects, as with `do`.\n\n  Example:\n\n  (for-all [a gen/large-integer\n            b gen/large-integer]\n    (>= (+ a b) a))\"\n  [bindings & body]\n  `(for-all* ~(vec (binding-gens bindings))\n             (fn [~@(binding-vars bindings)]\n               ~@body)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/reflect.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.reflect",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:author \"Stuart Halloway\"\n      :added \"1.3\"\n      :doc \"Reflection on Host Types\nAlpha - subject to change.\n\nTwo main entry points: \n\n* type-reflect reflects on something that implements TypeReference.\n* reflect (for REPL use) reflects on the class of an instance, or\n  on a class if passed a class\n\nKey features:\n\n* Exposes the read side of reflection as pure data. Reflecting\n  on a type returns a map with keys :bases, :flags, and :members.\n\n* Canonicalizes class names as Clojure symbols. Types can extend\n  to the TypeReference protocol to indicate that they can be\n  unambiguously resolved as a type name. The canonical format\n  requires one non-Java-ish convention: array brackets are <>\n  instead of [] so they can be part of a Clojure symbol.\n\n* Pluggable Reflectors for different implementations. The default\n  JavaReflector is good when you have a class in hand, or use\n  the AsmReflector for \\\"hands off\\\" reflection without forcing\n  classes to load.\n\nPlatform implementers must:\n\n* Create an implementation of Reflector.\n* Create one or more implementations of TypeReference.\n* def default-reflector to be an instance that satisfies Reflector.\"}\n  clojure.reflect\n  (:require [clojure.set :as set]))\n\n(defprotocol Reflector\n  \"Protocol for reflection implementers.\"\n  (do-reflect [reflector typeref]))\n\n(defprotocol TypeReference\n  \"A TypeReference can be unambiguously converted to a type name on\n   the host platform.\n\n   All typerefs are normalized into symbols. If you need to\n   normalize a typeref yourself, call typesym.\"\n  (typename [o] \"Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]\"))\n\n(declare default-reflector)\n\n(defn type-reflect\n  \"Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each member is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.\"\n  {:added \"1.3\"}\n  [typeref & options]\n  (let [{:keys [ancestors reflector]}\n        (merge {:reflector default-reflector}\n               (apply hash-map options))\n        refl (partial do-reflect reflector)\n        result (refl typeref)]\n    ;; could make simpler loop of two args: names an\n    (if ancestors\n      (let [make-ancestor-map (fn [names]\n                            (zipmap names (map refl names)))]\n        (loop [reflections (make-ancestor-map (:bases result))]\n          (let [ancestors-visited (set (keys reflections))\n                ancestors-to-visit (set/difference (set (mapcat :bases (vals reflections)))\n                                               ancestors-visited)]\n            (if (seq ancestors-to-visit)\n              (recur (merge reflections (make-ancestor-map ancestors-to-visit)))\n              (apply merge-with into result {:ancestors ancestors-visited}\n                     (map #(select-keys % [:members]) (vals reflections)))))))\n      result)))\n\n(defn reflect\n  \"Alpha - subject to change.\n   Reflect on the type of obj (or obj itself if obj is a class).\n   Return value and options are the same as for type-reflect. \"\n  {:added \"1.3\"}\n  [obj & options]\n  (apply type-reflect (if (class? obj) obj (class obj)) options))\n\n(load \"reflect/java\")\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/test.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.test",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns\n^{:author \"Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin\",\n     :doc \"A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \\\"is\\\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \\\"abcde\\\" \\\"ab\\\"))\n\n   You can type an \\\"is\\\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \\\"expected:\\\" line shows you the original expression, and the\n   \\\"actual:\\\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \\\"false\\\" on the last line is the value returned from the\n   expression.  The \\\"is\\\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \\\"(is (thrown? c ...))\\\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \\\"(is (thrown-with-msg? c re ...))\\\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\\\"Divide by zero\\\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \\\"is\\\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \\\"Crazy arithmetic\\\")\n\n   In addition, you can document groups of assertions with the\n   \\\"testing\\\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \\\"testing\\\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \\\"Arithmetic\\\"\n     (testing \\\"with positive integers\\\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \\\"with negative integers\\\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \\\"testing\\\" macro may only be used\n   INSIDE a \\\"deftest\\\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \\\"addition\\\" and \\\"subtraction\\\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \\\"Practical Common Lisp\\\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \\\"(arithmetic addition)\\\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \\\"(run-tests namespaces...)\\\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \\\"(run-all-tests)\\\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \\\"arithmetic\\\" example above, you\n   probably do not want the \\\"addition\\\" and \\\"subtraction\\\" tests run\n   separately.  In that case, you must define a special function\n   named \\\"test-ns-hook\\\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \\\"run-tests\\\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \\\"empty-env\\\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \\\"test-ns\\\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \\\"run-tests\\\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \\\":load-tests\\\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \\\"deftest\\\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \\\"each\\\"\n   fixtures are run repeatedly, once for each test function created\n   with \\\"deftest\\\".  \\\"each\\\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \\\"each\\\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \\\"once\\\" fixture, is only run once,\n   around ALL the tests in the namespace.  \\\"once\\\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \\\"once\\\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \\\"is\\\" macro by defining new\n   methods for the \\\"assert-expr\\\" multimethod.  These methods are\n   called during expansion of the \\\"is\\\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \\\"report\\\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \\\"testing\\\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n\"}\n  cljs.test\n  (:require-macros [clojure.template :as temp]\n                   [cljs.test :as test])\n  (:require [clojure.string :as string]\n            [cljs.pprint :as pprint]))\n\n;; =============================================================================\n;; Default Reporting\n\n(defn empty-env\n  \"Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report\"\n  ([] (empty-env ::default))\n  ([reporter]\n   (cond-> {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n            :testing-vars ()\n            :testing-contexts ()\n            :formatter pr-str\n            :reporter reporter}\n     (= ::pprint reporter) (assoc :reporter ::default\n                             :formatter pprint/pprint))))\n\n(def ^:dynamic *current-env* nil)\n\n(defn get-current-env []\n  (or *current-env* (empty-env)))\n\n(defn update-current-env! [ks f & args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))\n\n(defn set-env! [new-env]\n  (set! *current-env* new-env))\n\n(defn clear-env! []\n  (set! *current-env* nil))\n\n(defn get-and-clear-env! []\n  \"Like get-current-env, but cleans env before returning.\"\n  (let [env (cljs.test/get-current-env)]\n    (clear-env!)\n    env))\n\n(defn testing-vars-str\n  \"Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.\"\n  [m]\n  (let [{:keys [file line column]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      \" (\" file \":\" line (when column (str \":\" column)) \")\")))\n\n(defn testing-contexts-str\n  \"Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.\"\n  []\n  (apply str (interpose \" \" (reverse (:testing-contexts (get-current-env))))))\n\n(defn inc-report-counter!\n  \"Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.\"\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))\n\n(defmulti\n  ^{:doc \"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.\"\n     :dynamic true}\n  report (fn [m] [(:reporter (get-current-env)) (:type m)]))\n\n(defmethod report :default [m])\n\n(defmethod report [::default :pass] [m]\n  (inc-report-counter! :pass))\n\n(defn- print-comparison [m]\n  (let [formatter-fn (or (:formatter (get-current-env)) pr-str)]\n    (println \"expected:\" (formatter-fn (:expected m)))\n    (println \"  actual:\" (formatter-fn (:actual m)))))\n\n(defmethod report [::default :fail] [m]\n  (inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))\n\n(defmethod report [::default :error] [m]\n  (inc-report-counter! :error)\n  (println \"\\nERROR in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))\n\n(defmethod report [::default :summary] [m]\n  (println \"\\nRan\" (:test m) \"tests containing\"\n    (+ (:pass m) (:fail m) (:error m)) \"assertions.\")\n  (println (:fail m) \"failures,\" (:error m) \"errors.\"))\n\n(defmethod report [::default :begin-test-ns] [m]\n  (println \"\\nTesting\" (name (:ns m))))\n\n;; Ignore these message types:\n(defmethod report [::default :end-test-ns] [m])\n(defmethod report [::default :begin-test-var] [m]\n  #_(println \":begin-test-var\" (testing-vars-str m)))\n(defmethod report [::default :end-test-var] [m])\n(defmethod report [::default :end-run-tests] [m])\n(defmethod report [::default :end-test-all-vars] [m])\n(defmethod report [::default :end-test-vars] [m])\n\n;; =============================================================================\n;; File, Line, and Column Helpers\n\n(defn js-line-and-column [stack-element]\n  \"Returns a 2-element vector containing the line and\n  column encoded at the end of a stack element string.\n  A line or column will be represented as NaN if not\n  parsesable.\"\n  (let [parts (.split stack-element \":\")\n        cnt   (count parts)]\n    (if (> cnt 1)\n      [(js/parseInt (nth parts (- cnt 2)) 10)\n       (js/parseInt (nth parts (dec cnt)) 10)]\n      [##NaN ##NaN])))\n\n(defn js-filename [stack-element]\n  (let [output-dir (cljs.test/cljs-output-dir)\n        output-dir (cond-> output-dir\n                     (not (string/ends-with? output-dir \"/\"))\n                     (str \"/\"))]\n    (-> (.split stack-element output-dir)\n      last\n      (.split \":\")\n      first)))\n\n(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))\n\n(defn file-and-line [exception depth]\n  ;; TODO: flesh out\n  (if-let [stack-element (and (string? (.-stack exception))\n                              (some-> (.-stack exception)\n                                      string/split-lines\n                                      (get depth)\n                                      string/trim))]\n    (let [fname (js-filename stack-element)\n          [line column] (js-line-and-column stack-element)\n          [fname line column] (mapped-line-and-column fname line column)]\n      {:file fname :line line :column column})\n    {:file (.-fileName exception)\n     :line (.-lineNumber exception)}))\n\n(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))\n\n;; =============================================================================\n;; Async\n\n(defprotocol IAsyncTest\n  \"Marker protocol denoting CPS function to begin asynchronous\n  testing.\")\n\n(defn async?\n  \"Returns whether x implements IAsyncTest.\"\n  [x]\n  (satisfies? IAsyncTest x))\n\n(defn run-block\n  \"Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn\"\n  [fns]\n  (when-first [f fns]\n    (let [obj (f)]\n      (if (async? obj)\n        (obj (let [d (delay (run-block (rest fns)))]\n               (fn []\n                 (if (realized? d)\n                   (println \"WARNING: Async test called done more than one time.\")\n                   @d))))\n        (recur (cond->> (rest fns)\n                 (::block? (meta obj)) (concat obj)))))))\n\n(defn block\n  \"Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block.\"\n  [fns]\n  (some-> fns\n          (vary-meta assoc ::block? true)))\n\n;; =============================================================================\n;; Low-level functions\n\n(defn- test-var-block*\n  [v t]\n  {:pre [(instance? Var v)]}\n  [(fn []\n     (update-current-env! [:testing-vars] conj v)\n     (update-current-env! [:report-counters :test] inc)\n     (do-report {:type :begin-test-var :var v})\n     (try\n       (t)\n       (catch :default e\n         (case e\n           ::async-disabled (throw \"Async tests require fixtures to be specified as maps.  Testing aborted.\")\n           (do-report\n            {:type :error\n             :message \"Uncaught exception, not in assertion.\"\n             :expected nil\n             :actual e})))))\n   (fn []\n     (do-report {:type :end-test-var :var v})\n     (update-current-env! [:testing-vars] rest))])\n\n(defn test-var-block\n  \"Like test-var, but returns a block for further composition and\n  later execution.\"\n  [v]\n  (if-let [t (:test (meta v))]\n    (test-var-block* v t)))\n\n(defn test-var\n  \"If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env.\"\n  [v]\n  (run-block (test-var-block v)))\n\n(defn- default-fixture\n  \"The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures.\"\n  [f]\n  (f))\n\n(defn compose-fixtures\n  \"Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures.\"\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))\n\n(defn join-fixtures\n  \"Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures.\"\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))\n\n(defn- wrap-map-fixtures\n  \"Wraps block in map-fixtures.\"\n  [map-fixtures block]\n  (concat (keep :before map-fixtures)\n          block\n          (reverse (keep :after map-fixtures))))\n\n(defn- execution-strategy [once each]\n  (letfn [(fixtures-type [coll]\n            (cond\n              (empty? coll) :none\n              (every? map? coll) :map\n              (every? fn? coll) :fn))\n          (fixtures-types []\n            (->> (map fixtures-type [once each])\n              (remove #{:none})\n              (distinct)))]\n    (let [[type :as types] (fixtures-types)]\n      (assert (not-any? nil? types)\n        \"Fixtures may not be of mixed types\")\n      (assert (> 2 (count types))\n        \"fixtures specified in :once and :each must be of the same type\")\n      ({:map :async :fn :sync} type :async))))\n\n(defn- disable-async [f]\n  (fn []\n    (let [obj (f)]\n      (when (async? obj)\n        (throw ::async-disabled))\n      obj)))\n\n(defn test-vars-block\n  \"Like test-vars, but returns a block for further composition and\n  later execution.\"\n  [vars]\n  (map\n   (fn [[ns vars]]\n     (fn []\n       (block\n        (let [env (get-current-env)\n              once-fixtures (get-in env [:once-fixtures ns])\n              each-fixtures (get-in env [:each-fixtures ns])]\n          (case (execution-strategy once-fixtures each-fixtures)\n            :async\n            (->> vars\n                 (filter (comp :test meta))\n                 (mapcat (comp (partial wrap-map-fixtures each-fixtures)\n                               test-var-block))\n                 (wrap-map-fixtures once-fixtures))\n            :sync\n            (let [each-fixture-fn (join-fixtures each-fixtures)]\n              [(fn []\n                 ((join-fixtures once-fixtures)\n                  (fn []\n                    (doseq [v vars]\n                      (when-let [t (:test (meta v))]\n                        ;; (alter-meta! v update :test disable-async)\n                        (each-fixture-fn\n                         (fn []\n                           ;; (test-var v)\n                           (run-block\n                            (test-var-block* v (disable-async t))))))))))]))))))\n   (group-by (comp :ns meta) vars)))\n\n(defn test-vars\n  \"Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment.\"\n  [vars]\n  (run-block (concat (test-vars-block vars)\n                     [(fn []\n                        (report {:type :end-test-vars :vars vars}))])))\n\n;; =============================================================================\n;; Running Tests, high level functions\n\n(defn successful?\n  \"Returns true if the given test summary indicates all tests\n  were successful, false otherwise.\"\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/spec/gen/alpha.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.spec.gen.alpha",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.gen.alpha\n  (:refer-clojure :exclude [boolean cat hash-map list map not-empty set vector\n                            char double int keyword symbol string uuid delay shuffle])\n  (:require-macros [cljs.core :as c]\n                   [cljs.spec.gen.alpha :as gen :refer [dynaload lazy-combinators lazy-prims]])\n  (:require [cljs.core :as c])\n  (:import (goog Uri)))\n\n(deftype LazyVar [f ^:mutable cached]\n  IDeref\n  (-deref [this]\n    (if-not (nil? cached)\n      cached\n      (let [x (f)]\n        (when-not (nil? x)\n          (set! cached x))\n        x))))\n\n(def ^:private quick-check-ref\n  (dynaload 'clojure.test.check/quick-check))\n\n(defn quick-check\n  [& args]\n  (apply @quick-check-ref args))\n\n(def ^:private for-all*-ref\n  (dynaload 'clojure.test.check.properties/for-all*))\n\n(defn for-all*\n  \"Dynamically loaded clojure.test.check.properties/for-all*.\"\n  [& args]\n  (apply @for-all*-ref args))\n\n(let [g? (dynaload 'clojure.test.check.generators/generator?)\n      g (dynaload 'clojure.test.check.generators/generate)\n      mkg (dynaload 'clojure.test.check.generators/->Generator)]\n  (defn- generator?\n    [x]\n    (@g? x))\n  (defn- generator\n    [gfn]\n    (@mkg gfn))\n  (defn generate\n    \"Generate a single value using generator.\"\n    [generator]\n    (@g generator)))\n\n(defn ^:skip-wiki delay-impl\n  [gfnd]\n  ;;N.B. depends on test.check impl details\n  (generator (fn [rnd size]\n               ((:gen @gfnd) rnd size))))\n\n;(defn gen-for-name\n;  \"Dynamically loads test.check generator named s.\"\n;  [s]\n;  (let [g (dynaload s)]\n;    (if (generator? g)\n;      g\n;      (throw (js/Error. (str \"Var \" s \" is not a generator\"))))))\n\n(lazy-combinators hash-map list map not-empty set vector vector-distinct fmap elements\n  bind choose one-of such-that tuple sample return\n  large-integer* double* frequency shuffle)\n\n(lazy-prims any any-printable boolean char char-alpha char-alphanumeric char-ascii double\n  int keyword keyword-ns large-integer ratio simple-type simple-type-printable\n  string string-ascii string-alphanumeric symbol symbol-ns uuid)\n\n(defn cat\n  \"Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.\"\n  [& gens]\n  (fmap #(apply concat %)\n    (apply tuple gens)))\n\n(defn- ^boolean qualified? [ident] (not (nil? (namespace ident))))\n\n(def ^:private\ngen-builtins\n  (c/delay\n    (let [simple (simple-type-printable)]\n      {any? (one-of [(return nil) (any-printable)])\n       some? (such-that some? (any-printable))\n       number? (one-of [(large-integer) (double)])\n       integer? (large-integer)\n       int? (large-integer)\n       pos-int? (large-integer* {:min 1})\n       neg-int? (large-integer* {:max -1})\n       nat-int? (large-integer* {:min 0})\n       float? (double)\n       double? (double)\n       string? (string-alphanumeric)\n       ident? (one-of [(keyword-ns) (symbol-ns)])\n       simple-ident? (one-of [(keyword) (symbol)])\n       qualified-ident? (such-that qualified? (one-of [(keyword-ns) (symbol-ns)]))\n       keyword? (keyword-ns)\n       simple-keyword? (keyword)\n       qualified-keyword? (such-that qualified? (keyword-ns))\n       symbol? (symbol-ns)\n       simple-symbol? (symbol)\n       qualified-symbol? (such-that qualified? (symbol-ns))\n       uuid? (uuid)\n       uri? (fmap #(Uri. (str \"http://\" % \".com\")) (uuid))\n       inst? (fmap #(js/Date. %)\n                    (large-integer))\n       seqable? (one-of [(return nil)\n                         (list simple)\n                         (vector simple)\n                         (map simple simple)\n                         (set simple)\n                         (string-alphanumeric)])\n       indexed? (vector simple)\n       map? (map simple simple)\n       vector? (vector simple)\n       list? (list simple)\n       seq? (list simple)\n       char? (char)\n       set? (set simple)\n       nil? (return nil)\n       false? (return false)\n       true? (return true)\n       boolean? (boolean)\n       zero? (return 0)\n       ;rational? (one-of [(large-integer) (ratio)])\n       coll? (one-of [(map simple simple)\n                      (list simple)\n                      (vector simple)\n                      (set simple)])\n       empty? (elements [nil '() [] {} #{}])\n       associative? (one-of [(map simple simple) (vector simple)])\n       sequential? (one-of [(list simple) (vector simple)])\n       ;ratio? (such-that ratio? (ratio))\n       })))\n\n(defn gen-for-pred\n  \"Given a predicate, returns a built-in generator if one exists.\"\n  [pred]\n  (if (set? pred)\n    (elements pred)\n    (get @gen-builtins pred)))\n\n(comment\n  (require 'clojure.test.check)\n  (require 'clojure.test.check.properties)\n  (require 'cljs.spec.gen)\n  (in-ns 'cljs.spec.gen)\n\n  ;; combinators, see call to lazy-combinators above for complete list\n  (generate (one-of [(gen-for-pred integer?) (gen-for-pred string?)]))\n  (generate (such-that #(< 10000 %) (gen-for-pred integer?)))\n  (let [reqs {:a (gen-for-pred number?)\n              :b (gen-for-pred keyword?)}\n        opts {:c (gen-for-pred string?)}]\n    (generate (bind (choose 0 (count opts))\n                #(let [args (concat (seq reqs) (c/shuffle (seq opts)))]\n                  (->> args\n                    (take (+ % (count reqs)))\n                    (mapcat identity)\n                    (apply hash-map))))))\n  (generate (cat (list (gen-for-pred string?))\n              (list (gen-for-pred integer?))))\n\n  ;; load your own generator\n  ;(gen-for-name 'clojure.test.check.generators/int)\n\n  ;; failure modes\n  ;(gen-for-name 'unqualified)\n  ;(gen-for-name 'clojure.core/+)\n  ;(gen-for-name 'clojure.core/name-does-not-exist)\n  ;(gen-for-name 'ns.does.not.exist/f)\n\n  )\n\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/core.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.core",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.core\n  (:refer-clojure :exclude [-> ->> .. amap and areduce alength aclone assert assert-args binding bound-fn case comment\n                            cond condp declare definline definterface defmethod defmulti defn defn- defonce\n                            defprotocol defrecord defstruct deftype delay destructure doseq dosync dotimes doto\n                            extend-protocol extend-type fn for future gen-class gen-interface\n                            if-let if-not import io! lazy-cat lazy-seq let letfn locking loop\n                            memfn ns or proxy proxy-super pvalues refer-clojure reify sync time\n                            when when-first when-let when-not while with-bindings with-in-str\n                            with-loading-context with-local-vars with-open with-out-str with-precision with-redefs\n                            satisfies? identical? true? false? number? nil? instance? symbol? keyword? string? str get\n                            make-array vector list hash-map array-map hash-set\n\n                            aget aset\n                            + - * / < <= > >= == zero? pos? neg? inc dec max min mod\n                            byte char short int long float double\n                            unchecked-byte unchecked-char unchecked-short unchecked-int\n                            unchecked-long unchecked-float unchecked-double\n                            unchecked-add unchecked-add-int unchecked-dec unchecked-dec-int\n                            unchecked-divide unchecked-divide-int unchecked-inc unchecked-inc-int\n                            unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int\n                            unchecked-subtract unchecked-subtract-int unchecked-remainder-int\n                            unsigned-bit-shift-right\n\n                            bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set\n                            bit-test bit-shift-left bit-shift-right bit-xor defmacro\n\n                            cond-> cond->> as-> some-> some->>\n\n                            require use refer-clojure\n\n                            if-some when-some test ns-publics ns-imports ns-interns\n                            ns-unmap var vswap! macroexpand-1 macroexpand\n                            some? resolve\n                            #?@(:cljs [alias coercive-not coercive-not= coercive-= coercive-boolean\n                                       truth_ js-arguments js-delete js-in js-debugger exists? divide js-mod\n                                       unsafe-bit-and bit-shift-right-zero-fill mask bitpos caching-hash\n                                       defcurried rfn specify! js-this this-as implements? array js-obj\n                                       simple-benchmark gen-apply-to js-str es6-iterable load-file* undefined?\n                                       specify copy-arguments goog-define js-comment js-inline-comment\n                                       unsafe-cast require-macros use-macros gen-apply-to-simple unchecked-get unchecked-set])])\n  #?(:cljs (:require-macros [cljs.core :as core]\n                            [cljs.support :refer [assert-args]]))\n  (:require clojure.walk\n            clojure.set\n            [clojure.string :as string]\n            [cljs.compiler :as comp]\n            [cljs.env :as env]\n            #?(:clj [cljs.support :refer [assert-args]])\n            #?(:cljs [cljs.core :as core])\n            #?(:cljs [cljs.analyzer :as ana])))\n\n#?(:clj (alias 'core 'clojure.core))\n#?(:clj (alias 'ana 'cljs.analyzer))\n\n#?(:clj\n   (core/defmacro import-macros [ns [& vars]]\n     (core/let [ns (find-ns ns)\n                vars (map #(ns-resolve ns %) vars)\n                syms (map\n                       (core/fn [^clojure.lang.Var v]\n                         (core/-> v .sym\n                           (with-meta\n                             (merge\n                               {:macro true}\n                               (update-in (select-keys (meta v) [:arglists :doc :file :line])\n                                 [:arglists] (core/fn [arglists] `(quote ~arglists)))))))\n                       vars)\n                defs (map\n                       (core/fn [sym var]\n                         (core/let [{:keys [arglists doc file line]} (meta sym)]\n                           `(do\n                              (def ~sym (deref ~var))\n                              ;for AOT compilation\n                              (alter-meta! (var ~sym) assoc\n                                :macro true\n                                :arglists ~arglists\n                                :doc ~doc\n                                :file ~file\n                                :line ~line))))\n                       syms vars)]\n       `(do ~@defs\n            :imported))))\n\n#?(:clj\n   (import-macros clojure.core\n     [-> ->> .. assert comment cond\n      declare defn-\n      extend-protocol fn for\n      if-let if-not letfn\n      memfn\n      when when-first when-let when-not while\n      cond-> cond->> as-> some-> some->>\n      if-some when-some]))\n\n#?(:cljs\n   (core/defmacro ->\n     \"Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.\"\n     [x & forms]\n     (core/loop [x x, forms forms]\n       (if forms\n         (core/let [form (first forms)\n                    threaded (if (seq? form)\n                               (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                               (core/list form x))]\n           (recur threaded (next forms)))\n         x))))\n\n#?(:cljs\n   (core/defmacro ->>\n     \"Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.\"\n     [x & forms]\n     (core/loop [x x, forms forms]\n       (if forms\n         (core/let [form (first forms)\n                    threaded (if (seq? form)\n                               (with-meta `(~(first form) ~@(next form) ~x) (meta form))\n                               (core/list form x))]\n           (recur threaded (next forms)))\n         x))))\n\n#?(:cljs\n   (core/defmacro ..\n     \"form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \\\"os.name\\\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \\\"os.name\\\"))\n\n     but is easier to write, read, and understand.\"\n     ([x form] `(. ~x ~form))\n     ([x form & more] `(.. (. ~x ~form) ~@more))))\n\n#?(:cljs\n   (core/defmacro comment\n     \"Ignores body, yields nil\"\n     [& body]))\n\n#?(:cljs\n   (core/defmacro cond\n     \"Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil.\"\n     {:added \"1.0\"}\n     [& clauses]\n     (core/when clauses\n       (core/list 'if (first clauses)\n         (if (next clauses)\n           (second clauses)\n           (throw (js/Error. \"cond requires an even number of forms\")))\n         (cons 'cljs.core/cond (next (next clauses)))))))\n\n#?(:cljs\n   (core/defmacro declare\n     \"defs the supplied var names with no bindings, useful for making forward declarations.\"\n     [& names] `(do ~@(map #(core/list 'def (vary-meta % assoc :declared true)) names))))\n\n(core/defmacro doto\n  \"Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \\\"a\\\" 1) (.set \\\"b\\\" 2))\"\n  [x & forms]\n  (core/let [gx (gensym)]\n    `(let [~gx ~x]\n       ~@(map (core/fn [f]\n                (if (seq? f)\n                  `(~(first f) ~gx ~@(next f))\n                  `(~f ~gx)))\n           forms)\n       ~gx)))\n\n#?(:cljs\n   (core/defn- parse-impls [specs]\n     (core/loop [ret {} s specs]\n       (if (seq s)\n         (recur (assoc ret (first s) (take-while seq? (next s)))\n           (drop-while seq? (next s)))\n         ret))))\n\n#?(:cljs\n   (core/defn- emit-extend-protocol [p specs]\n     (core/let [impls (parse-impls specs)]\n       `(do\n          ~@(map (core/fn [[t fs]]\n                   `(extend-type ~t ~p ~@fs))\n              impls)))))\n\n#?(:cljs\n   (core/defmacro extend-protocol\n     \"Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))\"\n     [p & specs]\n     (emit-extend-protocol p specs)))\n\n#?(:cljs\n   (core/defn ^{:private true}\n   maybe-destructured\n     [params body]\n     (if (every? core/symbol? params)\n       (cons params body)\n       (core/loop [params params\n                   new-params (with-meta [] (meta params))\n                   lets []]\n         (if params\n           (if (core/symbol? (first params))\n             (recur (next params) (conj new-params (first params)) lets)\n             (core/let [gparam (gensym \"p__\")]\n               (recur (next params) (conj new-params gparam)\n                 (core/-> lets (conj (first params)) (conj gparam)))))\n           `(~new-params\n              (let ~lets\n                ~@body)))))))\n\n#?(:cljs\n   (core/defmacro fn\n     \"params => positional-params* , or positional-params* & next-param\n     positional-param => binding-form\n     next-param => binding-form\n     name => symbol\n\n     Defines a function\"\n     {:forms '[(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}\n     [& sigs]\n     (core/let [name (if (core/symbol? (first sigs)) (first sigs) nil)\n                sigs (if name (next sigs) sigs)\n                sigs (if (vector? (first sigs))\n                       (core/list sigs)\n                       (if (seq? (first sigs))\n                         sigs\n                         ;; Assume single arity syntax\n                         (throw (js/Error.\n                                  (if (seq sigs)\n                                    (core/str \"Parameter declaration \"\n                                      (core/first sigs)\n                                      \" should be a vector\")\n                                    (core/str \"Parameter declaration missing\"))))))\n                psig (fn* [sig]\n                       ;; Ensure correct type before destructuring sig\n                       (core/when (not (seq? sig))\n                         (throw (js/Error.\n                                  (core/str \"Invalid signature \" sig\n                                    \" should be a list\"))))\n                       (core/let [[params & body] sig\n                                  _ (core/when (not (vector? params))\n                                      (throw (js/Error.\n                                               (if (seq? (first sigs))\n                                                 (core/str \"Parameter declaration \" params\n                                                   \" should be a vector\")\n                                                 (core/str \"Invalid signature \" sig\n                                                   \" should be a list\")))))\n                                  conds (core/when (core/and (next body) (map? (first body)))\n                                          (first body))\n                                  body (if conds (next body) body)\n                                  conds (core/or conds (meta params))\n                                  pre (:pre conds)\n                                  post (:post conds)\n                                  body (if post\n                                         `((let [~'% ~(if (core/< 1 (count body))\n                                                        `(do ~@body)\n                                                        (first body))]\n                                             ~@(map (fn* [c] `(assert ~c)) post)\n                                             ~'%))\n                                         body)\n                                  body (if pre\n                                         (concat (map (fn* [c] `(assert ~c)) pre)\n                                           body)\n                                         body)]\n                         (maybe-destructured params body)))\n                new-sigs (map psig sigs)]\n       (with-meta\n         (if name\n           (list* 'fn* name new-sigs)\n           (cons 'fn* new-sigs))\n         (meta &form)))))\n\n#?(:cljs\n   (core/defmacro defn-\n     \"same as defn, yielding non-public def\"\n     [name & decls]\n     (list* `defn (with-meta name (assoc (meta name) :private true)) decls)))\n\n#?(:cljs\n   (core/defmacro if-let\n     \"bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else\"\n     ([bindings then]\n      `(if-let ~bindings ~then nil))\n     ([bindings then else & oldform]\n      (assert-args if-let\n        (vector? bindings) \"a vector for its binding\"\n        (empty? oldform) \"1 or 2 forms after binding vector\"\n        (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n      (core/let [form (bindings 0) tst (bindings 1)]\n        `(let [temp# ~tst]\n           (if temp#\n             (let [~form temp#]\n               ~then)\n             ~else))))))\n\n#?(:cljs\n   (core/defmacro if-not\n     \"Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.\"\n     ([test then] `(if-not ~test ~then nil))\n     ([test then else]\n      `(if (not ~test) ~then ~else))))\n\n#?(:cljs\n   (core/defmacro letfn\n     \"fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.\"\n     {:forms '[(letfn [fnspecs*] exprs*)],\n      :special-form true, :url nil}\n     [fnspecs & body]\n     `(letfn* ~(vec (interleave (map first fnspecs)\n                      (map #(cons `fn %) fnspecs)))\n        ~@body)))\n\n(core/defmacro memfn\n  \"Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.\"\n  [name & args]\n  (core/let [t (with-meta (gensym \"target\")\n                 (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))\n\n#?(:cljs\n   (core/defmacro when\n     \"Evaluates test. If logical true, evaluates body in an implicit do.\"\n     [test & body]\n     (core/list 'if test (cons 'do body))))\n\n#?(:cljs\n   (core/defmacro when-first\n     \"bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once\"\n     [bindings & body]\n     (assert-args when-first\n       (vector? bindings) \"a vector for its binding\"\n       (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n     (core/let [[x xs] bindings]\n       `(when-let [xs# (seq ~xs)]\n          (let [~x (first xs#)]\n            ~@body)))))\n\n#?(:cljs\n   (core/defmacro when-let\n     \"bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test\"\n     [bindings & body]\n     (assert-args when-let\n       (vector? bindings) \"a vector for its binding\"\n       (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n     (core/let [form (bindings 0) tst (bindings 1)]\n       `(let [temp# ~tst]\n          (when temp#\n            (let [~form temp#]\n              ~@body))))))\n\n#?(:cljs\n   (core/defmacro when-not\n     \"Evaluates test. If logical false, evaluates body in an implicit do.\"\n     [test & body]\n     (core/list 'if test nil (cons 'do body))))\n\n#?(:cljs\n   (core/defmacro while\n     \"Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil\"\n     [test & body]\n     `(loop []\n        (when ~test\n          ~@body\n          (recur)))))\n\n#?(:cljs\n   (core/defmacro cond->\n     \"Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.\"\n     [expr & clauses]\n     (core/assert (even? (count clauses)))\n     (core/let [g (gensym)\n                steps (map (core/fn [[test step]] `(if ~test (-> ~g ~step) ~g))\n                        (partition 2 clauses))]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro cond->>\n     \"Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.\"\n     [expr & clauses]\n     (core/assert (even? (count clauses)))\n     (core/let [g (gensym)\n                steps (map (core/fn [[test step]] `(if ~test (->> ~g ~step) ~g))\n                        (partition 2 clauses))]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro as->\n     \"Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.\"\n     [expr name & forms]\n     `(let [~name ~expr\n            ~@(interleave (repeat name) (butlast forms))]\n        ~(if (empty? forms)\n           name\n           (last forms)))))\n\n#?(:cljs\n   (core/defmacro some->\n     \"When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc\"\n     [expr & forms]\n     (core/let [g (gensym)\n                steps (map (core/fn [step] `(if (nil? ~g) nil (-> ~g ~step)))\n                        forms)]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro some->>\n     \"When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc\"\n     [expr & forms]\n     (core/let [g (gensym)\n                steps (map (core/fn [step] `(if (nil? ~g) nil (->> ~g ~step)))\n                        forms)]\n       `(let [~g ~expr\n              ~@(interleave (repeat g) (butlast steps))]\n          ~(if (empty? steps)\n             g\n             (last steps))))))\n\n#?(:cljs\n   (core/defmacro if-some\n     \"bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else\"\n     ([bindings then]\n      `(if-some ~bindings ~then nil))\n     ([bindings then else & oldform]\n      (assert-args if-some\n        (vector? bindings) \"a vector for its binding\"\n        (empty? oldform) \"1 or 2 forms after binding vector\"\n        (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n      (core/let [form (bindings 0) tst (bindings 1)]\n        `(let [temp# ~tst]\n           (if (nil? temp#)\n             ~else\n             (let [~form temp#]\n               ~then)))))))\n\n#?(:cljs\n   (core/defmacro when-some\n     \"bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test\"\n     [bindings & body]\n     (assert-args when-some\n       (vector? bindings) \"a vector for its binding\"\n       (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n     (core/let [form (bindings 0) tst (bindings 1)]\n       `(let [temp# ~tst]\n          (if (nil? temp#)\n            nil\n            (let [~form temp#]\n              ~@body))))))\n\n(core/defn- ^{:dynamic true} assert-valid-fdecl\n  \"A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.\"\n  [fdecl]\n  (core/when (empty? fdecl)\n    (throw\n      #?(:clj  (IllegalArgumentException. \"Parameter declaration missing\")\n         :cljs (js/Error. \"Parameter declaration missing\"))))\n  (core/let [argdecls\n             (map\n               #(if (seq? %)\n                 (first %)\n                 (throw\n                   #?(:clj (IllegalArgumentException.\n                             (if (seq? (first fdecl))\n                               (core/str \"Invalid signature \\\"\"\n                                 %\n                                 \"\\\" should be a list\")\n                               (core/str \"Parameter declaration \\\"\"\n                                 %\n                                 \"\\\" should be a vector\")))\n                      :cljs (js/Error.\n                              (if (seq? (first fdecl))\n                                (core/str \"Invalid signature \\\"\"\n                                  %\n                                  \"\\\" should be a list\")\n                                (core/str \"Parameter declaration \\\"\"\n                                  %\n                                  \"\\\" should be a vector\"))))))\n               fdecl)\n             bad-args (seq (remove #(vector? %) argdecls))]\n    (core/when bad-args\n      (throw\n        #?(:clj (IllegalArgumentException.\n                  (core/str \"Parameter declaration \\\"\" (first bad-args)\n                    \"\\\" should be a vector\"))\n           :cljs (js/Error.\n                   (core/str \"Parameter declaration \\\"\" (first bad-args)\n                     \"\\\" should be a vector\")))))))\n\n(def\n  ^{:private true}\n  sigs\n  (core/fn [fdecl]\n    (assert-valid-fdecl fdecl)\n    (core/let [asig\n               (core/fn [fdecl]\n                 (core/let [arglist (first fdecl)\n                            ;elide implicit macro args\n                            arglist (if #?(:clj (clojure.lang.Util/equals '&form (first arglist))\n                                           :cljs (= '&form (first arglist)))\n                                      #?(:clj (clojure.lang.RT/subvec arglist 2 (clojure.lang.RT/count arglist))\n                                         :cljs (subvec arglist 2 (count arglist)))\n                                      arglist)\n                            body (next fdecl)]\n                   (if (map? (first body))\n                     (if (next body)\n                       (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))\n                       arglist)\n                     arglist)))]\n      (if (seq? (first fdecl))\n        (core/loop [ret [] fdecls fdecl]\n          (if fdecls\n            (recur (conj ret (asig (first fdecls))) (next fdecls))\n            (seq ret)))\n        (core/list (asig fdecl))))))\n\n(core/defmacro defonce\n  \"defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated\"\n  [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))\n\n(core/defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n             pb (core/fn pb [bvec b v]\n                  (core/let [pvec\n                             (core/fn [bvec b val]\n                               (core/let [gvec (gensym \"vec__\")\n                                          gseq (gensym \"seq__\")\n                                          gfirst (gensym \"first__\")\n                                          has-rest (some #{'&} b)]\n                                 (core/loop [ret (core/let [ret (conj bvec gvec val)]\n                                                   (if has-rest\n                                                     (conj ret gseq (core/list `seq gvec))\n                                                     ret))\n                                             n 0\n                                             bs b\n                                             seen-rest? false]\n                                   (if (seq bs)\n                                     (core/let [firstb (first bs)]\n                                       (core/cond\n                                         (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                              n\n                                                              (nnext bs)\n                                                              true)\n                                         (= firstb :as) (pb ret (second bs) gvec)\n                                         :else (if seen-rest?\n                                                 (throw #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                           :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                                 (recur (pb (if has-rest\n                                                              (conj ret\n                                                                    gfirst `(first ~gseq)\n                                                                    gseq `(next ~gseq))\n                                                              ret)\n                                                            firstb\n                                                            (if has-rest\n                                                              gfirst\n                                                              (core/list `nth gvec n nil)))\n                                                        (core/inc n)\n                                                        (next bs)\n                                                        seen-rest?))))\n                                     ret))))\n                             pmap\n                             (core/fn [bvec b v]\n                               (core/let [gmap (gensym \"map__\")\n                                          defaults (:or b)]\n                                 (core/loop [ret (core/-> bvec (conj gmap) (conj v)\n                                                          (conj gmap) (conj `(if (implements? ISeq ~gmap) (apply cljs.core/hash-map ~gmap) ~gmap))\n                                                     ((core/fn [ret]\n                                                        (if (:as b)\n                                                          (conj ret (:as b) gmap)\n                                                          ret))))\n                                             bes (core/let [transforms\n                                                            (reduce\n                                                              (core/fn [transforms mk]\n                                                                (if (core/keyword? mk)\n                                                                  (core/let [mkns (namespace mk)\n                                                                        mkn (name mk)]\n                                                                    (core/cond (= mkn \"keys\") (assoc transforms mk #(keyword (core/or mkns (namespace %)) (name %)))\n                                                                               (= mkn \"syms\") (assoc transforms mk #(core/list `quote (symbol (core/or mkns (namespace %)) (name %))))\n                                                                               (= mkn \"strs\") (assoc transforms mk core/str)\n                                                                               :else transforms))\n                                                                  transforms))\n                                                              {}\n                                                              (keys b))]\n                                                   (reduce\n                                                     (core/fn [bes entry]\n                                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                                         (dissoc bes (key entry))\n                                                         ((key entry) bes)))\n                                                     (dissoc b :as :or)\n                                                     transforms))]\n                                   (if (seq bes)\n                                     (core/let [bb (key (first bes))\n                                                bk (val (first bes))\n                                                local (if #?(:clj  (core/instance? clojure.lang.Named bb)\n                                                             :cljs (cljs.core/implements? INamed bb))\n                                                          (with-meta (symbol nil (name bb)) (meta bb))\n                                                        bb)\n                                                bv (if (contains? defaults local)\n                                                     (core/list 'cljs.core/get gmap bk (defaults local))\n                                                     (core/list 'cljs.core/get gmap bk))]\n                                       (recur\n                                         (if (core/or (core/keyword? bb) (core/symbol? bb)) ;(ident? bb)\n                                           (core/-> ret (conj local bv))\n                                           (pb ret bb bv))\n                                              (next bes)))\n                                     ret))))]\n                    (core/cond\n                      (core/symbol? b) (core/-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (core/-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw\n                             #?(:clj (new Exception (core/str \"Unsupported binding form: \" b))\n                                :cljs (new js/Error (core/str \"Unsupported binding form: \" b)))))))\n             process-entry (core/fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? core/symbol? (map first bents))\n      bindings\n      (core/if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n        (throw\n          #?(:clj (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs)))\n             :cljs (new js/Error (core/str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))\n\n(core/defmacro ^:private return-first\n  [& body]\n  `(let [ret# ~(first body)]\n     ~@(rest body)\n     ret#))\n\n(core/defmacro goog-define\n  \"Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\\\"your_app.core.DEBUG_BANG_\\\" true}\n    or\n    :closure-defines {'your-app.core/DEBUG! true}\"\n  [sym default]\n  (assert-args goog-define\n   (core/or (core/string? default)\n            (core/number? default)\n            (core/true? default)\n            (core/false? default)) \"a string, number or boolean as default value\")\n  (core/let [defname (comp/munge (core/str *ns* \"/\" sym))\n             type    (core/cond\n                       (core/string? default) \"string\"\n                       (core/number? default) \"number\"\n                       (core/or (core/true? default) (core/false? default)) \"boolean\")]\n    `(~(if (:def-emits-var &env) `return-first `do)\n       (declare ~(core/vary-meta sym\n                   (core/fn [m]\n                     (core/cond-> m\n                       (core/not (core/contains? m :tag))\n                       (core/assoc :tag (core/symbol type))\n                       ))))\n       (~'js* ~(core/str \"/** @define {\" type \"} */\"))\n       (goog/define ~defname ~default))))\n\n(core/defmacro let\n  \"binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\"\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))\n\n(core/defmacro loop\n  \"Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.\"\n  [bindings & body]\n  (assert-args loop\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (core/let [db (destructure bindings)]\n    (if (= db bindings)\n      `(loop* ~bindings ~@body)\n      (core/let [vs (take-nth 2 (drop 1 bindings))\n                 bs (take-nth 2 bindings)\n                 gs (map (core/fn [b] (if (core/symbol? b) b (gensym))) bs)\n                 bfs (reduce (core/fn [ret [b v g]]\n                               (if (core/symbol? b)\n                                 (conj ret g v)\n                                 (conj ret g v b g)))\n                       [] (map core/vector bs vs gs))]\n        `(let ~bfs\n           (loop* ~(vec (interleave gs gs))\n             (let ~(vec (interleave bs gs))\n               ~@body)))))))\n\n(def fast-path-protocols\n  \"protocol fqn -> [partition number, bit]\"\n  (zipmap (map #(symbol \"cljs.core\" (core/str %))\n               '[IFn ICounted IEmptyableCollection ICollection IIndexed ASeq ISeq INext\n                 ILookup IAssociative IMap IMapEntry ISet IStack IVector IDeref\n                 IDerefWithTimeout IMeta IWithMeta IReduce IKVReduce IEquiv IHash\n                 ISeqable ISequential IList IRecord IReversible ISorted IPrintWithWriter IWriter\n                 IPrintWithWriter IPending IWatchable IEditableCollection ITransientCollection\n                 ITransientAssociative ITransientMap ITransientVector ITransientSet\n                 IMultiFn IChunkedSeq IChunkedNext IComparable INamed ICloneable IAtom\n                 IReset ISwap IIterable])\n          (iterate (core/fn [[p b]]\n                     (if (core/== 2147483648 b)\n                       [(core/inc p) 1]\n                       [p #?(:clj  (core/bit-shift-left b 1)\n                             :cljs (core/* 2 b))]))\n                   [0 1])))\n\n(def fast-path-protocol-partitions-count\n  \"total number of partitions\"\n  (core/let [c (count fast-path-protocols)\n             m (core/mod c 32)]\n    (if (core/zero? m)\n      (core/quot c 32)\n      (core/inc (core/quot c 32)))))\n\n(core/defn- compatible? [inferred-tag allowed-tags]\n  (if (set? inferred-tag)\n    (clojure.set/subset? inferred-tag allowed-tags)\n    (contains? allowed-tags inferred-tag)))\n\n(core/defn- typed-expr? [env form allowed-tags]\n  (compatible? (cljs.analyzer/infer-tag env\n                 (cljs.analyzer/no-warn (cljs.analyzer/analyze env form)))\n    allowed-tags))\n\n(core/defn- string-expr [e]\n  (vary-meta e assoc :tag 'string))\n\n(core/defmacro str\n  ([] \"\")\n  ([x]\n   (if (typed-expr? &env x '#{string})\n     x\n     (string-expr (core/list 'js* \"cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})\" x))))\n  ([x & ys]\n   (core/let [interpolate (core/fn [x]\n                            (if (typed-expr? &env x '#{string clj-nil})\n                              \"~{}\"\n                              \"cljs.core.str.cljs$core$IFn$_invoke$arity$1(~{})\"))\n              strs        (core/->> (core/list* x ys)\n                            (map interpolate)\n                            (interpose \",\")\n                            (apply core/str))]\n     (string-expr (list* 'js* (core/str \"[\" strs \"].join('')\") x ys)))))\n\n(core/defn- bool-expr [e]\n  (vary-meta e assoc :tag 'boolean))\n\n(core/defn- simple-test-expr? [env ast]\n  (core/and\n    (#{:var :js-var :local :invoke :const :host-field :host-call :js :quote} (:op ast))\n    ('#{boolean seq} (cljs.analyzer/infer-tag env ast))))\n\n(core/defmacro and\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.\"\n  ([] true)\n  ([x] x)\n  ([x & next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? &env %)\n           (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) forms))\n       (core/let [and-str (core/->> (repeat (count forms) \"(~{})\")\n                            (interpose \" && \")\n                            (#(concat [\"(\"] % [\")\"]))\n                            (apply core/str))]\n         (bool-expr `(~'js* ~and-str ~@forms)))\n       `(let [and# ~x]\n          (if and# (and ~@next) and#))))))\n\n(core/defmacro or\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.\"\n  ([] nil)\n  ([x] x)\n  ([x & next]\n   (core/let [forms (concat [x] next)]\n     (if (every? #(simple-test-expr? &env %)\n           (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) forms))\n       (core/let [or-str (core/->> (repeat (count forms) \"(~{})\")\n                           (interpose \" || \")\n                           (#(concat [\"(\"] % [\")\"]))\n                           (apply core/str))]\n         (bool-expr `(~'js* ~or-str ~@forms)))\n       `(let [or# ~x]\n          (if or# or# (or ~@next)))))))\n\n(core/defmacro nil? [x]\n  `(coercive-= ~x nil))\n\n(core/defmacro some? [x]\n  `(not (nil? ~x)))\n\n(core/defmacro coercive-not [x]\n  (bool-expr (core/list 'js* \"(!~{})\" x)))\n\n(core/defmacro coercive-not= [x y]\n  (bool-expr (core/list 'js* \"(~{} != ~{})\" x y)))\n\n(core/defmacro coercive-= [x y]\n  (bool-expr (core/list 'js* \"(~{} == ~{})\" x y)))\n\n(core/defmacro coercive-boolean [x]\n  (with-meta (core/list 'js* \"~{}\" x)\n    {:tag 'boolean}))\n\n;; internal - do not use.\n(core/defmacro truth_ [x]\n  (core/assert (core/symbol? x) \"x is substituted twice\")\n  (core/list 'js* \"(~{} != null && ~{} !== false)\" x x))\n\n(core/defmacro js-arguments []\n  (core/list 'js* \"arguments\"))\n\n(core/defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))\n\n(core/defmacro js-in [key obj]\n  (core/list 'js* \"~{} in ~{}\" key obj))\n\n(core/defmacro js-debugger\n  \"Emit JavaScript \\\"debugger;\\\" statement\"\n  []\n  (core/list 'do\n             (core/list 'js* \"debugger\")\n             nil))\n\n(core/defmacro js-comment\n  \"Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline\"\n  [comment]\n  (core/let [[x & ys] (string/split comment #\"\\n\")]\n    (core/list 'js*\n      (core/str\n        \"\\n/**\\n\"\n        (core/str \" * \" x \"\\n\")\n        (core/->> ys\n          (map #(core/str \" * \" (string/replace % #\"^   \" \"\") \"\\n\"))\n          (reduce core/str \"\"))\n        \" */\\n\"))))\n\n(core/defmacro unsafe-cast\n  \"EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.\"\n  [t x]\n  (core/let [cast-expr (core/str \"~{} = /** @type {\" t \"} */ (~{})\")]\n    (core/list 'js* cast-expr x x)))\n\n(core/defmacro js-inline-comment\n  \"Emit an inline JavaScript comment.\"\n  [comment]\n  (core/list 'js* (core/str \"/**\" comment \"*/\")))\n\n(core/defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))\n\n(core/defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))\n\n(core/defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))\n\n(core/defmacro exists?\n  \"Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.\"\n  [x]\n  (if (core/symbol? x)\n    (core/let [x     (core/cond-> (:name (cljs.analyzer/resolve-var &env x))\n                       (= \"js\" (namespace x)) name)\n               segs  (string/split (core/str (string/replace (core/str x) \"/\" \".\")) #\"\\.\")\n               n     (count segs)\n               syms  (map\n                       #(vary-meta (symbol \"js\" (string/join \".\" %))\n                          assoc :cljs.analyzer/no-resolve true)\n                       (reverse (take n (iterate butlast segs))))\n               js    (string/join \" && \" (repeat n \"(typeof ~{} !== 'undefined')\"))]\n      (bool-expr (concat (core/list 'js* js) syms)))\n    `(some? ~x)))\n\n(core/defmacro undefined?\n  \"Return true if argument is identical to the JavaScript undefined value.\"\n  [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))\n\n(core/defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))\n\n(core/defmacro instance? [c x]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? c)\n               (core/list 'js* \"(~{} instanceof ~{})\" x c)\n               `(let [c# ~c x# ~x]\n                  (~'js* \"(~{} instanceof ~{})\" x# c#)))))\n\n(core/defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))\n\n(core/defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))\n\n(core/defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))\n\n(core/defmacro aget\n  ([array idx]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx)\n     :error `(checked-aget' ~array ~idx)\n     (core/list 'js* \"(~{}[~{}])\" array idx)))\n  ([array idx & idxs]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aget ~array ~idx ~@idxs)\n     :error `(checked-aget' ~array ~idx ~@idxs)\n     (core/let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n       `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~array ~idx ~@idxs)))))\n\n(core/defmacro aset\n  ([array idx val]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~val)\n     :error `(checked-aset' ~array ~idx ~val)\n     (core/list 'js* \"(~{}[~{}] = ~{})\" array idx val)))\n  ([array idx idx2 & idxv]\n   (core/case (ana/checked-arrays)\n     :warn `(checked-aset ~array ~idx ~idx2 ~@idxv)\n     :error `(checked-aset' ~array ~idx ~idx2 ~@idxv)\n     (core/let [n    (core/dec (count idxv))\n                astr (apply core/str (repeat n \"[~{}]\"))]\n       `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~array ~idx ~idx2 ~@idxv)))))\n\n(core/defmacro unchecked-get\n  \"INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.\"\n  [obj key]\n  (core/list 'js* \"(~{}[~{}])\" obj key))\n\n(core/defmacro unchecked-set\n  \"INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.\"\n  [obj key val]\n  (core/list 'js* \"(~{}[~{}] = ~{})\" obj key val))\n\n(core/defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))\n\n(core/defmacro byte [x] x)\n(core/defmacro short [x] x)\n(core/defmacro float [x] x)\n(core/defmacro double [x] x)\n\n(core/defmacro unchecked-byte [x] x)\n(core/defmacro unchecked-char [x] x)\n(core/defmacro unchecked-short [x] x)\n(core/defmacro unchecked-float [x] x)\n(core/defmacro unchecked-double [x] x)\n\n(core/defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))\n\n(core/defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(core/mod ~x ~n)))\n\n(core/defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))\n\n(core/defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))\n\n(core/defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))\n\n(core/defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))\n\n(core/defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))\n\n(core/defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))\n\n(core/defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))\n\n(core/defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))\n\n(core/defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))\n\n(core/defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))\n\n(core/defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))\n\n(core/defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))\n\n(core/defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))\n\n(core/defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))\n\n(core/defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))\n\n;; internal do not use\n(core/defmacro ^::ana/numeric unsafe-bit-and\n  ([x y] (bool-expr (core/list 'js* \"(~{} & ~{})\" x y)))\n  ([x y & more] `(unsafe-bit-and (unsafe-bit-and ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))\n\n(core/defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))\n\n(core/defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))\n\n(core/defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))\n\n(core/defmacro bit-test [x n]\n  (bool-expr (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n)))\n\n(core/defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))\n\n(core/defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))\n\n(core/defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))\n\n(core/defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))\n\n(core/defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))\n\n;; internal\n(core/defmacro mask [hash shift]\n  (core/list 'js* \"((~{} >>> ~{}) & 0x01f)\" hash shift))\n\n;; internal\n(core/defmacro bitpos [hash shift]\n  (core/list 'js* \"(1 << ~{})\" `(mask ~hash ~shift)))\n\n;; internal\n(core/defmacro caching-hash [coll hash-fn hash-key]\n  (core/assert (clojure.core/symbol? hash-key) \"hash-key is substituted twice\")\n  `(let [h# ~hash-key]\n     (if-not (nil? h#)\n       h#\n       (let [h# (~hash-fn ~coll)]\n         (set! ~hash-key h#)\n         h#))))\n\n;;; internal -- reducers-related macros\n\n(core/defn- do-curried\n  [name doc meta args body]\n  (core/let [cargs (vec (butlast args))]\n    `(defn ~name ~doc ~meta\n       (~cargs (fn [x#] (~name ~@cargs x#)))\n       (~args ~@body))))\n\n(core/defmacro ^:private defcurried\n  \"Builds another arity of the fn that returns a fn awaiting the last\n  param\"\n  [name doc meta args & body]\n  (do-curried name doc meta args body))\n\n(core/defn- do-rfn [f1 k fkv]\n  `(fn\n     ([] (~f1))\n     ~(clojure.walk/postwalk\n       #(if (sequential? %)\n          ((if (vector? %) vec identity)\n           (core/remove #{k} %))\n          %)\n       fkv)\n     ~fkv))\n\n(core/defmacro ^:private rfn\n  \"Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.\"\n  [[f1 k] fkv]\n  (do-rfn f1 k fkv))\n\n;;; end of reducers macros\n\n(core/defn- protocol-prefix [psym]\n  (core/str (core/-> (core/str psym)\n              (.replace #?(:clj \\. :cljs (js/RegExp. \"\\\\.\" \"g\")) \\$)\n              (.replace \\/ \\$))\n    \"$\"))\n\n(def ^:private base-type\n     {nil \"null\"\n      'object \"object\"\n      'string \"string\"\n      'number \"number\"\n      'array \"array\"\n      'function \"function\"\n      'boolean \"boolean\"\n      'default \"_\"})\n\n(def ^:private js-base-type\n     {'js/Boolean \"boolean\"\n      'js/String \"string\"\n      'js/Array \"array\"\n      'js/Object \"object\"\n      'js/Number \"number\"\n      'js/Function \"function\"})\n\n(core/defmacro reify\n  \"reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \\\"foo\\\"]\n       (reify Object\n         (toString [this] f))))\n  == \\\"foo\\\"\n\n  (seq (let [f \\\"foo\\\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\\\"f\\\" \\\"o\\\" \\\"o\\\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \\\"foo\\\")))\n  == {:k :v}\"\n  [& impls]\n  (core/let [t        (with-meta\n                        (gensym\n                          (core/str \"t_\"\n                            (string/replace (core/str (munge ana/*cljs-ns*)) \".\" \"$\")))\n                        {:anonymous true})\n             meta-sym (gensym \"meta\")\n             this-sym (gensym \"_\")\n             locals   (keys (:locals &env))\n             ns       (core/-> &env :ns :name)\n             munge    comp/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(ana/elide-reader-meta (meta &form))))))\n\n(core/defmacro specify!\n  \"Identical to reify but mutates its first argument.\"\n  [expr & impls]\n  (core/let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))\n\n(core/defmacro specify\n  \"Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.\"\n  [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))\n\n(core/defmacro ^:private js-this []\n  (core/list 'js* \"this\"))\n\n(core/defmacro this-as\n  \"Defines a scope where JavaScript's implicit \\\"this\\\" is bound to the name provided.\"\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))\n\n(core/defn- to-property [sym]\n  (symbol (core/str \"-\" sym)))\n\n(core/defn- warn-and-update-protocol [p type env]\n  (core/when-not (= 'Object p)\n    (core/if-let [var (cljs.analyzer/resolve-existing-var (dissoc env :locals) p)]\n      (do\n        (core/when-not (:protocol-symbol var)\n          (cljs.analyzer/warning :invalid-protocol-symbol env {:protocol p}))\n        (core/when (core/and (:protocol-deprecated cljs.analyzer/*cljs-warnings*)\n                (core/-> var :deprecated)\n                (not (core/-> p meta :deprecation-nowarn)))\n          (cljs.analyzer/warning :protocol-deprecated env {:protocol p}))\n        (core/when (:protocol-symbol var)\n          (swap! env/*compiler* update-in [:cljs.analyzer/namespaces]\n            (core/fn [ns]\n              (update-in ns [(:ns var) :defs (symbol (name p)) :impls]\n                conj type)))))\n      (core/when (:undeclared cljs.analyzer/*cljs-warnings*)\n        (cljs.analyzer/warning :undeclared-protocol-symbol env {:protocol p})))))\n\n(core/defn- resolve-var [env sym]\n  (core/let [ret (:name (cljs.analyzer/resolve-var env sym))]\n    (core/assert ret (core/str \"Can't resolve: \" sym))\n    ret))\n\n(core/defn- ->impl-map [impls]\n  (core/loop [ret {} s impls]\n    (if (seq s)\n      (recur (assoc ret (first s) (take-while seq? (next s)))\n        (drop-while seq? (next s)))\n      ret)))\n\n(core/defn- base-assign-impls [env resolve tsym type [p sigs]]\n  (warn-and-update-protocol p tsym env)\n  (core/let [psym       (resolve p)\n             pfn-prefix (subs (core/str psym) 0\n                          (clojure.core/inc (.indexOf (core/str psym) \"/\")))]\n    (cons `(goog.object/set ~psym ~type true)\n      (map (core/fn [[f & meths :as form]]\n             `(goog.object/set ~(symbol (core/str pfn-prefix f))\n                ~type ~(with-meta `(fn ~@meths) (meta form))))\n        sigs))))\n\n(core/defmulti ^:private extend-prefix (core/fn [tsym sym] (core/-> tsym meta :extend)))\n\n(core/defmethod extend-prefix :instance\n  [tsym sym] `(.. ~tsym ~(to-property sym)))\n\n(core/defmethod extend-prefix :default\n  [tsym sym] `(.. ~tsym ~'-prototype ~(to-property sym)))\n\n(core/defn- adapt-obj-params [type [[this & args :as sig] & body]]\n  (core/list (vec args)\n    (list* 'this-as (vary-meta this assoc :tag type) body)))\n\n(core/defn- adapt-ifn-params [type [[this & args :as sig] & body]]\n  (core/let [self-sym (with-meta 'self__ {:tag type})]\n    `(~(vec (cons self-sym args))\n       (this-as ~self-sym\n         (let [~this ~self-sym]\n           ~@body)))))\n\n;; for IFn invoke implementations, we need to drop first arg\n(core/defn- adapt-ifn-invoke-params [type [[this & args :as sig] & body]]\n  `(~(vec args)\n     (this-as ~(vary-meta this assoc :tag type)\n       ~@body)))\n\n(core/defn- adapt-proto-params [type [[this & args :as sig] & body]]\n  (core/let [this' (vary-meta this assoc :tag type)]\n    `(~(vec (cons this' args))\n      (this-as ~this'\n        ~@body))))\n\n(core/defn- add-obj-methods [type type-sym sigs]\n  (map (core/fn [[f & meths :as form]]\n         (core/let [[f meths] (if (vector? (first meths))\n                                [f [(rest form)]]\n                                [f meths])]\n           `(set! ~(extend-prefix type-sym f)\n              ~(with-meta `(fn ~@(map #(adapt-obj-params type %) meths)) (meta form)))))\n    sigs))\n\n(core/defn- ifn-invoke-methods [type type-sym [f & meths :as form]]\n  (map\n    (core/fn [meth]\n      (core/let [arity (count (first meth))]\n        `(set! ~(extend-prefix type-sym (symbol (core/str \"cljs$core$IFn$_invoke$arity$\" arity)))\n           ~(with-meta `(fn ~meth) (meta form)))))\n    (map #(adapt-ifn-invoke-params type %) meths)))\n\n(core/defn- add-ifn-methods [type type-sym [f & meths :as form]]\n  (core/let [meths    (map #(adapt-ifn-params type %) meths)\n             this-sym (with-meta 'self__ {:tag type})\n             argsym   (gensym \"args\")]\n    (concat\n      [`(set! ~(extend-prefix type-sym 'call) ~(with-meta `(fn ~@meths) (meta form)))\n       `(set! ~(extend-prefix type-sym 'apply)\n          ~(with-meta\n             `(fn ~[this-sym argsym]\n                (this-as ~this-sym\n                  (.apply (.-call ~this-sym) ~this-sym\n                    (.concat (array ~this-sym) (cljs.core/aclone ~argsym)))))\n             (meta form)))]\n      (ifn-invoke-methods type type-sym form))))\n\n(core/defn- add-proto-methods* [pprefix type type-sym [f & meths :as form]]\n  (core/let [pf (core/str pprefix (munge (name f)))]\n    (if (vector? (first meths))\n      ;; single method case\n      (core/let [meth meths]\n        [`(set! ~(extend-prefix type-sym (core/str pf \"$arity$\" (count (first meth))))\n            ~(with-meta `(fn ~@(adapt-proto-params type meth)) (meta form)))])\n      (map (core/fn [[sig & body :as meth]]\n             `(set! ~(extend-prefix type-sym (core/str pf \"$arity$\" (count sig)))\n                ~(with-meta `(fn ~(adapt-proto-params type meth)) (meta form))))\n        meths))))\n\n(core/defn- proto-assign-impls [env resolve type-sym type [p sigs]]\n  (warn-and-update-protocol p type env)\n  (core/let [psym      (resolve p)\n             pprefix   (protocol-prefix psym)\n             skip-flag (set (core/-> type-sym meta :skip-protocol-flag))]\n    (if (= p 'Object)\n      (add-obj-methods type type-sym sigs)\n      (concat\n        (core/when-not (skip-flag psym)\n          [`(set! ~(extend-prefix type-sym pprefix) cljs.core/PROTOCOL_SENTINEL)])\n        (mapcat\n          (core/fn [sig]\n            (if (= psym 'cljs.core/IFn)\n              (add-ifn-methods type type-sym sig)\n              (add-proto-methods* pprefix type type-sym sig)))\n          sigs)))))\n\n(core/defn- validate-impl-sigs [env p method]\n  (core/when-not (= p 'Object)\n    (core/let [var (ana/resolve-var (dissoc env :locals) p)\n               minfo (core/-> var :protocol-info :methods)\n               method-name (first method)\n               ->name (comp symbol name)\n               [fname sigs] (if (core/vector? (second method))\n                              [(->name method-name) [(second method)]]\n                              [(->name method-name) (map first (rest method))])\n               decmeths (core/get minfo fname ::not-found)]\n      (core/when (= decmeths ::not-found)\n        (ana/warning :protocol-invalid-method env {:protocol p :fname fname :no-such-method true}))\n      (core/when (namespace method-name)\n        (core/let [method-var (ana/resolve-var (dissoc env :locals) method-name\n                                ana/confirm-var-exist-warning)]\n          (core/when-not (= (:name var) (:protocol method-var))\n            (ana/warning :protocol-invalid-method env\n              {:protocol p :fname method-name :no-such-method true}))))\n      (core/loop [sigs sigs seen #{}]\n        (core/when (seq sigs)\n          (core/let [sig (first sigs)\n                     c   (count sig)]\n            (core/when (contains? seen c)\n              (ana/warning :protocol-duped-method env {:protocol p :fname fname}))\n            (core/when (some '#{&} sig)\n              (ana/warning :protocol-impl-with-variadic-method env {:protocol p :name fname}))\n            (core/when (core/and (not= decmeths ::not-found) (not (some #{c} (map count decmeths))))\n              (ana/warning :protocol-invalid-method env {:protocol p :fname fname :invalid-arity c}))\n            (recur (next sigs) (conj seen c))))))))\n\n(core/defn- validate-impls [env impls]\n  (core/loop [protos #{} impls impls]\n    (core/when (seq impls)\n      (core/let [proto   (first impls)\n                 methods (take-while seq? (next impls))\n                 impls   (drop-while seq? (next impls))]\n        (core/when (contains? protos proto)\n          (ana/warning :protocol-multiple-impls env {:protocol proto}))\n        (core/loop [seen #{} methods methods]\n          (core/when (seq methods)\n            (core/let [[fname :as method] (first methods)]\n              (core/when (contains? seen fname)\n                (ana/warning :extend-type-invalid-method-shape env\n                  {:protocol proto :method fname}))\n              (validate-impl-sigs env proto method)\n              (recur (conj seen fname) (next methods)))))\n        (recur (conj protos proto) impls)))))\n\n(core/defn- type-hint-first-arg\n  [type-sym argv]\n  (assoc argv 0 (vary-meta (argv 0) assoc :tag type-sym)))\n\n(core/defn- type-hint-single-arity-sig\n  [type-sym sig]\n  (list* (first sig) (type-hint-first-arg type-sym (second sig)) (nnext sig)))\n\n(core/defn- type-hint-multi-arity-sig\n  [type-sym sig]\n  (list* (type-hint-first-arg type-sym (first sig)) (next sig)))\n\n(core/defn- type-hint-multi-arity-sigs\n  [type-sym sigs]\n  (list* (first sigs) (map (partial type-hint-multi-arity-sig type-sym) (rest sigs))))\n\n(core/defn- type-hint-sigs\n  [type-sym sig]\n  (if (vector? (second sig))\n    (type-hint-single-arity-sig type-sym sig)\n    (type-hint-multi-arity-sigs type-sym sig)))\n\n(core/defn- type-hint-impl-map\n  [type-sym impl-map]\n  (reduce-kv (core/fn [m proto sigs]\n               (assoc m proto (map (partial type-hint-sigs type-sym) sigs)))\n    {} impl-map))\n\n(core/defmacro extend-type\n  \"Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)\"\n  [type-sym & impls]\n  (core/let [env &env\n             _ (validate-impls env impls)\n             resolve (partial resolve-var env)\n             impl-map (->impl-map impls)\n             impl-map (if ('#{boolean number} type-sym)\n                        (type-hint-impl-map type-sym impl-map)\n                        impl-map)\n             [type assign-impls] (core/if-let [type (base-type type-sym)]\n                                   [type base-assign-impls]\n                                   [(resolve type-sym) proto-assign-impls])]\n    (core/when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n            (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n        {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))\n\n(core/defn- prepare-protocol-masks [env impls]\n  (core/let [resolve  (partial resolve-var env)\n             impl-map (->impl-map impls)\n             fpp-pbs  (seq\n                        (keep fast-path-protocols\n                          (map resolve\n                            (keys impl-map))))]\n    (if fpp-pbs\n      (core/let [fpps  (into #{}\n                         (filter (partial contains? fast-path-protocols)\n                           (map resolve (keys impl-map))))\n                 parts (core/as-> (group-by first fpp-pbs) parts\n                         (into {}\n                           (map (juxt key (comp (partial map peek) val))\n                             parts))\n                         (into {}\n                           (map (juxt key (comp (partial reduce core/bit-or) val))\n                             parts)))]\n        [fpps (reduce (core/fn [ps p] (update-in ps [p] (core/fnil identity 0)))\n                parts\n                (range fast-path-protocol-partitions-count))]))))\n\n(core/defn- annotate-specs [annots v [f sigs]]\n  (conj v\n    (vary-meta (cons f (map #(cons (second %) (nnext %)) sigs))\n      merge annots)))\n\n(core/defn dt->et\n  ([type specs fields]\n   (dt->et type specs fields false))\n  ([type specs fields inline]\n   (core/let [annots {:cljs.analyzer/type type\n                      :cljs.analyzer/protocol-impl true\n                      :cljs.analyzer/protocol-inline inline}]\n     (core/loop [ret [] specs specs]\n       (if (seq specs)\n         (core/let [p     (first specs)\n                    ret   (core/-> (conj ret p)\n                            (into (reduce (partial annotate-specs annots) []\n                                    (group-by first (take-while seq? (next specs))))))\n                    specs (drop-while seq? (next specs))]\n           (recur ret specs))\n         ret)))))\n\n(core/defn- collect-protocols [impls env]\n  (core/->> impls\n      (filter core/symbol?)\n      (map #(:name (cljs.analyzer/resolve-var (dissoc env :locals) %)))\n      (into #{})))\n\n(core/defn- build-positional-factory\n  [rsym rname fields]\n  (core/let [fn-name (with-meta (symbol (core/str '-> rsym))\n                       (assoc (meta rsym) :factory :positional))\n             docstring (core/str \"Positional factory function for \" rname \".\")\n        field-values (if (core/-> rsym meta :internal-ctor) (conj fields nil nil nil) fields)]\n    `(defn ~fn-name\n       ~docstring\n       [~@fields]\n       (new ~rname ~@field-values))))\n\n(core/defn- validate-fields\n  [case name fields]\n  (core/when-not (vector? fields)\n    (throw\n      #?(:clj (AssertionError. (core/str case \" \" name \", no fields vector given.\"))\n         :cljs (js/Error. (core/str case \" \" name \", no fields vector given.\"))))))\n\n(core/defmacro deftype\n  \"(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields\"\n  [t fields & impls]\n  (validate-fields \"deftype\" t fields)\n  (core/let [env &env\n             r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n             [fpps pmasks] (prepare-protocol-masks env impls)\n             protocols (collect-protocols impls env)\n             t (vary-meta t assoc\n                 :protocols protocols\n                 :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt->et t impls fields))))\n       (set! (.-getBasis ~t) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))\n\n(core/defn- emit-defrecord\n  \"Do not use this directly - use defrecord\"\n  [env tagname rname fields impls]\n  (core/let [hinted-fields fields\n             fields (vec (map #(with-meta % nil) fields))\n             base-fields fields\n             pr-open (core/str \"#\" #?(:clj  (.getNamespace rname)\n                                      :cljs (namespace rname))\n                               \".\" #?(:clj  (.getName rname)\n                                      :cljs (name rname))\n                               \"{\")\n             fields (conj fields '__meta '__extmap (with-meta '__hash {:mutable true}))]\n    (core/let [gs (gensym)\n               ksym (gensym \"k\")\n               impls (concat\n                       impls\n                       ['IRecord\n                        'ICloneable\n                        `(~'-clone [this#] (new ~tagname ~@fields))\n                        'IHash\n                        `(~'-hash [this#]\n                           (caching-hash this#\n                             (fn [coll#]\n                               (bit-xor\n                                 ~(hash (core/-> rname comp/munge core/str))\n                                 (hash-unordered-coll coll#)))\n                             ~'__hash))\n                        'IEquiv\n                        (core/let [this (gensym 'this) other (gensym 'other)]\n                          `(~'-equiv [~this ~other]\n                             (and (some? ~other)\n                                  (identical? (.-constructor ~this)\n                                              (.-constructor ~other))\n                                  ~@(map (core/fn [field]\n                                           `(= (.. ~this ~(to-property field))\n                                               (.. ~(with-meta other {:tag tagname}) ~(to-property field))))\n                                         base-fields)\n                                  (= (.-__extmap ~this)\n                                     (.-__extmap ~(with-meta other {:tag tagname}))))))\n                        'IMeta\n                        `(~'-meta [this#] ~'__meta)\n                        'IWithMeta\n                        `(~'-with-meta [this# ~gs] (new ~tagname ~@(replace {'__meta gs} fields)))\n                        'ILookup\n                        `(~'-lookup [this# k#] (-lookup this# k# nil))\n                        `(~'-lookup [this# ~ksym else#]\n                           (case ~ksym\n                             ~@(mapcat (core/fn [f] [(keyword f) f]) base-fields)\n                             (cljs.core/get ~'__extmap ~ksym else#)))\n                        'ICounted\n                        `(~'-count [this#] (+ ~(count base-fields) (count ~'__extmap)))\n                        'ICollection\n                        `(~'-conj [this# entry#]\n                           (if (vector? entry#)\n                             (-assoc this# (-nth entry# 0) (-nth entry# 1))\n                             (reduce -conj\n                               this#\n                               entry#)))\n                        'IAssociative\n                        `(~'-assoc [this# k# ~gs]\n                           (condp keyword-identical? k#\n                             ~@(mapcat (core/fn [fld]\n                                         [(keyword fld) (list* `new tagname (replace {fld gs '__hash nil} fields))])\n                                 base-fields)\n                             (new ~tagname ~@(remove #{'__extmap '__hash} fields) (assoc ~'__extmap k# ~gs) nil)))\n                        'IMap\n                        `(~'-dissoc [this# k#] (if (contains? #{~@(map keyword base-fields)} k#)\n                                                 (dissoc (-with-meta (into {} this#) ~'__meta) k#)\n                                                 (new ~tagname ~@(remove #{'__extmap '__hash} fields)\n                                                   (not-empty (dissoc ~'__extmap k#))\n                                                   nil)))\n                        'ISeqable\n                        `(~'-seq [this#] (seq (concat [~@(map #(core/list 'cljs.core/MapEntry. (keyword %) % nil) base-fields)]\n                                                ~'__extmap)))\n\n                        'IIterable\n                        `(~'-iterator [~gs]\n                          (RecordIter. 0 ~gs ~(count base-fields) [~@(map keyword base-fields)] (if ~'__extmap\n                                                                                                  (-iterator ~'__extmap)\n                                                                                                  (core/nil-iter))))\n\n                        'IPrintWithWriter\n                        `(~'-pr-writer [this# writer# opts#]\n                           (let [pr-pair# (fn [keyval#] (pr-sequential-writer writer# (~'js* \"cljs.core.pr_writer\") \"\" \" \" \"\" opts# keyval#))]\n                             (pr-sequential-writer\n                               writer# pr-pair# ~pr-open \", \" \"}\" opts#\n                               (concat [~@(map #(core/list `vector (keyword %) %) base-fields)]\n                                 ~'__extmap))))\n                        'IKVReduce\n                        `(~'-kv-reduce [this# f# init#]\n                           (reduce (fn [ret# [k# v#]] (f# ret# k# v#)) init# this#))\n                        ])\n               [fpps pmasks] (prepare-protocol-masks env impls)\n               protocols (collect-protocols impls env)\n               tagname (vary-meta tagname assoc\n                         :protocols protocols\n                         :skip-protocol-flag fpps)]\n      `(do\n         (~'defrecord* ~tagname ~hinted-fields ~pmasks\n           (extend-type ~tagname ~@(dt->et tagname impls fields true)))))))\n\n(core/defn- build-map-factory [rsym rname fields]\n  (core/let [fn-name (with-meta (symbol (core/str 'map-> rsym))\n                       (assoc (meta rsym) :factory :map))\n             docstring (core/str \"Factory function for \" rname \", taking a map of keywords to field values.\")\n             ms (gensym)\n             ks (map keyword fields)\n             getters (map (core/fn [k] `(~k ~ms)) ks)]\n    `(defn ~fn-name ~docstring [~ms]\n       (let [extmap# (cond->> (dissoc ~ms ~@ks)\n                        (record? ~ms) (into {}))]\n         (new ~rname ~@getters nil (not-empty extmap#) nil)))))\n\n(core/defmacro defrecord\n  \"(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.\"\n  [rsym fields & impls]\n  (validate-fields \"defrecord\" rsym fields)\n  (core/let [rsym (vary-meta rsym assoc :internal-ctor true)\n             r    (vary-meta\n                    (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n                    assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-getBasis ~r) (fn [] '[~@fields]))\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (cljs.core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))\n\n(core/defmacro defprotocol\n  \"A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \\\"A doc string for AProtocol abstraction\\\"\n\n  ;method signatures\n    (bar [this a b] \\\"bar docs\\\")\n    (baz [this a] [this a b] [this a b c] \\\"baz docs\\\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17\"\n  [psym & doc+methods]\n  (core/let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n             [opts methods]\n             (core/loop [opts {:protocol-symbol true}\n                         methods []\n                         sigs doc+methods]\n               (core/if-not (seq sigs)\n                 [opts methods]\n                 (core/let [[head & tail] sigs]\n                   (core/cond\n                     (core/string? head)\n                     (recur (assoc opts :doc head) methods tail)\n                     (core/keyword? head)\n                     (recur (assoc opts head (first tail)) methods (rest tail))\n                     (core/list? head)\n                     (recur opts (conj methods head) tail)\n                     :else\n                     (throw #?(:clj  (Exception.\n                                       (core/str \"Invalid protocol, \" psym \" received unexpected argument\"))\n                               :cljs (js/Error.\n                                       (core/str \"Invalid protocol, \" psym \" received unexpected argument\"))))\n                     ))))\n             psym (vary-meta psym merge opts)\n             ns-name (core/-> &env :ns :name)\n             fqn (core/fn [n] (symbol (core/str ns-name) (core/str n)))\n             prefix (protocol-prefix p)\n             _ (core/doseq [[mname & arities] methods]\n                 (core/when (some #{0} (map count (filter vector? arities)))\n                   (throw\n                     #?(:clj (Exception.\n                               (core/str \"Invalid protocol, \" psym\n                                 \" defines method \" mname \" with arity 0\"))\n                        :cljs (js/Error.\n                                (core/str \"Invalid protocol, \" psym\n                                  \" defines method \" mname \" with arity 0\"))))))\n             expand-sig (core/fn [fname slot sig]\n                          (core/let [sig (core/if-not (every? core/symbol? sig)\n                                           (mapv (core/fn [arg]\n                                                   (core/cond\n                                                     (core/symbol? arg) arg\n                                                     (core/and (map? arg) (core/some? (:as arg))) (:as arg)\n                                                     :else (gensym))) sig)\n                                           sig)\n\n                                     fqn-fname (fqn fname)\n                                     fsig (first sig)\n\n                                     ;; construct protocol checks in reverse order\n                                     ;; check the.protocol/fn[\"_\"] for default impl last\n                                     check\n                                     `(let [m# (unchecked-get ~fqn-fname \"_\")]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          (throw\n                                            (missing-protocol\n                                              ~(core/str psym \".\" fname) ~fsig))))\n\n                                     ;; then check protocol fn in metadata (only when protocol is marked with :extend-via-metadata true)\n                                     check\n                                     (core/if-not (:extend-via-metadata opts)\n                                       check\n                                       `(if-let [meta-impl# (-> ~fsig (core/meta) (core/get '~fqn-fname))]\n                                          (meta-impl# ~@sig)\n                                          ~check))\n\n                                     ;; then check protocol on js string,function,array,object\n                                     check\n                                     `(let [x# (if (nil? ~fsig) nil ~fsig)\n                                            m# (unchecked-get ~fqn-fname (goog/typeOf x#))]\n                                        (if-not (nil? m#)\n                                          (m# ~@sig)\n                                          ~check))\n\n                                     ;; then check protocol property on object (first check actually executed)\n                                     check\n                                     `(if (and (not (nil? ~fsig))\n                                               (not (nil? (. ~fsig ~(symbol (core/str \"-\" slot)))))) ;; Property access needed here.\n                                        (. ~fsig ~slot ~@sig)\n                                        ~check)]\n                            `(~sig ~check)))\n             psym (core/-> psym\n                    (vary-meta update-in [:jsdoc] conj\n                      \"@interface\")\n                    (vary-meta assoc-in [:protocol-info :methods]\n                      (into {}\n                        (map\n                          (core/fn [[fname & sigs]]\n                            (core/let [doc (core/as-> (last sigs) doc\n                                             (core/when (core/string? doc) doc))\n                                       sigs (take-while vector? sigs)]\n                              [(vary-meta fname assoc :doc doc)\n                               (vec sigs)]))\n                          methods))))\n             method (core/fn [[fname & sigs]]\n                      (core/let [doc (core/as-> (last sigs) doc\n                                       (core/when (core/string? doc) doc))\n                                 sigs (take-while vector? sigs)\n                                 amp (core/when (some #{'&} (apply concat sigs))\n                                       (cljs.analyzer/warning\n                                        :protocol-with-variadic-method\n                                        &env {:protocol psym :name fname}))\n                                 slot (symbol (core/str prefix (munge (name fname))))\n                                 fname (vary-meta fname assoc\n                                         :protocol p\n                                         :doc doc)]\n                        `(defn ~fname\n                           ~@(map (core/fn [sig]\n                                    (expand-sig fname\n                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                      sig))\n                               sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (~'js* \"function(){}\"))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))\n\n(core/defmacro implements?\n  \"EXPERIMENTAL\"\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if ~xsym\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false)\n           false))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           false)\n         false))))\n\n(core/defmacro satisfies?\n  \"Returns true if x satisfies the protocol\"\n  [psym x]\n  (core/let [p          (:name\n                          (cljs.analyzer/resolve-var\n                            (dissoc &env :locals) psym))\n             prefix     (protocol-prefix p)\n             xsym       (bool-expr (gensym))\n             [part bit] (fast-path-protocols p)\n             msym       (symbol\n                          (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    (core/if-not (core/symbol? x)\n      `(let [~xsym ~x]\n         (if-not (nil? ~xsym)\n           (if (or ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit) false)\n                    (identical? cljs.core/PROTOCOL_SENTINEL (. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false))\n           (cljs.core/native-satisfies? ~psym ~xsym)))\n      `(if-not (nil? ~x)\n         (if (or ~(if bit `(unsafe-bit-and (. ~x ~msym) ~bit) false)\n                  (identical? cljs.core/PROTOCOL_SENTINEL (. ~x ~(symbol (core/str \"-\" prefix)))))\n           true\n           (if (coercive-not (. ~x ~msym))\n             (cljs.core/native-satisfies? ~psym ~x)\n             false))\n         (cljs.core/native-satisfies? ~psym ~x)))))\n\n(core/defmacro lazy-seq\n  \"Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.\"\n  [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))\n\n(core/defmacro delay\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  [& body]\n  `(new cljs.core/Delay (fn [] ~@body) nil))\n\n(core/defmacro with-redefs\n  \"binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.\"\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)\n             vals (take-nth 2 (drop 1 bindings))\n             orig-val-syms (map (comp gensym #(core/str % \"-orig-val__\") name) names)\n             temp-val-syms (map (comp gensym #(core/str % \"-temp-val__\") name) names)\n             binds (map core/vector names temp-val-syms)\n             resets (reverse (map core/vector names orig-val-syms))\n             bind-value (core/fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave orig-val-syms names)\n           ~@(interleave temp-val-syms vals)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n         (finally\n           ~@(map bind-value resets))))))\n\n(core/defmacro binding\n  \"binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.\"\n  [bindings & body]\n  (core/let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))\n\n(core/defmacro condp\n  \"Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.\"\n  {:added \"1.0\"}\n\n  [pred expr & clauses]\n  (core/let [gpred (gensym \"pred__\")\n             gexpr (gensym \"expr__\")\n             emit (core/fn emit [pred expr args]\n                    (core/let [[[a b c :as clause] more]\n                               (split-at (if (= :>> (second args)) 3 2) args)\n                               n (count clause)]\n                      (core/cond\n                        (= 0 n) `(throw (js/Error. (cljs.core/str \"No matching clause: \" ~expr)))\n                        (= 1 n) a\n                        (= 2 n) `(if (~pred ~a ~expr)\n                                   ~b\n                                   ~(emit pred expr more))\n                        :else `(if-let [p# (~pred ~a ~expr)]\n                                 (~c p#)\n                                 ~(emit pred expr more)))))\n             gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))\n\n(core/defn- assoc-test [m test expr env]\n  (if (contains? m test)\n    (throw\n      #?(:clj (clojure.core/IllegalArgumentException.\n                (core/str \"Duplicate case test constant '\"\n                  test \"'\"\n                  (core/when (:line env)\n                    (core/str \" on line \" (:line env) \" \"\n                      cljs.analyzer/*cljs-file*))))\n         :cljs (js/Error.\n                 (core/str \"Duplicate case test constant '\"\n                   test \"'\"\n                   (core/when (:line env)\n                     (core/str \" on line \" (:line env) \" \"\n                       cljs.analyzer/*cljs-file*))))))\n    (assoc m test expr)))\n\n(core/defn- const? [env x]\n  (core/let [m (core/and (core/list? x)\n                         (ana/resolve-var env (last x)))]\n    (core/when m (core/get m :const))))\n\n(core/defmacro case\n  \"Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.\"\n  [e & clauses]\n  (core/let [esym    (gensym)\n             default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (cljs.core/str \"No matching clause: \" ~esym))))\n             env     &env\n             pairs   (reduce\n                       (core/fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (core/fn [m test]\n                               (core/let [test (if (core/symbol? test)\n                                                 (core/list 'quote test)\n                                                 test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list 'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             tests   (keys pairs)]\n    (core/cond\n      (every? (some-fn core/number? core/string? #?(:clj core/char? :cljs (core/fnil core/char? :nonchar)) #(const? env %)) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 kw-str #(.substring (core/str %) 1)\n                 tests (mapv #(if (seq? %) (mapv kw-str %) [(kw-str %)]) (take-nth 2 no-default))\n                 thens (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e\n               ~esym (if (keyword? ~esym) (.-fqn ~(vary-meta esym assoc :tag 'cljs.core/Keyword)) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n\n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (core/fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n           :else ~default)))))\n\n(core/defmacro ^:private when-assert [x]\n  (core/when *assert* x))\n\n(core/defmacro assert\n  \"Evaluates expr and throws an exception if it does not evaluate to\n  logical true.\"\n  ([x]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error. ~(core/str \"Assert failed: \" (core/pr-str x)))))))\n  ([x message]\n     (core/when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" ~(core/pr-str x))))))))\n\n(core/defmacro for\n  \"List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))\"\n  [seq-exprs body-expr]\n  (assert-args for\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [to-groups (core/fn [seq-exprs]\n                         (reduce (core/fn [groups [k v]]\n                                   (if (core/keyword? k)\n                                     (conj (pop groups) (conj (peek groups) [k v]))\n                                     (conj groups [k v])))\n                           [] (partition 2 seq-exprs)))\n             err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             emit-bind (core/fn emit-bind [[[bind expr & mod-pairs]\n                                       & [[_ next-expr] :as next-groups]]]\n                         (core/let [giter (gensym \"iter__\")\n                                    gxs (gensym \"s__\")\n                                    do-mod (core/fn do-mod [[[k v :as pair] & etc]]\n                                             (core/cond\n                                               (= k :let) `(let ~v ~(do-mod etc))\n                                               (= k :while) `(when ~v ~(do-mod etc))\n                                               (= k :when) `(if ~v\n                                                              ~(do-mod etc)\n                                                              (recur (rest ~gxs)))\n                                               (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                               next-groups\n                                               `(let [iterys# ~(emit-bind next-groups)\n                                                      fs# (seq (iterys# ~next-expr))]\n                                                  (if fs#\n                                                    (concat fs# (~giter (rest ~gxs)))\n                                                    (recur (rest ~gxs))))\n                                               :else `(cons ~body-expr\n                                                        (~giter (rest ~gxs)))))]\n                           (if next-groups\n                             #_ \"not the inner-most loop\"\n                             `(fn ~giter [~gxs]\n                                (lazy-seq\n                                  (loop [~gxs ~gxs]\n                                    (when-first [~bind ~gxs]\n                                      ~(do-mod mod-pairs)))))\n                             #_\"inner-most loop\"\n                             (core/let [gi (gensym \"i__\")\n                                        gb (gensym \"b__\")\n                                        do-cmod (core/fn do-cmod [[[k v :as pair] & etc]]\n                                                  (core/cond\n                                                    (= k :let) `(let ~v ~(do-cmod etc))\n                                                    (= k :while) `(when ~v ~(do-cmod etc))\n                                                    (= k :when) `(if ~v\n                                                                   ~(do-cmod etc)\n                                                                   (recur\n                                                                     (unchecked-inc ~gi)))\n                                                    (core/keyword? k)\n                                                    (err \"Invalid 'for' keyword \" k)\n                                                    :else\n                                                    `(do (chunk-append ~gb ~body-expr)\n                                                         (recur (unchecked-inc ~gi)))))]\n                               `(fn ~giter [~gxs]\n                                  (lazy-seq\n                                    (loop [~gxs ~gxs]\n                                      (when-let [~gxs (seq ~gxs)]\n                                        (if (chunked-seq? ~gxs)\n                                          (let [c# ^not-native (chunk-first ~gxs)\n                                                size# (count c#)\n                                                ~gb (chunk-buffer size#)]\n                                            (if (coercive-boolean\n                                                  (loop [~gi 0]\n                                                    (if (< ~gi size#)\n                                                      (let [~bind (-nth c# ~gi)]\n                                                        ~(do-cmod mod-pairs))\n                                                      true)))\n                                              (chunk-cons\n                                                (chunk ~gb)\n                                                (~giter (chunk-rest ~gxs)))\n                                              (chunk-cons (chunk ~gb) nil)))\n                                          (let [~bind (first ~gxs)]\n                                            ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))\n\n(core/defmacro doseq\n  \"Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \\\"for\\\".  Does not retain\n  the head of the sequence. Returns nil.\"\n  [seq-exprs & body]\n  (assert-args doseq\n    (vector? seq-exprs) \"a vector for its binding\"\n    (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (core/let [err (core/fn [& msg] (throw (ex-info (apply core/str msg) {})))\n             step (core/fn step [recform exprs]\n                    (core/if-not exprs\n                      [true `(do ~@body nil)]\n                      (core/let [k (first exprs)\n                                 v (second exprs)\n\n                                 seqsym (gensym \"seq__\")\n                                 recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                                 steppair (step recform (nnext exprs))\n                                 needrec (steppair 0)\n                                 subform (steppair 1)]\n                        (core/cond\n                          (= k :let) [needrec `(let ~v ~subform)]\n                          (= k :while) [false `(when ~v\n                                                 ~subform\n                                                 ~@(core/when needrec [recform]))]\n                          (= k :when) [false `(if ~v\n                                                (do\n                                                  ~subform\n                                                  ~@(core/when needrec [recform]))\n                                                ~recform)]\n                          (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                          :else (core/let [chunksym (with-meta (gensym \"chunk__\")\n                                                      {:tag 'not-native})\n                                           countsym (gensym \"count__\")\n                                           isym     (gensym \"i__\")\n                                           recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                           steppair-chunk (step recform-chunk (nnext exprs))\n                                           subform-chunk  (steppair-chunk 1)]\n                                  [true `(loop [~seqsym   (seq ~v)\n                                                ~chunksym nil\n                                                ~countsym 0\n                                                ~isym     0]\n                                           (if (coercive-boolean (< ~isym ~countsym))\n                                             (let [~k (-nth ~chunksym ~isym)]\n                                               ~subform-chunk\n                                               ~@(core/when needrec [recform-chunk]))\n                                             (when-let [~seqsym (seq ~seqsym)]\n                                               (if (chunked-seq? ~seqsym)\n                                                 (let [c# (chunk-first ~seqsym)]\n                                                   (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                                 (let [~k (first ~seqsym)]\n                                                   ~subform\n                                                   ~@(core/when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))\n\n(core/defmacro array [& rest]\n  (core/let [xs-str (core/->> (repeat \"~{}\")\n                      (take (count rest))\n                      (interpose \",\")\n                      (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))\n\n(core/defmacro make-array\n  ([size]\n   (vary-meta\n     (if (core/number? size)\n       `(array ~@(take size (repeat nil)))\n       `(js/Array. ~size))\n     assoc :tag 'array))\n  ([type size]\n   `(cljs.core/make-array ~size))\n  ([type size & more-sizes]\n   (vary-meta\n     `(let [dims#     (list ~@more-sizes)\n            dimarray# (cljs.core/make-array ~size)]\n        (dotimes [i# (alength dimarray#)]\n          (aset dimarray# i# (apply cljs.core/make-array nil dims#)))\n        dimarray#)\n     assoc :tag 'array)))\n\n(core/defmacro list\n  ([]\n   '(.-EMPTY cljs.core/List))\n  ([x]\n   `(cljs.core/List. nil ~x nil 1 nil))\n  ([x & xs]\n   (core/let [cnt (core/inc (count xs))]\n     `(cljs.core/List. nil ~x (list ~@xs) ~cnt nil))))\n\n(core/defmacro vector\n  ([] '(.-EMPTY cljs.core/PersistentVector))\n  ([& xs]\n   (core/let [cnt (count xs)]\n     (if (core/< cnt 32)\n       `(cljs.core/PersistentVector. nil ~cnt 5\n          (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n       (vary-meta\n         `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n         assoc :tag 'cljs.core/PersistentVector)))))\n\n(core/defmacro array-map\n  ([] '(.-EMPTY cljs.core/PersistentArrayMap))\n  ([& kvs]\n   (core/let [keys (map first (partition 2 kvs))]\n     (if (core/and (every? #(= (:op (cljs.analyzer/unwrap-quote %)) :const)\n                     (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) keys))\n           (= (count (into #{} keys)) (count keys)))\n       `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n       `(.createAsIfByAssoc cljs.core/PersistentArrayMap (array ~@kvs))))))\n\n(core/defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([& kvs]\n   (core/let [pairs (partition 2 kvs)\n              ks    (map first pairs)\n              vs    (map second pairs)]\n     (vary-meta\n       `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n       assoc :tag 'cljs.core/PersistentHashMap))))\n\n(core/defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op (cljs.analyzer/unwrap-quote %)) :const)\n                    (map #(cljs.analyzer/no-warn (cljs.analyzer/analyze &env %)) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.createAsIfByAssoc cljs.core/PersistentHashSet (array ~@xs))\n        assoc :tag 'cljs.core/PersistentHashSet))))\n\n(core/defn- js-obj* [kvs]\n  (core/let [kvs-str (core/->> (repeat \"~{}:~{}\")\n                       (take (count kvs))\n                       (interpose \",\")\n                       (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"({\" kvs-str \"})\") (apply concat kvs))\n      assoc :tag 'object)))\n\n(core/defmacro js-obj [& rest]\n  (core/let [sym-or-str? (core/fn [x] (core/or (core/symbol? x) (core/string? x)))\n             filter-on-keys (core/fn [f coll]\n                              (core/->> coll\n                                (filter (core/fn [[k _]] (f k)))\n                                (into {})))\n             kvs (into {} (map vec (partition 2 rest)))\n             sym-pairs (filter-on-keys core/symbol? kvs)\n             expr->local (zipmap\n                           (filter (complement sym-or-str?) (keys kvs))\n                           (repeatedly gensym))\n             obj (gensym \"obj\")]\n    (if (empty? rest)\n      (js-obj* '())\n      `(let [~@(apply concat (clojure.set/map-invert expr->local))\n            ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n        ~@(map (core/fn [[k v]] `(goog.object/set ~obj ~k ~v)) sym-pairs)\n        ~@(map (core/fn [[k v]] `(goog.object/set ~obj ~v ~(core/get kvs k))) expr->local)\n        ~obj))))\n\n(core/defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))\n\n(core/defmacro amap\n  \"Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.\"\n  [a idx ret expr]\n  `(let [a# ~a\n         l# (alength a#)\n         ~ret (cljs.core/aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx l#)\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))\n\n(core/defmacro areduce\n  \"Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.\"\n  [a idx ret init expr]\n  `(let [a# ~a\n         l# (alength a#)]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx l#)\n         (recur (inc ~idx) ~expr)\n         ~ret))))\n\n(core/defmacro dotimes\n  \"bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.\"\n  [bindings & body]\n  (core/let [i (first bindings)\n             n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))\n\n(core/defn- check-valid-options\n  \"Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.\"\n  [options & valid-keys]\n  (core/when (seq (apply disj (apply core/hash-set (keys options)) valid-keys))\n    (throw\n      (apply core/str \"Only these options are valid: \"\n        (first valid-keys)\n        (map #(core/str \", \" %) (rest valid-keys))))))\n\n(core/defmacro defmulti\n  \"Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy\"\n  {:arglists '([name docstring? attr-map? dispatch-fn & options])}\n  [mm-name & options]\n  (core/let [docstring   (if (core/string? (first options))\n                           (first options)\n                           nil)\n             options     (if (core/string? (first options))\n                           (next options)\n                           options)\n             m           (if (map? (first options))\n                           (first options)\n                           {})\n             options     (if (map? (first options))\n                           (next options)\n                           options)\n             dispatch-fn (first options)\n             options     (next options)\n             m           (if docstring\n                           (assoc m :doc docstring)\n                           m)\n             m           (if (meta mm-name)\n                           (conj (meta mm-name) m)\n                           m)\n             mm-ns (core/-> &env :ns :name core/str)]\n    (core/when (= (count options) 1)\n      (throw\n        #?(:clj (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")\n           :cljs (js/Error. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))))\n    (core/let [options (apply core/hash-map options)\n               default (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(defonce ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (cljs.core/get ~options :hierarchy ((~'js* \"cljs.core.get_global_hierarchy\")))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n             method-table# prefer-table# method-cache# cached-hierarchy#))))))\n\n(core/defmacro defmethod\n  \"Creates and installs a new method of multimethod associated with dispatch-value. \"\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))\n\n(core/defmacro time\n  \"Evaluates expr and prints the time it took. Returns the value of expr.\"\n  [expr]\n  `(let [start# (system-time)\n         ret# ~expr]\n     (prn (cljs.core/str \"Elapsed time: \"\n            (.toFixed (- (system-time) start#) 6)\n            \" msecs\"))\n     ret#))\n\n(core/defmacro simple-benchmark\n  \"Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.\"\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (core/let [bs-str   (pr-str bindings)\n             expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                      ~iterations \" runs, \" elapsed# \" msecs\"))))))\n\n(def ^:private cs (into [] (map (comp gensym core/str core/char) (range 97 118))))\n\n(core/defn- gen-apply-to-helper\n  ([] (gen-apply-to-helper 1))\n  ([n]\n   (if (core/<= n 20)\n     `(let [~(cs (core/dec n)) (-first ~'args)\n            ~'args (-rest ~'args)]\n        (if (== ~'argc ~n)\n          (~'f ~@(take n cs))\n          ~(gen-apply-to-helper (core/inc n))))\n     `(throw (js/Error. \"Only up to 20 arguments supported on functions\")))))\n\n(core/defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))\n\n(core/defn- gen-apply-to-simple-helper\n  [f num-args args]\n  (core/let [new-arg-sym (symbol (core/str \"a\" num-args))\n             proto-name (core/str \"cljs$core$IFn$_invoke$arity$\" (core/inc num-args))\n             proto-prop (symbol (core/str \".-\" proto-name))\n             proto-inv (symbol (core/str \".\" proto-name))\n             next-sym (symbol (core/str \"next_\" num-args))\n             all-args (mapv #(symbol (core/str \"a\" %)) (range (core/inc num-args)))]\n    `(let [~new-arg-sym (cljs.core/-first ~args)\n           ~next-sym (cljs.core/next ~args)]\n       (if (nil? ~next-sym)\n         (if (~proto-prop ~f)\n           (~proto-inv ~f ~@all-args)\n           (.call ~f ~f ~@all-args))\n         ~(if (core/<= 19 num-args)\n            ;; We've exhausted all protocols, fallback to .apply:\n            `(let [arr# (cljs.core/array ~@all-args)]\n               (loop [s# ~next-sym]\n                 (when s#\n                   (do (.push arr# (cljs.core/-first s#))\n                       (recur (cljs.core/next s#)))))\n               (.apply ~f ~f arr#))\n            (gen-apply-to-simple-helper f (core/inc num-args) next-sym))))))\n\n(core/defmacro gen-apply-to-simple\n  [f num-args args]\n  (gen-apply-to-simple-helper f num-args args))\n\n(core/defmacro with-out-str\n  \"Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.\"\n  [& body]\n  `(let [sb# (goog.string/StringBuffer.)]\n     (binding [cljs.core/*print-newline* true\n               cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))\n\n(core/defmacro lazy-cat\n  \"Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))\"\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))\n\n(core/defmacro js-str [s]\n  (core/list 'js* \"''+~{}\" s))\n\n(core/defmacro es6-iterable [ty]\n  `(goog.object/set (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))\n\n(core/defmacro ns-publics\n  \"Returns a map of the public intern mappings for the namespace.\"\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (= (first quoted-ns) 'quote)\n                         (core/symbol? (second quoted-ns)))\n    \"Argument to ns-publics must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (filter (core/fn [[_ info]]\n                      (not (core/-> info :meta :private)))\n              (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs])))])))\n\n(core/defmacro ns-imports\n  \"Returns a map of the import mappings for the namespace.\"\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                         (= (first quoted-ns) 'quote)\n                         (core/symbol? (second quoted-ns)))\n    \"Argument to ns-imports must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[ctor qualified-ctor]]\n              `[(symbol ~(name ctor)) ~(symbol qualified-ctor)])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :imports]))])))\n\n(core/defmacro ns-interns\n  \"Returns a map of the intern mappings for the namespace.\"\n  [quoted-ns]\n  (core/assert (core/and (seq? quoted-ns)\n                 (= (first quoted-ns) 'quote)\n                 (core/symbol? (second quoted-ns)))\n    \"Argument to ns-interns must be a quoted symbol\")\n  (core/let [ns (second quoted-ns)]\n    `(into {}\n       [~@(map\n            (core/fn [[sym _]]\n              `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n            (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))])))\n\n(core/defmacro ns-unmap\n  \"Removes the mappings for the symbol from the namespace.\"\n  [quoted-ns quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-ns) (= (first quoted-ns) 'quote) (core/symbol? (second quoted-ns))\n              (seq? quoted-sym) (= (first quoted-sym) 'quote) (core/symbol? (second quoted-sym)))\n    \"Arguments to ns-unmap must be quoted symbols\")\n  (core/let [ns (second quoted-ns)\n             sym (second quoted-sym)]\n    (swap! env/*compiler* update-in [::ana/namespaces ns :defs] dissoc sym)\n    `(js-delete ~(comp/munge ns) ~(comp/munge (core/str sym)))))\n\n(core/defmacro vswap!\n  \"Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.\"\n  [vol f & args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))\n\n(core/defmacro locking\n  [x & forms]\n  `(do ~@forms))\n\n;; An internal-use Var for defining specs on the ns special form\n(core/defmacro ^:private ns-special-form [])\n\n(core/defmacro require\n  \"Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])\"\n  [& args]\n  `(~'ns* ~(cons :require args)))\n\n(core/defmacro require-macros\n  \"Similar to require but only for macros.\"\n  [& args]\n  `(~'ns* ~(cons :require-macros args)))\n\n(core/defmacro use\n  \"Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])\"\n  [& args]\n  `(~'ns* ~(cons :use args)))\n\n(core/defmacro use-macros\n  \"Similar to use but only for macros.\"\n  [& args]\n  `(~'ns* ~(cons :use-macros args)))\n\n(core/defmacro import\n  \"import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.\"\n  [& import-symbols-or-lists]\n  `(~'ns* ~(cons :import import-symbols-or-lists)))\n\n(core/defmacro refer-clojure\n  \"Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.\"\n  [& args]\n  `(~'ns* ~(cons :refer-clojure args)))\n\n;; INTERNAL - do not use, only for Node.js\n(core/defmacro load-file* [f]\n  `(goog/nodeGlobalRequire ~f))\n\n(core/defmacro macroexpand-1\n  \"If form represents a macro form, returns its expansion,\n  else returns form.\"\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand-1 must be quoted\")\n  (core/let [form (second quoted)]\n    (if (seq? form)\n      `(quote ~(ana/macroexpand-1 &env form))\n      form)))\n\n(core/defmacro macroexpand\n  \"Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.\"\n  [quoted]\n  (core/assert (core/= (core/first quoted) 'quote)\n    \"Argument to macroexpand must be quoted\")\n  (core/let [form (second quoted)\n             env &env]\n    (if (seq? form)\n      (core/loop [form form form' (ana/macroexpand-1 env form)]\n        (core/if-not (core/identical? form form')\n          (recur form' (ana/macroexpand-1 env form'))\n          `(quote ~form')))\n      form)))\n\n(core/defn- multi-arity-fn? [fdecl]\n  (core/< 1 (count fdecl)))\n\n(core/defn- variadic-fn? [fdecl]\n  (core/and (= 1 (count fdecl))\n            (some '#{&} (ffirst fdecl))))\n\n(core/defn- variadic-fn*\n  ([sym method]\n   (variadic-fn* sym method true))\n  ([sym [arglist & body :as method] solo]\n   (core/let [sig (remove '#{&} arglist)\n              restarg (gensym \"seq\")]\n     (core/letfn [(get-delegate []\n                    'cljs$core$IFn$_invoke$arity$variadic)\n                  (get-delegate-prop []\n                    (symbol (core/str \"-\" (get-delegate))))\n                  (param-bind [param]\n                    `[~param (^::ana/no-resolve first ~restarg)\n                      ~restarg (^::ana/no-resolve next ~restarg)])\n                  (apply-to []\n                    (if (core/< 1 (count sig))\n                      (core/let [params (repeatedly (core/dec (count sig)) gensym)]\n                        `(fn\n                           ([~restarg]\n                            (let [~@(mapcat param-bind params)]\n                              (this-as self#\n                                (. self# (~(get-delegate) ~@params ~restarg)))))))\n                      `(fn\n                         ([~restarg]\n                          (this-as self#\n                            (. self# (~(get-delegate) (seq ~restarg))))))))]\n       `(do\n          (set! (. ~sym ~(get-delegate-prop))\n            (fn (~(vec sig) ~@body)))\n          ~@(core/when solo\n              `[(set! (. ~sym ~'-cljs$lang$maxFixedArity)\n                  ~(core/dec (count sig)))])\n          (js-inline-comment \" @this {Function} \")\n          ;; dissoc :top-fn so this helper gets ignored in cljs.analyzer/parse 'set!\n          (set! (. ~(vary-meta sym dissoc :top-fn) ~'-cljs$lang$applyTo)\n            ~(apply-to)))))))\n\n(core/defmacro copy-arguments [dest]\n  `(let [len# (alength (js-arguments))]\n     (loop [i# 0]\n       (when (< i# len#)\n         (.push ~dest (unchecked-get (js-arguments) i#))\n         (recur (inc i#))))))\n\n(core/defn- elide-implicit-macro-args [arglists]\n  (core/map (core/fn [arglist]\n              (if (core/vector? arglist)\n                (core/subvec arglist 2)\n                (core/drop 2 arglist)))\n    arglists))\n\n(core/defn- variadic-fn [name meta [[arglist & body :as method] :as fdecl] emit-var?]\n  (core/letfn [(dest-args [c]\n                 (map (core/fn [n] `(unchecked-get (js-arguments) ~n))\n                   (range c)))]\n    (core/let [rname (symbol (core/str ana/*cljs-ns*) (core/str name))\n               sig   (remove '#{&} arglist)\n               c-1   (core/dec (count sig))\n               macro? (:macro meta)\n               mfa   (core/cond-> c-1 macro? (core/- 2))\n               meta  (assoc meta\n                       :top-fn\n                       {:variadic? true\n                        :fixed-arity mfa\n                        :max-fixed-arity mfa\n                        :method-params (core/cond-> [sig] macro? elide-implicit-macro-args)\n                        :arglists (core/cond-> (core/list arglist) macro? elide-implicit-macro-args)\n                        :arglists-meta (doall (map meta [arglist]))})\n               name  (with-meta name meta)]\n      `(do\n         (def ~name\n           (fn [~'var_args]\n             (let [args# (array)]\n               (copy-arguments args#)\n               (let [argseq# (when (< ~c-1 (alength args#))\n                               (new ^::ana/no-resolve cljs.core/IndexedSeq\n                                 (.slice args# ~c-1) 0 nil))]\n                 (. ~rname (~'cljs$core$IFn$_invoke$arity$variadic ~@(dest-args c-1) argseq#))))))\n         ~(variadic-fn* name method)\n         ~(core/when emit-var? `(var ~name))))))\n\n(core/comment\n  (require '[clojure.pprint :as pp])\n  (pp/pprint (variadic-fn 'foo {} '(([& xs]))))\n  (pp/pprint (variadic-fn 'foo {} '(([a & xs] xs))))\n  (pp/pprint (variadic-fn 'foo {} '(([a b & xs] xs))))\n  (pp/pprint (variadic-fn 'foo {} '(([a [b & cs] & xs] xs))))\n  )\n\n(core/defn- multi-arity-fn [name meta fdecl emit-var?]\n  (core/letfn [(dest-args [c]\n                 (map (core/fn [n] `(unchecked-get (js-arguments) ~n))\n                   (range c)))\n               (fixed-arity [rname sig]\n                 (core/let [c (count sig)]\n                   [c `(. ~rname\n                         (~(symbol\n                             (core/str \"cljs$core$IFn$_invoke$arity$\" c))\n                           ~@(dest-args c)))]))\n               (fn-method [name [sig & body :as method]]\n                 (if (some '#{&} sig)\n                   (variadic-fn* name method false)\n                   ;; fix up individual :fn-method meta for\n                   ;; cljs.analyzer/parse 'set! :top-fn handling\n                   `(set!\n                      (. ~(vary-meta name update :top-fn merge\n                            {:variadic? false :fixed-arity (count sig)})\n                        ~(symbol (core/str \"-cljs$core$IFn$_invoke$arity$\"\n                                   (count sig))))\n                      (fn ~method))))]\n    (core/let [rname    (symbol (core/str ana/*cljs-ns*) (core/str name))\n               arglists (map first fdecl)\n               varsig?  #(some '#{&} %)\n               variadic (boolean (some varsig? arglists))\n               sigs     (remove varsig? arglists)\n               maxfa    (apply core/max\n                          (concat\n                            (map count sigs)\n                            [(core/- (count (first (filter varsig? arglists))) 2)]))\n               macro?   (:macro meta)\n               mfa      (core/cond-> maxfa macro? (core/- 2))\n               meta     (assoc meta\n                          :top-fn\n                          {:variadic? variadic\n                           :fixed-arity mfa\n                           :max-fixed-arity mfa\n                           :method-params (core/cond-> sigs macro? elide-implicit-macro-args)\n                           :arglists (core/cond-> arglists macro? elide-implicit-macro-args)\n                           :arglists-meta (doall (map meta arglists))})\n               args-sym (gensym \"args\")\n               param-counts (map count arglists)\n               name     (with-meta name meta)]\n      (core/when (not= (distinct param-counts) param-counts)\n        (ana/warning :overload-arity {} {:name name}))\n      `(do\n         (def ~name\n           (fn [~'var_args]\n             (case (alength (js-arguments))\n               ~@(mapcat #(fixed-arity rname %) sigs)\n               ~(if variadic\n                  `(let [args-arr# (array)]\n                     (copy-arguments args-arr#)\n                     (let [argseq# (new ^::ana/no-resolve cljs.core/IndexedSeq\n                                        (.slice args-arr# ~maxfa) 0 nil)]\n                       (. ~rname\n                          (~'cljs$core$IFn$_invoke$arity$variadic\n                           ~@(dest-args maxfa)\n                           argseq#))))\n                  (if (:macro meta)\n                    `(throw (js/Error.\n                             (str \"Invalid arity: \" (- (alength (js-arguments)) 2))))\n                    `(throw (js/Error.\n                             (str \"Invalid arity: \" (alength (js-arguments))))))))))\n         ~@(map #(fn-method name %) fdecl)\n         ;; optimization properties\n         (set! (. ~name ~'-cljs$lang$maxFixedArity) ~maxfa)\n         ~(core/when emit-var? `(var ~name))))))\n\n(core/comment\n  (require '[clojure.pprint :as pp])\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a b]))))\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a & xs]))))\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a [b & cs] & xs]))))\n  ;; CLJS-1216\n  (pp/pprint (multi-arity-fn 'foo {} '(([a]) ([a b & xs]))))\n  )\n\n(def\n  ^{:doc \"Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n    :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                 [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n    :macro true}\n  defn (core/fn defn [&form &env name & fdecl]\n         ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n         (if (core/instance? #?(:clj clojure.lang.Symbol :cljs Symbol) name)\n           nil\n           (throw\n             #?(:clj (IllegalArgumentException. \"First argument to defn must be a symbol\")\n                :cljs (js/Error. \"First argument to defn must be a symbol\"))))\n         (core/let [m (if (core/string? (first fdecl))\n                        {:doc (first fdecl)}\n                        {})\n                    fdecl (if (core/string? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    m (if (map? (first fdecl))\n                        (conj m (first fdecl))\n                        m)\n                    fdecl (if (map? (first fdecl))\n                            (next fdecl)\n                            fdecl)\n                    fdecl (if (vector? (first fdecl))\n                            (core/list fdecl)\n                            fdecl)\n                    m (if (map? (last fdecl))\n                        (conj m (last fdecl))\n                        m)\n                    fdecl (if (map? (last fdecl))\n                            (butlast fdecl)\n                            fdecl)\n                    m (conj {:arglists (core/list 'quote (sigs fdecl))} m)\n                    ;; no support for :inline\n                    ;m (core/let [inline (:inline m)\n                    ;             ifn (first inline)\n                    ;             iname (second inline)]\n                    ;    ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                    ;    (if (if #?(:clj (clojure.lang.Util/equiv 'fn ifn)\n                    ;               :cljs (= 'fn ifn))\n                    ;          (if #?(:clj (core/instance? clojure.lang.Symbol iname)\n                    ;                 :cljs (core/instance? Symbol iname)) false true))\n                    ;      ;; inserts the same fn name to the inline fn if it does not have one\n                    ;      (assoc m\n                    ;        :inline (cons ifn\n                    ;                  (cons (clojure.lang.Symbol/intern\n                    ;                          (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                    ;                    (next inline))))\n                    ;      m))\n                    m (conj (if (meta name) (meta name) {}) m)]\n           (core/cond\n             (multi-arity-fn? fdecl)\n             (multi-arity-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl (:def-emits-var &env))\n\n             (variadic-fn? fdecl)\n             (variadic-fn name\n               (if (comp/checking-types?)\n                 (update-in m [:jsdoc] conj \"@param {...*} var_args\")\n                 m) fdecl (:def-emits-var &env))\n\n             :else\n             (core/list 'def (with-meta name m)\n               ;;todo - restore propagation of fn name\n               ;;must figure out how to convey primitive hints to self calls first\n               (cons `fn fdecl))))))\n\n#?(:clj  (. (var defn) (setMacro))\n   :cljs (set! (. defn -cljs$lang$macro) true))\n\n(core/defn defmacro\n  \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n  {:arglists '([name doc-string? attr-map? [params*] body]\n               [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :macro true}\n  [&form &env name & args]\n  (core/let [prefix (core/loop [p (core/list (vary-meta name assoc :macro true)) args args]\n                      (core/let [f (first args)]\n                        (if (core/string? f)\n                          (recur (cons f p) (next args))\n                          (if (map? f)\n                            (recur (cons f p) (next args))\n                            p))))\n             fdecl (core/loop [fd args]\n                     (if (core/string? (first fd))\n                       (recur (next fd))\n                       (if (map? (first fd))\n                         (recur (next fd))\n                         fd)))\n             fdecl (if (vector? (first fdecl))\n                     (core/list fdecl)\n                     fdecl)\n             add-implicit-args (core/fn [fd]\n                                 (core/let [args (first fd)]\n                                   (cons (vec (cons '&form (cons '&env args))) (next fd))))\n             add-args (core/fn [acc ds]\n                        (if (core/nil? ds)\n                          acc\n                          (core/let [d (first ds)]\n                            (if (map? d)\n                              (conj acc d)\n                              (recur (conj acc (add-implicit-args d)) (next ds))))))\n             fdecl (seq (add-args [] fdecl))\n             decl (core/loop [p prefix d fdecl]\n                    (if p\n                      (recur (next p) (cons (first p) d))\n                      d))]\n    `(let [ret# ~(cons `defn decl)]\n       (set! (. ~name ~'-cljs$lang$macro) true)\n       ret#)))\n\n#?(:clj  (. (var defmacro) (setMacro))\n   :cljs (set! (. defmacro -cljs$lang$macro) true))\n\n(core/defmacro resolve\n  \"Returns the var to which a symbol will be resolved in the namespace else nil.\"\n  [quoted-sym]\n  (core/assert\n    (core/and (seq? quoted-sym)\n              (= 'quote (first quoted-sym)))\n    \"Argument to resolve must be a quoted symbol\")\n  (core/let [sym (second quoted-sym)\n             env &env\n             [var meta] (try\n                          (core/let [var (ana/resolve-var env sym (ana/confirm-var-exists-throw)) ]\n                            [var (ana/var-meta var)])\n                          (catch #?@(:clj [Throwable t] :cljs [:default e])\n                              [(ana/resolve-var env sym) nil]))\n             resolved (vary-meta (:name var) assoc ::ana/no-resolve true)]\n    `(when (exists? ~resolved)\n       (cljs.core/Var. (fn [] ~resolved) '~resolved ~meta))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/test/check/clojure_test.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.test.check.clojure-test",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.clojure-test\n  (:require #?(:clj  [clojure.test :as ct]\n               :cljs [cljs.test :as ct :include-macros true])\n            [clojure.test.check :as tc]\n            [clojure.test.check.clojure-test.assertions]\n            [clojure.test.check.impl :refer [get-current-time-millis]])\n  #?(:cljs (:require-macros [clojure.test.check.clojure-test :refer [defspec]])))\n\n(defn assert-check\n  [{:keys [result result-data] :as m}]\n  (if-let [error (:clojure.test.check.properties/error result-data)]\n    (throw error)\n    (ct/is (clojure.test.check.clojure-test/check? m))))\n\n(def ^:dynamic *default-test-count* 100)\n\n(defn default-reporter-fn\n  \"Default function passed as the :reporter-fn to clojure.test.check/quick-check.\n  Delegates to clojure.test/report.\"\n  [{:keys [type] :as args}]\n  (case type\n    :complete\n    (let [testing-vars #?(:clj ct/*testing-vars*\n                          :cljs (:testing-vars ct/*current-env*))\n          params       (merge (select-keys args [:result :num-tests :seed\n                                                 :time-elapsed-ms])\n                              (when (seq testing-vars)\n                                {:test-var (-> testing-vars first meta :name name)}))]\n      (ct/report {:type :clojure.test.check.clojure-test/complete\n                  :clojure.test.check.clojure-test/property (:property args)\n                  :clojure.test.check.clojure-test/complete params}))\n\n    :trial\n    (ct/report {:type :clojure.test.check.clojure-test/trial\n                :clojure.test.check.clojure-test/property (:property args)\n                :clojure.test.check.clojure-test/trial [(:num-tests args)\n                                                        (:num-tests-total args)]})\n\n    :failure\n    (ct/report {:type :clojure.test.check.clojure-test/shrinking\n                :clojure.test.check.clojure-test/property (:property args)\n                :clojure.test.check.clojure-test/params (vec (:fail args))})\n\n    :shrunk\n    (ct/report {:type :clojure.test.check.clojure-test/shrunk\n                :clojure.test.check.clojure-test/property (:property args)\n                :clojure.test.check.clojure-test/params (-> args :shrunk :smallest vec)})\n    nil))\n\n(def ^:dynamic *default-opts*\n  \"The default options passed to clojure.test.check/quick-check\n  by defspec.\"\n  {:reporter-fn default-reporter-fn})\n\n(defn process-options\n  {:no-doc true}\n  [options]\n  (cond (nil? options) (merge {:num-tests *default-test-count*} *default-opts*)\n        (number? options) (assoc *default-opts* :num-tests options)\n        (map? options) (merge {:num-tests *default-test-count*}\n                              *default-opts*\n                              options)\n        :else (throw (ex-info (str \"Invalid defspec options: \" (pr-str options))\n                              {:bad-options options}))))\n\n(defmacro defspec\n  \"Defines a new clojure.test test var that uses `quick-check` to verify the\n  property, running num-times trials by default.  You can call the function defined as `name`\n  with no arguments to trigger this test directly (i.e., without starting a\n  wider clojure.test run).  If called with arguments, the first argument is the number of\n  trials, optionally followed by keyword arguments as defined for `quick-check`.\"\n  {:arglists '([name property] [name num-tests? property] [name options? property])}\n  ([name property] `(defspec ~name nil ~property))\n  ([name options property]\n   `(defn ~(vary-meta name assoc\n                      ::defspec true\n                      :test `(fn []\n                               (clojure.test.check.clojure-test/assert-check\n                                (assoc (~name) :test-var (str '~name)))))\n      {:arglists '([] ~'[num-tests & {:keys [seed max-size reporter-fn]}])}\n      ([] (let [options# (process-options ~options)]\n            (apply ~name (:num-tests options#) (apply concat options#))))\n      ([times# & {:as quick-check-opts#}]\n       (let [options# (merge (process-options ~options) quick-check-opts#)]\n         (apply\n          tc/quick-check\n          times#\n          (vary-meta ~property assoc :name '~name)\n          (apply concat options#)))))))\n\n(def ^:dynamic *report-trials*\n  \"Controls whether property trials should be reported via clojure.test/report.\n  Valid values include:\n\n  * false - no reporting of trials (default)\n  * a function - will be passed a clojure.test/report-style map containing\n  :clojure.test.check/property and :clojure.test.check/trial slots\n  * true - provides quickcheck-style trial reporting (dots) via\n  `trial-report-dots`\n\n  (Note that all reporting requires running `quick-check` within the scope of a\n  clojure.test run (via `test-ns`, `test-all-vars`, etc.))\n\n  Reporting functions offered by clojure.test.check include `trial-report-dots` and\n  `trial-report-periodic` (which prints more verbose trial progress information\n  every `*trial-report-period*` milliseconds).\"\n  false)\n\n(def ^:dynamic *report-shrinking*\n  \"If true, a verbose report of the property being tested, the\n  failing return value, and the arguments provoking that failure is emitted\n  prior to the start of the shrinking search.\"\n  false)\n\n(def ^:dynamic *trial-report-period*\n  \"Milliseconds between reports emitted by `trial-report-periodic`.\"\n  10000)\n\n(def ^:private last-trial-report (atom 0))\n\n(defn- get-property-name\n  [{property-fun ::property :as report-map}]\n  (or (-> property-fun meta :name) (ct/testing-vars-str report-map)))\n\n(defn with-test-out* [f]\n  #?(:clj  (ct/with-test-out (f))\n     :cljs (f)))\n\n(defn trial-report-periodic\n  \"Intended to be bound as the value of `*report-trials*`; will emit a verbose\n  status every `*trial-report-period*` milliseconds, like this one:\n\n  Passing trial 3286 / 5000 for (your-test-var-name-here) (:)\"\n  [m]\n  (let [t (get-current-time-millis)]\n    (when (> (- t *trial-report-period*) @last-trial-report)\n      (with-test-out*\n        (fn []\n          (println \"Passing trial\"\n                   (-> m ::trial first) \"/\" (-> m ::trial second)\n                   \"for\" (get-property-name m))))\n      (reset! last-trial-report t))))\n\n(defn trial-report-dots\n  \"Intended to be bound as the value of `*report-trials*`; will emit a single\n  dot every 1000 trials reported.\"\n  [{[so-far total] ::trial}]\n  (when (pos? so-far)\n    (when (zero? (mod so-far 1000))\n      (print \".\")\n      (flush))\n    (when (== so-far total) (println))))\n\n(def ^:dynamic *report-completion*\n  \"If true, completed tests report test-var, num-tests and seed. Failed tests\n  report shrunk results. Defaults to true.\"\n  true)\n\n(when #?(:clj true :cljs (not (and *ns* (re-matches #\".*\\$macros\" (name (ns-name *ns*))))))\n  ;; This check accomodates a number of tools that rebind ct/report\n  ;; to be a regular function instead of a multimethod, and may do\n  ;; so before this code is loaded (see TCHECK-125)\n  (if-not (instance? #?(:clj clojure.lang.MultiFn :cljs MultiFn) ct/report)\n    (binding [*out* #?(:clj *err* :cljs *out*)]\n      (println \"clojure.test/report is not a multimethod, some reporting functions have been disabled.\"))\n    (let [begin-test-var-method (get-method ct/report #?(:clj  :begin-test-var\n                                                         :cljs [::ct/default :begin-test-var]))]\n      (defmethod ct/report #?(:clj  :begin-test-var\n                              :cljs [::ct/default :begin-test-var]) [m]\n        (reset! last-trial-report (get-current-time-millis))\n        (when begin-test-var-method (begin-test-var-method m)))\n\n      (defmethod ct/report #?(:clj ::trial :cljs [::ct/default ::trial]) [m]\n        (when-let [trial-report-fn (and *report-trials*\n                                        (if (true? *report-trials*)\n                                          trial-report-dots\n                                          *report-trials*))]\n          (trial-report-fn m)))\n\n      (defmethod ct/report #?(:clj ::shrinking :cljs [::ct/default ::shrinking]) [m]\n        (when *report-shrinking*\n          (with-test-out*\n            (fn []\n              (println \"Shrinking\" (get-property-name m)\n                \"starting with parameters\" (pr-str (::params m)))))))\n\n      (defmethod ct/report #?(:clj ::complete :cljs [::ct/default ::complete]) [m]\n        (when *report-completion*\n          (prn (::complete m))))\n\n      (defmethod ct/report #?(:clj ::shrunk :cljs [::ct/default ::shrunk]) [m]\n        (when *report-completion*\n          (with-test-out*\n            (fn [] (prn m))))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader/impl/inspect.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader.impl.inspect",new cljs.core.Keyword(null,"source","source",-433931539),";;   Copyright (c) Russ Olsen, Nicola Mometto, Rich Hickey & contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.inspect)\n\n(declare inspect*)\n\n(defn- inspect*-col [truncate col start end]\n  (let [n (count col)\n        l (if truncate 0 (min 10 n))\n        elements (map (partial inspect* true) (take l col))\n        content (apply str (interpose \" \" elements))\n        suffix (if (< l n) \"...\")]\n    (str start content suffix end)))\n\n(defn- dispatch-inspect\n  [_ x]\n  (cond\n   (nil? x) :nil\n   (string? x) :string\n   (keyword? x) :strable\n   (number? x) :strable\n   (symbol? x) :strable\n   (vector? x) :vector\n   (list? x)  :list\n   (map? x) :map\n   (set? x) :set\n   (= x true) :strable\n   (= x false) :strable\n   :default (type x)))\n\n(defmulti inspect* dispatch-inspect)\n\n(defmethod inspect* :string [truncate ^String x]\n  (let [n (if truncate 5 20)\n        suffix (if (> (.-length x) n) \"...\\\"\" \"\\\"\")]\n    (str\n      \\\"\n      (.substring ^String x 0 (min n (.-length x)))\n      suffix)))\n\n(defmethod inspect* :strable [truncate x] (str x))\n\n(defmethod inspect* cljs.core/IndexedSeq [truncate x]\n  \"<indexed seq>\")\n\n(defmethod inspect* cljs.core/PersistentArrayMapSeq [truncate x]\n  \"<map seq>\")\n\n(defmethod inspect* cljs.core/NodeSeq [truncate x]\n  \"<map seq>\")\n\n(defmethod inspect* cljs.core/Cons [truncate x] \"<cons>\")\n\n(defmethod inspect* cljs.core/LazySeq [truncate x] \"<lazy seq>\")\n\n(defmethod inspect* :nil [_ _] \"nil\")\n\n(defmethod inspect* :list [truncate col]\n  (inspect*-col truncate col \\( \\)))\n\n(defmethod inspect* :map [truncate m]\n  (let [len (count m)\n        n-shown (if truncate 0 len)\n        contents (apply concat (take n-shown m))\n        suffix (if (> len n-shown) \"...}\" \\})]\n    (inspect*-col truncate contents \\{ suffix)))\n\n(defmethod inspect* :set [truncate col]\n  (inspect*-col truncate col \"#{\" \\}))\n\n(defmethod inspect* :vector [truncate col]\n  (inspect*-col truncate col \\[ \\]))\n\n(defmethod inspect* :default [truncate x]\n  (pr-str (type x)))\n\n(defn inspect\n  \"Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \\\"true\\\")\n   or it may be a description (e.g. \\\"an instance of Foo\\\").\n   If truncate is true then return a very terse version of\n   the inspection.\"\n  ([x] (inspect* false x))\n  ([truncate x] (inspect* truncate x)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader/impl/commons.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader.impl.commons",new cljs.core.Keyword(null,"source","source",-433931539),";;   Copyright (c) Nicola Mometto, Rich Hickey & contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.tools.reader.impl.commons\n  (:refer-clojure :exclude [char])\n  (:require\n   [cljs.tools.reader.impl.errors :refer [reader-error]]\n   [cljs.tools.reader.reader-types :refer [peek-char read-char]]\n   [cljs.tools.reader.impl.utils :refer [numeric? newline? char]]))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; helpers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn ^boolean number-literal?\n  \"Checks whether the reader is at the start of a number literal\"\n  [^not-native reader initch]\n  (or (numeric? initch)\n      (and (or (identical? \\+ initch) (identical?  \\- initch))\n           (numeric? (peek-char reader)))))\n\n(defn read-past\n  \"Read until first character that doesn't match pred, returning\n   char.\"\n  [pred ^not-native rdr]\n  (loop [ch (read-char rdr)]\n    (if ^boolean (pred ch)\n      (recur (read-char rdr))\n      ch)))\n\n(defn skip-line\n  \"Advances the reader to the end of a line. Returns the reader\"\n  [^not-native reader]\n  (loop []\n    (when-not (newline? (read-char reader))\n      (recur)))\n  reader)\n\n(def int-pattern #\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$\")\n(def ratio-pattern #\"([-+]?[0-9]+)/([0-9]+)\")\n(def float-pattern #\"([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\")\n\n(defn- match-int\n  [s]\n  (let [m (vec (re-find int-pattern s))]\n    (if-not (nil? (m 2))\n      0\n      (let [^boolean negate? (identical? \"-\" (m 1))\n            a (cond\n               (not (nil? (m 3))) [(m 3) 10]\n               (not (nil? (m 4))) [(m 4) 16]\n               (not (nil? (m 5))) [(m 5) 8]\n               (not (nil? (m 7))) [(m 7) (js/parseInt (m 6))]\n               :else              [nil nil])\n            n (a 0)]\n        (when-not (nil? n)\n          (let [bn (js/parseInt n (a 1))\n                bn (if negate? (* -1 bn) bn)]\n            (when-not (js/isNaN bn)\n              bn)))))))\n\n(defn- match-ratio\n  [s]\n  (let [m (vec (re-find ratio-pattern s))\n        numerator (m 1)\n        denominator (m 2)\n        numerator (if (re-find #\"^\\+\" numerator)\n                    (subs numerator 1)\n                    numerator)]\n    (/ (-> numerator   js/parseInt) ;;; No ratio type in cljs\n       (-> denominator js/parseInt)))); So will convert to js/Number\n\n(defn- match-float\n  [s]\n  (let [m (vec (re-find float-pattern s))]\n    (if-not (nil? (m 4)) ;; for BigDecimal \"10.03M\", as all parsed to js/Number\n      (js/parseFloat (m 1))\n      (js/parseFloat s))))\n\n(defn ^boolean matches? [pattern s]\n  (let [[match] (re-find pattern s)]\n    (identical? match s)))\n\n(defn match-number [s]\n  (if (matches? int-pattern s)\n    (match-int s)\n    (if (matches? float-pattern s)\n      (match-float s)\n      (when (matches? ratio-pattern s)\n        (match-ratio s)))))\n\n(defn parse-symbol\n  \"Parses a string into a vector of the namespace and symbol\"\n  [token]\n  (when-not (or (identical? \"\" token)\n                (true? (.test #\":$\" token))\n                (true? (.test #\"^::\" token)))\n    (let [ns-idx (.indexOf token \"/\")\n          ns (when (pos? ns-idx)\n               (subs token 0 ns-idx))]\n      (if-not (nil? ns)\n        (let [ns-idx (inc ns-idx)]\n          (when-not (== ns-idx (count token))\n            (let [sym (subs token ns-idx)]\n              (when (and (not (numeric? (nth sym 0)))\n                         (not (identical? \"\" sym))\n                         (false? (.test #\":$\" ns))\n                         (or (identical? sym \"/\")\n                             (== -1 (.indexOf sym \"/\"))))\n                [ns sym]))))\n        (when (or (identical? token \"/\")\n                  (== -1 (.indexOf token \"/\")))\n          [nil token])))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; readers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn read-comment\n  [rdr & _]\n  (skip-line rdr))\n\n(defn throwing-reader\n  [msg]\n  (fn [rdr & _]\n    (reader-error rdr msg)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/walk.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.walk",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;;; walk.clj - generic tree walker with replacement\n\n;; by Stuart Sierra\n;; December 15, 2008\n\n;; CHANGE LOG:\n;;\n;; * December 15, 2008: replaced 'walk' with 'prewalk' & 'postwalk'\n;;\n;; * December 9, 2008: first version\n\n\n(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)\n\n(defn walk\n  \"Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n\n  {:added \"1.1\"}\n  [inner outer form]\n  (cond\n   (list? form) (outer (apply list (map inner form)))\n   (instance? clojure.lang.IMapEntry form)\n   (outer (clojure.lang.MapEntry/create (inner (key form)) (inner (val form))))\n   (seq? form) (outer (doall (map inner form)))\n   (instance? clojure.lang.IRecord form)\n     (outer (reduce (fn [r x] (conj r (inner x))) form form))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))\n\n(defn postwalk\n  \"Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial postwalk f) f form))\n\n(defn prewalk\n  \"Like postwalk, but does pre-order traversal.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))\n\n\n;; Note: I wanted to write:\n;;\n;; (defn walk\n;;   [f form]\n;;   (let [pf (partial walk f)]\n;;     (if (coll? form)\n;;       (f (into (empty form) (map pf form)))\n;;       (f form))))\n;;\n;; but this throws a ClassCastException when applied to a map.\n\n\n(defn postwalk-demo\n  \"Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.\"\n  {:added \"1.1\"}\n  [form]\n  (postwalk (fn [x] (print \"Walked: \") (prn x) x) form))\n\n(defn prewalk-demo\n  \"Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.\"\n  {:added \"1.1\"}\n  [form]\n  (prewalk (fn [x] (print \"Walked: \") (prn x) x) form))\n\n(defn keywordize-keys\n  \"Recursively transforms all map keys from strings to keywords.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn stringify-keys\n  \"Recursively transforms all map keys from keywords to strings.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn prewalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn postwalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn macroexpand-all\n  \"Recursively performs all possible macroexpansions in form.\"\n  {:added \"1.1\"}\n  [form]\n  (prewalk (fn [x] (if (seq? x) (macroexpand x) x)) form))\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/repl.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.repl",new cljs.core.Keyword(null,"source","source",-433931539),";; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.repl\n  (:refer-clojure :exclude [load load-file])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [clojure.set :as set]\n            [clojure.data.json :as json]\n            [clojure.tools.reader :as reader]\n            [clojure.tools.reader.reader-types :as readers]\n            [cljs.tagged-literals :as tags]\n            [clojure.edn :as edn]\n            [cljs.util :as util]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            [cljs.env :as env]\n            [cljs.js-deps :as deps]\n            [cljs.closure :as cljsc]\n            [cljs.source-map :as sm])\n  (:import [java.io File PushbackReader FileWriter PrintWriter]\n           [java.net URL]\n           [java.util Base64]\n           [java.util.concurrent.atomic AtomicLong]\n           [clojure.lang IExceptionInfo]\n           [java.util.regex Pattern]\n           [com.google.common.base Throwables]))\n\n(def ^:dynamic *cljs-verbose* false)\n(def ^:dynamic *repl-opts* nil)\n(def ^:dynamic *repl-env* nil)\n\n(def known-repl-opts\n  \"Set of all known REPL options.\"\n  #{:analyze-path :bind-err :caught :compiler-env :def-emits-var :eval :flush\n    :init :inits :need-prompt :print :print-no-newline :prompt :quit-prompt :read\n    :reader :repl-requires :repl-verbose :source-map-inline :watch :watch-fn\n    :wrap})\n\n(defmacro ^:private err-out [& body]\n  `(binding [*out* *err*]\n     ~@body))\n\n;; =============================================================================\n;; Copied over from clojure.main\n\n(defn skip-if-eol\n  \"If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\\\newline.\"\n  [s]\n  (let [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      (do (readers/unread s c) :body))))\n\n(defn skip-whitespace\n  \"Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\\\newline.\"\n  [s]\n  (loop [c (readers/read-char s)]\n    (case c\n      \\newline :line-start\n      nil :stream-end\n      \\; (do (readers/read-line s) :line-start)\n      (if (or (Character/isWhitespace c) (identical? c \\,))\n        (recur (readers/read-char s))\n        (do (readers/unread s c) :body)))))\n\n(defn repl-read\n  \"Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\\\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.\"\n  ([request-prompt request-exit]\n   (repl-read request-prompt request-exit *repl-opts*))\n  ([request-prompt request-exit opts]\n   (let [current-in *in*\n         bind-in?   (true? (:source-map-inline opts))]\n     (binding [*in* (if bind-in?\n                      ((:reader opts))\n                      *in*)]\n       (or ({:line-start request-prompt :stream-end request-exit}\n             (skip-whitespace *in*))\n         (let [input (reader/read {:read-cond :allow :features #{:cljs}} *in*)]\n           ;; Transfer 1-char buffer to original *in*\n           (readers/unread current-in (readers/read-char *in*))\n           (skip-if-eol (if bind-in? current-in *in*))\n           input))))))\n\n;; =============================================================================\n;; CLJS Specifics\n\n(defprotocol IReplEnvOptions\n  (-repl-options [repl-env] \"Return default REPL options for a REPL Env\"))\n\n(defn repl-options [repl-env]\n  (-repl-options repl-env))\n\n(defprotocol IJavaScriptEnv\n  (-setup [repl-env opts] \"initialize the environment\")\n  (-evaluate [repl-env filename line js] \"evaluate a javascript string\")\n  (-load [repl-env provides url] \"load code at url into the environment\")\n  (-tear-down [repl-env] \"dispose of the environment\"))\n\n(defn setup [repl-env opts]\n  (-setup repl-env opts))\n\n(defn evaluate [repl-env filename line js]\n  (-evaluate repl-env filename line js))\n\n(defn load [repl-env provides url]\n  (-load repl-env provides url))\n\n(defn tear-down [repl-env]\n  (-tear-down repl-env))\n\n(extend-type\n  Object\n  IReplEnvOptions\n  (-repl-options [_] nil))\n\n(defprotocol IParseError\n  (-parse-error [repl-env error build-options]\n    \"Given the original JavaScript error return the error to actually\n     use.\"))\n\n(defprotocol IGetError\n  (-get-error [repl-env name env build-options]\n    \"Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.\"))\n\n(defprotocol IParseStacktrace\n  (-parse-stacktrace [repl-env stacktrace error build-options]\n    \"Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \\\"<cljs repl>\\\".\"))\n\n(defprotocol IPrintStacktrace\n  (-print-stacktrace [repl-env stacktrace error build-options]\n    \"Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.\"))\n\n(defn- env->opts\n  \"Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.\"\n  ([repl-env] (env->opts repl-env nil))\n  ([repl-env opts]\n    ;; some bits in cljs.closure use the options value as an ifn :-/\n   (-> (into {} repl-env)\n     (assoc :optimizations\n            (or (:optimizations opts) (get repl-env :optimizations :none)))\n     (assoc :output-dir\n            (or (:output-dir opts) (get repl-env :working-dir \".repl\"))))))\n\n(defn add-url [ijs]\n  (cond-> ijs\n    (not (contains? ijs :url))\n    (assoc :url (io/resource (:file ijs)))))\n\n(defn ns->input [ns opts]\n  (or (some-> (util/ns->source ns) (ana/parse-ns opts))\n      (some-> (get-in @env/*compiler* [:js-dependency-index (str ns)]) add-url)\n      (some-> (deps/find-classpath-lib ns))\n      (throw\n        (ex-info (str ns \" does not exist\")\n          {::error :invalid-ns}))))\n\n(defn compilable? [input]\n  (contains? input :source-file))\n\n(defn- load-sources\n  \"Load the compiled `sources` into the REPL.\"\n  [repl-env sources opts]\n  (if (:output-dir opts)\n    ;; REPLs that read from :output-dir just need to add deps,\n    ;; environment will handle actual loading - David\n    (let [sb (StringBuffer.)]\n      (doseq [source sources]\n        (with-open [rdr (io/reader (:url source))]\n          (.append sb (cljsc/add-dep-string opts source))))\n      (when (:repl-verbose opts)\n        (println (.toString sb)))\n      (-evaluate repl-env \"<cljs repl>\" 1 (.toString sb)))\n    ;; REPLs that stream must manually load each dep - David\n    (doseq [{:keys [url provides]} sources]\n      (-load repl-env provides url))))\n\n(defn- load-cljs-loader\n  \"Compile and load the cljs.loader namespace if it's present in `sources`.\"\n  [repl-env sources opts]\n  (when-let [source (first (filter #(= (:ns %) 'cljs.loader) sources))]\n    (cljsc/compile-loader sources opts)\n    (load-sources repl-env [source] opts)))\n\n(defn load-namespace\n  \"Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.\"\n  ([repl-env ns] (load-namespace repl-env ns nil))\n  ([repl-env ns opts]\n   (let [ns      (if (and (seq? ns) (= (first ns) 'quote)) (second ns) ns)\n         sources (seq\n                   (when-not (ana/node-module-dep? ns)\n                     (let [input (ns->input ns opts)]\n                       (if (compilable? input)\n                         (->> (cljsc/compile-inputs [input]\n                                (merge (env->opts repl-env) opts))\n                           (remove (comp #{[\"goog\"]} :provides)))\n                         (map #(cljsc/source-on-disk opts %)\n                              (cljsc/add-js-sources [input] opts))))))]\n     (when (:repl-verbose opts)\n       (println (str \"load-namespace \" ns \" , compiled:\") (map :provides sources)))\n     (load-sources repl-env sources opts)\n     sources)))\n\n(defn- load-dependencies\n  \"Compile and load the given `requires` and return the compiled sources.\"\n  ([repl-env requires]\n   (load-dependencies repl-env requires nil))\n  ([repl-env requires opts]\n   (doall (mapcat #(load-namespace repl-env % opts) (distinct requires)))))\n\n(defn ^File js-src->cljs-src\n  \"Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).\"\n  [f]\n  (let [f (io/file f)\n        dir (.getParentFile f)\n        base-name (string/replace (.getName f) \".js\" \"\")\n        cljsf (io/file dir (str base-name \".cljs\"))]\n    (if (.exists cljsf)\n      cljsf\n      (let [cljcf (io/file dir (str base-name \".cljc\"))]\n        (if (.exists cljcf)\n          cljcf)))))\n\n(defn read-source-map\n  \"Return the source map for the JavaScript source file.\"\n  [f]\n  (when-let [smf (util/file-or-resource (str f \".map\"))]\n    (let [ns (if (= f \"cljs/core.aot.js\")\n               'cljs.core\n               (some-> (js-src->cljs-src f) ana/parse-ns :ns))]\n      (when ns\n        (as-> @env/*compiler* compiler-env\n          (let [t (util/last-modified smf)]\n            (if (or (and (= ns 'cljs.core)\n                         (nil? (get-in compiler-env [::source-maps ns])))\n                    (and (not= ns 'cljs.core)\n                         (> t (get-in compiler-env [::source-maps ns :last-modified] 0))))\n              (swap! env/*compiler* assoc-in [::source-maps ns]\n                {:last-modified t\n                 :source-map (sm/decode (json/read-str (slurp smf) :key-fn keyword))})\n              compiler-env))\n          (get-in compiler-env [::source-maps ns :source-map]))))))\n\n(defn ns-info\n  \"Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.\"\n  [f]\n  (let [f' (js-src->cljs-src f)]\n    (when (and f' (.exists f'))\n      (ana/parse-ns f'))))\n\n(defn- mapped-line-column-call\n  \"Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.\"\n  [source-map line column]\n  (let [default [line column nil]]\n    ;; source maps are 0 indexed for lines\n    (if-let [columns (get source-map (dec line))]\n      (vec\n        (map #(%1 %2)\n          [inc inc identity]\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; the last segment seems most accurate\n            (last\n              (or\n                (get columns (last (filter #(<= % (dec column)) (sort (keys columns)))))\n                (second (first columns))))\n            [:line :col :name])))\n      default)))\n\n(defn- mapped-frame\n  \"Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.\"\n  [{:keys [function file line column]} opts]\n  (let [no-source-file? (if-not file\n                          true\n                          (.startsWith file \"<\"))\n        rfile (when-not no-source-file?\n                (io/file (URL. (.toURL (io/file (util/output-directory opts))) file)))\n        [sm {:keys [ns source-file] :as ns-info}]\n        (when-not no-source-file?\n          ((juxt read-source-map ns-info) rfile))\n        [line' column' call] (if ns-info\n                               (mapped-line-column-call sm line column)\n                               [line column])\n        name' (when (and ns-info function)\n                function)\n        file' (if no-source-file?\n                file\n                (string/replace\n                  (.getCanonicalFile\n                    (if ns-info\n                      source-file\n                      (io/file rfile)))\n                  (str (System/getProperty \"user.dir\") File/separator) \"\"))\n        url (or (and ns-info (util/ns->source ns))\n                (and file (io/resource file)))]\n    (merge\n      {:function name'\n       :call     call\n       :file     (if no-source-file?\n                   (str \"<NO_SOURCE_FILE>\"\n                        (when file\n                          (str \" \" file)))\n                   (io/file file'))\n       :line     line'\n       :column   column'}\n      (when url\n        {:url url}))))\n\n(defn mapped-stacktrace\n  \"Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.\"\n  ([stacktrace] (mapped-stacktrace stacktrace nil))\n  ([stacktrace opts]\n   (vec\n     (let [mapped-frames (map (memoize #(mapped-frame % opts)) stacktrace)]\n       ;; take each non-nil :call and optionally merge it into :function one-level up\n       ;; to avoid replacing with local symbols, we only replace munged name if we can munge call symbol back to it\n       (map #(merge-with (fn [munged-fn-name unmunged-call-name]\n                           (if (= munged-fn-name (string/replace (cljs.compiler/munge unmunged-call-name) \".\" \"$\"))\n                             unmunged-call-name\n                             munged-fn-name)) %1 %2)\n         (map #(dissoc % :call) mapped-frames)\n         (concat (rest (map #(if (:call %)\n                              (hash-map :function (:call %))\n                              {})\n                         mapped-frames)) [{}]))))))\n\n(defn file-display\n  [file {:keys [output-dir temp-output-dir?]}]\n  (if temp-output-dir?\n    (let [canonicalize (fn [file] (.getCanonicalPath (io/file file)))\n          can-file (canonicalize file)\n          can-out (canonicalize output-dir)]\n      (if (.startsWith can-file can-out)\n        (subs can-file (inc (count can-out)))\n        (subs can-file (inc (.lastIndexOf can-file java.io.File/separator)))))\n    file))\n\n(defn print-mapped-stacktrace\n  \"Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.\"\n  ([stacktrace] (print-mapped-stacktrace stacktrace *repl-opts*))\n  ([stacktrace opts]\n   (doseq [{:keys [function file line column]}\n           (mapped-stacktrace stacktrace opts)]\n     (err-out\n       (println \"\\t\"\n         (str (when function (str function \" \"))\n           \"(\" (file-display file opts) (when line (str \":\" line)) (when column (str \":\" column)) \")\"))))))\n\n(comment\n  (def st (env/default-compiler-env))\n\n  (cljsc/build \"samples/hello/src\"\n    {:optimizations :none\n     :output-dir \"samples/hello/out\"\n     :output-to \"samples/hello/out/hello.js\"\n     :source-map true}\n    st)\n\n  (env/with-compiler-env st\n    (mapped-stacktrace\n      [{:file \"hello/core.js\"\n        :function \"first\"\n        :line 6\n        :column 0}]\n      {:output-dir \"samples/hello/out\"}))\n\n  (env/with-compiler-env st\n    (print-mapped-stacktrace\n      [{:file \"hello/core.js\"\n        :function \"first\"\n        :line 6\n        :column 0}]\n      {:output-dir \"samples/hello/out\"}))\n\n  ;; URL example\n\n  (cljsc/build \"samples/hello/src\"\n    {:optimizations :none\n     :output-dir \"out\"\n     :output-to \"out/hello.js\"\n     :source-map true}\n    st)\n\n  (env/with-compiler-env st\n    (mapped-stacktrace\n      [{:file \"cljs/core.js\"\n        :function \"first\"\n        :line 2\n        :column 1}]\n      {:output-dir \"out\"}))\n\n  (env/with-compiler-env st\n    (print-mapped-stacktrace\n      [{:file \"cljs/core.js\"\n        :function \"first\"\n        :line 2\n        :column 1}]\n      {:output-dir \"out\"}))\n  )\n\n(defn- display-error\n  ([repl-env ret form opts]\n   (display-error repl-env ret form (constantly nil) opts))\n  ([repl-env ret form f opts]\n   (err-out\n     (f)\n     (when-let [value (:value ret)]\n       (println value))\n     (when-let [st (:stacktrace ret)]\n       (if (and (true? (:source-map opts))\n             (satisfies? IParseStacktrace repl-env))\n         (let [cst (try\n                     (-parse-stacktrace repl-env st ret opts)\n                     (catch Throwable e\n                       (when (:repl-verbose opts)\n                         (println \"Failed to canonicalize stacktrace\")\n                         (println (Throwables/getStackTraceAsString e)))))]\n           (if (vector? cst)\n             (if (satisfies? IPrintStacktrace repl-env)\n               (-print-stacktrace repl-env cst ret opts)\n               (print-mapped-stacktrace cst opts))\n             (println st)))\n         (println st))))))\n\n(defn- bytes-to-base64-str\n  \"Convert a byte array into a base-64 encoded string.\"\n  [^bytes bytes]\n  (.encodeToString (Base64/getEncoder) bytes))\n\n(defn evaluate-form\n  \"Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.\"\n  ([repl-env env filename form]\n    (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n    (evaluate-form repl-env env filename form wrap *repl-opts*))\n  ([repl-env env filename form wrap opts]\n   (binding [ana/*cljs-file* filename]\n     (let [env (merge env\n                 {:root-source-info {:source-type :fragment\n                                     :source-form form}\n                  :repl-env repl-env})\n           def-emits-var (:def-emits-var opts)\n           backup-comp @env/*compiler*\n           ->ast (fn [form]\n                   (binding [ana/*analyze-deps* false]\n                     (ana/analyze (assoc env :def-emits-var def-emits-var)\n                       (wrap form) nil opts)))\n           ast (->ast form)\n           ast (if-not (#{:ns :ns*} (:op ast))\n                 ast\n                 (let [ijs (ana/parse-ns [form])]\n                   (cljsc/handle-js-modules opts\n                     (deps/dependency-order\n                       (cljsc/add-dependency-sources [ijs] opts))\n                     env/*compiler*)\n                   (binding [ana/*check-alias-dupes* false]\n                     (ana/no-warn (->ast form))))) ;; need new AST after we know what the modules are - David\n           wrap-js\n           ;; TODO: check opts as well - David\n           (if (:source-map repl-env)\n             (binding [comp/*source-map-data*\n                       (atom {:source-map (sorted-map)\n                              :gen-line 0})\n                       comp/*source-map-data-gen-col* (AtomicLong.)]\n               (let [js (comp/emit-str ast)\n                     t (System/currentTimeMillis)]\n                 (str js\n                   \"\\n//# sourceURL=repl-\" t \".js\"\n                   \"\\n//# sourceMappingURL=data:application/json;base64,\"\n                   (bytes-to-base64-str\n                     (.getBytes\n                       (sm/encode\n                         {(str \"repl-\" t \".cljs\")\n                          (:source-map @comp/*source-map-data*)}\n                         {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                          :file (str \"repl-\" t \".js\")\n                          :sources-content\n                          [(or (:source (meta form))\n                             ;; handle strings / primitives without metadata\n                             (with-out-str (pr form)))]})\n                       \"UTF-8\")))))\n             (comp/emit-str ast))]\n       ;; NOTE: means macros which expand to ns aren't supported for now\n       ;; when eval'ing individual forms at the REPL - David\n       (when (#{:ns :ns*} (:op ast))\n         (let [ast (try\n                     (ana/no-warn (ana/analyze env form nil opts))\n                     (catch #?(:clj Exception :cljs js/Error) e\n                         (reset! env/*compiler* backup-comp)\n                         (throw e)))\n               sources (load-dependencies repl-env\n                         (into (vals (:requires ast))\n                               (distinct (vals (:uses ast))))\n                         opts)]\n           (load-cljs-loader repl-env sources opts)))\n       (when *cljs-verbose*\n         (err-out (println wrap-js)))\n       (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n         (case (:status ret)\n           :error (throw\n                    (ex-info (:value ret)\n                      {:type :js-eval-error\n                       :error ret\n                       :repl-env repl-env\n                       :form form}))\n           :exception (throw\n                        (ex-info (:value ret)\n                          {:type :js-eval-exception\n                           :error ret\n                           :repl-env repl-env\n                           :form form\n                           :js wrap-js}))\n           :success (:value ret)))))))\n\n(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (with-open [rdr (io/reader res)]\n      (doseq [form (ana/forms-seq* rdr filename)]\n        (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n          (evaluate-form repl-env env filename form))))))\n\n(defn load-file\n  ([repl-env f] (load-file repl-env f *repl-opts*))\n  ([repl-env f opts]\n    (if (:output-dir opts)\n      (let [src (cond\n                  (util/url? f) f\n                  (.exists (io/file f)) (io/file f)\n                  :else (io/resource f))\n            compiled (binding [ana/*reload-macros* true]\n                       (cljsc/compile src\n                         (assoc opts\n                           :output-file (cljsc/src-file->target-file src)\n                           :force true\n                           :mode :interactive)))]\n        ;; copy over the original source file if source maps enabled\n        (when-let [ns (and (:source-map opts) (first (:provides compiled)))]\n          (spit\n            (io/file (io/file (util/output-directory opts))\n              (util/ns->relpath ns (util/ext (:source-url compiled))))\n            (slurp src)))\n        ;; need to load dependencies first\n        (let [sources (load-dependencies repl-env (:requires compiled) opts)]\n          (load-cljs-loader repl-env (conj sources compiled) opts))\n        (-evaluate repl-env f 1 (cljsc/add-dep-string opts compiled))\n        (-evaluate repl-env f 1\n          (cljsc/src-file->goog-require src\n            {:wrap true :reload true :macros-ns (:macros-ns compiled)})))\n      (binding [ana/*cljs-ns* ana/*cljs-ns*]\n        (let [res (if (= File/separatorChar (first f)) f (io/resource f))]\n          (assert res (str \"Can't find \" f \" in classpath\"))\n          (load-stream repl-env f res))))))\n\n(defn- root-resource\n  \"Returns the root directory path for a lib\"\n  {:tag String}\n  [lib]\n  (str \\/\n       (.. (name lib)\n           (replace \\- \\_)\n           (replace \\. \\/))))\n\n(defn- root-directory\n  \"Returns the root resource path for a lib\"\n  [lib]\n  (let [d (root-resource lib)]\n    (subs d 0 (.lastIndexOf d \"/\"))))\n\n(defn- load-path->cp-path\n  [path]\n  (let [src (if (= File/separatorChar (first path))\n              path\n              (str (root-directory ana/*cljs-ns*) \\/ path))\n        src (.substring src 1)]\n    (or (io/resource (str src \".cljs\"))\n        (io/resource (str src \".cljc\")))))\n\n(defn- wrap-fn [form]\n  (cond\n    (and (seq? form)\n         (#{'ns 'require 'require-macros\n            'use 'use-macros 'import 'refer-clojure} (first form)))\n    identity\n\n    ('#{*1 *2 *3 *e} form) (fn [x] `(cljs.core.pr-str ~x))\n    :else\n    (fn [x]\n      `(try\n         (cljs.core.pr-str\n           (let [ret# ~x]\n             (set! *3 *2)\n             (set! *2 *1)\n             (set! *1 ret#)\n             ret#))\n         (catch :default e#\n           (set! *e e#)\n           (throw e#))))))\n\n(defn- init-wrap-fn [form]\n  (cond\n    (and (seq? form)\n      (#{'ns 'require 'require-macros\n         'use 'use-macros 'import 'refer-clojure} (first form)))\n    identity\n\n    ('#{*1 *2 *3 *e} form) (fn [x] `(cljs.core.pr-str ~x))\n    :else\n    (fn [x]\n      `(cljs.core.pr-str ~x))))\n\n(defn eval-cljs\n  \"Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.\"\n  ([repl-env env form]\n    (eval-cljs repl-env env form *repl-opts*))\n  ([repl-env env form opts]\n   (evaluate-form repl-env\n     (assoc env :ns (ana/get-namespace ana/*cljs-ns*))\n     \"<cljs repl>\"\n     form\n     ;; the pluggability of :wrap is needed for older JS runtimes like Rhino\n     ;; where catching the error will swallow the original trace\n     ((or (:wrap opts) wrap-fn) form)\n     opts)))\n\n(defn decorate-specs [specs]\n  (if-let [k (some #{:reload :reload-all} specs)]\n    (->> specs (remove #{k}) (map #(vary-meta % assoc :reload k)))\n    specs))\n\n(comment\n  (ana/canonicalize-specs\n    '['foo.bar '[bar.core :as bar]])\n\n  (ana/canonicalize-specs\n    '['foo.bar '[bar.core :as bar] :reload])\n\n  (map meta\n    (decorate-specs\n      (ana/canonicalize-specs\n        '['foo.bar '[bar.core :as bar] :reload])))\n  )\n\n;; Special REPL fns, these provide compatiblity with Clojure functions\n;; that are not possible to reproduce given ClojureScript's compilation model\n;; All functions should have the following signature\n;;\n;; (fn self\n;;   ([repl-env env form]\n;;     (self repl-env env form))\n;;   ([repl-env env form opts]\n;;     ..))\n;;\n;; repl-env - IJavaScriptEnv instance\n;; env      - a cljs.analyzer environment, *not* cljs.env environment\n;; form     - complete form entered at the repl\n;; opts     - REPL options, essentially augmented cljs.closure/build options\n\n(defn- wrap-self\n  \"Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.\"\n  [f]\n  (fn g\n    ([a b c]\n     (g a b c nil))\n    ([a b c d]\n     (let [backup-comp @env/*compiler*]\n       (try\n         (apply f [a b c d])\n         (catch #?(:clj Exception :cljs js/Error) e ;;Exception\n           (reset! env/*compiler* backup-comp)\n           (throw e)))))))\n\n(defn- wrap-special-fns\n  [wfn fns]\n  \"Wrap wfn around all (fn) values in fns hashmap.\"\n  (into {} (for [[k v] fns] [k (wfn v)])))\n\n(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))\n        in-ns-fn\n        (fn self\n          ([repl-env env form]\n           (self repl-env env form nil))\n          ([repl-env env [_ [quote ns-name] :as form] _]\n            ;; guard against craziness like '5 which wreaks havoc\n           (when-not (and (= quote 'quote) (symbol? ns-name))\n             (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n           (when-not (ana/get-namespace ns-name)\n             (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n             (-evaluate repl-env \"<cljs repl>\" 1\n               (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n           (set! ana/*cljs-ns* ns-name)))\n        load-fn\n        (fn self\n          ([repl-env env form]\n           (self env repl-env form nil))\n          ([repl-env env [_ & paths :as form] opts]\n           (let [cp-paths (map load-path->cp-path paths)]\n             (run! #(load-file repl-env % opts) cp-paths))))]\n    (wrap-special-fns wrap-self\n     {'in-ns in-ns-fn\n      'clojure.core/in-ns in-ns-fn\n      'load-file load-file-fn\n      'clojure.core/load-file load-file-fn\n      'load-namespace\n      (fn self\n        ([repl-env env form]\n         (self env repl-env form nil))\n        ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))\n      'load load-fn\n      'clojure.core/load load-fn})))\n\n(defn analyze-source\n  \"Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.\"\n  ([src-dir] (analyze-source src-dir nil))\n  ([src-dir opts]\n    (if-let [src-dir (and (not (empty? src-dir))\n                       (File. src-dir))]\n      (doseq [file (comp/cljs-files-in src-dir)]\n        (ana/analyze-file (str \"file://\" (.getAbsolutePath file)) opts)))))\n\n(defn repl-title []\n  (when-not (util/synthetic-version?)\n    (println \"ClojureScript\" (util/clojurescript-version))))\n\n(defn repl-quit-prompt []\n  (println \"To quit, type:\" :cljs/quit))\n\n(defn repl-prompt []\n  (print (str ana/*cljs-ns* \"=> \")))\n\n(defn demunge\n  \"Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.\"\n  [fn-name]\n  (clojure.lang.Compiler/demunge fn-name))\n\n(def ^:private core-namespaces\n  #{\"clojure.core\" \"clojure.core.reducers\" \"clojure.core.protocols\" \"clojure.data\" \"clojure.datafy\"\n    \"clojure.edn\" \"clojure.instant\" \"clojure.java.io\" \"clojure.main\" \"clojure.pprint\" \"clojure.reflect\"\n    \"clojure.repl\" \"clojure.set\" \"clojure.spec.alpha\" \"clojure.spec.gen.alpha\" \"clojure.spec.test.alpha\"\n    \"clojure.string\" \"clojure.template\" \"clojure.uuid\" \"clojure.walk\" \"clojure.xml\" \"clojure.zip\"})\n\n(defn- core-class?\n  [^String class-name]\n  (and (not (nil? class-name))\n       (or (.startsWith class-name \"clojure.lang.\")\n           (contains? core-namespaces (second (re-find #\"^([^$]+)\\$\" class-name))))))\n\n(defn- file-name\n  \"Helper to get just the file name part of a path or nil\"\n  [^String full-path]\n  (when full-path\n    (try\n      (.getName (java.io.File. full-path))\n      (catch Throwable t))))\n\n(defn- java-loc->source\n  \"Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.\"\n  [clazz method]\n  (if (#{'invoke 'invokeStatic} method)\n    (let [degen #(.replaceAll ^String % \"--.*$\" \"\")\n          [ns-name fn-name & nested] (->> (str clazz) (.split #\"\\$\") (map demunge) (map degen))]\n      (symbol ns-name (String/join \"$\" ^\"[Ljava.lang.String;\" (into-array String (cons fn-name nested)))))\n    (symbol (name clazz) (name method))))\n\n(defn ex-triage\n  \"Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error\"\n  [datafied-throwable]\n  (let [{:keys [via trace phase] :or {phase :execution}} datafied-throwable\n        {:keys [type message data]} (last via)\n        {:keys [:clojure.spec.alpha/problems :clojure.spec.alpha/fn :clojure.spec.test.alpha/caller]} data\n        {:keys [:clojure.error/source] :as top-data} (:data (first via))]\n    (assoc\n     (case phase\n       :read-source\n       (let [{:keys [:clojure.error/line :clojure.error/column]} data]\n         (cond-> (merge (-> via second :data) top-data)\n           source (assoc :clojure.error/source (file-name source))\n           (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} source) (dissoc :clojure.error/source)\n           message (assoc :clojure.error/cause message)))\n\n       (:compile-syntax-check :compilation :macro-syntax-check :macroexpansion)\n       (cond-> top-data\n         source (assoc :clojure.error/source (file-name source))\n         (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} source) (dissoc :clojure.error/source)\n         type (assoc :clojure.error/class type)\n         message (assoc :clojure.error/cause message)\n         problems (assoc :clojure.error/spec data))\n\n       (:read-eval-result :print-eval-result)\n       (let [[source method file line] (-> trace first)]\n         (cond-> top-data\n           line (assoc :clojure.error/line line)\n           file (assoc :clojure.error/source file)\n           (and source method) (assoc :clojure.error/symbol (java-loc->source source method))\n           type (assoc :clojure.error/class type)\n           message (assoc :clojure.error/cause message)))\n\n       :execution\n       (let [[source method file line] (->> trace (drop-while #(core-class? (name (first %)))) first)\n             file (first (remove #(or (nil? %) (#{\"NO_SOURCE_FILE\" \"NO_SOURCE_PATH\"} %)) [(:file caller) file]))\n             err-line (or (:line caller) line)]\n         (cond-> {:clojure.error/class type}\n           err-line (assoc :clojure.error/line err-line)\n           message (assoc :clojure.error/cause message)\n           (or fn (and source method)) (assoc :clojure.error/symbol (or fn (java-loc->source source method)))\n           file (assoc :clojure.error/source file)\n           problems (assoc :clojure.error/spec data))))\n      :clojure.error/phase phase)))\n\n(defn ex-str\n  \"Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.\"\n  [{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column\n           :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec]\n    :as triage-data}]\n  (let [spec-loaded? (some? (resolve 'clojure.spec.alpha/explain-out))\n        loc (str (or source \"REPL\") \":\" (or line 1) (if column (str \":\" column) \"\"))\n        class-name (name (or class \"\"))\n        simple-class (if class (or (first (re-find #\"([^.])++$\" class-name)) class-name))\n        cause-type (if (contains? #{\"Exception\" \"RuntimeException\"} simple-class)\n                     \"\" ;; omit, not useful\n                     (str \" (\" simple-class \")\"))]\n    (case phase\n      :read-source\n      (format \"Syntax error reading source at (%s).%n%s%n\" loc cause)\n\n      :macro-syntax-check\n      (format \"Syntax error macroexpanding %sat (%s).%n%s\"\n        (if symbol (str symbol \" \") \"\")\n        loc\n        (if (and spec spec-loaded?)\n          (with-out-str\n            ((resolve 'clojure.spec.alpha/explain-out)\n             (if (= @(resolve 'clojure.spec.alpha/*explain-out*) @(resolve 'clojure.spec.alpha/explain-printer))\n                (update spec :clojure.spec.alpha/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec)))\n          (format \"%s%n\" cause)))\n\n      :macroexpansion\n      (format \"Unexpected error%s macroexpanding %sat (%s).%n%s%n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :compile-syntax-check\n      (format \"Syntax error%s compiling %sat (%s).%n%s%n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :compilation\n      (format \"Unexpected error%s compiling %sat (%s).%n%s%n\"\n        cause-type\n        (if symbol (str symbol \" \") \"\")\n        loc\n        cause)\n\n      :read-eval-result\n      (format \"Error reading eval result%s at %s (%s).%n%s%n\" cause-type symbol loc cause)\n\n      :print-eval-result\n      (format \"Error printing return value%s at %s (%s).%n%s%n\" cause-type symbol loc cause)\n\n      :execution\n      (if (and spec spec-loaded?)\n        (format \"Execution error - invalid arguments to %s at (%s).%n%s\"\n          symbol\n          loc\n          (with-out-str\n            ((resolve 'clojure.spec.alpha/explain-out)\n              (if (= @(resolve 'clojure.spec.alpha/*explain-out*) @(resolve 'clojure.spec.alpha/explain-printer))\n                (update spec :clojure.spec.alpha/problems\n                  (fn [probs] (map #(dissoc % :in) probs)))\n                spec))))\n        (format \"Execution error%s at %s(%s).%n%s%n\"\n          cause-type\n          (if symbol (str symbol \" \") \"\")\n          loc\n          cause)))))\n\n(defn repl-caught [e repl-env opts]\n  (if (and (instance? IExceptionInfo e)\n           (#{:js-eval-error :js-eval-exception} (:type (ex-data e))))\n    (let [{:keys [type repl-env error form js]} (ex-data e)]\n      (case type\n        :js-eval-error\n        (display-error repl-env error form opts)\n\n        :js-eval-exception\n        (display-error repl-env error form\n          (if (:repl-verbose opts)\n            #(prn \"Error evaluating:\" form :as js)\n            (constantly nil))\n          opts)))\n    (binding [*out* *err*]\n      (print (-> e Throwable->map ex-triage ex-str))\n      (flush))))\n\n(defn repl-nil? [x]\n  (boolean (#{\"\" \"nil\"} x)))\n\n(defn run-inits [renv inits]\n  (doseq [{:keys [type] :as init} inits]\n    (case type\n      :init-forms\n      (doseq [form (:forms init)]\n        (eval-cljs renv (ana/empty-env) form))\n      :eval-forms\n      (binding [*repl-opts* (merge *repl-opts* {:def-emits-var true :wrap init-wrap-fn})]\n        (doseq [form (:forms init)]\n          (let [value (eval-cljs renv (ana/empty-env) form *repl-opts*)]\n            (when-not (repl-nil? value)\n              (println value)))))\n      :init-script\n      (let [script (:script init)]\n        (load-stream renv (util/get-name script) script)))))\n\n(defn maybe-install-npm-deps [opts]\n  (when (:install-deps opts)\n    (cljsc/check-npm-deps opts)\n    (swap! env/*compiler* update-in [:npm-deps-installed?]\n      (fn [installed?]\n        (if-not installed?\n          (cljsc/maybe-install-node-deps! opts)\n          installed?)))))\n\n(defn initial-prompt [quit-prompt prompt]\n  (quit-prompt)\n  (prompt)\n  (flush))\n\n(defn repl*\n  [repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader\n                    print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt?\n                    compiler-env bind-err]\n             :or {need-prompt #(if (readers/indexing-reader? *in*)\n                                (== (readers/get-column-number *in*) 1)\n                                (identity true))\n                  fast-initial-prompt? false\n                  quit-prompt repl-title\n                  prompt repl-prompt\n                  flush flush\n                  read repl-read\n                  eval eval-cljs\n                  print println\n                  caught repl-caught\n                  reader #(readers/source-logging-push-back-reader\n                           *in*\n                           1 \"<NO_SOURCE_FILE>\")\n                  print-no-newline print\n                  source-map-inline true\n                  repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]]\n                                  [cljs.pprint :refer [pprint] :refer-macros [pp]]]\n                  bind-err true}\n             :as opts}]\n  (doseq [[unknown-opt suggested-opt] (util/unknown-opts (set (keys opts)) (set/union known-repl-opts cljsc/known-opts))]\n    (when suggested-opt\n      (println (str \"WARNING: Unknown option '\" unknown-opt \"'. Did you mean '\" suggested-opt \"'?\"))))\n  (when fast-initial-prompt?\n    (initial-prompt quit-prompt prompt))\n  (let [repl-opts (-repl-options repl-env)\n        repl-requires (into repl-requires (:repl-requires repl-opts))\n        {:keys [analyze-path repl-verbose warn-on-undeclared special-fns\n                checked-arrays static-fns fn-invoke-direct]\n         :as opts\n         :or   {warn-on-undeclared true}}\n        (merge\n          {:def-emits-var true}\n          (cljsc/add-implicit-options\n            (merge-with (fn [a b] (if (nil? b) a b))\n              repl-opts\n              opts\n              {:prompt prompt\n               :need-prompt need-prompt\n               :flush flush\n               :read read\n               :print print\n               :caught caught\n               :reader reader\n               :print-no-newline print-no-newline\n               :source-map-inline source-map-inline})))\n        done? (atom false)]\n    (env/with-compiler-env (or compiler-env env/*compiler* (env/default-compiler-env opts))\n     (when (:source-map opts)\n       (.start (Thread. (bound-fn [] (read-source-map \"cljs/core.aot.js\")))))\n     (binding [*repl-env* repl-env\n               ana/*unchecked-if* false\n               ana/*unchecked-arrays* false\n               *err* (if bind-err\n                       (cond-> *out*\n                         (not (instance? PrintWriter *out*)) (PrintWriter.))\n                       *err*)\n               ana/*cljs-ns* ana/*cljs-ns*\n               *cljs-verbose* repl-verbose\n               ana/*cljs-warnings*\n               (let [warnings (opts :warnings)]\n                 (merge\n                   ana/*cljs-warnings*\n                   (if (or (true? warnings)\n                           (false? warnings))\n                     (zipmap (keys ana/*cljs-warnings*) (repeat warnings))\n                     warnings)\n                   (zipmap\n                     [:unprovided :undeclared-var\n                      :undeclared-ns :undeclared-ns-form]\n                     (repeat (if (false? warnings)\n                               false\n                               warn-on-undeclared)))\n                   {:infer-warning false}))\n               ana/*checked-arrays* checked-arrays\n               ana/*cljs-static-fns* static-fns\n               ana/*fn-invoke-direct* (and static-fns fn-invoke-direct)\n               *repl-opts* opts]\n       (try\n         (let [env {:context :expr :locals {}}\n               special-fns (merge default-special-fns special-fns)\n               is-special-fn? (set (keys special-fns))\n               request-prompt (Object.)\n               request-exit (Object.)\n               opts (comp/with-core-cljs opts\n                      (fn []\n                        (if-let [merge-opts (:merge-opts (-setup repl-env opts))]\n                          (merge opts merge-opts)\n                          opts)))\n               init (do\n                      (evaluate-form repl-env env \"<cljs repl>\"\n                        `(~'set! ~'cljs.core/*print-namespace-maps* true)\n                        identity opts)\n                      (or init\n                        #(evaluate-form repl-env env \"<cljs repl>\"\n                           (with-meta\n                             `(~'ns ~'cljs.user\n                                (:require ~@repl-requires))\n                             {:line 1 :column 1})\n                           identity opts)))\n               maybe-load-user-file #(when-let [user-resource (util/ns->source 'user)]\n                                       (when (= \"file\" (.getProtocol ^URL user-resource))\n                                         (load-file repl-env (io/file user-resource) opts)))\n               read-eval-print\n               (fn []\n                 (let [input (binding [*ns* (create-ns ana/*cljs-ns*)\n                                       reader/resolve-symbol ana/resolve-symbol\n                                       reader/*data-readers* tags/*cljs-data-readers*\n                                       reader/*alias-map*\n                                       (apply merge\n                                         ((juxt :requires :require-macros)\n                                           (ana/get-namespace ana/*cljs-ns*)))]\n                               (try\n                                 (read request-prompt request-exit)\n                                 (catch Throwable e\n                                   (throw (ex-info nil {:clojure.error/phase :read-source} e)))))]\n                   (or ({request-exit request-exit\n                         :cljs/quit request-exit\n                         request-prompt request-prompt} input)\n                     (if (and (seq? input) (is-special-fn? (first input)))\n                       (do\n                         ((get special-fns (first input)) repl-env env input opts)\n                         (print nil))\n                       (let [value (eval repl-env env input opts)]\n                         (try\n                           (print value)\n                           (catch Throwable e\n                             (throw (ex-info nil {:clojure.error/phase :print-eval-result} e)))))))))]\n           (maybe-install-npm-deps opts)\n           (comp/with-core-cljs opts\n             (fn []\n               (binding [*repl-opts* opts]\n                 (try\n                   (when analyze-path\n                     (if (vector? analyze-path)\n                       (run! #(analyze-source % opts) analyze-path)\n                       (analyze-source analyze-path opts)))\n                   (init)\n                   (run-inits repl-env inits)\n                   (maybe-load-user-file)\n                   (catch Throwable e\n                     (caught e repl-env opts)))\n                 (when-let [src (:watch opts)]\n                   (.start\n                     (Thread.\n                       ((ns-resolve 'clojure.core 'binding-conveyor-fn)\n                         (fn []\n                           (let [log-file (io/file (util/output-directory opts) \"watch.log\")]\n                             (err-out (println \"Watch compilation log available at:\" (str log-file)))\n                             (try\n                               (let [log-out (FileWriter. log-file)]\n                                 (binding [*err* log-out\n                                           *out* log-out]\n                                   (cljsc/watch src (dissoc opts :watch)\n                                     env/*compiler* done?)))\n                               (catch Throwable e\n                                 (caught e repl-env opts)))))))))\n                 ;; let any setup async messages flush\n                 (Thread/sleep 50)\n                 (binding [*in* (if (true? (:source-map-inline opts))\n                                  *in*\n                                  (reader))]\n                   (when-not fast-initial-prompt?\n                     (initial-prompt quit-prompt prompt))\n                   (loop []\n                     (when-not\n                       (try\n                         (identical? (read-eval-print) request-exit)\n                         (catch Throwable e\n                           (caught e repl-env opts)\n                           nil))\n                       (when (need-prompt)\n                         (prompt)\n                         (flush))\n                       (recur))))))))\n         (finally\n           (reset! done? true)\n           (-tear-down repl-env)))))))\n\n(defn repl\n  \"Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\\\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true\"\n  [repl-env & opts]\n  (assert (even? (count opts))\n    \"Arguments after repl-env must be interleaved key value pairs\")\n  (repl* repl-env (apply hash-map opts)))\n\n;; =============================================================================\n;; ClojureScript REPL interaction support\n\n(def special-doc-map\n  '{. {:forms [(.instanceMethod instance args*)\n               (.-instanceField instance)]\n       :doc \"The instance member form works for methods and fields.\n  They all expand into calls to the dot operator at macroexpansion time.\"}\n    ns {:forms [(name docstring? attr-map? references*)]\n        :doc \"You must currently use the ns form only with the following caveats\n\n    * You must use the :only form of :use\n    * :require supports :as, :refer, and :rename\n      - all options can be skipped\n      - in this case a symbol can be used as a libspec directly\n        - that is, (:require lib.foo) and (:require [lib.foo]) are both\n          supported and mean the same thing\n      - :rename specifies a map from referred var names to different\n        symbols (and can be used to prevent clashes)\n      - prefix lists are not supported\n    * The only options for :refer-clojure are :exclude and :rename\n    * :import is available for importing Google Closure classes\n      - ClojureScript types and records should be brought in with :use\n        or :require :refer, not :import ed\n    * Macros must be defined in a different compilation stage than the one\n      from where they are consumed. One way to achieve this is to define\n      them in one namespace and use them from another. They are referenced\n      via the :require-macros / :use-macros options to ns\n      - :require-macros and :use-macros support the same forms that\n        :require and :use do\n\n  Implicit macro loading: If a namespace is required or used, and that\n  namespace itself requires or uses macros from its own namespace, then\n  the macros will be implicitly required or used using the same\n  specifications. Furthermore, in this case, macro vars may be included\n  in a :refer or :only spec. This oftentimes leads to simplified library\n  usage, such that the consuming namespace need not be concerned about\n  explicitly distinguishing between whether certain vars are functions\n  or macros. For example:\n\n  (ns testme.core (:require [cljs.test :as test :refer [test-var deftest]]))\n\n  will result in test/is resolving properly, along with the test-var\n  function and the deftest macro being available unqualified.\n\n  Inline macro specification: As a convenience, :require can be given\n  either :include-macros true or :refer-macros [syms...]. Both desugar\n  into forms which explicitly load the matching Clojure file containing\n  macros. (This works independently of whether the namespace being\n  required internally requires or uses its own macros.) For example:\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n            [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\n  is sugar for\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn]]\n            [woz.core :as woz :refer [woz-fn]])\n  (:require-macros [foo.core :as foo]\n                   [woz.core :as woz :refer [app jx]]))\n\n  Auto-aliasing clojure namespaces: If a non-existing clojure.* namespace\n  is required or used and a matching cljs.* namespace exists, the cljs.*\n  namespace will be loaded and an alias will be automatically established\n  from the clojure.* namespace to the cljs.* namespace. For example:\n\n  (ns testme.core (:require [clojure.test]))\n\n  will be automatically converted to\n\n  (ns testme.core (:require [cljs.test :as clojure.test]))\"}\n    def {:forms [(def symbol doc-string? init?)]\n         :doc \"Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected.\"}\n    do {:forms [(do exprs*)]\n        :doc \"Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil.\"}\n    if {:forms [(if test then else?)]\n        :doc \"Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil.\"}\n    new {:forms [(Constructor. args*) (new Constructor args*)]\n         :url \"java_interop#new\"\n         :doc \"The args, if any, are evaluated from left to right, and\n  passed to the JavaScript constructor. The constructed object is\n  returned.\"}\n    quote {:forms [(quote form)]\n           :doc \"Yields the unevaluated form.\"}\n    recur {:forms [(recur exprs*)]\n           :doc \"Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method.\"}\n    set! {:forms[(set! var-symbol expr)\n                 (set! (.- instance-expr instanceFieldName-symbol) expr)]\n          :url \"vars#set\"\n          :doc \"Used to set vars and JavaScript object fields\"}\n    throw {:forms [(throw expr)]\n           :doc \"The expr is evaluated and thrown.\"}\n    try {:forms [(try expr* catch-clause* finally-clause?)]\n         :doc \"catch-clause => (catch classname name expr*)\n  finally-clause => (finally expr*)\n  Catches and handles JavaScript exceptions.\"}\n    var {:forms [(var symbol)]\n         :doc \"The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x).\"}})\n\n(defn- special-doc [name-symbol]\n  (assoc (or (special-doc-map name-symbol) (meta (resolve name-symbol)))\n    :name name-symbol\n    :special-form true))\n\n(def repl-special-doc-map\n  '{in-ns {:arglists ([name])\n           :doc \"Sets *cljs-ns* to the namespace named by the symbol, creating it if needed.\"}\n    load-file {:arglists ([name])\n               :doc \"Sequentially read and evaluate the set of forms contained in the file.\"}\n    load {:arglists ([& paths])\n               :doc \"Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.\"}})\n\n(defn- repl-special-doc [name-symbol]\n  (assoc (repl-special-doc-map name-symbol)\n    :name name-symbol\n    :repl-special-function true))\n\n(defmacro doc\n  \"Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword\"\n  [name]\n  `(print\n     (binding [cljs.core/*print-newline* true]\n       (with-out-str\n         ~(if-let [special-name ('{& fn catch try finally try} name)]\n            `(doc ~special-name)\n            (cond\n              (special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(special-doc name)))\n\n              (repl-special-doc-map name)\n              `(cljs.repl/print-doc (quote ~(repl-special-doc name)))\n\n              (keyword? name)\n              `(cljs.repl/print-doc {:spec ~name :doc (cljs.spec.alpha/describe ~name)})\n\n              (ana-api/find-ns name)\n              `(cljs.repl/print-doc\n                 (quote ~(select-keys (ana-api/find-ns name) [:name :doc])))\n\n              (ana-api/resolve &env name)\n              `(cljs.repl/print-doc\n                 (quote ~(let [var (ana-api/resolve &env name)\n                               m (select-keys var\n                                   [:ns :name :doc :forms :arglists :macro :url])]\n                           (cond-> (update-in m [:name] clojure.core/name)\n                             (:protocol-symbol var)\n                             (assoc :protocol true\n                                    :methods\n                                    (->> (get-in var [:protocol-info :methods])\n                                      (map (fn [[fname sigs]]\n                                             [fname {:doc (:doc\n                                                            (ana-api/resolve &env\n                                                              (symbol (str (:ns var)) (str fname))))\n                                                     :arglists (seq sigs)}]))\n                                      (into {})))))))))))))\n\n(defmacro find-doc\n  \"Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern\"\n  [re-string-or-pattern]\n  (let [re (re-pattern re-string-or-pattern)\n        ms (concat\n             (mapcat\n               (fn [ns]\n                 (map\n                   (fn [m]\n                     (update-in (select-keys m [:ns :name :doc :forms :arglists :macro :url])\n                       [:name] #(if-not (nil? %) (clojure.core/name %) %)))\n                   (sort-by :name (vals (ana-api/ns-interns ns)))))\n               (ana-api/all-ns))\n             (map #(select-keys (ana-api/find-ns %) [:name :doc]) (ana-api/all-ns))\n             (map special-doc (keys special-doc-map)))\n        ms (for [m ms\n                 :when (and (:doc m)\n                            (or (re-find (re-matcher re (:doc m)))\n                                (re-find (re-matcher re (str (:name m))))))]\n             m)]\n    `(doseq [m# (quote ~ms)]\n       (cljs.repl/print-doc m#))))\n\n(defn source-fn\n  \"Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)\"\n  [env x]\n  (when-let [v (ana-api/resolve env x)]\n    (when-let [filepath (:file v)]\n      (let [f (io/file filepath)\n            f (if (.exists f)\n                f\n                (io/resource filepath))]\n        (when f\n          (with-open [pbr (PushbackReader. (io/reader f))]\n            (let [rdr (readers/source-logging-push-back-reader pbr)]\n              (dotimes [_ (dec (:line v))] (readers/read-line rdr))\n              (binding [reader/*alias-map*    identity\n                        reader/*data-readers* tags/*cljs-data-readers*]\n                (-> (reader/read {:read-cond :allow :features #{:cljs}} rdr)\n                  meta :source)))))))))\n\n(comment\n  (def cenv (env/default-compiler-env))\n  (def aenv (assoc-in (ana/empty-env) [:ns :name] 'cljs.user))\n\n  (binding [ana/*cljs-ns* 'cljs.user]\n    (env/with-compiler-env cenv\n      (comp/with-core-cljs {}\n        (fn []\n          (source-fn aenv 'cljs.core/first)))))\n  )\n\n(defmacro source\n  \"Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)\"\n  [n]\n  `(println ~(or (source-fn &env n) (str \"Source not found\"))))\n\n(defn- named-publics-vars\n  \"Gets the public vars in a namespace that are not anonymous.\"\n  [ns]\n  (->> (ana-api/ns-publics ns)\n       (remove (comp :anonymous val))\n       (map key)))\n\n(defmacro apropos\n  \"Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.\"\n  [str-or-pattern]\n  (let [matches? (if (instance? Pattern str-or-pattern)\n                   #(re-find str-or-pattern (str %))\n                   #(.contains (str %) (str str-or-pattern)))]\n    `(quote\n       ~(sort\n          (mapcat\n            (fn [ns]\n              (let [ns-name (str ns)]\n                (map #(symbol ns-name (str %))\n                  (filter matches? (named-publics-vars ns)))))\n            (ana-api/all-ns))))))\n\n(defn- resolve-ns\n  \"Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.\"\n  [ns-sym]\n  (or (get-in @env/*compiler* [::ana/namespaces ana/*cljs-ns* :requires ns-sym])\n      (get-in @env/*compiler* [::ana/namespaces ana/*cljs-ns* :require-macros ns-sym])\n      ns-sym))\n\n(defmacro dir\n  \"Prints a sorted directory of public vars in a namespace\"\n  [ns]\n  `(doseq [sym# (quote ~(sort (named-publics-vars (resolve-ns ns))))]\n     (println sym#)))\n\n(defmacro pst\n  ([] `(pst *e))\n  ([e]\n   (let [{:keys [repl-env] :as env} &env]\n     (when (and e repl-env)\n       (when-let [ret (if (satisfies? IGetError repl-env)\n                   (-get-error repl-env e env *repl-opts*)\n                   (edn/read-string\n                     (evaluate-form repl-env env \"<cljs repl>\"\n                       `(when ~e\n                          (pr-str\n                            {:value (str ~e)\n                             :stacktrace (.-stack ~e)})))))]\n         (display-error repl-env\n           (if (satisfies? IParseError repl-env)\n             (-parse-error repl-env ret *repl-opts*)\n             ret)\n           nil *repl-opts*))))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/string.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.string",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))\n\n(defn- seq-reverse\n  [coll]\n  (reduce conj () coll))\n\n(def ^:private re-surrogate-pair\n  (js/RegExp. \"([\\\\uD800-\\\\uDBFF])([\\\\uDC00-\\\\uDFFF])\" \"g\"))\n\n(defn reverse\n  \"Returns s with its characters reversed.\"\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))\n\n(defn- replace-all\n  [s re replacement]\n  (let [r (js/RegExp. (.-source re)\n                      (cond-> \"g\"\n                        (.-ignoreCase re) (str \"i\")\n                        (.-multiline re) (str \"m\")\n                        (.-unicode re) (str \"u\")))]\n    (.replace s r replacement)))\n\n(defn- replace-with\n  [f]\n  (fn [& args]\n    (let [matches (drop-last 2 args)]\n      (if (= (count matches) 1)\n        (f (first matches))\n        (f (vec matches))))))\n\n(defn replace\n  \"Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace \\\"Almost Pig Latin\\\" #\\\"\\\\b(\\\\w)(\\\\w+)\\\\b\\\" \\\"$2$1ay\\\")\n   -> \\\"lmostAay igPay atinLay\\\"\"\n  [s match replacement]\n  (cond\n    (string? match)\n    (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n\n    (instance? js/RegExp match)\n    (if (string? replacement)\n      (replace-all s match replacement)\n      (replace-all s match (replace-with replacement)))\n\n    :else (throw (str \"Invalid match arg: \" match))))\n\n(defn replace-first\n  \"Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace-first \\\"swap first two words\\\"\n                                 #\\\"(\\\\w+)(\\\\s+)(\\\\w+)\\\" \\\"$3$2$1\\\")\n   -> \\\"first swap two words\\\"\"\n  [s match replacement]\n  (.replace s match replacement))\n\n(defn join\n  \"Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.\"\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if-not (nil? coll)\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))\n\n(defn upper-case\n  \"Converts string to all upper-case.\"\n  [s]\n  (.toUpperCase s))\n\n(defn lower-case\n  \"Converts string to all lower-case.\"\n  [s]\n  (.toLowerCase s))\n\n(defn capitalize\n  \"Converts first character of the string to upper-case, all other\n  characters to lower-case.\"\n  [s]\n  (gstring/capitalize s))\n\n;; The JavaScript split function takes a limit argument but the return\n;; value is not the same as the Java split function.\n;;\n;; Java: (.split \"a-b-c\" #\"-\" 2) => [\"a\" \"b-c\"]\n;; JavaScript: (.split \"a-b-c\" #\"-\" 2) => [\"a\" \"b\"]\n;;\n;; For consistency, the three arg version has been implemented to\n;; mimic Java's behavior.\n\n(defn- pop-last-while-empty\n  [v]\n  (loop [v v]\n    (if (identical? \"\" (peek v))\n      (recur (pop v))\n      v)))\n\n(defn- discard-trailing-if-needed\n  [limit v]\n  (if (and (== 0 limit) (< 1 (count v)))\n    (pop-last-while-empty v)\n    v))\n\n(defn- split-with-empty-regex\n  [s limit]\n  (if (or (<= limit 0) (>= limit (+ 2 (count s))))\n    (conj (vec (cons \"\" (map str (seq s)))) \"\")\n    (condp == limit\n      1 (vector s)\n      2 (vector \"\" s)\n      (let [c (- limit 2)]\n        (conj (vec (cons \"\" (subvec (vec (map str (seq s))) 0 c))) (subs s c))))))\n\n(defn split\n  \"Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (identical? \"/(?:)/\" (str re))\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (== 1 limit)\n               (conj parts s)\n               (let [m (re-find re s)]\n                 (if-not (nil? m)\n                   (let [index (.indexOf s m)]\n                     (recur (.substring s (+ index (count m)))\n                       (dec limit)\n                       (conj parts (.substring s 0 index))))\n                   (conj parts s))))))))))\n\n(defn split-lines\n  \"Splits s on \\\\n or \\\\r\\\\n.\"\n  [s]\n  (split s #\"\\n|\\r\\n\"))\n\n(defn trim\n  \"Removes whitespace from both ends of string.\"\n  [s]\n  (gstring/trim s))\n\n(defn triml\n  \"Removes whitespace from the left side of string.\"\n  [s]\n  (gstring/trimLeft s))\n\n(defn trimr\n  \"Removes whitespace from the right side of string.\"\n  [s]\n  (gstring/trimRight s))\n\n(defn trim-newline\n  \"Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl's chomp.\"\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (identical? \\newline ch)\n                (identical? \\return ch))\n          (recur (dec index))\n          (.substring s 0 index))))))\n\n(defn ^boolean blank?\n  \"True is s is nil, empty, or contains only whitespace.\"\n  [s]\n  (gstring/isEmptySafe s))\n\n(defn escape\n  \"Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (== length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)\n              replacement (get cmap ch)]\n          (if-not (nil? replacement)\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))\n\n(defn index-of\n  \"Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.\"\n  ([s value]\n   (let [result (.indexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.indexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn last-index-of\n  \"Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.\"\n  ([s value]\n   (let [result (.lastIndexOf s value)]\n     (if (neg? result)\n       nil\n       result)))\n  ([s value from-index]\n   (let [result (.lastIndexOf s value from-index)]\n     (if (neg? result)\n       nil\n       result))))\n\n(defn ^boolean starts-with?\n  \"True if s starts with substr.\"\n  [s substr]\n  (gstring/startsWith s substr))\n\n(defn ^boolean ends-with?\n  \"True if s ends with substr.\"\n  [s substr]\n  (gstring/endsWith s substr))\n\n(defn ^boolean includes?\n  \"True if s includes substr.\"\n  [s substr]\n  (gstring/contains s substr))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tagged_literals.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tagged-literals",new cljs.core.Keyword(null,"source","source",-433931539),";; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.tagged-literals\n  #?(:clj  (:require [clojure.instant :as inst])\n     :cljs (:require [cljs.reader :as reader])))\n\n(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"Queue literal expects a vector for its elements.\")\n         :cljs (js/Error.\n                 \"Queue literal expects a vector for its elements.\"))))\n  (list 'cljs.core/into 'cljs.core.PersistentQueue.EMPTY form))\n\n#?(:clj\n   (defn read-uuid\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. \"UUID literal expects a string as its representation.\")))\n     (try\n       (java.util.UUID/fromString form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e)))))))\n\n#?(:cljs\n   (defn read-uuid\n     [form]\n     (when-not (string? form)\n       (throw (js/Error. \"UUID literal expects a string as its representation.\")))\n     (try\n       (uuid form)\n       (catch :default e\n         (throw (js/Error. (. e -message)))))))\n\n#?(:clj\n   (defn read-inst\n     [form]\n     (when-not (string? form)\n       (throw (RuntimeException. \"Instance literal expects a string for its timestamp.\")))\n     (try\n       (inst/read-instant-date form)\n       (catch Throwable e\n         (throw (RuntimeException. (.getMessage e)))))))\n\n#?(:cljs\n   (defn read-inst\n     [form]\n     (when-not (string? form)\n       (throw (js/Error. \"Instance literal expects a string for its timestamp.\")))\n     (try\n       (#'reader/read-date form)\n       (catch :default e\n         (throw (js/Error. (. e -message)))))))\n\n(defn valid-js-literal-key? [k]\n  (or (string? k)\n      (and (keyword? k)\n           (nil? (namespace k)))))\n\n(deftype JSValue [val])\n\n(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"JavaScript literal must use map or vector notation\")\n         :cljs (js/Error.\n                 \"JavaScript literal must use map or vector notation\"))))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw\n      #?(:clj  (RuntimeException.\n                 \"JavaScript literal keys must be strings or unqualified keywords\")\n         :cljs (js/Error.\n                 \"JavaScript literal keys must be strings or unqualified keywords\"))))\n  (JSValue. form))\n\n(def ^:dynamic *cljs-data-readers*\n  (merge ;; assumes we can read all data_readers\n    #?(:clj *data-readers*)\n    {'queue read-queue\n     'uuid  read-uuid\n     'inst  read-inst\n     'js    read-js}))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/test.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.test",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.test\n  #?(:cljs (:require-macros [clojure.template :as temp]))\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.analyzer.api :as ana-api]\n            #?(:clj [clojure.template :as temp])))\n\n;; =============================================================================\n;; Utilities for assertions\n\n(defn function?\n  \"Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).\"\n  [menv x]\n  (and (symbol? x) (:fn-var (ana-api/resolve menv x))))\n\n(defn assert-predicate\n  \"Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).\"\n  [msg form]\n  (let [args (rest form)\n        pred (first form)]\n    `(let [values# (list ~@args)\n           result# (apply ~pred values#)]\n       (if result#\n         (do-report\n           {:type :pass, :message ~msg,\n            :expected '~form, :actual (cons ~pred values#)})\n         (do-report\n           {:type :fail, :message ~msg,\n            :expected '~form, :actual (list '~'not (cons '~pred values#))}))\n       result#)))\n\n(defn assert-any\n  \"Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.\"\n  [msg form]\n  `(let [value# ~form]\n     (if value#\n       (do-report\n         {:type :pass, :message ~msg,\n          :expected '~form, :actual value#})\n       (do-report\n         {:type :fail, :message ~msg,\n          :expected '~form, :actual value#}))\n     value#))\n\n(defmacro ^:private cljs-output-dir []\n  (let [{:keys [output-dir]} (ana-api/get-options)]\n    (or output-dir \"out\")))\n\n;; =============================================================================\n;; Assertion Methods\n\n;; You don't call these, but you can add methods to extend the 'is'\n;; macro.  These define different kinds of tests, based on the first\n;; symbol in the test expression.\n\n(defmulti assert-expr \n  (fn [menv msg form]\n    (cond\n      (nil? form) :always-fail\n      (seq? form) (first form)\n      :else :default)))\n\n(defmethod assert-expr :always-fail [menv msg form]\n  ;; nil test: always fail\n  `(do-report {:type :fail, :message ~msg}))\n\n(defmethod assert-expr :default [menv msg form]\n  (if (and (sequential? form)\n           (function? menv (first form)))\n    (assert-predicate msg form)\n    (assert-any msg form)))\n\n(defmethod assert-expr 'instance? [menv msg form]\n  ;; Test if x is an instance of y.\n  `(let [klass# ~(nth form 1)\n         object# ~(nth form 2)]\n     (let [result# (instance? klass# object#)]\n       (if result#\n         (do-report\n           {:type :pass, :message ~msg,\n            :expected '~form, :actual (type object#)})\n         (do-report\n           {:type :fail, :message ~msg,\n            :expected '~form, :actual (type object#)}))\n       result#)))\n\n(defmethod assert-expr 'thrown? [menv msg form]\n  ;; (is (thrown? c expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Returns the exception thrown.\n  (let [klass (second form)\n        body (nthnext form 2)]\n    `(try\n       ~@body\n       (do-report\n         {:type :fail, :message ~msg,\n          :expected '~form, :actual nil})\n       (catch ~klass e#\n         (do-report\n           {:type :pass, :message ~msg,\n            :expected '~form, :actual e#})\n         e#))))\n\n(defmethod assert-expr 'thrown-with-msg? [menv msg form]\n  ;; (is (thrown-with-msg? c re expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Also asserts that the message string of the exception matches\n  ;; (with re-find) the regular expression re.\n  (let [klass (nth form 1)\n        re (nth form 2)\n        body (nthnext form 3)]\n    `(try\n       ~@body\n       (do-report {:type :fail, :message ~msg, :expected '~form, :actual nil})\n       (catch ~klass e#\n         (let [m# (.-message e#)]\n           (if (re-find ~re m#)\n             (do-report\n               {:type :pass, :message ~msg,\n                :expected '~form, :actual e#})\n             (do-report\n               {:type :fail, :message ~msg,\n                :expected '~form, :actual e#}))\n           e#)))))\n\n(defmacro try-expr\n  \"Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.\"\n  [msg form]\n  `(try\n     ~(assert-expr &env msg form)\n     (catch :default t#\n       (do-report\n         {:type :error, :message ~msg,\n          :expected '~form, :actual t#}))))\n\n;; =============================================================================\n;; Assertion Macros\n\n(defmacro is\n  \"Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \\\"Two plus two should be 4\\\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.\"\n  ([form] `(cljs.test/is ~form nil))\n  ([form msg]\n   `(try-expr ~msg ~form)))\n\n(defmacro are\n  \"Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.\"\n  [argv expr & args]\n  (if (or\n        ;; (are [] true) is meaningless but ok\n        (and (empty? argv) (empty? args))\n        ;; Catch wrong number of args\n        (and (pos? (count argv))\n          (pos? (count args))\n          (zero? (mod (count args) (count argv)))))\n    `(clojure.template/do-template ~argv (is ~expr) ~@args)\n    (throw (#?(:clj Exception. :cljs js/Error.) \"The number of args doesn't match are's argv.\"))))\n\n(defmacro testing\n  \"Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).\"\n  ([string & body]\n   `(do\n      (update-current-env! [:testing-contexts] conj ~string)\n      (try\n        ~@body\n        (finally\n          (update-current-env! [:testing-contexts] rest))))))\n\n;; =============================================================================\n;; Defining Tests\n\n(defmacro deftest\n  \"Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.\"\n  [name & body]\n  (when ana/*load-tests*\n    `(do\n       (def ~(vary-meta name assoc :test `(fn [] ~@body))\n         (fn [] (cljs.test/test-var (.-cljs$lang$var ~name))))\n       (set! (.-cljs$lang$var ~name) (var ~name)))))\n\n(defmacro async\n  \"Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))\"\n  [done & body]\n  `(reify\n     cljs.test/IAsyncTest\n     cljs.core/IFn\n     (~'-invoke [_# ~done]\n       ~@body)))\n\n;; =============================================================================\n;; Running Tests\n\n(defn ns? [x]\n  (and (seq? x) (= (first x) 'quote)))\n\n(defmacro run-tests-block\n  \"Like test-vars, but returns a block for further composition and\n  later execution.\"\n  [env-or-ns & namespaces]\n  (assert (every?\n           (fn [[quote ns]] (and (= quote 'quote) (symbol? ns)))\n           namespaces)\n          \"All arguments to run-tests must be quoted symbols\")\n  (let [is-ns (ns? env-or-ns)\n        env (gensym \"env\")\n        summary (gensym \"summary\")]\n    `(let [~env ~(if is-ns\n                   `(empty-env)\n                   env-or-ns)\n           ~summary (cljs.core/volatile!\n                     {:test 0 :pass 0 :fail 0 :error 0\n                      :type :summary})]\n       (concat ~@(map\n                  (fn [ns]\n                    `(concat (test-ns-block ~env ~ns)\n                             [(fn []\n                                (cljs.core/vswap!\n                                 ~summary\n                                 (partial merge-with +)\n                                 (:report-counters\n                                  (get-and-clear-env!))))]))\n                  (if is-ns\n                    (concat [env-or-ns] namespaces)\n                    namespaces))\n               [(fn []\n                   (set-env! ~env)\n                   (do-report (deref ~summary))\n                   (report (assoc (deref ~summary) :type :end-run-tests))\n                   (clear-env!))]))))\n\n(defmacro run-tests\n  \"Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.\"\n  ([] `(run-tests (empty-env) '~ana/*cljs-ns*))\n  ([env-or-ns]\n   (if (ns? env-or-ns)\n     `(run-tests (empty-env) ~env-or-ns)\n     `(run-tests ~env-or-ns '~ana/*cljs-ns*)))\n  ([env-or-ns & namespaces]\n   `(run-block (run-tests-block ~env-or-ns ~@namespaces))))\n\n(defmacro run-all-tests\n  \"Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.\"\n  ([] `(run-all-tests nil (empty-env)))\n  ([re] `(run-all-tests ~re (empty-env)))\n  ([re env]\n   `(run-tests ~env\n      ~@(map\n          (fn [ns] `(quote ~ns))\n          (cond->> (ana-api/all-ns)\n            re (filter #(re-matches re (name %))))))))\n\n(defmacro test-all-vars-block\n  ([[quote ns]]\n   `(let [env# (get-current-env)]\n      (concat\n       [(fn []\n          (when (nil? env#)\n            (set-env! (empty-env)))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-once-fixtures)\n             `(update-current-env! [:once-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-once-fixtures\")))\n          ~(when (ana-api/ns-resolve ns 'cljs-test-each-fixtures)\n             `(update-current-env! [:each-fixtures] assoc '~ns\n                                             ~(symbol (name ns) \"cljs-test-each-fixtures\"))))]\n       (test-vars-block\n        [~@(->> (ana-api/ns-interns ns)\n                (filter (fn [[_ v]] (:test v)))\n                (sort-by (fn [[_ v]] (:line v)))\n                (map (fn [[k _]]\n                       `(var ~(symbol (name ns) (name k))))))])\n       [(fn []\n          (when (nil? env#)\n            (clear-env!)))]))))\n\n(defmacro test-all-vars\n  \"Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.\"\n  [[quote ns :as form]]\n  `(run-block\n     (concat (test-all-vars-block ~form)\n             [(fn []\n                (report {:type :end-test-all-vars :ns ~form}))])))\n\n(defmacro test-ns-block\n  \"Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.\"\n  ([env [quote ns :as form]]\n   (assert (and (= quote 'quote) (symbol? ns)) \"Argument to test-ns must be a quoted symbol\")\n   (assert (ana-api/find-ns ns) (str \"Namespace \" ns \" does not exist\"))\n   `[(fn []\n       (set-env! ~env)\n       (do-report {:type :begin-test-ns, :ns ~form})\n       ;; If the namespace has a test-ns-hook function, call that:\n       ~(if-let [v (ana-api/ns-resolve ns 'test-ns-hook)]\n          `(~(symbol (name ns) \"test-ns-hook\"))\n          ;; Otherwise, just test every var in the namespace.\n          `(block (test-all-vars-block ~form))))\n     (fn []\n       (do-report {:type :end-test-ns, :ns ~form}))]))\n\n(defmacro test-ns\n  \"If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  \"\n  ([ns] `(test-ns (empty-env) ~ns))\n  ([env [quote ns :as form]]\n   `(run-block\n     (concat (test-ns-block ~env ~form)\n             [(fn []\n                (clear-env!))]))))\n\n;; =============================================================================\n;; Fixes\n\n(defmacro use-fixtures [type & fns]\n  (condp = type\n    :once\n    `(def ~'cljs-test-once-fixtures\n       [~@fns])\n    :each\n    `(def ~'cljs-test-each-fixtures\n       [~@fns])\n    :else\n    (throw\n      (#?(:clj Exception. :cljs js/Error.) \"First argument to cljs.test/use-fixtures must be :once or :each\"))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/core/reducers.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.core.reducers",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc\n      \"A library for reduction and parallel folding. Alpha and subject\n      to change.\"\n      :author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [clojure.walk :as walk]))\n\n(alias 'core 'clojure.core)\n(set! *warn-on-reflection* true)\n\n;;;;;;;;;;;;;; some fj stuff ;;;;;;;;;;\n\n(def pool (delay (java.util.concurrent.ForkJoinPool.)))\n\n(defn fjtask [^Callable f]\n  (java.util.concurrent.ForkJoinTask/adapt f))\n\n(defn- fjinvoke [f]\n  (if (java.util.concurrent.ForkJoinTask/inForkJoinPool)\n    (f)\n    (.invoke ^java.util.concurrent.ForkJoinPool @pool ^java.util.concurrent.ForkJoinTask (fjtask f))))\n\n(defn- fjfork [task] (.fork ^java.util.concurrent.ForkJoinTask task))\n\n(defn- fjjoin [task] (.join ^java.util.concurrent.ForkJoinTask task))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn reduce\n  \"Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv\"\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (instance? java.util.Map coll)\n       (clojure.core.protocols/kv-reduce coll f init)\n       (clojure.core.protocols/coll-reduce coll f init))))\n\n(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))\n\n(defn fold\n  \"Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\"\n  {:added \"1.5\"}\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))\n\n(defn reducer\n  \"Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  {:added \"1.5\"}\n  ([coll xf]\n     (reify\n      clojure.core.protocols/CollReduce\n      (coll-reduce [this f1]\n                   (clojure.core.protocols/coll-reduce this f1 (f1)))\n      (coll-reduce [_ f1 init]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) init)))))\n\n(defn folder\n  \"Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  {:added \"1.5\"}\n  ([coll xf]\n     (reify\n      clojure.core.protocols/CollReduce\n      (coll-reduce [_ f1]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) (f1)))\n      (coll-reduce [_ f1 init]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) init))\n\n      CollFold\n      (coll-fold [_ n combinef reducef]\n                 (coll-fold coll n combinef (xf reducef))))))\n\n(defn- do-curried\n  [name doc meta args body]\n  (let [cargs (vec (butlast args))]\n    `(defn ~name ~doc ~meta\n       (~cargs (fn [x#] (~name ~@cargs x#)))\n       (~args ~@body))))\n\n(defmacro ^:private defcurried\n  \"Builds another arity of the fn that returns a fn awaiting the last\n  param\"\n  [name doc meta args & body]\n  (do-curried name doc meta args body))\n\n(defn- do-rfn [f1 k fkv]\n  `(fn\n     ([] (~f1))\n     ~(clojure.walk/postwalk\n       #(if (sequential? %)\n          ((if (vector? %) vec identity)\n           (core/remove #{k} %))\n          %)\n       fkv)\n     ~fkv))\n\n(defmacro ^:private rfn\n  \"Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.\"\n  [[f1 k] fkv]\n  (do-rfn f1 k fkv))\n\n(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {:added \"1.5\"}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))\n\n(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {:added \"1.5\"}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (let [f1 (fn\n                ([ret v]\n                  (let [x (f1 ret v)] (if (reduced? x) (reduced x) x)))\n                ([ret k v]\n                  (let [x (f1 ret k v)] (if (reduced? x) (reduced x) x))))]\n       (rfn [f1 k]\n            ([ret k v]\n               (reduce f1 ret (f k v))))))))\n\n(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {:added \"1.5\"}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))\n\n(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {:added \"1.5\"}\n  [pred coll]\n  (filter (complement pred) coll))\n\n(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {:added \"1.5\"}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (clojure.core.protocols/coll-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))\n\n(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {:added \"1.5\"}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))\n\n(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {:added \"1.5\"}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))\n\n(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {:added \"1.5\"}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))\n\n;;do not construct this directly, use cat\n(deftype Cat [cnt left right]\n  clojure.lang.Counted\n  (count [_] cnt)\n\n  clojure.lang.Seqable\n  (seq [_] (concat (seq left) (seq right)))\n\n  clojure.core.protocols/CollReduce\n  (coll-reduce [this f1] (clojure.core.protocols/coll-reduce this f1 (f1)))\n  (coll-reduce\n   [_  f1 init]\n   (clojure.core.protocols/coll-reduce\n    right f1\n    (clojure.core.protocols/coll-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n   [_ n combinef reducef]\n   (fjinvoke\n    (fn []\n      (let [rt (fjfork (fjtask #(coll-fold right n combinef reducef)))]\n        (combinef\n         (coll-fold left n combinef reducef)\n         (fjjoin rt)))))))\n\n(defn cat\n  \"A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.\"\n  {:added \"1.5\"}\n  ([] (java.util.ArrayList.))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n      (zero? (count left)) right\n      (zero? (count right)) left\n      :else\n      (Cat. (+ (count left) (count right)) left right))))\n\n(defn append!\n  \".adds x to acc and returns acc\"\n  {:added \"1.5\"}\n  [^java.util.Collection acc x]\n  (doto acc (.add x)))\n\n(defn foldcat\n  \"Equivalent to (fold cat append! coll)\"\n  {:added \"1.5\"}\n  [coll]\n  (fold cat append! coll))\n\n(defn monoid\n  \"Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.\"\n  {:added \"1.5\"}\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; fold impls ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n(defn- foldvec\n  [v n combinef reducef]\n  (cond\n   (empty? v) (combinef)\n   (<= (count v) n) (reduce reducef (combinef) v)\n   :else\n   (let [split (quot (count v) 2)\n         v1 (subvec v 0 split)\n         v2 (subvec v split (count v))\n         fc (fn [child] #(foldvec child n combinef reducef))]\n     (fjinvoke\n      #(let [f1 (fc v1)\n             t2 (fjtask (fc v2))]\n         (fjfork t2)\n         (combinef (f1) (fjjoin t2)))))))\n\n(extend-protocol CollFold\n nil\n (coll-fold\n  [coll n combinef reducef]\n  (combinef))\n\n Object\n (coll-fold\n  [coll n combinef reducef]\n  ;;can't fold, single reduce\n  (reduce reducef (combinef) coll))\n\n clojure.lang.IPersistentVector\n (coll-fold\n  [v n combinef reducef]\n  (foldvec v n combinef reducef))\n\n clojure.lang.PersistentHashMap\n (coll-fold\n  [m n combinef reducef]\n  (.fold m n combinef reducef fjinvoke fjtask fjfork fjjoin)))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/core.cljs.cache.json",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs/core.cljs.cache.json",new cljs.core.Keyword(null,"source","source",-433931539),"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:externs\",[\"^ \",\"~$console\",[\"^ \",\"~$log\",[\"^ \",\"~$apply\",[\"^ \"]],\"~$error\",[\"^ \",\"^5\",[\"^ \"]]],\"~$ReferenceError\",[\"^ \"],\"~$Error\",[\"^ \",\"~$prototype\",[\"^ \",\"~$name\",[\"^ \"],\"~$description\",[\"^ \"],\"~$number\",[\"^ \"],\"~$fileName\",[\"^ \"],\"~$lineNumber\",[\"^ \"],\"~$columnNumber\",[\"^ \"],\"~$stack\",[\"^ \"]]],\"~$Object\",[\"^ \",\"~$out\",[\"^ \",\"~$println\",[\"^ \"]],\"^6\",[\"^ \",\"^C\",[\"^ \"]]],\"~$isFinite\",[\"^ \"],\"~$Symbol\",[\"^ \",\"~$iterator\",[\"^ \"]],\"~$Infinity\",[\"^ \"],\"~$String\",[\"^ \",\"~$fromCharCode\",[\"^ \"]],\"~$eval\",[\"^ \"],\"~$Array\",[\"^ \",\"~$isArray\",[\"^ \"]],\"~$parseInt\",[\"^ \"],\"~$TypeError\",[\"^ \"],\"~$isNaN\",[\"^ \"],\"~$parseFloat\",[\"^ \"],\"~$performance\",[\"^ \",\"~$now\",[\"^ \"]],\"~$process\",[\"^ \",\"~$hrtime\",[\"^ \"]],\"~$setTimeout\",[\"^ \"],\"~$Number\",[\"^ \",\"~$POSITIVE_INFINITY\",[\"^ \"],\"~$NEGATIVE_INFINITY\",[\"^ \"],\"~$MAX_VALUE\",[\"^ \"]],\"~$RegExp\",[\"^ \",\"^9\",[\"^ \",\"~$source\",[\"^ \"],\"~$exec\",[\"^ \"],\"~$lastIndex\",[\"^ \"]]],\"~$Date\",[\"^ \",\"^9\",[\"^ \",\"~$getTime\",[\"^ \"],\"~$valueOf\",[\"^ \"]]],\"~$Java\",[\"^ \",\"~$type\",[\"^ \"]],\"~$COMPILED\",[\"^ \"]],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$cljs.core\",\"~:imports\",[\"^ \",\"~$StringBuffer\",\"~$goog.string.StringBuffer\"],\"~:requires\",[\"^ \",\"~$gstring\",\"~$goog.string\",\"^1B\",\"^1B\",\"~$goog.Uri\",\"^1C\",\"~$garray\",\"~$goog.array\",\"~$goog.object\",\"^1F\",\"~$goog.math.Integer\",\"^1G\",\"^1>\",\"^1?\",\"~$gobject\",\"^1F\",\"^1E\",\"^1E\",\"~$goog.math.Long\",\"^1I\"],\"~:cljs.spec/speced-vars\",[],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$->PersistentHashSet\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:protocols\",[\"^1:\",[\"~$cljs.core/IEquiv\",\"~$cljs.core/IHash\",\"~$cljs.core/IFn\",\"~$cljs.core/ICollection\",\"~$cljs.core/IEditableCollection\",\"~$cljs.core/Object\",\"~$cljs.core/ISet\",\"~$cljs.core/IEmptyableCollection\",\"~$cljs.core/ICounted\",\"~$cljs.core/ISeqable\",\"~$cljs.core/IMeta\",\"~$cljs.core/ICloneable\",\"~$cljs.core/IIterable\",\"~$cljs.core/IWithMeta\",\"~$cljs.core/ILookup\"]],\"~:file\",\"cljs/core.cljs\",\"~:end-column\",27,\"~:column\",10,\"~:factory\",\"~:positional\",\"~:line\",9143,\"~:end-line\",9143,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^2<\",[[\"~$meta\",\"~$hash-map\",\"~$__hash\"]]]]],\"~:skip-protocol-flag\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1W\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^23\"]],\"~:doc\",\"Positional factory function for cljs.core/PersistentHashSet.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^1W\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^23\"]],\"^1;\",\"~$cljs.core/->PersistentHashSet\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"~:method-params\",[\"^2<\",[[\"^2>\",\"^2?\",\"^2@\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^2<\",[null,null]],\"^26\",1,\"~:variadic?\",false,\"^27\",\"^28\",\"^29\",9143,\"~:ret-tag\",\"~$cljs.core/PersistentHashSet\",\"^2:\",9143,\"~:max-fixed-arity\",3,\"~:fn-var\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^2?\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1W\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentHashSet.\"],\"~$js->clj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10744,\"^26\",7,\"^2:\",10744,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",\"~$opts\"]]]]],\"^2B\",\"Recursively transforms JavaScript arrays into ClojureScript\\n  vectors, and JavaScript objects into ClojureScript maps.  With\\n  option ':keywordize-keys true' will convert object fields from\\n  strings to keywords.\",\"~:top-fn\",[\"^ \",\"^2G\",true,\"~:fixed-arity\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",\"^2M\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/js->clj\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",\"^2M\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"~:methods\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"~:tag\",\"~$any\"],[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"~$clj\",\"^2S\",\"~$cljs.core/MapEntry\"]]]],\"^29\",10744,\"^2:\",10744,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",\"^2M\"]]],\"^2B\",\"Recursively transforms JavaScript arrays into ClojureScript\\n  vectors, and JavaScript objects into ClojureScript maps.  With\\n  option ':keywordize-keys true' will convert object fields from\\n  strings to keywords.\"],\"~$sort-by\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2447,\"^26\",7,\"^2:\",2447,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$keyfn\",\"~$coll\"],[\"^2W\",\"~$comp\",\"^2X\"]]]]],\"^2B\",\"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2W\",\"^2X\"],[\"^2W\",\"^2Y\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2W\",\"^2X\"],[\"^2W\",\"^2Y\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/sort-by\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2W\",\"^2X\"],[\"^2W\",\"^2Y\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2W\",\"^2X\"],[\"^2W\",\"^2Y\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2W\",\"^2X\"],[\"^2W\",\"^2Y\",\"^2X\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"~$seq\",\"~$cljs.core/IList\"]]]],\"^29\",2447,\"^2:\",2447,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2W\",\"^2X\"],[\"^2W\",\"^2Y\",\"^2X\"]]],\"^2B\",\"Returns a sorted sequence of the items in coll, where the sort\\n   order is determined by comparing (keyfn item).  Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"],\"~$ITransientAssociative\",[\"^ \",\"^1O\",[\"^ \",\"~:protocol-symbol\",true,\"^24\",\"cljs/core.cljs\",\"^25\",35,\"^26\",14,\"^29\",793,\"~:protocol-info\",[\"^ \",\"^2Q\",[\"^ \",\"~$-assoc!\",[[\"~$tcoll\",\"~$key\",\"~$val\"]]]],\"^2:\",793,\"^2B\",\"Protocol for adding associativity to transient collections.\",\"~:jsdoc\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/ITransientAssociative\",\"^24\",\"cljs/core.cljs\",\"^25\",35,\"^26\",1,\"^29\",793,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^34\",[[\"^35\",\"^36\",\"^37\"]]]],\"~:info\",null,\"^2:\",793,\"^2R\",\"^2S\",\"~:impls\",[\"^1:\",[\"~$cljs.core/TransientVector\",\"~$cljs.core/TransientHashMap\",\"~$cljs.core/TransientArrayMap\"]],\"^2B\",\"Protocol for adding associativity to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$chunk-first\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3628,\"^26\",7,\"^2:\",3628,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"^1;\",\"~$cljs.core/chunk-first\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3628,\"^2H\",\"^2S\",\"^2:\",3628,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"~$print-meta?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10081,\"^26\",7,\"^2:\",10081,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2M\",\"~$obj\"]]]]]],\"^1;\",\"~$cljs.core/print-meta?\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2M\",\"^3B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10081,\"^2H\",\"~$boolean\",\"^2:\",10081,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2M\",\"^3B\"]]]]]],\"~$m3-hash-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",929,\"^26\",15,\"^2:\",929,\"^25\",26,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$in\"]]]]]],\"^1;\",\"~$cljs.core/m3-hash-int\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"^3F\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",929,\"^2H\",\"^<\",\"^2:\",929,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3F\"]]]]]],\"~$pr-str*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",877,\"^26\",7,\"^2:\",877,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\"]]]]],\"^2B\",\"Support so that collections can implement toString without\\n   loading all the printing machinery.\"],\"^1;\",\"~$cljs.core/pr-str*\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^3B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",877,\"^2H\",\"~$string\",\"^2:\",877,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\"]]]]],\"^2B\",\"Support so that collections can implement toString without\\n   loading all the printing machinery.\"],\"~$eduction\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10679,\"^26\",7,\"^2:\",10679,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$xform*\",\"^2X\"]]]]],\"^2B\",\"Returns a reducible/iterable application of the transducers\\n  to the items in coll. Transducers are applied in order as if\\n  combined with comp. Note that these applications will be\\n  performed every time reduce/iterator is called.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"~$xforms\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^3M\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/eduction\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^3M\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^3M\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^3M\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"~$cljs.core/Eduction\"]],\"^29\",10679,\"^2H\",\"^2S\",\"^2:\",10679,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^3M\"]]],\"^2B\",\"Returns a reducible/iterable application of the transducers\\n  to the items in coll. Transducers are applied in order as if\\n  combined with comp. Note that these applications will be\\n  performed every time reduce/iterator is called.\"],\"~$tree-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5184,\"^26\",7,\"^2:\",5184,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$branch?\",\"~$children\",\"~$root\"]]]]],\"^2B\",\"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"],\"^1;\",\"~$cljs.core/tree-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^3Q\",\"^3R\",\"^3S\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5184,\"^2H\",\"~$cljs.core/LazySeq\",\"^2:\",5184,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3Q\",\"^3R\",\"^3S\"]]]]],\"^2B\",\"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\\n  branch? must be a fn of one arg that returns true if passed a node\\n  that can have children (but may not).  children must be a fn of one\\n  arg that returns a sequence of the children. Will only be called on\\n  nodes for which branch? returns true. Root is the root node of the\\n  tree.\"],\"~$unchecked-remainder-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2774,\"^26\",7,\"^2:\",2774,\"^25\",30,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-remainder-int\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2774,\"^2H\",\"^<\",\"^2:\",2774,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]]],\"~$uuid\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11276,\"^26\",7,\"^2:\",11276,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"^1;\",\"~$cljs.core/uuid\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11276,\"^2H\",\"~$cljs.core/UUID\",\"^2:\",11276,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"^2[\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1205,\"^26\",12,\"^2:\",1205,\"^25\",15,\"^2R\",\"^2[\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"],\"^1;\",\"~$cljs.core/seq\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1205,\"^2H\",\"^2[\",\"^2:\",1205,\"^2J\",1,\"^2R\",\"^2[\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq on the collection. If the collection is\\n  empty, returns nil.  (seq nil) returns nil. seq also works on\\n  Strings.\"],\"~$Volatile\",[\"^ \",\"~:num-fields\",1,\"^1P\",[\"^1:\",[\"~$cljs.core/IVolatile\",\"~$cljs.core/IDeref\"]],\"^1;\",\"~$cljs.core/Volatile\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"~:type\",true,\"^26\",10,\"^29\",4557,\"~:record\",false,\"^2:\",4557,\"^2R\",\"~$function\",\"^2A\",[\"^1:\",[\"^43\"]]],\"~$reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2504,\"^26\",7,\"^2:\",2504,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]]]],\"^2B\",\"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2504,\"^2:\",2504,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2B\",\"f should be a function of 2 arguments. If val is not supplied,\\n  returns the result of applying f to the first 2 items in coll, then\\n  applying f to that result and the 3rd item, etc. If coll contains no\\n  items, f must accept no arguments as well, and reduce returns the\\n  result of calling f with no arguments.  If coll has only 1 item, it\\n  is returned and f is not called.  If val is supplied, returns the\\n  result of applying f to val and the first item in coll, then\\n  applying f to that result and the 2nd item, etc. If coll contains no\\n  items, returns val and f is not called.\"],\"~$IUUID\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",11248,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",11248,\"^2B\",\"A marker protocol for UUIDs\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/IUUID\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",11248,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",11248,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^3Z\"]],\"^2B\",\"A marker protocol for UUIDs\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$INIT\",[\"^ \",\"^1;\",\"~$cljs.core/INIT\",\"^24\",\"cljs/core.cljs\",\"^29\",4030,\"^26\",1,\"^2:\",4030,\"^25\",10,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4030,\"^26\",6,\"^2:\",4030,\"^25\",10],\"^2R\",\"~$object\"],\"~$find-ns\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11641,\"^26\",7,\"^2:\",11641,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$ns\"]]]]],\"^2B\",\"Returns the namespace named by the symbol or nil if it doesn't exist.\\n  Bootstrap only.\"],\"^1;\",\"~$cljs.core/find-ns\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^4@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11641,\"^2H\",[\"^1:\",[\"~$cljs.core/Namespace\",\"^2S\",\"~$clj-nil\"]],\"^2:\",11641,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\"]]]]],\"^2B\",\"Returns the namespace named by the symbol or nil if it doesn't exist.\\n  Bootstrap only.\"],\"~$contains?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2336,\"^26\",7,\"^2:\",2336,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$v\"]]]]],\"^2B\",\"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"],\"^1;\",\"~$cljs.core/contains?\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^2X\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2336,\"^2H\",\"^3D\",\"^2:\",2336,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$v\"]]]]],\"^2B\",\"Returns true if key is present in the given collection, otherwise\\n  returns false.  Note that for numerically indexed collections like\\n  vectors and arrays, this tests if the numeric key is within the\\n  range of indexes. 'contains?' operates constant or logarithmic time;\\n  it will not perform a linear search for a value.  See also 'some'.\"],\"~$every?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4217,\"^26\",7,\"^2:\",4217,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$pred\",\"^2X\"]]]]],\"^2B\",\"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"],\"^1;\",\"~$cljs.core/every?\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4217,\"^2H\",\"^3D\",\"^2:\",4217,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns true if (pred x) is logical true for every x in coll, else\\n  false.\"],\"~$->ES6IteratorSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"~$cljs.core/ISeq\",\"^1Z\"]],\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^26\",10,\"^27\",\"^28\",\"^29\",1296,\"^2:\",1296,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$value\",\"~$iter\",\"~$_rest\"]]]]],\"^2A\",[\"^1:\",[\"^4J\",\"^1Z\"]],\"^2B\",\"Positional factory function for cljs.core/ES6IteratorSeq.\"],\"^1P\",[\"^1:\",[\"^4J\",\"^1Z\"]],\"^1;\",\"~$cljs.core/->ES6IteratorSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^4K\",\"^4L\",\"^4M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",1296,\"^2H\",\"~$cljs.core/ES6IteratorSeq\",\"^2:\",1296,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\",\"^4L\",\"^4M\"]]]]],\"^2A\",[\"^1:\",[\"^4J\",\"^1Z\"]],\"^2B\",\"Positional factory function for cljs.core/ES6IteratorSeq.\"],\"~$Var\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^1[\",\"~$cljs.core/Fn\",\"^43\",\"^22\"]],\"^1;\",\"~$cljs.core/Var\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^45\",true,\"^26\",10,\"^29\",1118,\"^46\",false,\"^2:\",1118,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1[\",\"^43\",\"^22\"]]],\"~$keep-indexed\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4579,\"^26\",7,\"^2:\",4579,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/keep-indexed\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false]],\"^29\",4579,\"^2:\",4579,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of the non-nil results of (f index item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a stateful transducer when no collection is\\n  provided.\"],\"~$->PersistentQueueSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"~$cljs.core/INext\",\"^1Z\",\"^1[\",\"~$cljs.core/ISequential\",\"^22\"]],\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",10,\"^27\",\"^28\",\"^29\",6188,\"^2:\",6188,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$front\",\"~$rear\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentQueueSeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\"]],\"^1;\",\"~$cljs.core/->PersistentQueueSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2D\",[\"^2<\",[[\"^2>\",\"^4X\",\"^4Y\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6188,\"^2H\",\"~$cljs.core/PersistentQueueSeq\",\"^2:\",6188,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^4X\",\"^4Y\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentQueueSeq.\"],\"~$subs\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2970,\"^26\",7,\"^2:\",2970,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\",\"~$start\"],[\"~$s\",\"^51\",\"~$end\"]]]]],\"^2B\",\"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$s\",\"^51\"],[\"~$s\",\"^51\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"~$s\",\"^51\"],[\"~$s\",\"^51\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/subs\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$s\",\"^51\"],[\"~$s\",\"^51\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"~$s\",\"^51\"],[\"~$s\",\"^51\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$s\",\"^51\"],[\"~$s\",\"^51\",\"^52\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",2970,\"^2:\",2970,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$s\",\"^51\"],[\"~$s\",\"^51\",\"^52\"]]],\"^2B\",\"Returns the substring of s beginning at start inclusive, and ending\\n  at end (defaults to length of string), exclusive.\"],\"~$IFind\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",634,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-find\",[[\"^2X\",\"~$k\"]]]],\"^2:\",634,\"^2B\",\"Protocol for implementing entry finding in collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/IFind\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",634,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^55\",[[\"^2X\",\"~$k\"]]]],\"^3:\",null,\"^2:\",634,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"~$cljs.core/PersistentHashMap\",\"~$cljs.core/ObjMap\",\"~$cljs.core/PersistentArrayMap\",\"~$cljs.core/BlackNode\",\"^2U\",\"~$cljs.core/Subvec\",\"~$cljs.core/PersistentVector\",\"~$cljs.core/PersistentTreeMap\",\"~$cljs.core/RedNode\"]],\"^2B\",\"Protocol for implementing entry finding in collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$set\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9411,\"^26\",7,\"^2:\",9411,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a set of the distinct elements of coll.\"],\"^1;\",\"~$cljs.core/set\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9411,\"^2H\",[\"^1:\",[\"^2T\",\"^2S\",\"^1W\",\"~$cljs.core/MetaFn\",\"^4C\"]],\"^2:\",9411,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a set of the distinct elements of coll.\"],\"~$MODULE_URIS\",[\"^ \",\"^1;\",\"~$cljs.core/MODULE_URIS\",\"^24\",\"cljs/core.cljs\",\"^29\",39,\"^26\",1,\"^2:\",39,\"^25\",17,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",39,\"^26\",6,\"^2:\",39,\"^25\",17],\"^2R\",\"^4C\"],\"~$compare-indexed\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"~:private\",true,\"^24\",\"cljs/core.cljs\",\"^25\",32,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$xs\",\"~$ys\"],[\"^5F\",\"^5G\",\"~$len\",\"~$n\"]]],\"^2;\",[\"^2<\",[[\"^5F\",\"^5G\"],[\"^5F\",\"^5G\",\"^5H\",\"~$n\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",17,\"^29\",2401,\"^2:\",2401,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5F\",\"^5G\"],[\"^5F\",\"^5G\",\"^5H\",\"~$n\"]]]]],\"^2B\",\"Compare indexed collection.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/compare-indexed\",\"^24\",\"cljs/core.cljs\",\"^25\",32,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^5F\",\"^5G\"],[\"^5F\",\"^5G\",\"^5H\",\"~$n\"]]],\"^2;\",[\"^2<\",[[\"^5F\",\"^5G\"],[\"^5F\",\"^5G\",\"^5H\",\"~$n\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^5F\",\"^5G\"],[\"^5F\",\"^5G\",\"^5H\",\"~$n\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^<\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^<\"]],\"^29\",2401,\"^2:\",2401,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^5F\",\"^5G\"],[\"^5F\",\"^5G\",\"^5H\",\"~$n\"]]],\"^2B\",\"Compare indexed collection.\"],\"~$take-last\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4797,\"^26\",7,\"^2:\",4797,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"],\"^1;\",\"~$cljs.core/take-last\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4797,\"^2H\",\"^2[\",\"^2:\",4797,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a seq of the last n items in coll.  Depending on the type\\n  of coll may be no better than linear time.  For vectors, see also subvec.\"],\"~$IndexedSeq\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1188,\"^26\",29,\"^2:\",1188,\"^25\",39,\"~:declared\",true],\"^41\",3,\"^1P\",[\"^1:\",[\"~$cljs.core/IIndexed\",\"~$cljs.core/IReversible\",\"^1Q\",\"^1R\",\"~$cljs.core/ASeq\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^4W\",\"^22\",\"~$cljs.core/IReduce\"]],\"^1;\",\"~$cljs.core/IndexedSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^45\",true,\"^26\",10,\"^29\",1571,\"^46\",false,\"^5M\",true,\"^2:\",1571,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^5O\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$bit-set\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2885,\"^26\",7,\"^2:\",2885,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Set bit at index n\"],\"^1;\",\"~$cljs.core/bit-set\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2885,\"^2H\",\"^<\",\"^2:\",2885,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Set bit at index n\"],\"~$string-hash-cache-count\",[\"^ \",\"^1;\",\"~$cljs.core/string-hash-cache-count\",\"^24\",\"cljs/core.cljs\",\"^29\",956,\"^26\",1,\"^2:\",956,\"^25\",29,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",956,\"^26\",6,\"^2:\",956,\"^25\",29],\"^2R\",\"^<\"],\"~$qualified-keyword?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3384,\"^26\",7,\"^2:\",3384,\"^25\",25,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a keyword with a namespace\"],\"^1;\",\"~$cljs.core/qualified-keyword?\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3384,\"^2H\",\"^3D\",\"^2:\",3384,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a keyword with a namespace\"],\"~$->Eduction\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\",\"^1Z\",\"~$cljs.core/IPrintWithWriter\",\"^21\",\"^4W\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",10,\"^27\",\"^28\",\"^29\",10649,\"^2:\",10649,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$xform\",\"^2X\"]]]]],\"^2A\",[\"^1:\",[\"^1Z\",\"^5Z\",\"^21\",\"^4W\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Eduction.\"],\"^1P\",[\"^1:\",[\"^1V\",\"^1Z\",\"^5Z\",\"^21\",\"^4W\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->Eduction\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^5[\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",10649,\"^2H\",\"^3O\",\"^2:\",10649,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5[\",\"^2X\"]]]]],\"^2A\",[\"^1:\",[\"^1Z\",\"^5Z\",\"^21\",\"^4W\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Eduction.\"],\"~$tree-map-add\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8619,\"^26\",8,\"^2:\",8619,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2Y\",\"~$tree\",\"~$k\",\"~$v\",\"~$found\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tree-map-add\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^2Y\",\"^62\",\"~$k\",\"~$v\",\"^63\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8619,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\",\"^5>\"]],\"^2:\",8619,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2Y\",\"^62\",\"~$k\",\"~$v\",\"^63\"]]]]]],\"~$->ES6SetEntriesIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^26\",10,\"^27\",\"^28\",\"^29\",6540,\"^2:\",6540,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ES6SetEntriesIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->ES6SetEntriesIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6540,\"^2H\",\"~$cljs.core/ES6SetEntriesIterator\",\"^2:\",6540,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ES6SetEntriesIterator.\"],\"~$-with-meta\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"~:protocol\",\"^22\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",9,\"^29\",686,\"^2:\",686,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^2>\"]]]]],\"^2B\",\"Returns a new object with value of o and metadata meta added to it.\"],\"^69\",\"^22\",\"^1;\",\"~$cljs.core/-with-meta\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$o\",\"^2>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",684,\"^2H\",\"^2T\",\"^2:\",686,\"^2J\",2,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^2>\"]]]]],\"^2B\",\"Returns a new object with value of o and metadata meta added to it.\"],\"~$reset-cache\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10956,\"^26\",8,\"^2:\",10956,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$method-cache\",\"~$method-table\",\"~$cached-hierarchy\",\"~$hierarchy\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/reset-cache\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^6<\",\"^6=\",\"^6>\",\"^6?\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10956,\"^2H\",[\"^1:\",[null,\"^2S\"]],\"^2:\",10956,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6<\",\"^6=\",\"^6>\",\"^6?\"]]]]]],\"~$->PersistentArrayMapIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",36,\"^26\",10,\"^27\",\"^28\",\"^29\",6802,\"^2:\",6802,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$arr\",\"~$i\",\"~$cnt\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/PersistentArrayMapIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->PersistentArrayMapIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",36,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"^6C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6802,\"^2H\",\"~$cljs.core/PersistentArrayMapIterator\",\"^2:\",6802,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^6C\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/PersistentArrayMapIterator.\"],\"~$PersistentArrayMapIterator\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^6E\",\"^24\",\"cljs/core.cljs\",\"^25\",36,\"^45\",true,\"^26\",10,\"^29\",6802,\"^46\",false,\"^2:\",6802,\"^2R\",\"^47\",\"^2A\",null],\"~$butlast\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9491,\"^26\",7,\"^2:\",9491,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Return a seq of all but the last item in coll, in linear time\"],\"^1;\",\"~$cljs.core/butlast\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9491,\"^2H\",\"^2[\",\"^2:\",9491,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Return a seq of all but the last item in coll, in linear time\"],\"~$tail-off\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5357,\"^26\",8,\"^2:\",5357,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$pv\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tail-off\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^6J\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5357,\"^2H\",\"^<\",\"^2:\",5357,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\"]]]]]],\"~$unchecked-subtract-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",37,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"~$more\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",15,\"^29\",2784,\"^2:\",2784,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"],\"^1;\",\"~$cljs.core/unchecked-subtract-int\",\"^24\",\"cljs/core.cljs\",\"^25\",37,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2784,\"^2H\",\"^<\",\"^2:\",2784,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"],\"~$-iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",867,\"^26\",4,\"^2:\",867,\"^25\",13,\"^69\",\"^21\",\"^2B\",\"Returns an iterator for coll.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^21\",\"^1;\",\"~$cljs.core/-iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",865,\"^2H\",\"^2S\",\"^2:\",867,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns an iterator for coll.\"],\"~$*print-namespace-maps*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",138,\"^26\",3,\"^2:\",138,\"^25\",25,\"~:dynamic\",true,\"^2B\",\"*print-namespace-maps* controls whether the printer will print\\n  namespace map literal syntax.\\n\\n  Defaults to false, but the REPL binds it to true.\"],\"^1;\",\"~$cljs.core/*print-namespace-maps*\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",1,\"^6R\",true,\"^29\",132,\"^2:\",138,\"^2R\",\"^3D\",\"^2B\",\"*print-namespace-maps* controls whether the printer will print\\n  namespace map literal syntax.\\n\\n  Defaults to false, but the REPL binds it to true.\"],\"~$take-nth\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9807,\"^26\",7,\"^2:\",9807,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy seq of every nth item in coll.  Returns a stateful\\n  transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/take-nth\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",9807,\"^2:\",9807,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2B\",\"Returns a lazy seq of every nth item in coll.  Returns a stateful\\n  transducer when no collection is provided.\"],\"~$first\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1228,\"^26\",7,\"^2:\",1228,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"],\"^1;\",\"~$cljs.core/first\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1228,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",1228,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the first item in the collection. Calls seq on its\\n  argument. If coll is nil, returns nil.\"],\"~$native-satisfies?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",280,\"^26\",7,\"^2:\",280,\"^25\",24,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$p\",\"~$x\"]]]]],\"^2B\",\"Internal - do not use!\"],\"^1;\",\"~$cljs.core/native-satisfies?\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$p\",\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",280,\"^2H\",\"^3D\",\"^2:\",280,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$p\",\"~$x\"]]]]],\"^2B\",\"Internal - do not use!\"],\"~$seq?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2230,\"^26\",7,\"^2:\",2230,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Return true if s satisfies ISeq\"],\"^1;\",\"~$cljs.core/seq?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2230,\"^2H\",\"^3D\",\"^2:\",2230,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Return true if s satisfies ISeq\"],\"~$-global-hierarchy\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10846,\"^26\",3,\"^2:\",10846,\"^25\",20,\"^5E\",true,\"^38\",[\"@type {*}\"]],\"^5E\",true,\"^1;\",\"~$cljs.core/-global-hierarchy\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",10843,\"^2:\",10846,\"^2R\",\"^4C\",\"^38\",[\"@type {*}\"]],\"~$UUID\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\",\"^5Z\",\"~$cljs.core/IComparable\",\"^4;\"]],\"^1;\",\"^3Z\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^45\",true,\"^26\",10,\"^29\",11250,\"^46\",false,\"^2:\",11250,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5Z\",\"^73\"]]],\"~$-sorted-seq-from\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"~$cljs.core/ISorted\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",9,\"^29\",738,\"^2:\",738,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\",\"~$ascending?\"]]]]],\"^2B\",\"Returns a sorted seq from coll in either ascending or descending order.\\n     If ascending is true, the result should contain all items which are > or >=\\n     than k. If ascending is false, the result should contain all items which\\n     are < or <= than k, e.g.\\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)\"],\"^69\",\"^75\",\"^1;\",\"~$cljs.core/-sorted-seq-from\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^2X\",\"~$k\",\"^76\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",733,\"^2H\",\"^2T\",\"^2:\",738,\"^2J\",3,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\",\"^76\"]]]]],\"^2B\",\"Returns a sorted seq from coll in either ascending or descending order.\\n     If ascending is true, the result should contain all items which are > or >=\\n     than k. If ascending is false, the result should contain all items which\\n     are < or <= than k, e.g.\\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)\"],\"~$println-str\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10266,\"^26\",7,\"^2:\",10266,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"~$objs\"]]]]],\"^2B\",\"println to a string, returning it\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/println-str\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^3J\"]],\"^29\",10266,\"^2H\",\"^2S\",\"^2:\",10266,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2B\",\"println to a string, returning it\"],\"~$inst-ms\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1387,\"^26\",7,\"^2:\",1387,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$inst\"]]]]],\"^2B\",\"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"],\"^1;\",\"~$cljs.core/inst-ms\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^7<\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1387,\"^2H\",\"^2S\",\"^2:\",1387,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7<\"]]]]],\"^2B\",\"Return the number of milliseconds since January 1, 1970, 00:00:00 GMT\"],\"~$linear-traversal-nth\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1835,\"^26\",8,\"^2:\",1835,\"^25\",28,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"~$not-found\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/linear-traversal-nth\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^4C\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\",\"^4C\"]]]],\"^29\",1835,\"^2:\",1835,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]]],\"~$iterate\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5080,\"^26\",7,\"^2:\",5080,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"~$x\"]]]]],\"^2B\",\"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\",\"~:added\",\"1.0\"],\"^7B\",\"1.0\",\"^1;\",\"~$cljs.core/iterate\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$f\",\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5080,\"^2H\",\"~$cljs.core/Iterate\",\"^2:\",5080,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"~$x\"]]]]],\"^2B\",\"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"],\"~$checked-aget'\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",480,\"^26\",8,\"^2:\",480,\"^25\",21,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$array\",\"~$idx\"],[\"^7F\",\"^7G\",\"~$&\",\"~$idxs\"]]]]],\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/checked-aget'\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",480,\"^2:\",480,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]]],\"~$-empty\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",577,\"^26\",4,\"^2:\",577,\"^25\",10,\"^69\",\"^1X\",\"^2B\",\"Returns an empty collection of the same category as coll. Used\\n     by cljs.core/empty.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^1X\",\"^1;\",\"~$cljs.core/-empty\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",575,\"^2H\",\"^2S\",\"^2:\",577,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns an empty collection of the same category as coll. Used\\n     by cljs.core/empty.\"],\"~$newline\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10221,\"^26\",7,\"^2:\",10221,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^2M\"]]]]],\"^2B\",\"Prints a newline using *print-fn*\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^2M\"]]],\"^2;\",[\"^2<\",[[],[\"^2M\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/newline\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^2M\"]]],\"^2;\",[\"^2<\",[[],[\"^2M\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[],[\"^2M\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^4C\"]],\"^29\",10221,\"^2:\",10221,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^2M\"]]],\"^2B\",\"Prints a newline using *print-fn*\"],\"~$ILookup\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",14,\"^29\",619,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-lookup\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]]],\"^2:\",619,\"^2B\",\"Protocol for looking up a value in a data structure.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^23\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",1,\"^29\",619,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^7O\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]]],\"^3:\",null,\"^2:\",619,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^3<\",\"^59\",\"^5:\",\"^2U\",\"^5;\",\"^3=\",\"~$cljs.core/TaggedLiteral\",\"^5<\",\"^3>\",\"~$cljs.core/TransientHashSet\",\"^2I\",\"^5=\",\"~$cljs.core/PersistentTreeSet\",\"^5>\"]],\"^2B\",\"Protocol for looking up a value in a data structure.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$-chunked-rest\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",831,\"^26\",4,\"^2:\",831,\"^25\",17,\"^69\",\"~$cljs.core/IChunkedSeq\",\"^2B\",\"Return a new collection of coll with the first chunk removed.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^7T\",\"^1;\",\"~$cljs.core/-chunked-rest\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",827,\"^2H\",\"^2S\",\"^2:\",831,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Return a new collection of coll with the first chunk removed.\"],\"~$write-all\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10049,\"^26\",7,\"^2:\",10049,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$writer\",\"~$&\",\"~$ss\"]]]]],\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"^7W\",\"^7X\"]]],\"^2;\",[\"^2<\",[[\"^7W\",\"~$&\",\"^7X\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/write-all\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"^7W\",\"^7X\"]]],\"^2;\",[\"^2<\",[[\"^7W\",\"~$&\",\"^7X\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^7W\",\"^7X\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",\"^4C\"]],\"^29\",10049,\"^2H\",\"^2S\",\"^2:\",10049,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7W\",\"~$&\",\"^7X\"]]]],\"~$fn?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2008,\"^26\",7,\"^2:\",2008,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Return true if f is a JavaScript function or satisfies the Fn protocol.\"],\"^1;\",\"~$cljs.core/fn?\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2008,\"^2H\",\"^3D\",\"^2:\",2008,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Return true if f is a JavaScript function or satisfies the Fn protocol.\"],\"~$-prefer-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11015,\"^26\",4,\"^2:\",11015,\"^25\",18,\"^69\",\"~$cljs.core/IMultiFn\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$mf\",\"~$dispatch-val\",\"~$dispatch-val-y\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-prefer-method\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^82\",\"^83\",\"^84\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11015,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\",\"^84\"]]]]],\"^2B\",null],\"~$-assoc\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"~$cljs.core/IAssociative\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",9,\"^29\",630,\"^2:\",630,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\",\"~$v\"]]]]],\"^2B\",\"Returns a new collection of coll with a mapping from key k to\\n     value v added to it.\"],\"^69\",\"^87\",\"^1;\",\"~$cljs.core/-assoc\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2X\",\"~$k\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",625,\"^2H\",\"^2T\",\"^2:\",630,\"^2J\",3,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\",\"~$v\"]]]]],\"^2B\",\"Returns a new collection of coll with a mapping from key k to\\n     value v added to it.\"],\"~$doall\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9948,\"^26\",7,\"^2:\",9948,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]]]],\"^2B\",\"When lazy sequences are produced via functions that have side\\n  effects, any effects other than those needed to produce the first\\n  element in the seq do not occur until the seq is consumed. doall can\\n  be used to force any effects. Walks through the successive nexts of\\n  the seq, retains the head and returns it, thus causing the entire\\n  seq to reside in memory at one time.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/doall\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false]],\"^29\",9948,\"^2:\",9948,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2B\",\"When lazy sequences are produced via functions that have side\\n  effects, any effects other than those needed to produce the first\\n  element in the seq do not occur until the seq is consumed. doall can\\n  be used to force any effects. Walks through the successive nexts of\\n  the seq, retains the head and returns it, thus causing the entire\\n  seq to reside in memory at one time.\"],\"~$keyword-identical?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3335,\"^26\",7,\"^2:\",3335,\"^25\",25,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Efficient test to determine that two keywords are identical.\"],\"^1;\",\"~$cljs.core/keyword-identical?\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3335,\"^2H\",\"^3D\",\"^2:\",3335,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Efficient test to determine that two keywords are identical.\"],\"~$*print-err-fn*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",84,\"^26\",3,\"^2:\",84,\"^25\",17,\"^2B\",\"Each runtime environment provides a different way to print error output.\\n  Whatever function *print-err-fn* is bound to will be passed any\\n  Strings which should be printed.\",\"^6R\",true],\"^1;\",\"~$cljs.core/*print-err-fn*\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",1,\"^6R\",true,\"^29\",80,\"^2:\",84,\"^2R\",\"^4C\",\"^2B\",\"Each runtime environment provides a different way to print error output.\\n  Whatever function *print-err-fn* is bound to will be passed any\\n  Strings which should be printed.\"],\"~$pv-aset\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5351,\"^26\",8,\"^2:\",5351,\"^25\",15,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$node\",\"^7G\",\"^37\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pv-aset\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^8@\",\"^7G\",\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5351,\"^2H\",\"^2S\",\"^2:\",5351,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\",\"^7G\",\"^37\"]]]]]],\"~$prefers\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11235,\"^26\",7,\"^2:\",11235,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$multifn\"]]]]],\"^2B\",\"Given a multimethod, returns a map of preferred value -> set of other values\"],\"^1;\",\"~$cljs.core/prefers\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^8C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11235,\"^2H\",\"^2S\",\"^2:\",11235,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, returns a map of preferred value -> set of other values\"],\"~$-js->clj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10742,\"^26\",4,\"^2:\",10742,\"^25\",12,\"^69\",\"~$cljs.core/IEncodeClojure\",\"^2B\",\"Transforms JavaScript values to Clojure\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$options\"]]]]]],\"^69\",\"^8F\",\"^1;\",\"~$cljs.core/-js->clj\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\",\"^8G\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10741,\"^2H\",\"^2S\",\"^2:\",10742,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"^8G\"]]]]],\"^2B\",\"Transforms JavaScript values to Clojure\"],\"~$LazySeq\",[\"^ \",\"^41\",4,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"~$cljs.core/IPending\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^3U\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",3412,\"^46\",false,\"^2:\",3412,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$dedupe\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10622,\"^26\",7,\"^2:\",10622,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence removing consecutive duplicates in coll.\\n  Returns a transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^2X\"]]],\"^2;\",[\"^2<\",[[],[\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/dedupe\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^2X\"]]],\"^2;\",[\"^2<\",[[],[\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[],[\"^2X\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2T\"]],\"^29\",10622,\"^2:\",10622,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^2X\"]]],\"^2B\",\"Returns a lazy sequence removing consecutive duplicates in coll.\\n  Returns a transducer when no collection is provided.\"],\"~$unchecked-editable-array-for\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6024,\"^26\",8,\"^2:\",6024,\"^25\",36,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$tv\",\"~$i\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/unchecked-editable-array-for\",\"^24\",\"cljs/core.cljs\",\"^25\",36,\"^2D\",[\"^2<\",[[\"^8N\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6024,\"^2H\",\"^2S\",\"^2:\",6024,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8N\",\"~$i\"]]]]]],\"~$->ES6Iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",10,\"^27\",\"^28\",\"^29\",1280,\"^2:\",1280,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ES6Iterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->ES6Iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",1280,\"^2H\",\"~$cljs.core/ES6Iterator\",\"^2:\",1280,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ES6Iterator.\"],\"~$VectorNode\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[]],\"^1;\",\"~$cljs.core/VectorNode\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^45\",true,\"^26\",10,\"^29\",5343,\"^46\",false,\"^2:\",5343,\"^2R\",\"^47\",\"^2A\",null],\"~$dissoc\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1994,\"^26\",7,\"^2:\",1994,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"~$ks\"]]]]],\"^2B\",\"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/dissoc\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^4C\"]]],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^4C\"]]]],\"^29\",1994,\"^2:\",1994,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]],\"^2B\",\"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\\n  that does not contain a mapping for key(s).\"],\"~$atom\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4443,\"^26\",7,\"^2:\",4443,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",[\"^ \",\"~:keys\",[\"^2>\",\"~$validator\"]]]]]]],\"^2B\",\"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will become the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",[\"^ \",\"^8Y\",[\"^2>\",\"^8Z\"]]]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/atom\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",[\"^ \",\"^8Y\",[\"^2>\",\"^8Z\"]]]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"~$cljs.core/Atom\"],[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",\"^90\"]],\"^29\",4443,\"^2:\",4443,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$&\",[\"^ \",\"^8Y\",[\"^2>\",\"^8Z\"]]]]],\"^2B\",\"Creates and returns an Atom with an initial value of x and zero or\\n  more options (in any order):\\n\\n  :meta metadata-map\\n\\n  :validator validate-fn\\n\\n  If metadata-map is supplied, it will become the metadata on the\\n  atom. validate-fn must be nil or a side-effect-free fn of one\\n  argument, which will be passed the intended new state on any state\\n  change. If the new state is unacceptable, the validate-fn should\\n  return false or throw an Error.  If either of these error conditions\\n  occur, then the value of the atom will not change.\"],\"~$bit-shift-right\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2899,\"^26\",7,\"^2:\",2899,\"^25\",22,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Bitwise shift right\"],\"^1;\",\"~$cljs.core/bit-shift-right\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2899,\"^2H\",\"^<\",\"^2:\",2899,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Bitwise shift right\"],\"~$MapEntry\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1977,\"^26\",47,\"^2:\",1977,\"^25\",55,\"^5M\",true],\"^41\",3,\"^1P\",[\"^1:\",[\"^5N\",\"~$cljs.core/IVector\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"~$cljs.core/IStack\",\"~$cljs.core/IMapEntry\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"^2U\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^45\",true,\"^26\",10,\"^29\",6631,\"^46\",false,\"^5M\",true,\"^2:\",6631,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]]],\"~$*clojurescript-version*\",[\"^ \",\"^1;\",\"~$cljs.core/*clojurescript-version*\",\"^24\",\"cljs/core.cljs\",\"^29\",19,\"^26\",1,\"^2:\",19,\"^25\",29,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",19,\"^26\",6,\"^2:\",19,\"^25\",29],\"^2R\",\"^3J\"],\"~$-first\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",603,\"^26\",4,\"^2:\",603,\"^25\",10,\"^69\",\"^4J\",\"^2B\",\"Returns the first item in the collection coll. Used by cljs.core/first.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^4J\",\"^1;\",\"~$cljs.core/-first\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",601,\"^2H\",\"^2S\",\"^2:\",603,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the first item in the collection coll. Used by cljs.core/first.\"],\"~$peek\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2082,\"^26\",7,\"^2:\",2082,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"],\"^1;\",\"~$cljs.core/peek\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2082,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",2082,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"For a list or queue, same as first, for a vector, same as, but much\\n  more efficient than, last. If the collection is empty, returns nil.\"],\"~$IKVReduce\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",14,\"^29\",697,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-kv-reduce\",[[\"^2X\",\"~$f\",\"~$init\"]]]],\"^2:\",697,\"^2B\",\"Protocol for associative types that can reduce themselves\\n  via a function of key and val. Called by cljs.core/reduce-kv.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/IKVReduce\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",1,\"^29\",697,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^9>\",[[\"^2X\",\"~$f\",\"^9?\"]]]],\"^3:\",null,\"^2:\",697,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^59\",\"^5;\",\"^5<\",\"^5=\"]],\"^2B\",\"Protocol for associative types that can reduce themselves\\n  via a function of key and val. Called by cljs.core/reduce-kv.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$iter-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2481,\"^26\",8,\"^2:\",2481,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/iter-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2481,\"^2:\",2481,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^9?\"]]]],\"~$aget\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",496,\"^26\",7,\"^2:\",496,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]]]],\"^2B\",\"Returns the value at the index/indices. Works on JavaScript arrays.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/aget\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",496,\"^2:\",496,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\"],[\"^7F\",\"^7G\",\"~$&\",\"^7H\"]]],\"^2B\",\"Returns the value at the index/indices. Works on JavaScript arrays.\"],\"~$PersistentTreeMapSeq\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/PersistentTreeMapSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^45\",true,\"^26\",10,\"^29\",8156,\"^46\",false,\"^2:\",8156,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$-write\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",752,\"^26\",4,\"^2:\",752,\"^25\",10,\"^69\",\"~$cljs.core/IWriter\",\"^2B\",\"Writes s with writer and returns the result.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7W\",\"~$s\"]]]]]],\"^69\",\"^9H\",\"^1;\",\"~$cljs.core/-write\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^7W\",\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",750,\"^2H\",\"^2S\",\"^2:\",752,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7W\",\"~$s\"]]]]],\"^2B\",\"Writes s with writer and returns the result.\"],\"~$->t_cljs$core9576\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"~:anonymous\",true,\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]],\"^27\",\"^28\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$meta9577\"]]]]],\"^2B\",\"Positional factory function for cljs.core/t_cljs$core9576.\",\"^24\",\"cljs/core.cljs\"],\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^1;\",\"~$cljs.core/->t_cljs$core9576\",\"^24\",\"cljs/core.cljs\",\"^2D\",[\"^2<\",[[\"^9L\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^9K\",true,\"^26\",3,\"^2G\",false,\"^27\",\"^28\",\"^29\",4000,\"^2H\",\"~$cljs.core/t_cljs$core9576\",\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^9L\"]]]]],\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/t_cljs$core9576.\"],\"^4L\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4054,\"^26\",7,\"^2:\",4054,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^1;\",\"~$cljs.core/iter\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4054,\"^2H\",[\"^1:\",[\"^2T\",\"^2S\"]],\"^2:\",4054,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"~$mk-bound-fn\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9599,\"^26\",7,\"^2:\",9599,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$sc\",\"~$test\",\"^36\"]]]]]],\"^1;\",\"~$cljs.core/mk-bound-fn\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9599,\"^2H\",\"^47\",\"^2:\",9599,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"]]]]]],\"~$last\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1768,\"^26\",7,\"^2:\",1768,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Return the last item in coll, in linear time\"],\"^1;\",\"~$cljs.core/last\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1768,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",1768,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Return the last item in coll, in linear time\"],\"~$-default-dispatch-val\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11019,\"^26\",4,\"^2:\",11019,\"^25\",25,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-default-dispatch-val\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^82\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11019,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]],\"^2B\",null],\"~$pr\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10239,\"^26\",7,\"^2:\",10239,\"^25\",9,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^79\"]]]]],\"^2B\",\"Prints the object(s) using string-print.  Prints the\\n  object(s), separated by spaces if there is more than one.\\n  By default, pr and prn print in a way that objects can be\\n  read by the reader\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/pr\",\"^24\",\"cljs/core.cljs\",\"^25\",9,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^4C\"]],\"^29\",10239,\"^2H\",\"^2S\",\"^2:\",10239,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2B\",\"Prints the object(s) using string-print.  Prints the\\n  object(s), separated by spaces if there is more than one.\\n  By default, pr and prn print in a way that objects can be\\n  read by the reader\"],\"~$tree-map-seq-push\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8149,\"^26\",8,\"^2:\",8149,\"^25\",25,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\",\"^@\",\"^76\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tree-map-seq-push\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^8@\",\"^@\",\"^76\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8149,\"^2:\",8149,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\",\"^@\",\"^76\"]]]]]],\"~$namespace\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3353,\"^26\",7,\"^2:\",3353,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the namespace String of a symbol or keyword, or nil if not present.\"],\"^1;\",\"~$cljs.core/namespace\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3353,\"^2H\",[\"^1:\",[\"^3J\",\"^4C\"]],\"^2:\",3353,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the namespace String of a symbol or keyword, or nil if not present.\"],\"~$empty-unordered-hash\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1354,\"^26\",16,\"^2:\",1354,\"^25\",36,\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/empty-unordered-hash\",\"^24\",\"cljs/core.cljs\",\"^25\",36,\"^26\",1,\"^29\",1354,\"^2:\",1354,\"^2R\",\"^<\"],\"~$obj-map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8901,\"^26\",7,\"^2:\",8901,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"~$keyvals\"]]]]],\"^2B\",\"keyval => key val\\n  Returns a new object map with supplied mappings.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^:5\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^:5\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/obj-map\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^:5\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^:5\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^:5\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",8901,\"^2H\",\"^2S\",\"^2:\",8901,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^:5\"]]],\"^2B\",\"keyval => key val\\n  Returns a new object map with supplied mappings.\"],\"~$Reduced\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^43\"]],\"^1;\",\"~$cljs.core/Reduced\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",1420,\"^46\",false,\"^2:\",1420,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^43\"]]],\"~$-conj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^1T\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",9,\"^29\",583,\"^2:\",583,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$o\"]]]]],\"^2B\",\"Returns a new collection of coll with o added to it. The new item\\n     should be added to the most efficient place, e.g.\\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)\"],\"^69\",\"^1T\",\"^1;\",\"~$cljs.core/-conj\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\",\"~$o\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",581,\"^2H\",\"^2T\",\"^2:\",583,\"^2J\",2,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$o\"]]]]],\"^2B\",\"Returns a new collection of coll with o added to it. The new item\\n     should be added to the most efficient place, e.g.\\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)\"],\"~$NodeSeq\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/NodeSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",7691,\"^46\",false,\"^2:\",7691,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$=\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",1261,\"^2:\",1261,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"],\"^1;\",\"~$cljs.core/=\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",1261,\"^2H\",\"^3D\",\"^2:\",1261,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Equality. Returns true if x equals y, false if not. Compares\\n  numbers and collections in a type-independent manner.  Clojure's immutable data\\n  structures define -equiv (and thus =) as a value, not an identity,\\n  comparison.\"],\"~$ITransientMap\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",14,\"^29\",799,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-dissoc!\",[[\"^35\",\"^36\"]]]],\"^2:\",799,\"^2B\",\"Protocol for adding mapping functionality to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/ITransientMap\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",1,\"^29\",799,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^:?\",[[\"^35\",\"^36\"]]]],\"^3:\",null,\"^2:\",799,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^3=\",\"^3>\"]],\"^2B\",\"Protocol for adding mapping functionality to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$push-tail\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5373,\"^26\",8,\"^2:\",5373,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"~$level\",\"~$parent\",\"~$tailnode\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/push-tail\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^6J\",\"^:B\",\"^:C\",\"^:D\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5373,\"^2H\",\"^8T\",\"^2:\",5373,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"^:B\",\"^:C\",\"^:D\"]]]]]],\"~$take\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4740,\"^26\",7,\"^2:\",4740,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/take\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",4740,\"^2:\",4740,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of the first n items in coll, or all items if\\n  there are fewer than n.  Returns a stateful transducer when\\n  no collection is provided.\"],\"~$vector?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2163,\"^26\",7,\"^2:\",2163,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies IVector\"],\"^1;\",\"~$cljs.core/vector?\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2163,\"^2H\",\"^3D\",\"^2:\",2163,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies IVector\"],\"~$array-index-of-equiv?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6590,\"^26\",8,\"^2:\",6590,\"^25\",29,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-index-of-equiv?\",\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^2D\",[\"^2<\",[[\"^6B\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6590,\"^2H\",\"^<\",\"^2:\",6590,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"~$bitmap-indexed-node-index\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7153,\"^26\",8,\"^2:\",7153,\"^25\",33,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$bitmap\",\"~$bit\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/bitmap-indexed-node-index\",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2D\",[\"^2<\",[[\"^:M\",\"^:N\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7153,\"^2H\",\"^<\",\"^2:\",7153,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:M\",\"^:N\"]]]]]],\"^3D\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2246,\"^26\",7,\"^2:\",2246,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to boolean\"],\"^1;\",\"~$cljs.core/boolean\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2246,\"^2H\",\"^3D\",\"^2:\",2246,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to boolean\"],\"~$IChunk\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",14,\"^29\",822,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-drop-first\",[[\"^2X\"]]]],\"^2:\",822,\"^2B\",\"Protocol for accessing the items of a chunk.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/IChunk\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",822,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^:R\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",822,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"~$cljs.core/RangeChunk\",\"~$cljs.core/ArrayChunk\"]],\"^2B\",\"Protocol for accessing the items of a chunk.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$bit-shift-left\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2895,\"^26\",7,\"^2:\",2895,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Bitwise shift left\"],\"^1;\",\"~$cljs.core/bit-shift-left\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2895,\"^2H\",\"^<\",\"^2:\",2895,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Bitwise shift left\"],\"~$random-uuid\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11280,\"^26\",7,\"^2:\",11280,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"^1;\",\"~$cljs.core/random-uuid\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11280,\"^2:\",11280,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"~$any?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",275,\"^26\",7,\"^2:\",275,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if given any argument.\"],\"^1;\",\"~$cljs.core/any?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",275,\"^2H\",\"^3D\",\"^2:\",275,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if given any argument.\"],\"~$rand-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10816,\"^26\",7,\"^2:\",10816,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns a random integer between 0 (inclusive) and n (exclusive).\"],\"^1;\",\"~$cljs.core/rand-int\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10816,\"^2H\",\"^2S\",\"^2:\",10816,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns a random integer between 0 (inclusive) and n (exclusive).\"],\"~$aclone\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",426,\"^26\",7,\"^2:\",426,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"]]]]],\"^2B\",\"Returns a javascript array, cloned from the passed in array\"],\"^1;\",\"~$cljs.core/aclone\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",426,\"^2H\",\"^7F\",\"^2:\",426,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"]]]]],\"^2B\",\"Returns a javascript array, cloned from the passed in array\"],\"~$BlackNode\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8230,\"^26\",18,\"^2:\",8230,\"^25\",27,\"^5M\",true],\"^41\",5,\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"^5:\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^45\",true,\"^26\",10,\"^29\",8330,\"^46\",false,\"^5M\",true,\"^2:\",8330,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]]],\"~$vreset!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4574,\"^26\",7,\"^2:\",4574,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$vol\",\"~$newval\"]]]]],\"^2B\",\"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"],\"^1;\",\"~$cljs.core/vreset!\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^;6\",\"^;7\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4574,\"^2H\",\"^2S\",\"^2:\",4574,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;6\",\"^;7\"]]]]],\"^2B\",\"Sets the value of volatile to newval without regard for the\\n   current value. Returns newval.\"],\"~$chunk\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3625,\"^26\",7,\"^2:\",3625,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$b\"]]]]]],\"^1;\",\"~$cljs.core/chunk\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$b\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3625,\"^2H\",\"^2S\",\"^2:\",3625,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$b\"]]]]]],\"~$UNREALIZED-SEED\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5019,\"^26\",16,\"^2:\",5019,\"^25\",31,\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/UNREALIZED-SEED\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^26\",1,\"^29\",5019,\"^2:\",5019,\"^2R\",\"^4>\"],\"~$dec\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2677,\"^26\",7,\"^2:\",2677,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one less than num.\"],\"^1;\",\"~$cljs.core/dec\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2677,\"^2H\",\"^<\",\"^2:\",2677,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one less than num.\"],\"~$->TransformerIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^26\",10,\"^27\",\"^28\",\"^29\",4136,\"^2:\",4136,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$buffer\",\"~$_next\",\"~$completed\",\"~$xf\",\"~$sourceIter\",\"~$multi\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/TransformerIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->TransformerIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^2D\",[\"^2<\",[[\"^;@\",\"^;A\",\"^;B\",\"^;C\",\"^;D\",\"^;E\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4136,\"^2H\",\"~$cljs.core/TransformerIterator\",\"^2:\",4136,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;@\",\"^;A\",\"^;B\",\"^;C\",\"^;D\",\"^;E\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/TransformerIterator.\"],\"~$APersistentVector\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^26\",14,\"^29\",5478,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",5478,\"^2B\",\"Marker protocol\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/APersistentVector\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^26\",1,\"^29\",5478,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",5478,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^5<\"]],\"^2B\",\"Marker protocol\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4693,\"^26\",7,\"^2:\",4693,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"~$c1\",\"~$c2\"],[\"~$f\",\"^;K\",\"^;L\",\"~$c3\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"~$colls\"]]]]],\"^2B\",\"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/map\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",4,\"^2G\",true,\"^2R\",\"^3U\"]],\"^29\",4693,\"^2:\",4693,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]],\"^2B\",\"Returns a lazy sequence consisting of the result of applying f to\\n  the set of first items of each coll, followed by applying f to the\\n  set of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments. Returns a transducer when\\n  no collection is provided.\"],\"~$juxt\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9899,\"^26\",7,\"^2:\",9899,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"~$f\",\"~$g\",\"~$h\",\"~$&\",\"~$fs\"]]]]],\"^2B\",\"Takes a set of functions and returns a fn that is the juxtaposition\\n  of those fns.  The returned fn takes a variable number of args, and\\n  returns a vector containing the result of applying each fn to the\\n  args (left-to-right).\\n  ((juxt a b c) x) => [(a x) (b x) (c x)]\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"~$f\",\"~$g\",\"~$h\",\"~$&\",\"^;Q\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/juxt\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"~$f\",\"~$g\",\"~$h\",\"~$&\",\"^;Q\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^47\"]],\"^29\",9899,\"^2:\",9899,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"~$f\",\"~$g\",\"~$h\",\"~$&\",\"^;Q\"]]],\"^2B\",\"Takes a set of functions and returns a fn that is the juxtaposition\\n  of those fns.  The returned fn takes a variable number of args, and\\n  returns a vector containing the result of applying each fn to the\\n  args (left-to-right).\\n  ((juxt a b c) x) => [(a x) (b x) (c x)]\"],\"~$->PersistentQueueIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^26\",10,\"^27\",\"^28\",\"^29\",6173,\"^2:\",6173,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$fseq\",\"~$riter\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/PersistentQueueIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->PersistentQueueIter\",\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^2D\",[\"^2<\",[[\"^;T\",\"^;U\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6173,\"^2H\",\"~$cljs.core/PersistentQueueIter\",\"^2:\",6173,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;T\",\"^;U\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/PersistentQueueIter.\"],\"~$<\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",2629,\"^2:\",2629,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"],\"^1;\",\"~$cljs.core/<\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",2629,\"^2H\",\"^3D\",\"^2:\",2629,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns non-nil if nums are in monotonically increasing order,\\n  otherwise false.\"],\"~$*eval*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11713,\"^26\",3,\"^2:\",11713,\"^25\",9,\"^2B\",\"Runtime environments may provide a way to evaluate ClojureScript\\n  forms. Whatever function *eval* is bound to will be passed any forms which\\n  should be evaluated.\",\"^6R\",true],\"^1;\",\"~$cljs.core/*eval*\",\"^24\",\"cljs/core.cljs\",\"^25\",9,\"^2D\",[\"^2<\",[[\"~$_\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[]],\"^26\",1,\"^2G\",false,\"^6R\",true,\"^29\",11709,\"^2H\",\"~$ignore\",\"^2:\",11713,\"^2J\",1,\"^2K\",true,\"^2;\",null,\"^2B\",\"Runtime environments may provide a way to evaluate ClojureScript\\n  forms. Whatever function *eval* is bound to will be passed any forms which\\n  should be evaluated.\"],\"~$inode-kv-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7170,\"^26\",8,\"^2:\",7170,\"^25\",23,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$f\",\"^9?\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/inode-kv-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^6B\",\"~$f\",\"^9?\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7170,\"^2H\",[\"^1:\",[null,\"^:8\"]],\"^2:\",7170,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$f\",\"^9?\"]]]]]],\"~$obj-map->hash-map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6370,\"^26\",8,\"^2:\",6370,\"^25\",25,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$v\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/obj-map->hash-map\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6370,\"^2H\",\"^2T\",\"^2:\",6370,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$v\"]]]]]],\"^9R\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11381,\"^26\",7,\"^2:\",11381,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\"]]]]],\"^2B\",\"test [v] finds fn at key :test in var metadata and calls it,\\n  presuming failure will throw exception\"],\"^1;\",\"~$cljs.core/test\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11381,\"^2H\",\"~$cljs.core/Keyword\",\"^2:\",11381,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\"]]]]],\"^2B\",\"test [v] finds fn at key :test in var metadata and calls it,\\n  presuming failure will throw exception\"],\"~$rest\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1239,\"^26\",12,\"^2:\",1239,\"^25\",16,\"^2R\",\"^2[\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"],\"^1;\",\"~$cljs.core/rest\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1239,\"^2H\",\"^2[\",\"^2:\",1239,\"^2J\",1,\"^2R\",\"^2[\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a possibly empty seq of the items after the first. Calls seq on its\\n  argument.\"],\"~$ex-data\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11345,\"^26\",7,\"^2:\",11345,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$ex\"]]]]],\"^2B\",\"Returns exception data (a map) if ex is an ExceptionInfo.\\n  Otherwise returns nil.\"],\"^1;\",\"~$cljs.core/ex-data\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^<9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11345,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",11345,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<9\"]]]]],\"^2B\",\"Returns exception data (a map) if ex is an ExceptionInfo.\\n  Otherwise returns nil.\"],\"~$PersistentArrayMapSeq\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/PersistentArrayMapSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^45\",true,\"^26\",10,\"^29\",6731,\"^46\",false,\"^2:\",6731,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"^:R\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",824,\"^26\",4,\"^2:\",824,\"^25\",15,\"^69\",\"^:S\",\"^2B\",\"Return a new chunk of coll with the first item removed.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^:S\",\"^1;\",\"~$cljs.core/-drop-first\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",822,\"^2H\",\"^2S\",\"^2:\",824,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Return a new chunk of coll with the first item removed.\"],\"~$isa?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$child\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]],\"^2;\",[\"^2<\",[[\"^<?\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",16,\"^29\",10856,\"^2:\",10856,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<?\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]]]],\"^2B\",\"Returns true if (= child parent), or child is directly or indirectly derived from\\n  parent, either via a JavaScript type inheritance relationship or a\\n  relationship established via derive. h must be a hierarchy obtained\\n  from make-hierarchy, if not supplied defaults to the global\\n  hierarchy\"],\"^1;\",\"~$cljs.core/isa?\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^<?\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]],\"^2;\",[\"^2<\",[[\"^<?\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^<?\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^3D\"]],\"^29\",10856,\"^2H\",\"^3D\",\"^2:\",10856,\"^2J\",3,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"^<?\",\"^:C\"],[\"~$h\",\"^<?\",\"^:C\"]]],\"^2B\",\"Returns true if (= child parent), or child is directly or indirectly derived from\\n  parent, either via a JavaScript type inheritance relationship or a\\n  relationship established via derive. h must be a hierarchy obtained\\n  from make-hierarchy, if not supplied defaults to the global\\n  hierarchy\"],\"~$boolean?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2221,\"^26\",7,\"^2:\",2221,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a Boolean\"],\"^1;\",\"~$cljs.core/boolean?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2221,\"^2H\",\"^3D\",\"^2:\",2221,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a Boolean\"],\"~$-clone\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^20\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",9,\"^29\",567,\"^2:\",567,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\"]]]]],\"^2B\",\"Creates a clone of value.\"],\"^69\",\"^20\",\"^1;\",\"~$cljs.core/-clone\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^4K\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",565,\"^2H\",\"^2T\",\"^2:\",567,\"^2J\",1,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\"]]]]],\"^2B\",\"Creates a clone of value.\"],\"~$munge\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11490,\"^26\",7,\"^2:\",11490,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\"]]]]]],\"^1;\",\"~$cljs.core/munge\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^:\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11490,\"^2H\",[\"^1:\",[\"^2S\",\"^3J\",\"~$cljs.core/Symbol\"]],\"^2:\",11490,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\"]]]]]],\"~$empty-ordered-hash\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1339,\"^26\",16,\"^2:\",1339,\"^25\",34,\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/empty-ordered-hash\",\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^26\",1,\"^29\",1339,\"^2:\",1339,\"^2R\",\"^<\"],\"~$DEMUNGE_MAP\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",363,\"^26\",3,\"^2:\",363,\"^25\",14,\"^38\",[\"@enum {string}\"]],\"^1;\",\"~$cljs.core/DEMUNGE_MAP\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",1,\"^29\",362,\"^2:\",363,\"^2R\",\"^4>\",\"^38\",[\"@enum {string}\"]],\"~$ES6IteratorSeq\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^4J\",\"^1Z\"]],\"^1;\",\"^4O\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^45\",true,\"^26\",10,\"^29\",1296,\"^46\",false,\"^2:\",1296,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^4J\",\"^1Z\"]]],\"~$->NeverEquiv\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",6319,\"^2:\",6319,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]],\"^2A\",[\"^1:\",[\"^1Q\"]],\"^2B\",\"Positional factory function for cljs.core/NeverEquiv.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1V\"]],\"^1;\",\"~$cljs.core/->NeverEquiv\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6319,\"^2H\",\"~$cljs.core/NeverEquiv\",\"^2:\",6319,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]],\"^2A\",[\"^1:\",[\"^1Q\"]],\"^2B\",\"Positional factory function for cljs.core/NeverEquiv.\"],\"~$re-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10008,\"^26\",7,\"^2:\",10008,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$re\",\"~$s\"]]]]],\"^2B\",\"Returns a lazy sequence of successive matches of re in s.\"],\"^1;\",\"~$cljs.core/re-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^<Q\",\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10008,\"^2H\",[\"^1:\",[\"^2T\",\"^4C\"]],\"^2:\",10008,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]],\"^2B\",\"Returns a lazy sequence of successive matches of re in s.\"],\"~$char?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",270,\"^26\",7,\"^2:\",270,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is a JavaScript string of length one.\"],\"^1;\",\"~$cljs.core/char?\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",270,\"^2H\",\"^3D\",\"^2:\",270,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is a JavaScript string of length one.\"],\"~$make-hierarchy\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10839,\"^26\",7,\"^2:\",10839,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]],\"^2B\",\"Creates a hierarchy object for use with derive, isa? etc.\"],\"^1;\",\"~$cljs.core/make-hierarchy\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10839,\"^2H\",\"~$cljs.core/IMap\",\"^2:\",10839,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]],\"^2B\",\"Creates a hierarchy object for use with derive, isa? etc.\"],\"^E\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",952,\"^26\",15,\"^2:\",952,\"^25\",21,\"^5M\",true],\"^41\",5,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"~$cljs.core/INamed\",\"^1[\",\"^5Z\",\"^22\"]],\"^1;\",\"^<G\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",1060,\"^46\",false,\"^5M\",true,\"^2:\",1060,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^<X\",\"^1[\",\"^5Z\",\"^22\"]]],\"~$PROTOCOL_SENTINEL\",[\"^ \",\"^1;\",\"~$cljs.core/PROTOCOL_SENTINEL\",\"^24\",\"cljs/core.cljs\",\"^29\",37,\"^26\",1,\"^2:\",37,\"^25\",27,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",37,\"^26\",10,\"^2:\",37,\"^25\",27],\"^2R\",\"^4>\"],\"~$tv-push-tail\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5998,\"^26\",8,\"^2:\",5998,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8N\",\"^:B\",\"^:C\",\"~$tail-node\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tv-push-tail\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^8N\",\"^:B\",\"^:C\",\"^=0\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5998,\"^2H\",[\"^1:\",[null,\"^8T\"]],\"^2:\",5998,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8N\",\"^:B\",\"^:C\",\"^=0\"]]]]]],\"~$-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^5Q\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",4,\"^29\",692,\"^2:\",692,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]]]],\"^2B\",\"f should be a function of 2 arguments. If start is not supplied,\\n     returns the result of applying f to the first 2 items in coll, then\\n     applying f to that result and the 3rd item, etc.\"],\"^69\",\"^5Q\",\"^1;\",\"~$cljs.core/-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",689,\"^2:\",692,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]],\"^2B\",\"f should be a function of 2 arguments. If start is not supplied,\\n     returns the result of applying f to the first 2 items in coll, then\\n     applying f to that result and the 3rd item, etc.\"],\"~$-count\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^1Y\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",12,\"^29\",572,\"^2:\",572,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Calculates the count of coll in constant time. Used by cljs.core/count.\"],\"^69\",\"^1Y\",\"^1;\",\"~$cljs.core/-count\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",570,\"^2H\",\"^<\",\"^2:\",572,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Calculates the count of coll in constant time. Used by cljs.core/count.\"],\"~$swap-vals!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^7B\",\"1.9\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",7,\"^29\",4515,\"^2:\",4515,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"],\"^7B\",\"1.9\",\"^1;\",\"~$cljs.core/swap-vals!\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^94\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^94\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^94\"],[\"^ \",\"^2O\",4,\"^2G\",true,\"^2R\",\"^94\"]],\"^29\",4515,\"^2:\",4515,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.\\n  Returns [old new], the value of the atom before and after the swap.\"],\"~$keep\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4380,\"^26\",7,\"^2:\",4380,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/keep\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",4380,\"^2:\",4380,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of the non-nil results of (f item). Note,\\n  this means false return values will be included.  f must be free of\\n  side-effects.  Returns a transducer when no collection is provided.\"],\"~$char\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2697,\"^26\",7,\"^2:\",2697,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to char\"],\"^1;\",\"~$cljs.core/char\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2697,\"^2H\",[\"^1:\",[null,\"~$js\"]],\"^2:\",2697,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to char\"],\"~$mapcat\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^7B\",\"1.0\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"~:static\",true,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",7,\"^29\",5137,\"^2:\",5137,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^;N\"]]]]],\"^2B\",\"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"],\"^7B\",\"1.0\",\"^1;\",\"~$cljs.core/mapcat\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^=>\",true,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",5137,\"^2:\",5137,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^;N\"]]],\"^2B\",\"Returns the result of applying concat to the result of applying map\\n  to f and colls.  Thus function f should return a collection. Returns\\n  a transducer when no collections are provided\"],\"~$unchecked-long\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2811,\"^26\",7,\"^2:\",2811,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to long by stripping decimal places. Identical to `int'.\"],\"^1;\",\"~$cljs.core/unchecked-long\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2811,\"^2H\",\"^<\",\"^2:\",2811,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to long by stripping decimal places. Identical to `int'.\"],\"~$m3-seed\",[\"^ \",\"^1;\",\"~$cljs.core/m3-seed\",\"^24\",\"cljs/core.cljs\",\"^29\",910,\"^26\",1,\"^2:\",910,\"^25\",13,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",910,\"^26\",6,\"^2:\",910,\"^25\",13],\"^2R\",\"^<\"],\"~$some?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",254,\"^26\",16,\"^2:\",254,\"^25\",21,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is not nil, false otherwise.\"],\"^1;\",\"~$cljs.core/some?\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",254,\"^2H\",\"^3D\",\"^2:\",254,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is not nil, false otherwise.\"],\"~$unchecked-negate\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2766,\"^26\",7,\"^2:\",2766,\"^25\",23,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-negate\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2766,\"^2H\",\"^<\",\"^2:\",2766,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$remove-tap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11539,\"^26\",7,\"^2:\",11539,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Remove f from the tap set.\"],\"^1;\",\"~$cljs.core/remove-tap\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11539,\"^2H\",\"^4C\",\"^2:\",11539,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Remove f from the tap set.\"],\"~$symbol-identical?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3344,\"^26\",7,\"^2:\",3344,\"^25\",24,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Efficient test to determine that two symbols are identical.\"],\"^1;\",\"~$cljs.core/symbol-identical?\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3344,\"^2H\",\"^3D\",\"^2:\",3344,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Efficient test to determine that two symbols are identical.\"],\"~$*command-line-args*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",303,\"^26\",3,\"^2:\",303,\"^25\",22,\"^2B\",\"A sequence of the supplied command line arguments, or nil if\\n  none were supplied\"],\"^1;\",\"~$cljs.core/*command-line-args*\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",1,\"^29\",300,\"^2:\",303,\"^2R\",\"^4C\",\"^2B\",\"A sequence of the supplied command line arguments, or nil if\\n  none were supplied\"],\"~$reverse\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3195,\"^26\",7,\"^2:\",3195,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq of the items in coll in reverse order. Not lazy.\"],\"^1;\",\"~$cljs.core/reverse\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3195,\"^2H\",[\"^1:\",[null,\"^2[\",\"^30\",\"^2S\"]],\"^2:\",3195,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq of the items in coll in reverse order. Not lazy.\"],\"~$inst?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1392,\"^26\",7,\"^2:\",1392,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies Inst\"],\"^1;\",\"~$cljs.core/inst?\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1392,\"^2H\",\"^3D\",\"^2:\",1392,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies Inst\"],\"~$range\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9783,\"^26\",7,\"^2:\",9783,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"~$step\"]]]]],\"^2B\",\"Returns a lazy seq of nums from start (inclusive) to end\\n   (exclusive), by step, where start defaults to 0, step to 1,\\n   and end to infinity.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"^=S\"]]],\"^2;\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"^=S\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/range\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"^=S\"]]],\"^2;\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"^=S\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"^=S\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2T\"]],\"^29\",9783,\"^2:\",9783,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^52\"],[\"^51\",\"^52\"],[\"^51\",\"^52\",\"^=S\"]]],\"^2B\",\"Returns a lazy seq of nums from start (inclusive) to end\\n   (exclusive), by step, where start defaults to 0, step to 1,\\n   and end to infinity.\"],\"~$bit-count\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2911,\"^26\",7,\"^2:\",2911,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\"]]]]],\"^2B\",\"Counts the number of bits set in n\"],\"^1;\",\"~$cljs.core/bit-count\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2911,\"^2H\",\"^<\",\"^2:\",2911,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\"]]]]],\"^2B\",\"Counts the number of bits set in n\"],\"~$create-node\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7673,\"^26\",8,\"^2:\",7673,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$shift\",\"~$key1\",\"~$val1\",\"~$key2hash\",\"~$key2\",\"~$val2\"],[\"~$edit\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",7,\"^2J\",7,\"^2D\",[\"^2<\",[[\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"],[\"^>2\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]],\"^2;\",[\"^2<\",[[\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"],[\"^>2\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/create-node\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",7,\"^2J\",7,\"^2D\",[\"^2<\",[[\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"],[\"^>2\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]],\"^2;\",[\"^2<\",[[\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"],[\"^>2\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"],[\"^>2\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]],\"^2E\",null,\"^2O\",7,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",6,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"~$cljs.core/HashCollisionNode\"]]],[\"^ \",\"^2O\",7,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^>4\"]]]],\"^29\",7673,\"^2:\",7673,\"^2J\",7,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"],[\"^>2\",\"^=X\",\"^=Y\",\"^=Z\",\"^=[\",\"^>0\",\"^>1\"]]]],\"~$sort\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2433,\"^26\",7,\"^2:\",2433,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]]]],\"^2B\",\"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/sort\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2[\",\"^30\"]]]],\"^29\",2433,\"^2:\",2433,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2Y\",\"^2X\"]]],\"^2B\",\"Returns a sorted sequence of the items in coll. Comp can be\\n   boolean-valued comparison function, or a -/0/+ valued comparator.\\n   Comp defaults to compare.\"],\"~$->MetaFn\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1S\",\"^1[\",\"^4Q\",\"^22\"]],\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",10,\"^27\",\"^28\",\"^29\",2013,\"^2:\",2013,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$afn\",\"^2>\"]]]]],\"^2A\",[\"^1:\",[\"^1S\",\"^1[\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/MetaFn.\"],\"^1P\",[\"^1:\",[\"^1S\",\"^1[\",\"^4Q\",\"^22\"]],\"^1;\",\"~$cljs.core/->MetaFn\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^>8\",\"^2>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",2013,\"^2H\",\"^5A\",\"^2:\",2013,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>8\",\"^2>\"]]]]],\"^2A\",[\"^1:\",[\"^1S\",\"^1[\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/MetaFn.\"],\"~$unchecked-inc-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2749,\"^26\",7,\"^2:\",2749,\"^25\",24,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-inc-int\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2749,\"^2H\",\"^<\",\"^2:\",2749,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$-compare\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^73\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",12,\"^29\",818,\"^2:\",818,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Returns a negative number, zero, or a positive number when x is logically\\n     'less than', 'equal to', or 'greater than' y.\"],\"^69\",\"^73\",\"^1;\",\"~$cljs.core/-compare\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",816,\"^2H\",\"^<\",\"^2:\",818,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Returns a negative number, zero, or a positive number when x is logically\\n     'less than', 'equal to', or 'greater than' y.\"],\"~$map-indexed\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4352,\"^26\",7,\"^2:\",4352,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/map-indexed\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false]],\"^29\",4352,\"^2:\",4352,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence consisting of the result of applying f to 0\\n  and the first item of coll, followed by applying f to 1 and the second\\n  item in coll, etc, until coll is exhausted. Thus function f should\\n  accept 2 arguments, index and item. Returns a stateful transducer when\\n  no collection is provided.\"],\"~$array-list\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9546,\"^26\",7,\"^2:\",9546,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"^1;\",\"~$cljs.core/array-list\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9546,\"^2H\",\"~$cljs.core/ArrayList\",\"^2:\",9546,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"~$rand-nth\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10820,\"^26\",7,\"^2:\",10820,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Return a random element of the (sequential) collection. Will have\\n  the same performance characteristics as nth for the given\\n  collection.\"],\"^1;\",\"~$cljs.core/rand-nth\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10820,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",10820,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Return a random element of the (sequential) collection. Will have\\n  the same performance characteristics as nth for the given\\n  collection.\"],\"^2Y\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4269,\"^26\",7,\"^2:\",4269,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"~$f1\",\"~$f2\",\"~$f3\",\"~$&\",\"^;Q\"]]]]],\"^2B\",\"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"]]],\"^2;\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"^>E\",\"^>F\",\"^>G\",\"~$&\",\"^;Q\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/comp\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"]]],\"^2;\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"^>E\",\"^>F\",\"^>G\",\"~$&\",\"^;Q\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^47\"]],\"^29\",4269,\"^2:\",4269,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$f\"],[\"~$f\",\"~$g\"],[\"~$f\",\"~$g\",\"~$h\"],[\"^>E\",\"^>F\",\"^>G\",\"~$&\",\"^;Q\"]]],\"^2B\",\"Takes a set of functions and returns a fn that is the composition\\n  of those fns.  The returned fn takes a variable number of args,\\n  applies the rightmost of fns to the args, the next\\n  fn (right-to-left) to the result, etc.\"],\"~$array-chunk\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3536,\"^26\",7,\"^2:\",3536,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"~$off\"],[\"^6B\",\"^>J\",\"^52\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"^>J\"],[\"^6B\",\"^>J\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"^>J\"],[\"^6B\",\"^>J\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/array-chunk\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"^>J\"],[\"^6B\",\"^>J\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"^>J\"],[\"^6B\",\"^>J\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"^>J\"],[\"^6B\",\"^>J\",\"^52\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^:U\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^:U\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^:U\"]],\"^29\",3536,\"^2:\",3536,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^6B\"],[\"^6B\",\"^>J\"],[\"^6B\",\"^>J\",\"^52\"]]]],\"~$dispatch-fn\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11243,\"^26\",7,\"^2:\",11243,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, return it's dispatch-fn.\"],\"^1;\",\"~$cljs.core/dispatch-fn\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^8C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11243,\"^2H\",\"^2S\",\"^2:\",11243,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, return it's dispatch-fn.\"],\"~$bit-shift-right-zero-fill\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2903,\"^26\",7,\"^2:\",2903,\"^25\",32,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"DEPRECATED: Bitwise shift right with zero fill\"],\"^1;\",\"~$cljs.core/bit-shift-right-zero-fill\",\"^24\",\"cljs/core.cljs\",\"^25\",32,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2903,\"^2H\",\"^<\",\"^2:\",2903,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"DEPRECATED: Bitwise shift right with zero fill\"],\"~$js-reserved?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11455,\"^26\",8,\"^2:\",11455,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/js-reserved?\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11455,\"^2H\",\"^2S\",\"^2:\",11455,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$-as-transient\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^1U\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",9,\"^29\",783,\"^2:\",783,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new, transient version of the collection, in constant time.\"],\"^69\",\"^1U\",\"^1;\",\"~$cljs.core/-as-transient\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",781,\"^2H\",\"^2T\",\"^2:\",783,\"^2J\",1,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new, transient version of the collection, in constant time.\"],\"~$dorun\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9935,\"^26\",7,\"^2:\",9935,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]]]],\"^2B\",\"When lazy sequences are produced via functions that have side\\n  effects, any effects other than those needed to produce the first\\n  element in the seq do not occur until the seq is consumed. dorun can\\n  be used to force any effects. Walks through the successive nexts of\\n  the seq, does not retain the head and returns nil.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/dorun\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^4C\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^4C\"]],\"^29\",9935,\"^2:\",9935,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\"],[\"~$n\",\"^2X\"]]],\"^2B\",\"When lazy sequences are produced via functions that have side\\n  effects, any effects other than those needed to produce the first\\n  element in the seq do not occur until the seq is consumed. dorun can\\n  be used to force any effects. Walks through the successive nexts of\\n  the seq, does not retain the head and returns nil.\"],\"~$pr-sequential-writer\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10026,\"^26\",7,\"^2:\",10026,\"^25\",27,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7W\",\"~$print-one\",\"~$begin\",\"~$sep\",\"^52\",\"^2M\",\"^2X\"]]]]]],\"^1;\",\"~$cljs.core/pr-sequential-writer\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^7W\",\"^>W\",\"^>X\",\"^>Y\",\"^52\",\"^2M\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10026,\"^2:\",10026,\"^2J\",7,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7W\",\"^>W\",\"^>X\",\"^>Y\",\"^52\",\"^2M\",\"^2X\"]]]]]],\"~$simple-symbol?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3372,\"^26\",7,\"^2:\",3372,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a symbol without a namespace\"],\"^1;\",\"~$cljs.core/simple-symbol?\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3372,\"^2H\",\"^3D\",\"^2:\",3372,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a symbol without a namespace\"],\"~$accumulating-seq-count\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1808,\"^26\",8,\"^2:\",1808,\"^25\",30,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/accumulating-seq-count\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1808,\"^2H\",\"^<\",\"^2:\",1808,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"~$IIndexed\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",14,\"^29\",592,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-nth\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]]],\"^2:\",592,\"^2B\",\"Protocol for collections to provide indexed-based access to their items.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^5N\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",1,\"^29\",592,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^?4\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]]],\"^3:\",null,\"^2:\",592,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^:T\",\"^3<\",\"^5R\",\"^5:\",\"^2U\",\"^5;\",\"^5<\",\"^:U\",\"~$cljs.core/Range\",\"^5>\"]],\"^2B\",\"Protocol for collections to provide indexed-based access to their items.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$disj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2097,\"^26\",7,\"^2:\",2097,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]]]],\"^2B\",\"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/disj\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"]]],\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^4C\"]]],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^4C\"]]]],\"^29\",2097,\"^2:\",2097,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\"],[\"^2X\",\"~$k\"],[\"^2X\",\"~$k\",\"~$&\",\"^8V\"]]],\"^2B\",\"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"],\"~$MultiIterator\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/MultiIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^45\",true,\"^26\",10,\"^29\",4109,\"^46\",false,\"^2:\",4109,\"^2R\",\"^47\",\"^2A\",null],\"~$IPrintWithWriter\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^26\",14,\"^29\",757,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-pr-writer\",[[\"~$o\",\"^7W\",\"^2M\"]]]],\"^2:\",757,\"^2B\",\"The old IPrintable protocol's implementation consisted of building a giant\\n   list of strings to concatenate.  This involved lots of concat calls,\\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\\n   be implemented efficiently in terms of e.g. a StringBuffer append.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^5Z\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^26\",1,\"^29\",757,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^?;\",[[\"~$o\",\"^7W\",\"^2M\"]]]],\"^3:\",null,\"^2:\",757,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"~$cljs.core/Cons\",\"^3O\",\"^59\",\"^:<\",\"~$cljs.core/PersistentQueue\",\"^5R\",\"^44\",\"^<5\",\"^5:\",\"^2U\",\"~$cljs.core/EmptyList\",\"~$cljs.core/Delay\",\"^3U\",\"^5;\",\"^4[\",\"~$cljs.core/ExceptionInfo\",\"^4R\",\"~$cljs.core/ArrayNodeSeq\",\"~$cljs.core/ValSeq\",\"^7P\",\"~$cljs.core/Cycle\",\"^4O\",\"^<<\",\"^5<\",\"~$cljs.core/List\",\"~$cljs.core/Repeat\",\"^;G\",\"~$cljs.core/RSeq\",\"^7D\",\"^2I\",\"^5=\",\"~$cljs.core/KeySeq\",\"~$cljs.core/ChunkedSeq\",\"^90\",\"^7R\",\"~$cljs.core/ChunkedCons\",\"^<G\",\"^3Z\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"The old IPrintable protocol's implementation consisted of building a giant\\n   list of strings to concatenate.  This involved lots of concat calls,\\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\\n   be implemented efficiently in terms of e.g. a StringBuffer append.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->UUID\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\",\"^5Z\",\"^73\",\"^4;\"]],\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",10,\"^27\",\"^28\",\"^29\",11250,\"^2:\",11250,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3X\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5Z\",\"^73\"]],\"^2B\",\"Positional factory function for cljs.core/UUID.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\",\"^5Z\",\"^73\",\"^4;\"]],\"^1;\",\"~$cljs.core/->UUID\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^3X\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",11250,\"^2H\",\"^3Z\",\"^2:\",11250,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3X\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5Z\",\"^73\"]],\"^2B\",\"Positional factory function for cljs.core/UUID.\"],\"~$IVector\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",14,\"^29\",666,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-assoc-n\",[[\"^2X\",\"~$n\",\"^37\"]]]],\"^2:\",666,\"^2B\",\"Protocol for adding vector functionality to collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^94\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",1,\"^29\",666,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^?M\",[[\"^2X\",\"~$n\",\"^37\"]]]],\"^3:\",null,\"^2:\",666,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^5:\",\"^2U\",\"^5;\",\"^5<\",\"^5>\"]],\"^2B\",\"Protocol for adding vector functionality to collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$IIterable\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",14,\"^29\",865,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^6O\",[[\"^2X\"]]]],\"^2:\",865,\"^2B\",\"Protocol for iterating over a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^21\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",1,\"^29\",865,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^6O\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",865,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^3O\",\"^59\",\"^?=\",\"^5R\",\"^5;\",\"^5<\",\"~$cljs.core/ArrayNode\",\"^2I\",\"^>4\",\"^?5\",\"~$cljs.core/BitmapIndexedNode\"]],\"^2B\",\"Protocol for iterating over a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->MultiIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",10,\"^27\",\"^28\",\"^29\",4109,\"^2:\",4109,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$iters\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/MultiIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->MultiIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^?R\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4109,\"^2H\",\"^?9\",\"^2:\",4109,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^?R\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/MultiIterator.\"],\"~$*2\",[\"^ \",\"^1;\",\"~$cljs.core/*2\",\"^24\",\"cljs/core.cljs\",\"^29\",203,\"^26\",1,\"^2:\",205,\"^25\",5,\"^2B\",\"bound in a repl thread to the second most recent value printed\",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",205,\"^26\",3,\"^2:\",205,\"^25\",5,\"^2B\",\"bound in a repl thread to the second most recent value printed\"]],\"^J\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11717,\"^26\",7,\"^2:\",11717,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$form\"]]]]],\"^2B\",\"Evaluates the form data structure (not text!) and returns the result.\\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\\n  which sets up an implementation of cljs.core/*eval* for that environment.\"],\"^1;\",\"~$cljs.core/eval\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^?V\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11717,\"^2H\",\"^;[\",\"^2:\",11717,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^?V\"]]]]],\"^2B\",\"Evaluates the form data structure (not text!) and returns the result.\\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\\n  which sets up an implementation of cljs.core/*eval* for that environment.\"],\"~$Eduction\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1V\",\"^1Z\",\"^5Z\",\"^21\",\"^4W\",\"^5Q\"]],\"^1;\",\"^3O\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^45\",true,\"^26\",10,\"^29\",10649,\"^46\",false,\"^2:\",10649,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Z\",\"^5Z\",\"^21\",\"^4W\",\"^5Q\"]]],\"~$pv-clone-node\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5354,\"^26\",8,\"^2:\",5354,\"^25\",21,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pv-clone-node\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^8@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5354,\"^2H\",\"^8T\",\"^2:\",5354,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\"]]]]]],\"~$cons\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3279,\"^26\",7,\"^2:\",3279,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"^2X\"]]]]],\"^2B\",\"Returns a new seq where x is the first element and coll is the rest.\"],\"^1;\",\"~$cljs.core/cons\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3279,\"^2H\",\"^2T\",\"^2:\",3279,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"^2X\"]]]]],\"^2B\",\"Returns a new seq where x is the first element and coll is the rest.\"],\"~$PersistentTreeSet\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^1W\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^23\"]],\"^1;\",\"^7R\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^45\",true,\"^26\",10,\"^29\",9304,\"^46\",false,\"^2:\",9304,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1W\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^23\"]]],\"~$->HashSetIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",10,\"^27\",\"^28\",\"^29\",9133,\"^2:\",9133,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4L\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/HashSetIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->HashSetIter\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^4L\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9133,\"^2H\",\"~$cljs.core/HashSetIter\",\"^2:\",9133,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4L\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/HashSetIter.\"],\"~$ns-lookup\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11560,\"^26\",8,\"^2:\",11560,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$ns-obj\",\"~$k\"]]]]],\"^2B\",\"Bootstrap only.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/ns-lookup\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^@6\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11560,\"^2H\",\"^47\",\"^2:\",11560,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@6\",\"~$k\"]]]]],\"^2B\",\"Bootstrap only.\"],\"~$floats\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2821,\"^26\",7,\"^2:\",2821,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/floats\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2821,\"^2:\",2821,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$TransientVector\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5475,\"^26\",44,\"^2:\",5475,\"^25\",59,\"^5M\",true],\"^41\",4,\"^1P\",[\"^1:\",[\"^5N\",\"^1S\",\"^1Y\",\"~$cljs.core/ITransientCollection\",\"~$cljs.core/ITransientVector\",\"^39\",\"^23\"]],\"^1;\",\"^3<\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^45\",true,\"^26\",10,\"^29\",6040,\"^46\",false,\"^5M\",true,\"^2:\",6040,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^1S\",\"^1Y\",\"^@;\",\"^@<\",\"^39\",\"^23\"]]],\"~$pos?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2931,\"^26\",16,\"^2:\",2931,\"^25\",20,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if num is greater than zero, else false\"],\"^1;\",\"~$cljs.core/pos?\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2931,\"^2H\",\"^3D\",\"^2:\",2931,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if num is greater than zero, else false\"],\"~$fnil\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4327,\"^26\",7,\"^2:\",4327,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^2B\",\"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/fnil\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^47\"]],\"^29\",4327,\"^2:\",4327,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"~$x\"],[\"~$f\",\"~$x\",\"~$y\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2B\",\"Takes a function f, and returns a function that calls f, replacing\\n  a nil first argument to f with the supplied value x. Higher arity\\n  versions can replace arguments in the second and third\\n  positions (y, z). Note that the function f can take any number of\\n  arguments, not just the one(s) being nil-patched.\"],\"~$merge-with\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9099,\"^26\",7,\"^2:\",9099,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"~$&\",\"~$maps\"]]]]],\"^2B\",\"Returns a map that consists of the rest of the maps conj-ed onto\\n  the first.  If a key occurs in more than one map, the mapping(s)\\n  from the latter (left-to-right) will be combined with the mapping in\\n  the result by calling (f val-in-result val-in-latter).\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"~$f\",\"^@B\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"~$&\",\"^@B\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/merge-with\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"~$f\",\"^@B\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"~$&\",\"^@B\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"~$f\",\"^@B\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\",\"^4C\"]]]],\"^29\",9099,\"^2H\",\"^2S\",\"^2:\",9099,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"~$&\",\"^@B\"]]],\"^2B\",\"Returns a map that consists of the rest of the maps conj-ed onto\\n  the first.  If a key occurs in more than one map, the mapping(s)\\n  from the latter (left-to-right) will be combined with the mapping in\\n  the result by calling (f val-in-result val-in-latter).\"],\"~$nthrest\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1927,\"^26\",7,\"^2:\",1927,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\"]]]]],\"^2B\",\"Returns the nth rest of coll, coll when n is 0.\"],\"^1;\",\"~$cljs.core/nthrest\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1927,\"^2:\",1927,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\"]]]]],\"^2B\",\"Returns the nth rest of coll, coll when n is 0.\"],\"~$*warn-on-infer*\",[\"^ \",\"^1;\",\"~$cljs.core/*warn-on-infer*\",\"^24\",\"cljs/core.cljs\",\"^29\",33,\"^26\",1,\"^2:\",33,\"^25\",21,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",33,\"^26\",6,\"^2:\",33,\"^25\",21],\"^2R\",\"^3D\"],\"^55\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",636,\"^26\",4,\"^2:\",636,\"^25\",9,\"^69\",\"^56\",\"^2B\",\"Returns the map entry for key, or nil if key not present.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]]],\"^69\",\"^56\",\"^1;\",\"~$cljs.core/-find\",\"^24\",\"cljs/core.cljs\",\"^25\",9,\"^2D\",[\"^2<\",[[\"^2X\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",634,\"^2H\",\"^2S\",\"^2:\",636,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns the map entry for key, or nil if key not present.\"],\"~$sequential?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2139,\"^26\",7,\"^2:\",2139,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll satisfies ISequential\"],\"^1;\",\"~$cljs.core/sequential?\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2139,\"^2H\",\"^3D\",\"^2:\",2139,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll satisfies ISequential\"],\"~$tree-map-replace\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8717,\"^26\",8,\"^2:\",8717,\"^25\",24,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2Y\",\"^62\",\"~$k\",\"~$v\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tree-map-replace\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^2Y\",\"^62\",\"~$k\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8717,\"^2H\",\"^2S\",\"^2:\",8717,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2Y\",\"^62\",\"~$k\",\"~$v\"]]]]]],\"~$checked-aset'\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",488,\"^26\",8,\"^2:\",488,\"^25\",21,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"~$idx2\",\"~$&\",\"~$idxv\"]]]]],\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/checked-aset'\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",488,\"^2:\",488,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]]],\"~$m3-mix-H1\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",917,\"^26\",15,\"^2:\",917,\"^25\",24,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$h1\",\"~$k1\"]]]]]],\"^1;\",\"~$cljs.core/m3-mix-H1\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^@R\",\"^@S\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",917,\"^2H\",\"^<\",\"^2:\",917,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@R\",\"^@S\"]]]]]],\"~$RecordIter\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/RecordIter\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^45\",true,\"^26\",10,\"^29\",6514,\"^46\",false,\"^2:\",6514,\"^2R\",\"^47\",\"^2A\",null],\"~$->TransientArrayMap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1S\",\"^:@\",\"^1Y\",\"^@;\",\"^39\",\"^23\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",7034,\"^2:\",7034,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$editable?\",\"^5H\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^1S\",\"^:@\",\"^1Y\",\"^@;\",\"^39\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/TransientArrayMap.\"],\"^1P\",[\"^1:\",[\"^1S\",\"^:@\",\"^1Y\",\"^@;\",\"^39\",\"^23\"]],\"^1;\",\"~$cljs.core/->TransientArrayMap\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^@X\",\"^5H\",\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7034,\"^2H\",\"^3>\",\"^2:\",7034,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@X\",\"^5H\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^1S\",\"^:@\",\"^1Y\",\"^@;\",\"^39\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/TransientArrayMap.\"],\"~$re-seq*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9995,\"^26\",8,\"^2:\",9995,\"^25\",15,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/re-seq*\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^<Q\",\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9995,\"^2H\",[\"^1:\",[\"^2T\",\"^4C\"]],\"^2:\",9995,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]]],\"~$prim-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1661,\"^26\",7,\"^2:\",1661,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$prim\"],[\"^A1\",\"~$i\"]]]]],\"^2B\",\"Create seq from a primitive JavaScript Array-like.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^A1\"],[\"^A1\",\"~$i\"]]],\"^2;\",[\"^2<\",[[\"^A1\"],[\"^A1\",\"~$i\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/prim-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^A1\"],[\"^A1\",\"~$i\"]]],\"^2;\",[\"^2<\",[[\"^A1\"],[\"^A1\",\"~$i\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^A1\"],[\"^A1\",\"~$i\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^5R\",\"^4C\"]]]],\"^29\",1661,\"^2:\",1661,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^A1\"],[\"^A1\",\"~$i\"]]],\"^2B\",\"Create seq from a primitive JavaScript Array-like.\"],\"~$*print-level*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",163,\"^26\",3,\"^2:\",163,\"^25\",16,\"^6R\",true,\"^2B\",\"*print-level* controls how many levels deep the printer will\\n  print nested objects. If it is bound to logical false, there is no\\n  limit. Otherwise, it must be bound to an integer indicating the maximum\\n  level to print. Each argument to print is at level 0; if an argument is a\\n  collection, its items are at level 1; and so on. If an object is a\\n  collection and is at a level greater than or equal to the value bound to\\n  *print-level*, the printer prints '#' to represent it. The root binding\\n  is nil indicating no limit.\",\"^38\",[\"@type {null|number}\"]],\"^1;\",\"~$cljs.core/*print-level*\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",1,\"^6R\",true,\"^29\",152,\"^2:\",163,\"^2R\",\"^4C\",\"^2B\",\"*print-level* controls how many levels deep the printer will\\n  print nested objects. If it is bound to logical false, there is no\\n  limit. Otherwise, it must be bound to an integer indicating the maximum\\n  level to print. Each argument to print is at level 0; if an argument is a\\n  collection, its items are at level 1; and so on. If an object is a\\n  collection and is at a level greater than or equal to the value bound to\\n  *print-level*, the printer prints '#' to represent it. The root binding\\n  is nil indicating no limit.\",\"^38\",[\"@type {null|number}\"]],\"~$shuffle\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2474,\"^26\",7,\"^2:\",2474,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Return a random permutation of coll\"],\"^1;\",\"~$cljs.core/shuffle\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2474,\"^2H\",[\"^1:\",[\"^2T\",\"^94\",\"^2S\",\"^5A\",\"^4C\"]],\"^2:\",2474,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Return a random permutation of coll\"],\"~$ChunkedSeq\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2167,\"^26\",22,\"^2:\",2167,\"^25\",32,\"^5M\",true],\"^41\",6,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"~$cljs.core/IChunkedNext\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?H\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^45\",true,\"^26\",10,\"^29\",5729,\"^46\",false,\"^5M\",true,\"^2:\",5729,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$hash-keyword\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3287,\"^26\",7,\"^2:\",3287,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\"]]]]]],\"^1;\",\"~$cljs.core/hash-keyword\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3287,\"^2H\",\"^<\",\"^2:\",3287,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\"]]]]]],\"~$find\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2347,\"^26\",7,\"^2:\",2347,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns the map entry for key, or nil if key not present.\"],\"^1;\",\"~$cljs.core/find\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^2X\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2347,\"^2H\",[\"^1:\",[\"^2S\",\"^2U\",\"^4C\"]],\"^2:\",2347,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns the map entry for key, or nil if key not present.\"],\"~$alength\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",511,\"^26\",15,\"^2:\",511,\"^25\",22,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\"]]]]],\"^2B\",\"Returns the length of the array. Works on arrays of all types.\"],\"^1;\",\"~$cljs.core/alength\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^7F\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",511,\"^2H\",\"^<\",\"^2:\",511,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\"]]]]],\"^2B\",\"Returns the length of the array. Works on arrays of all types.\"],\"~$bit-xor\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2847,\"^26\",7,\"^2:\",2847,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Bitwise exclusive or\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/bit-xor\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2847,\"^2:\",2847,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Bitwise exclusive or\"],\"~$->IndexedSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^5O\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",1571,\"^2:\",1571,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^2>\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^5O\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/IndexedSeq.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^5O\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->IndexedSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"^2>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",1571,\"^2H\",\"^5R\",\"^2:\",1571,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^2>\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^5O\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/IndexedSeq.\"],\"~$ObjMap\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^1;\",\"^58\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",6394,\"^46\",false,\"^2:\",6394,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^22\",\"^87\",\"^<W\",\"^23\"]]],\"~$unsigned-bit-shift-right\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2907,\"^26\",7,\"^2:\",2907,\"^25\",31,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Bitwise shift right with zero fill\"],\"^1;\",\"~$cljs.core/unsigned-bit-shift-right\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2907,\"^2H\",\"^<\",\"^2:\",2907,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Bitwise shift right with zero fill\"],\"~$ES6SetEntriesIterator\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^67\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^45\",true,\"^26\",10,\"^29\",6540,\"^46\",false,\"^2:\",6540,\"^2R\",\"^47\",\"^2A\",null],\"~$neg?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2940,\"^26\",16,\"^2:\",2940,\"^25\",20,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if num is less than zero, else false\"],\"^1;\",\"~$cljs.core/neg?\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2940,\"^2H\",\"^3D\",\"^2:\",2940,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if num is less than zero, else false\"],\"~$Cons\",[\"^ \",\"^41\",4,\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?<\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^45\",true,\"^26\",10,\"^29\",3219,\"^46\",false,\"^2:\",3219,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$-remove-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11014,\"^26\",4,\"^2:\",11014,\"^25\",18,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-remove-method\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^82\",\"^83\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11014,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\"]]]]],\"^2B\",null],\"~$->StringIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",4006,\"^2:\",4006,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\",\"~$i\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/StringIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->StringIter\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$s\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4006,\"^2H\",\"~$cljs.core/StringIter\",\"^2:\",4006,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\",\"~$i\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/StringIter.\"],\"~$js-invoke\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",526,\"^26\",7,\"^2:\",526,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"~$s\",\"~$&\",\"~$args\"]]]]],\"^2B\",\"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[[\"^2<\",[\"^3B\",\"~$s\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"^3B\",\"~$s\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/js-invoke\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[[\"^2<\",[\"^3B\",\"~$s\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"^3B\",\"~$s\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^3B\",\"~$s\",\"^AP\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",526,\"^2H\",\"^2S\",\"^2:\",526,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^3B\",\"~$s\",\"~$&\",\"^AP\"]]],\"^2B\",\"Invoke JavaScript object method via string. Needed when the\\n  string is not a valid unquoted property name.\"],\"~$->List\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",10,\"^27\",\"^28\",\"^29\",3036,\"^2:\",3036,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6V\",\"^<6\",\"~$count\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/List.\"],\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->List\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2>\",\"^6V\",\"^<6\",\"^AS\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3036,\"^2H\",\"^?D\",\"^2:\",3036,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6V\",\"^<6\",\"^AS\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/List.\"],\"~$m3-mix-K1\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",914,\"^26\",15,\"^2:\",914,\"^25\",24,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@S\"]]]]]],\"^1;\",\"~$cljs.core/m3-mix-K1\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^@S\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",914,\"^2H\",\"^<\",\"^2:\",914,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@S\"]]]]]],\"~$Iterate\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^7D\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",5021,\"^46\",false,\"^2:\",5021,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$unchecked-float\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2712,\"^26\",15,\"^2:\",2712,\"^25\",30,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-float\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2712,\"^2H\",\"^<\",\"^2:\",2712,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$undefined?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2225,\"^26\",16,\"^2:\",2225,\"^25\",26,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x identical to the JavaScript undefined value.\"],\"^1;\",\"~$cljs.core/undefined?\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2225,\"^2H\",\"^3D\",\"^2:\",2225,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x identical to the JavaScript undefined value.\"],\"~$t_cljs$core11184\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^1;\",\"~$cljs.core/t_cljs$core11184\",\"^24\",\"cljs/core.cljs\",\"^45\",true,\"^9K\",true,\"^26\",3,\"^29\",4000,\"^46\",false,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]]],\"~$IMeta\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",679,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-meta\",[[\"~$o\"]]]],\"^2:\",679,\"^2B\",\"Protocol for accessing the metadata of an object.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1[\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",679,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^B3\",[[\"~$o\"]]]],\"^3:\",null,\"^2:\",679,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^?<\",\"^59\",\"^:<\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^4R\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^2I\",\"^47\",\"^5=\",\"^?G\",\"^?H\",\"^90\",\"^7R\",\"^?I\",\"^<G\",\"^5A\",\"~$cljs.core/t_cljs$core1506\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for accessing the metadata of an object.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$reduced?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1429,\"^26\",7,\"^2:\",1429,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$r\"]]]]],\"^2B\",\"Returns true if x is the result of a call to reduced\"],\"^1;\",\"~$cljs.core/reduced?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$r\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1429,\"^2H\",\"^3D\",\"^2:\",1429,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$r\"]]]]],\"^2B\",\"Returns true if x is the result of a call to reduced\"],\"~$apply-to\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"~$argc\",\"^AP\"]]]]],\"^24\",\"cljs/core.cljs\"],\"^1;\",\"~$cljs.core/apply-to\",\"^24\",\"cljs/core.cljs\",\"^2D\",[\"^2<\",[[\"~$f\",\"^B8\",\"^AP\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3877,\"^2H\",\"^2S\",\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^B8\",\"^AP\"]]]]]],\"~$disj!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3862,\"^26\",7,\"^2:\",3862,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"~$vals\"]]]]],\"^2B\",\"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^35\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/disj!\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^35\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^35\",\"^37\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2T\"]],\"^29\",3862,\"^2:\",3862,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]],\"^2B\",\"disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\\n  does not contain key(s).\"],\"^7O\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^23\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",4,\"^29\",621,\"^2:\",621,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]]]],\"^2B\",\"Use k to look up a value in o. If not-found is supplied and k is not\\n     a valid value that can be used for look up, not-found is returned.\"],\"^69\",\"^23\",\"^1;\",\"~$cljs.core/-lookup\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",619,\"^2:\",621,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2B\",\"Use k to look up a value in o. If not-found is supplied and k is not\\n     a valid value that can be used for look up, not-found is returned.\"],\"~$float?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2320,\"^26\",7,\"^2:\",2320,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true for JavaScript numbers, false otherwise.\"],\"^1;\",\"~$cljs.core/float?\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2320,\"^2H\",\"^3D\",\"^2:\",2320,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true for JavaScript numbers, false otherwise.\"],\"~$ICloneable\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^26\",14,\"^29\",565,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^<C\",[[\"^4K\"]]]],\"^2:\",565,\"^2B\",\"Protocol for cloning a value.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^20\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^26\",1,\"^29\",565,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^<C\",[[\"^4K\"]]]],\"^3:\",null,\"^2:\",565,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^?<\",\"^59\",\"^?=\",\"^5R\",\"^?>\",\"^5;\",\"^5<\",\"^?D\",\"^?F\",\"^2I\",\"^5=\",\"^7R\",\"^?5\"]],\"^2B\",\"Protocol for cloning a value.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$IEncodeClojure\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10741,\"^26\",14,\"^2:\",10741,\"^25\",28,\"^32\",true,\"^38\",[\"^2<\",[\"@interface\"]],\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^8E\",[[\"~$x\",\"^8G\"]]]]],\"^32\",true,\"^1;\",\"^8F\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",1,\"^29\",10741,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^8E\",[[\"~$x\",\"^8G\"]]]],\"^3:\",null,\"^2:\",10741,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[]],\"^38\",[\"^2<\",[\"@interface\"]]],\"~$booleans\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2816,\"^26\",7,\"^2:\",2816,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/booleans\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2816,\"^2:\",2816,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$->ArrayList\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",10,\"^27\",\"^28\",\"^29\",9538,\"^2:\",9538,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ArrayList.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->ArrayList\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9538,\"^2H\",\"^>B\",\"^2:\",9538,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ArrayList.\"],\"~$RSeq\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1518,\"^26\",40,\"^2:\",1518,\"^25\",44,\"^5M\",true],\"^41\",3,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?F\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^45\",true,\"^26\",10,\"^29\",1678,\"^46\",false,\"^5M\",true,\"^2:\",1678,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$mask\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7135,\"^26\",8,\"^2:\",7135,\"^25\",12,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$hash\",\"^=X\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/mask\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^BH\",\"^=X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7135,\"^2H\",\"^<\",\"^2:\",7135,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BH\",\"^=X\"]]]]]],\"~$int-array\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3662,\"^26\",7,\"^2:\",3662,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$size-or-seq\"],[\"~$size\",\"~$init-val-or-seq\"]]]]],\"^2B\",\"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/int-array\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^7F\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^7F\"]],\"^29\",3662,\"^2:\",3662,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2B\",\"Creates an array of ints. Does not coerce array, provided for compatibility\\n  with Clojure.\"],\"~$find-and-cache-best-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10983,\"^26\",8,\"^2:\",10983,\"^25\",34,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\",\"^83\",\"^6?\",\"^6=\",\"~$prefer-table\",\"^6<\",\"^6>\",\"~$default-dispatch-val\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/find-and-cache-best-method\",\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^2D\",[\"^2<\",[[\"^:\",\"^83\",\"^6?\",\"^6=\",\"^BP\",\"^6<\",\"^6>\",\"^BQ\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10983,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",10983,\"^2J\",8,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\",\"^83\",\"^6?\",\"^6=\",\"^BP\",\"^6<\",\"^6>\",\"^BQ\"]]]]]],\"~$set?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2124,\"^26\",7,\"^2:\",2124,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x satisfies ISet\"],\"^1;\",\"~$cljs.core/set?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2124,\"^2H\",\"^3D\",\"^2:\",2124,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x satisfies ISet\"],\"~$iterable?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1190,\"^26\",7,\"^2:\",1190,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x implements IIterable protocol.\"],\"^1;\",\"~$cljs.core/iterable?\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1190,\"^2H\",\"^3D\",\"^2:\",1190,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x implements IIterable protocol.\"],\"~$cat\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10586,\"^26\",7,\"^2:\",10586,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$rf\"]]]]],\"^2B\",\"A transducer which concatenates the contents of each input, which must be a\\n  collection, into the reduction.\",\"^7B\",\"1.7\"],\"^7B\",\"1.7\",\"^1;\",\"~$cljs.core/cat\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^BX\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10586,\"^2H\",\"^47\",\"^2:\",10586,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BX\"]]]]],\"^2B\",\"A transducer which concatenates the contents of each input, which must be a\\n  collection, into the reduction.\"],\"~$->ES6EntriesIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",10,\"^27\",\"^28\",\"^29\",6527,\"^2:\",6527,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ES6EntriesIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->ES6EntriesIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6527,\"^2H\",\"~$cljs.core/ES6EntriesIterator\",\"^2:\",6527,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ES6EntriesIterator.\"],\"~$divide\",[\"^ \",\"^1;\",\"~$cljs.core/divide\",\"^24\",\"cljs/core.cljs\",\"^29\",2620,\"^26\",1,\"^2:\",2620,\"^25\",16,\"^5M\",true,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2620,\"^26\",10,\"^2:\",2620,\"^25\",16,\"^5M\",true]],\"~$js-reserved-arr\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11436,\"^26\",3,\"^2:\",11436,\"^25\",18,\"^5E\",true,\"^38\",[\"@type {*}\"]],\"^5E\",true,\"^1;\",\"~$cljs.core/js-reserved-arr\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^29\",11433,\"^2:\",11436,\"^2R\",\"^7F\",\"^38\",[\"@type {*}\"]],\"^?;\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",763,\"^26\",4,\"^2:\",763,\"^25\",14,\"^69\",\"^5Z\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^7W\",\"^2M\"]]]]]],\"^69\",\"^5Z\",\"^1;\",\"~$cljs.core/-pr-writer\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$o\",\"^7W\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",757,\"^2H\",\"^2S\",\"^2:\",763,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^7W\",\"^2M\"]]]]],\"^2B\",null],\"~$flush\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10059,\"^26\",7,\"^2:\",10059,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"^1;\",\"~$cljs.core/flush\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10059,\"^2H\",\"^4C\",\"^2:\",10059,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"~$set-from-indexed-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9405,\"^26\",7,\"^2:\",9405,\"^25\",27,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$iseq\"]]]]]],\"^1;\",\"~$cljs.core/set-from-indexed-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^C9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9405,\"^2H\",\"^2T\",\"^2:\",9405,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^C9\"]]]]]],\"~$maybe-init-tapset\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11527,\"^26\",8,\"^2:\",11527,\"^25\",25,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/maybe-init-tapset\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11527,\"^2H\",[\"^1:\",[null,\"^4C\"]],\"^2:\",11527,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"~$take-while\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9580,\"^26\",7,\"^2:\",9580,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of successive items from coll while\\n  (pred item) returns logical true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/take-while\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",9580,\"^2:\",9580,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of successive items from coll while\\n  (pred item) returns logical true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"],\"~$vary-meta\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3972,\"^26\",7,\"^2:\",3972,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^AP\"]]]]],\"^2B\",\"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"]]],\"^2;\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/vary-meta\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"]]],\"^2;\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"]]],\"^2E\",null,\"^2O\",6,\"^2F\",[\"^2<\",[null,null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]]],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]]],[\"^ \",\"^2O\",6,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]]],[\"^ \",\"^2O\",6,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]]]],\"^29\",3972,\"^2:\",3972,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^3B\",\"~$f\"],[\"^3B\",\"~$f\",\"~$a\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^3B\",\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^AP\"]]],\"^2B\",\"Returns an object of the same type and value as obj, with\\n  (apply f (meta obj) args) as its metadata.\"],\"~$INext\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",611,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-next\",[[\"^2X\"]]]],\"^2:\",611,\"^2B\",\"Protocol for accessing the next items of a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^4V\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",611,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^CB\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",611,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^?<\",\"^:<\",\"^5R\",\"^?>\",\"^3U\",\"^4[\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^?G\",\"^?H\",\"^?I\",\"^?5\",\"^9F\"]],\"^2B\",\"Protocol for accessing the next items of a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$is_proto_\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",290,\"^26\",7,\"^2:\",290,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/is_proto_\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",290,\"^2H\",\"^3D\",\"^2:\",290,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$START\",[\"^ \",\"^1;\",\"~$cljs.core/START\",\"^24\",\"cljs/core.cljs\",\"^29\",4031,\"^26\",1,\"^2:\",4031,\"^25\",11,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4031,\"^26\",6,\"^2:\",4031,\"^25\",11],\"^2R\",\"^4>\"],\"~$ICounted\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",14,\"^29\",570,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^=4\",[[\"^2X\"]]]],\"^2:\",570,\"^2B\",\"Protocol for adding the ability to count a collection in constant time.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1Y\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",1,\"^29\",570,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^=4\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",570,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[null,\"^:T\",\"^57\",\"^58\",\"^3<\",\"^59\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^5;\",\"^3=\",\"~$cljs.core/ChunkBuffer\",\"^<<\",\"^5<\",\"^?D\",\"^3>\",\"^?F\",\"^7Q\",\"^2I\",\"^5=\",\"^:U\",\"^7R\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for adding the ability to count a collection in constant time.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$IMapEntry\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",14,\"^29\",644,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-key\",[[\"^2X\"]],\"~$-val\",[[\"^2X\"]]]],\"^2:\",644,\"^2B\",\"Protocol for examining a map entry.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^96\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",1,\"^29\",644,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^CJ\",[[\"^2X\"]],\"^CK\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",644,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^5:\",\"^2U\",\"^5>\"]],\"^2B\",\"Protocol for examining a map entry.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$pv-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5459,\"^26\",8,\"^2:\",5459,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pv-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]],\"^2E\",null,\"^2O\",5,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",5459,\"^2:\",5459,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^6J\",\"~$f\",\"^51\",\"^52\"],[\"^6J\",\"~$f\",\"^9?\",\"^51\",\"^52\"]]]],\"~$<=\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",2641,\"^2:\",2641,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"],\"^1;\",\"~$cljs.core/<=\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",2641,\"^2H\",\"^3D\",\"^2:\",2641,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns non-nil if nums are in monotonically non-decreasing order,\\n  otherwise false.\"],\"~$MODULE_INFOS\",[\"^ \",\"^1;\",\"~$cljs.core/MODULE_INFOS\",\"^24\",\"cljs/core.cljs\",\"^29\",40,\"^26\",1,\"^2:\",40,\"^25\",18,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",40,\"^26\",6,\"^2:\",40,\"^25\",18],\"^2R\",\"^4C\"],\"~$conj!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3821,\"^26\",7,\"^2:\",3821,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]]]],\"^2B\",\"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"]]],\"^2;\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/conj!\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"]]],\"^2;\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2T\"]],\"^29\",3821,\"^2:\",3821,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^35\"],[\"^35\",\"^37\"],[\"^35\",\"^37\",\"~$&\",\"^B;\"]]],\"^2B\",\"Adds val to the transient collection, and return tcoll. The 'addition'\\n  may happen at different 'places' depending on the concrete type.\"],\"~$-pop\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^95\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^26\",9,\"^29\",662,\"^2:\",662,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new stack without the item on top of the stack. Is used\\n     by cljs.core/pop.\"],\"^69\",\"^95\",\"^1;\",\"~$cljs.core/-pop\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",656,\"^2H\",\"^2T\",\"^2:\",662,\"^2J\",1,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new stack without the item on top of the stack. Is used\\n     by cljs.core/pop.\"],\"~$array-index-of-identical?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6582,\"^26\",8,\"^2:\",6582,\"^25\",33,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-index-of-identical?\",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2D\",[\"^2<\",[[\"^6B\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6582,\"^2H\",\"^<\",\"^2:\",6582,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"~$repeatedly\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5012,\"^26\",7,\"^2:\",5012,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]]]],\"^2B\",\"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/repeatedly\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",5012,\"^2:\",5012,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$n\",\"~$f\"]]],\"^2B\",\"Takes a function of no args, presumably with side effects, and\\n  returns an infinite (or length n if supplied) lazy sequence of calls\\n  to it\"],\"~$zipmap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9508,\"^26\",7,\"^2:\",9508,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$keys\",\"^B;\"]]]]],\"^2B\",\"Returns a map with the keys mapped to the corresponding vals.\"],\"^1;\",\"~$cljs.core/zipmap\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^C[\",\"^B;\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9508,\"^2H\",\"^2T\",\"^2:\",9508,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^C[\",\"^B;\"]]]]],\"^2B\",\"Returns a map with the keys mapped to the corresponding vals.\"],\"~$reset-vals!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4478,\"^26\",7,\"^2:\",4478,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$new-value\"]]]]],\"^2B\",\"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\",\"^7B\",\"1.9\"],\"^7B\",\"1.9\",\"^1;\",\"~$cljs.core/reset-vals!\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"~$a\",\"^D2\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4478,\"^2H\",\"^94\",\"^2:\",4478,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"^D2\"]]]]],\"^2B\",\"Sets the value of atom to newval. Returns [old new], the value of the\\n   atom before and after the reset.\"],\"~$IStack\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",14,\"^29\",656,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-peek\",[[\"^2X\"]],\"^CT\",[[\"^2X\"]]]],\"^2:\",656,\"^2B\",\"Protocol for collections to provide access to their items as stacks. The top\\n  of the stack should be accessed in the most efficient way for the different\\n  data structures.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^95\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",656,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^D5\",[[\"^2X\"]],\"^CT\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",656,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^?=\",\"^5:\",\"^2U\",\"^?>\",\"^5;\",\"^5<\",\"^?D\",\"^5>\"]],\"^2B\",\"Protocol for collections to provide access to their items as stacks. The top\\n  of the stack should be accessed in the most efficient way for the different\\n  data structures.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$-remove-watch\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",778,\"^26\",4,\"^2:\",778,\"^25\",17,\"^69\",\"~$cljs.core/IWatchable\",\"^2B\",\"Removes watcher that corresponds to key from this.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$this\",\"^36\"]]]]]],\"^69\",\"^D7\",\"^1;\",\"~$cljs.core/-remove-watch\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^D8\",\"^36\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",771,\"^2H\",\"^2S\",\"^2:\",778,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^D8\",\"^36\"]]]]],\"^2B\",\"Removes watcher that corresponds to key from this.\"],\"~$IVolatile\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",14,\"^29\",859,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-vreset!\",[[\"~$o\",\"^D2\"]]]],\"^2:\",859,\"^2B\",\"Protocol for adding volatile functionality.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^42\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",1,\"^29\",859,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^D;\",[[\"~$o\",\"^D2\"]]]],\"^3:\",null,\"^2:\",859,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^44\"]],\"^2B\",\"Protocol for adding volatile functionality.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$remove\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5176,\"^26\",7,\"^2:\",5176,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns logical false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/remove\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",5176,\"^2:\",5176,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns logical false. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"],\"~$->BitmapIndexedNode\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",7226,\"^2:\",7226,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^:M\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^21\"]],\"^2B\",\"Positional factory function for cljs.core/BitmapIndexedNode.\"],\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^1;\",\"~$cljs.core/->BitmapIndexedNode\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^>2\",\"^:M\",\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7226,\"^2H\",\"^?P\",\"^2:\",7226,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^:M\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^21\"]],\"^2B\",\"Positional factory function for cljs.core/BitmapIndexedNode.\"],\"~$->t_cljs$core11184\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^9K\",true,\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]],\"^27\",\"^28\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$meta11185\"]]]]],\"^2B\",\"Positional factory function for cljs.core/t_cljs$core11184.\",\"^24\",\"cljs/core.cljs\"],\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^1;\",\"~$cljs.core/->t_cljs$core11184\",\"^24\",\"cljs/core.cljs\",\"^2D\",[\"^2<\",[[\"^DA\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^9K\",true,\"^26\",3,\"^2G\",false,\"^27\",\"^28\",\"^29\",4000,\"^2H\",\"^B1\",\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^DA\"]]]]],\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/t_cljs$core11184.\"],\"~$*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",15,\"^29\",2613,\"^2:\",2613,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the product of nums. (*) returns 1.\"],\"^1;\",\"~$cljs.core/*\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2613,\"^2H\",\"^<\",\"^2:\",2613,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the product of nums. (*) returns 1.\"],\"~$re-pattern\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10015,\"^26\",7,\"^2:\",10015,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Returns an instance of RegExp which has compiled the provided string.\"],\"^1;\",\"~$cljs.core/re-pattern\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10015,\"^2H\",[\"^1:\",[null,\"~$js/RegExp\"]],\"^2:\",10015,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]],\"^2B\",\"Returns an instance of RegExp which has compiled the provided string.\"],\"~$min\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",15,\"^29\",2688,\"^2:\",2688,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the least of the nums.\"],\"^1;\",\"~$cljs.core/min\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2688,\"^2H\",\"^<\",\"^2:\",2688,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the least of the nums.\"],\"~$array-index-of-nil?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6554,\"^26\",8,\"^2:\",6554,\"^25\",27,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-index-of-nil?\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6554,\"^2H\",\"^<\",\"^2:\",6554,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\"]]]]]],\"~$-persistent!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^@;\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",9,\"^29\",790,\"^2:\",790,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Creates a persistent data structure from tcoll and returns it.\"],\"^69\",\"^@;\",\"^1;\",\"~$cljs.core/-persistent!\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^35\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",786,\"^2H\",\"^2T\",\"^2:\",790,\"^2J\",1,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Creates a persistent data structure from tcoll and returns it.\"],\"^?4\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^5N\",\"^24\",\"cljs/core.cljs\",\"^25\",8,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",4,\"^29\",594,\"^2:\",594,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]]]],\"^2B\",\"Returns the value at the index n in the collection coll.\\n     Returns not-found if index n is out of bounds and not-found is supplied.\"],\"^69\",\"^5N\",\"^1;\",\"~$cljs.core/-nth\",\"^24\",\"cljs/core.cljs\",\"^25\",8,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",592,\"^2:\",594,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2B\",\"Returns the value at the index n in the collection coll.\\n     Returns not-found if index n is out of bounds and not-found is supplied.\"],\"~$pop!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3856,\"^26\",7,\"^2:\",3856,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"],\"^1;\",\"~$cljs.core/pop!\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^35\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3856,\"^2H\",\"^2T\",\"^2:\",3856,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Removes the last item from a transient vector. If\\n  the collection is empty, throws an exception. Returns tcoll\"],\"~$chunk-append\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3622,\"^26\",7,\"^2:\",3622,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$b\",\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/chunk-append\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$b\",\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3622,\"^2H\",\"^2S\",\"^2:\",3622,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$b\",\"~$x\"]]]]]],\"~$*unchecked-arrays*\",[\"^ \",\"^1;\",\"~$cljs.core/*unchecked-arrays*\",\"^24\",\"cljs/core.cljs\",\"^29\",30,\"^26\",1,\"^2:\",30,\"^25\",24,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",30,\"^26\",6,\"^2:\",30,\"^25\",24],\"^2R\",\"^3D\"],\"~$prn-str\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10234,\"^26\",7,\"^2:\",10234,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^79\"]]]]],\"^2B\",\"Same as pr-str followed by (newline)\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/prn-str\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^3J\"]],\"^29\",10234,\"^2H\",\"^2S\",\"^2:\",10234,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2B\",\"Same as pr-str followed by (newline)\"],\"~$IReversible\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",14,\"^29\",728,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-rseq\",[[\"^2X\"]]]],\"^2:\",728,\"^2B\",\"Protocol for reversing a seq.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^5O\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",1,\"^29\",728,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^DW\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",728,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^5R\",\"^5:\",\"^2U\",\"^5;\",\"^5<\",\"^5=\",\"^7R\",\"^5>\"]],\"^2B\",\"Protocol for reversing a seq.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$reversible?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3184,\"^26\",7,\"^2:\",3184,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns true if coll satisfies? IReversible.\"],\"^1;\",\"~$cljs.core/reversible?\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3184,\"^2H\",\"^3D\",\"^2:\",3184,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns true if coll satisfies? IReversible.\"],\"~$-realized?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^8J\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",13,\"^29\",768,\"^2:\",768,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if a value for x has been produced, false otherwise.\"],\"^69\",\"^8J\",\"^1;\",\"~$cljs.core/-realized?\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",765,\"^2H\",\"^3D\",\"^2:\",768,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if a value for x has been produced, false otherwise.\"],\"~$-add-watch\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",775,\"^26\",4,\"^2:\",775,\"^25\",14,\"^69\",\"^D7\",\"^2B\",\"Adds a watcher function f to this. Keys must be unique per reference,\\n     and can be used to remove the watch with -remove-watch.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^D8\",\"^36\",\"~$f\"]]]]]],\"^69\",\"^D7\",\"^1;\",\"~$cljs.core/-add-watch\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^D8\",\"^36\",\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",771,\"^2H\",\"^2S\",\"^2:\",775,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^D8\",\"^36\",\"~$f\"]]]]],\"^2B\",\"Adds a watcher function f to this. Keys must be unique per reference,\\n     and can be used to remove the watch with -remove-watch.\"],\"~$-deref-with-timeout\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",677,\"^26\",4,\"^2:\",677,\"^25\",23,\"^69\",\"~$cljs.core/IDerefWithTimeout\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"~$msec\",\"~$timeout-val\"]]]]]],\"^69\",\"^E3\",\"^1;\",\"~$cljs.core/-deref-with-timeout\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$o\",\"^E4\",\"^E5\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",676,\"^2H\",\"^2S\",\"^2:\",677,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^E4\",\"^E5\"]]]]],\"^2B\",null],\"~$conj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1780,\"^26\",7,\"^2:\",1780,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"~$&\",\"^5F\"]]]]],\"^2B\",\"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"]]],\"^2;\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"~$&\",\"^5F\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/conj\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"]]],\"^2;\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"~$&\",\"^5F\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^94\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2T\"]],\"^29\",1780,\"^2:\",1780,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^2X\"],[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"~$&\",\"^5F\"]]],\"^2B\",\"conj[oin]. Returns a new collection with the xs\\n  'added'. (conj nil item) returns (item).  The 'addition' may\\n  happen at different 'places' depending on the concrete type.\"],\"~$-sorted-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^75\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",9,\"^29\",736,\"^2:\",736,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"^76\"]]]]],\"^2B\",\"Returns a sorted seq from coll in either ascending or descending order.\"],\"^69\",\"^75\",\"^1;\",\"~$cljs.core/-sorted-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^2X\",\"^76\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",733,\"^2H\",\"^2T\",\"^2:\",736,\"^2J\",2,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"^76\"]]]]],\"^2B\",\"Returns a sorted seq from coll in either ascending or descending order.\"],\"~$flatten1\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5123,\"^26\",8,\"^2:\",5123,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;N\"]]]]],\"^2B\",\"Take a collection of collections, and return a lazy seq\\n  of items from the inner collection\"],\"^5E\",true,\"^1;\",\"~$cljs.core/flatten1\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^;N\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5123,\"^2H\",\"^3U\",\"^2:\",5123,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;N\"]]]]],\"^2B\",\"Take a collection of collections, and return a lazy seq\\n  of items from the inner collection\"],\"~$transduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2580,\"^26\",7,\"^2:\",2580,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]]]],\"^2B\",\"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/transduce\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",2580,\"^2:\",2580,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^5[\",\"~$f\",\"^2X\"],[\"^5[\",\"~$f\",\"^9?\",\"^2X\"]]],\"^2B\",\"reduce with a transformation of f (xf). If init is not\\n  supplied, (f) will be called to produce it. f should be a reducing\\n  step function that accepts both 1 and 2 arguments, if it accepts\\n  only 2 you can add the arity-1 with 'completing'. Returns the result\\n  of applying (the transformed) xf to init and the first item in coll,\\n  then applying xf to that result and the 2nd item, etc. If coll\\n  contains no items, returns init and f is not called. Note that\\n  certain transforms may inject or skip items.\"],\"~$-swap!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"~$cljs.core/ISwap\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]],\"^2;\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",4,\"^29\",856,\"^2:\",856,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]]]],\"^2B\",\"Swaps the value of o to be (apply f current-value-of-atom args).\"],\"^69\",\"^E@\",\"^1;\",\"~$cljs.core/-swap!\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]],\"^2;\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]],\"^2E\",null,\"^2O\",5,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",854,\"^2:\",856,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]],\"^2B\",\"Swaps the value of o to be (apply f current-value-of-atom args).\"],\"~$*print-length*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",150,\"^26\",3,\"^2:\",150,\"^25\",17,\"^6R\",true,\"^2B\",\"*print-length* controls how many items of each collection the\\n  printer will print. If it is bound to logical false, there is no\\n  limit. Otherwise, it must be bound to an integer indicating the maximum\\n  number of items of each collection to print. If a collection contains\\n  more items, the printer will print items up to the limit followed by\\n  '...' to represent the remaining items. The root binding is nil\\n  indicating no limit.\",\"^38\",[\"@type {null|number}\"]],\"^1;\",\"~$cljs.core/*print-length*\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",1,\"^6R\",true,\"^29\",140,\"^2:\",150,\"^2R\",\"^4C\",\"^2B\",\"*print-length* controls how many items of each collection the\\n  printer will print. If it is bound to logical false, there is no\\n  limit. Otherwise, it must be bound to an integer indicating the maximum\\n  number of items of each collection to print. If a collection contains\\n  more items, the printer will print items up to the limit followed by\\n  '...' to represent the remaining items. The root binding is nil\\n  indicating no limit.\",\"^38\",[\"@type {null|number}\"]],\"~$js-delete\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2187,\"^26\",7,\"^2:\",2187,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^36\"]]]]],\"^2B\",\"Delete a property from a JavaScript object.\\n  Returns true upon success, false otherwise.\"],\"^1;\",\"~$cljs.core/js-delete\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^3B\",\"^36\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2187,\"^2H\",\"^2S\",\"^2:\",2187,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^36\"]]]]],\"^2B\",\"Delete a property from a JavaScript object.\\n  Returns true upon success, false otherwise.\"],\"~$truth_\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",215,\"^26\",7,\"^2:\",215,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Internal - do not use!\"],\"^1;\",\"~$cljs.core/truth_\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",215,\"^2H\",\"^2S\",\"^2:\",215,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Internal - do not use!\"],\"~$array-index-of\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6598,\"^26\",7,\"^2:\",6598,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"^1;\",\"~$cljs.core/array-index-of\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^6B\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6598,\"^2H\",\"^<\",\"^2:\",6598,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"~$->MultiFn\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1R\",\"^1S\",\"^81\",\"^<X\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",11025,\"^2:\",11025,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\",\"^>L\",\"^BQ\",\"^6?\",\"^6=\",\"^BP\",\"^6<\",\"^6>\"]]]]],\"^2A\",[\"^1:\",[\"^1R\",\"^1S\",\"^81\",\"^<X\"]],\"^2B\",\"Positional factory function for cljs.core/MultiFn.\"],\"^1P\",[\"^1:\",[\"^1R\",\"^1S\",\"^81\",\"^<X\"]],\"^1;\",\"~$cljs.core/->MultiFn\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^:\",\"^>L\",\"^BQ\",\"^6?\",\"^6=\",\"^BP\",\"^6<\",\"^6>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",11025,\"^2H\",\"~$cljs.core/MultiFn\",\"^2:\",11025,\"^2J\",8,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\",\"^>L\",\"^BQ\",\"^6?\",\"^6=\",\"^BP\",\"^6<\",\"^6>\"]]]]],\"^2A\",[\"^1:\",[\"^1R\",\"^1S\",\"^81\",\"^<X\"]],\"^2B\",\"Positional factory function for cljs.core/MultiFn.\"],\"~$key->js\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10702,\"^26\",7,\"^2:\",10702,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"~$primitive-fn\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"^EN\"]]],\"^2;\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"^EN\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/key->js\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"^EN\"]]],\"^2;\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"^EN\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"^EN\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^3J\"]]]],\"^29\",10702,\"^2:\",10702,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$k\"],[\"~$k\",\"^EN\"]]]],\"~$IEncodeJS\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10695,\"^26\",14,\"^2:\",10695,\"^25\",23,\"^32\",true,\"^38\",[\"^2<\",[\"@interface\"]],\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-clj->js\",[[\"~$x\"]],\"~$-key->js\",[[\"~$x\"]]]]],\"^32\",true,\"^1;\",\"~$cljs.core/IEncodeJS\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",1,\"^29\",10695,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^EQ\",[[\"~$x\"]],\"^ER\",[[\"~$x\"]]]],\"^3:\",null,\"^2:\",10695,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[]],\"^38\",[\"^2<\",[\"@interface\"]]],\"~$new-path\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5363,\"^26\",8,\"^2:\",5363,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^:B\",\"^8@\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/new-path\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^>2\",\"^:B\",\"^8@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5363,\"^2:\",5363,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^:B\",\"^8@\"]]]]]],\"~$compare-and-set!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4530,\"^26\",7,\"^2:\",4530,\"^25\",23,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$oldval\",\"^;7\"]]]]],\"^2B\",\"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"],\"^1;\",\"~$cljs.core/compare-and-set!\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$a\",\"^EW\",\"^;7\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4530,\"^2H\",\"^3D\",\"^2:\",4530,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"^EW\",\"^;7\"]]]]],\"^2B\",\"Atomically sets the value of atom to newval if and only if the\\n  current value of the atom is equal to oldval. Returns true if\\n  set happened, else false.\"],\"~$array-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1669,\"^26\",7,\"^2:\",1669,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]]]],\"^2B\",\"Create a seq from a JavaScript array.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]],\"^2;\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/array-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]],\"^2;\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^5R\",\"^4C\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^5R\",\"^4C\"]]]],\"^29\",1669,\"^2:\",1669,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7F\"],[\"^7F\",\"~$i\"]]],\"^2B\",\"Create a seq from a JavaScript array.\"],\"~$array-copy-downward\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2201,\"^26\",8,\"^2:\",2201,\"^25\",27,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$from\",\"~$i\",\"~$to\",\"~$j\",\"^5H\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-copy-downward\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^F0\",\"~$i\",\"^F1\",\"~$j\",\"^5H\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2201,\"^2:\",2201,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^F0\",\"~$i\",\"^F1\",\"~$j\",\"^5H\"]]]]]],\"~$pack-array-node\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7428,\"^26\",8,\"^2:\",7428,\"^25\",23,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$array-node\",\"^>2\",\"^7G\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pack-array-node\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^F4\",\"^>2\",\"^7G\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7428,\"^2H\",\"^?P\",\"^2:\",7428,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^F4\",\"^>2\",\"^7G\"]]]]]],\"~$interleave\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5085,\"^26\",7,\"^2:\",5085,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"],[\"^;K\",\"^;L\",\"~$&\",\"^;N\"]]]]],\"^2B\",\"Returns a lazy seq of the first item in each coll, then the second etc.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"]]],\"^2;\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"],[\"^;K\",\"^;L\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/interleave\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"]]],\"^2;\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"],[\"^;K\",\"^;L\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^30\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3U\"]],\"^29\",5085,\"^2:\",5085,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^;K\"],[\"^;K\",\"^;L\"],[\"^;K\",\"^;L\",\"~$&\",\"^;N\"]]],\"^2B\",\"Returns a lazy seq of the first item in each coll, then the second etc.\"],\"~$print-map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10310,\"^26\",7,\"^2:\",10310,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"^>W\",\"^7W\",\"^2M\"]]]]]],\"^1;\",\"~$cljs.core/print-map\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$m\",\"^>W\",\"^7W\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10310,\"^2H\",\"^2S\",\"^2:\",10310,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"^>W\",\"^7W\",\"^2M\"]]]]]],\"~$map?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2151,\"^26\",7,\"^2:\",2151,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies IMap\"],\"^1;\",\"~$cljs.core/map?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2151,\"^2H\",\"^3D\",\"^2:\",2151,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies IMap\"],\"~$m3-C1\",[\"^ \",\"^1;\",\"~$cljs.core/m3-C1\",\"^24\",\"cljs/core.cljs\",\"^29\",911,\"^26\",1,\"^2:\",911,\"^25\",11,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",911,\"^26\",6,\"^2:\",911,\"^25\",11],\"^2R\",\"^<\"],\"~$get\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1935,\"^26\",7,\"^2:\",1935,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]]]],\"^2B\",\"Returns the value mapped to key, not-found or nil if key not present.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/get\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^4C\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",1935,\"^2:\",1935,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$o\",\"~$k\"],[\"~$o\",\"~$k\",\"^7?\"]]],\"^2B\",\"Returns the value mapped to key, not-found or nil if key not present.\"],\"~$identity\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2565,\"^26\",7,\"^2:\",2565,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns its argument.\"],\"^1;\",\"~$cljs.core/identity\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2565,\"^2:\",2565,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns its argument.\"],\"~$into\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5207,\"^26\",7,\"^2:\",5207,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]]]],\"^2B\",\"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]],\"^2;\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/into\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]],\"^2;\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^94\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]]],\"^29\",5207,\"^2:\",5207,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^F1\"],[\"^F1\",\"^F0\"],[\"^F1\",\"^5[\",\"^F0\"]]],\"^2B\",\"Returns a new coll consisting of to-coll with all of the items of\\n  from-coll conjoined. A transducer may be supplied.\"],\"~$long\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2806,\"^26\",7,\"^2:\",2806,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to long by stripping decimal places. Identical to `int'.\"],\"^1;\",\"~$cljs.core/long\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2806,\"^2H\",\"^<\",\"^2:\",2806,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to long by stripping decimal places. Identical to `int'.\"],\"~$double\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2707,\"^26\",15,\"^2:\",2707,\"^25\",21,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/double\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2707,\"^2H\",\"^<\",\"^2:\",2707,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$volatile?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4570,\"^26\",7,\"^2:\",4570,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is a volatile.\"],\"^1;\",\"~$cljs.core/volatile?\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4570,\"^2H\",\"^3D\",\"^2:\",4570,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is a volatile.\"],\"~$ChunkBuffer\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1V\",\"^1Y\"]],\"^1;\",\"^CH\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^45\",true,\"^26\",10,\"^29\",3495,\"^46\",false,\"^2:\",3495,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Y\"]]],\"~$HashSetIter\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^@4\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^45\",true,\"^26\",10,\"^29\",9133,\"^46\",false,\"^2:\",9133,\"^2R\",\"^47\",\"^2A\",null],\"^CJ\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",646,\"^26\",4,\"^2:\",646,\"^25\",8,\"^69\",\"^96\",\"^2B\",\"Returns the key of the map entry.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^96\",\"^1;\",\"~$cljs.core/-key\",\"^24\",\"cljs/core.cljs\",\"^25\",8,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",644,\"^2H\",\"^2S\",\"^2:\",646,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the key of the map entry.\"],\"~$nfirst\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1753,\"^26\",7,\"^2:\",1753,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (next (first x))\"],\"^1;\",\"~$cljs.core/nfirst\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1753,\"^2H\",\"^2[\",\"^2:\",1753,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (next (first x))\"],\"~$StringBufferWriter\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^9H\"]],\"^1;\",\"~$cljs.core/StringBufferWriter\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^45\",true,\"^26\",10,\"^29\",872,\"^46\",false,\"^2:\",872,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^9H\"]]],\"^2>\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2075,\"^26\",7,\"^2:\",2075,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the metadata of obj, returns nil if there is no metadata.\"],\"^1;\",\"~$cljs.core/meta\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$o\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2075,\"^2H\",[\"^1:\",[\"~$clj-or-nil\",\"^4C\"]],\"^2:\",2075,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the metadata of obj, returns nil if there is no metadata.\"],\"~$tv-editable-tail\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5993,\"^26\",8,\"^2:\",5993,\"^25\",24,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$tl\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tv-editable-tail\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^FT\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5993,\"^2H\",\"^7F\",\"^2:\",5993,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^FT\"]]]]]],\"^9>\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",700,\"^26\",4,\"^2:\",700,\"^25\",14,\"^69\",\"^9@\",\"^2B\",\"Reduces an associative collection and returns the result. f should be\\n     a function that takes three arguments.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$f\",\"^9?\"]]]]]],\"^69\",\"^9@\",\"^1;\",\"~$cljs.core/-kv-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\",\"~$f\",\"^9?\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",697,\"^2H\",\"^2S\",\"^2:\",700,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$f\",\"^9?\"]]]]],\"^2B\",\"Reduces an associative collection and returns the result. f should be\\n     a function that takes three arguments.\"],\"~$IHash\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",709,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-hash\",[[\"~$o\"]]]],\"^2:\",709,\"^2B\",\"Protocol for adding hashing functionality to a type.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1R\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",709,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^FX\",[[\"~$o\"]]]],\"^3:\",null,\"^2:\",709,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^4B\",\"^57\",\"^EL\",\"^58\",\"^?<\",\"^59\",\"^:<\",\"^?=\",\"^5R\",\"^<5\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^4R\",\"^?A\",\"^?B\",\"^7P\",\"~$default\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^2I\",\"^5=\",\"^?G\",\"^?H\",\"^90\",\"^7R\",\"^?I\",\"^<G\",\"^3Z\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for adding hashing functionality to a type.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$bit-and-not\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2865,\"^26\",7,\"^2:\",2865,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Bitwise and with complement\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/bit-and-not\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2865,\"^2:\",2865,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Bitwise and with complement\"],\"~$var?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1094,\"^26\",7,\"^2:\",1094,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\"]]]]],\"^2B\",\"Returns true if v is of type cljs.core.Var\"],\"^1;\",\"~$cljs.core/var?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1094,\"^2H\",\"^3D\",\"^2:\",1094,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\"]]]]],\"^2B\",\"Returns true if v is of type cljs.core.Var\"],\"~$-comparator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",747,\"^26\",4,\"^2:\",747,\"^25\",15,\"^69\",\"^75\",\"^2B\",\"Returns the comparator for coll.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^75\",\"^1;\",\"~$cljs.core/-comparator\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",733,\"^2H\",\"^2S\",\"^2:\",747,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the comparator for coll.\"],\"~$unchecked-add-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",32,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",15,\"^29\",2722,\"^2:\",2722,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the sum of nums. (+) returns 0.\"],\"^1;\",\"~$cljs.core/unchecked-add-int\",\"^24\",\"cljs/core.cljs\",\"^25\",32,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2722,\"^2H\",\"^<\",\"^2:\",2722,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the sum of nums. (+) returns 0.\"],\"~$hash-ordered-coll\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1328,\"^26\",15,\"^2:\",1328,\"^25\",32,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"],\"^1;\",\"~$cljs.core/hash-ordered-coll\",\"^24\",\"cljs/core.cljs\",\"^25\",32,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1328,\"^2H\",\"^<\",\"^2:\",1328,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the hash code, consistent with =, for an external ordered\\n   collection implementing Iterable.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"],\"~$extend-object!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3024,\"^26\",8,\"^2:\",3024,\"^25\",22,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"~$fn-map\"]]]]],\"^2B\",\"Takes a JavaScript object and a map of names to functions and\\n  attaches said functions as methods on the object.  Any references to\\n  JavaScript's implicit this (via the this-as macro) will resolve to the\\n  object that the function is attached.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/extend-object!\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^3B\",\"^G9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3024,\"^2:\",3024,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^G9\"]]]]],\"^2B\",\"Takes a JavaScript object and a map of names to functions and\\n  attaches said functions as methods on the object.  Any references to\\n  JavaScript's implicit this (via the this-as macro) will resolve to the\\n  object that the function is attached.\"],\"~$do-assoc\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5416,\"^26\",8,\"^2:\",5416,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"^:B\",\"^8@\",\"~$i\",\"^37\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/do-assoc\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^6J\",\"^:B\",\"^8@\",\"~$i\",\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5416,\"^2H\",\"^8T\",\"^2:\",5416,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"^:B\",\"^8@\",\"~$i\",\"^37\"]]]]]],\"~$reset-meta!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10493,\"^26\",7,\"^2:\",10493,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$iref\",\"~$m\"]]]]],\"^2B\",\"Atomically resets the metadata for an atom\"],\"^1;\",\"~$cljs.core/reset-meta!\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^G>\",\"~$m\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10493,\"^2:\",10493,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"~$m\"]]]]],\"^2B\",\"Atomically resets the metadata for an atom\"],\"~$->KeySeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",10,\"^27\",\"^28\",\"^29\",8933,\"^2:\",8933,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$mseq\",\"~$_meta\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/KeySeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->KeySeq\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^GA\",\"^GB\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",8933,\"^2H\",\"^?G\",\"^2:\",8933,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^GA\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/KeySeq.\"],\"~$IEquiv\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",14,\"^29\",704,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-equiv\",[[\"~$o\",\"~$other\"]]]],\"^2:\",704,\"^2B\",\"Protocol for adding value comparison functionality to a type.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1Q\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",704,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^GE\",[[\"~$o\",\"^GF\"]]]],\"^3:\",null,\"^2:\",704,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^4B\",\"^57\",\"^58\",\"^?<\",\"^59\",\"^:<\",\"~$js/Date\",\"^?=\",\"^5R\",\"^<5\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^4R\",\"^?A\",\"^?B\",\"^7P\",\"^<\",\"^FY\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^2I\",\"^5=\",\"^?G\",\"^?H\",\"^90\",\"^7R\",\"^?I\",\"^<G\",\"^<O\",\"^3Z\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for adding value comparison functionality to a type.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$tree-map-kv-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8317,\"^26\",8,\"^2:\",8317,\"^25\",26,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\",\"~$f\",\"^9?\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tree-map-kv-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"^8@\",\"~$f\",\"^9?\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8317,\"^2H\",[\"^1:\",[\"^:8\",\"^2S\"]],\"^2:\",8317,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\",\"~$f\",\"^9?\"]]]]]],\"~$cycle\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4892,\"^26\",7,\"^2:\",4892,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"],\"^1;\",\"~$cljs.core/cycle\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4892,\"^2H\",[\"^1:\",[\"^2S\",\"^?C\"]],\"^2:\",4892,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"],\"~$-deref\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",673,\"^26\",4,\"^2:\",673,\"^25\",10,\"^69\",\"^43\",\"^2B\",\"Returns the value of the reference o.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]]],\"^69\",\"^43\",\"^1;\",\"~$cljs.core/-deref\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$o\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",671,\"^2H\",\"^2S\",\"^2:\",673,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the value of the reference o.\"],\"~$pr-writer-ex-info\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11298,\"^26\",8,\"^2:\",11298,\"^25\",25,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^7W\",\"^2M\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pr-writer-ex-info\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^3B\",\"^7W\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11298,\"^2H\",\"^2S\",\"^2:\",11298,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^7W\",\"^2M\"]]]]]],\"~$empty?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2111,\"^26\",7,\"^2:\",2111,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"],\"^1;\",\"~$cljs.core/empty?\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2111,\"^2H\",\"^3D\",\"^2:\",2111,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns true if coll has no items - same as (not (seq coll)).\\n  Please use the idiom (seq x) rather than (not (empty? x))\"],\"~$TaggedLiteral\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\",\"^5Z\",\"^23\"]],\"^1;\",\"^7P\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^45\",true,\"^26\",10,\"^29\",11391,\"^46\",false,\"^2:\",11391,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5Z\",\"^23\"]]],\"~$short\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2705,\"^26\",15,\"^2:\",2705,\"^25\",20,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/short\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2705,\"^2H\",\"^<\",\"^2:\",2705,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^EQ\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10696,\"^26\",4,\"^2:\",10696,\"^25\",12,\"^69\",\"^ES\",\"^2B\",\"Recursively transforms clj values to JavaScript\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^69\",\"^ES\",\"^1;\",\"~$cljs.core/-clj->js\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10695,\"^2H\",\"^2S\",\"^2:\",10696,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Recursively transforms clj values to JavaScript\"],\"~$-chunked-first\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",829,\"^26\",4,\"^2:\",829,\"^25\",18,\"^69\",\"^7T\",\"^2B\",\"Returns the first chunk in coll.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^7T\",\"^1;\",\"~$cljs.core/-chunked-first\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",827,\"^2H\",\"^2S\",\"^2:\",829,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the first chunk in coll.\"],\"~$add-tap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11531,\"^26\",7,\"^2:\",11531,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Adds f, a fn of one argument, to the tap set. This function will be called with\\n  anything sent via tap>. Remember f in order to remove-tap\"],\"^1;\",\"~$cljs.core/add-tap\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11531,\"^2H\",\"^4C\",\"^2:\",11531,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Adds f, a fn of one argument, to the tap set. This function will be called with\\n  anything sent via tap>. Remember f in order to remove-tap\"],\"~$filterv\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5239,\"^26\",7,\"^2:\",5239,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a vector of the items in coll for which\\n  (pred item) returns logical true. pred must be free of side-effects.\"],\"^1;\",\"~$cljs.core/filterv\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5239,\"^2H\",\"^2T\",\"^2:\",5239,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a vector of the items in coll for which\\n  (pred item) returns logical true. pred must be free of side-effects.\"],\"~$->TaggedLiteral\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\",\"^5Z\",\"^23\"]],\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",10,\"^27\",\"^28\",\"^29\",11391,\"^2:\",11391,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$tag\",\"^?V\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5Z\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/TaggedLiteral.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\",\"^5Z\",\"^23\"]],\"^1;\",\"~$cljs.core/->TaggedLiteral\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^H1\",\"^?V\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",11391,\"^2H\",\"^7P\",\"^2:\",11391,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H1\",\"^?V\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5Z\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/TaggedLiteral.\"],\"~$tv-editable-root\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5990,\"^26\",8,\"^2:\",5990,\"^25\",24,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tv-editable-root\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^8@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5990,\"^2H\",\"^8T\",\"^2:\",5990,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8@\"]]]]]],\"^BH\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",987,\"^26\",7,\"^2:\",987,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"],\"^1;\",\"~$cljs.core/hash\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$o\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",987,\"^2H\",[\"^1:\",[null,\"^<\"]],\"^2:\",987,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the hash code of its argument. Note this is the hash code\\n   consistent with =.\"],\"~$quot\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2835,\"^26\",7,\"^2:\",2835,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"quot[ient] of dividing numerator by denominator.\"],\"^1;\",\"~$cljs.core/quot\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$n\",\"~$d\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2835,\"^2H\",\"^<\",\"^2:\",2835,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"quot[ient] of dividing numerator by denominator.\"],\"~$ns-interns*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11621,\"^26\",7,\"^2:\",11621,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$sym\"]]]]],\"^2B\",\"Returns a map of the intern mappings for the namespace.\\n  Bootstrap only.\"],\"^1;\",\"~$cljs.core/ns-interns*\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^H9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11621,\"^2:\",11621,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H9\"]]]]],\"^2B\",\"Returns a map of the intern mappings for the namespace.\\n  Bootstrap only.\"],\"~$unchecked-double\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2713,\"^26\",15,\"^2:\",2713,\"^25\",31,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-double\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2713,\"^2H\",\"^<\",\"^2:\",2713,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$*target*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^26\",3,\"^6R\",true,\"^29\",48,\"^5M\",true,\"^2:\",48,\"^2R\",\"^3J\",\"^2B\",\"Var bound to the name value of the compiler build :target option.\\n  For example, if the compiler build :target is :nodejs, *target* will be bound\\n  to \\\"nodejs\\\". *target* is a Google Closure define and can be set by compiler\\n  :closure-defines option.\"],\"^1;\",\"~$cljs.core/*target*\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^26\",1,\"^6R\",true,\"^29\",42,\"^5M\",true,\"^2:\",48,\"^2R\",\"^3J\",\"^2B\",\"Var bound to the name value of the compiler build :target option.\\n  For example, if the compiler build :target is :nodejs, *target* will be bound\\n  to \\\"nodejs\\\". *target* is a Google Closure define and can be set by compiler\\n  :closure-defines option.\"],\"~$->ChunkedCons\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\"]],\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",10,\"^27\",\"^28\",\"^29\",3544,\"^2:\",3544,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;9\",\"^6M\",\"^2>\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/ChunkedCons.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\"]],\"^1;\",\"~$cljs.core/->ChunkedCons\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^;9\",\"^6M\",\"^2>\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3544,\"^2H\",\"^?I\",\"^2:\",3544,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;9\",\"^6M\",\"^2>\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/ChunkedCons.\"],\"~$ranged-iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5452,\"^26\",7,\"^2:\",5452,\"^25\",22,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\",\"^51\",\"^52\"]]]]]],\"^1;\",\"~$cljs.core/ranged-iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"~$v\",\"^51\",\"^52\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5452,\"^2H\",\"~$cljs.core/RangedIterator\",\"^2:\",5452,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\",\"^51\",\"^52\"]]]]]],\"~$ITransientVector\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^26\",14,\"^29\",804,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-assoc-n!\",[[\"^35\",\"~$n\",\"^37\"]],\"~$-pop!\",[[\"^35\"]]]],\"^2:\",804,\"^2B\",\"Protocol for adding vector functionality to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^@<\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^26\",1,\"^29\",804,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^HE\",[[\"^35\",\"~$n\",\"^37\"]],\"^HF\",[[\"^35\"]]]],\"^3:\",null,\"^2:\",804,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^3<\"]],\"^2B\",\"Protocol for adding vector functionality to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^36\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9007,\"^26\",7,\"^2:\",9007,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$map-entry\"]]]]],\"^2B\",\"Returns the key of the map entry.\"],\"^1;\",\"~$cljs.core/key\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^HG\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9007,\"^2H\",\"^2S\",\"^2:\",9007,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^HG\"]]]]],\"^2B\",\"Returns the key of the map entry.\"],\"~$longs\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2823,\"^26\",7,\"^2:\",2823,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/longs\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2823,\"^2:\",2823,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$not=\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",3988,\"^2:\",3988,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Same as (not (= obj1 obj2))\"],\"^1;\",\"~$cljs.core/not=\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",3988,\"^2H\",\"^3D\",\"^2:\",3988,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Same as (not (= obj1 obj2))\"],\"~$set-print-err-fn!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",90,\"^26\",7,\"^2:\",90,\"^25\",24,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Set *print-err-fn* to f.\"],\"^1;\",\"~$cljs.core/set-print-err-fn!\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",90,\"^2:\",90,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Set *print-err-fn* to f.\"],\"~$string?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",265,\"^26\",16,\"^2:\",265,\"^25\",23,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is a JavaScript string.\"],\"^1;\",\"~$cljs.core/string?\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",265,\"^2H\",\"^3D\",\"^2:\",265,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is a JavaScript string.\"],\"~$uri?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11681,\"^26\",7,\"^2:\",11681,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true x is a goog.Uri instance.\",\"^7B\",\"1.9\"],\"^7B\",\"1.9\",\"^1;\",\"~$cljs.core/uri?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11681,\"^2H\",\"^3D\",\"^2:\",11681,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true x is a goog.Uri instance.\"],\"~$es6-iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1289,\"^26\",7,\"^2:\",1289,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"],\"^1;\",\"~$cljs.core/es6-iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1289,\"^2H\",\"^8R\",\"^2:\",1289,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"EXPERIMENTAL: Return a ES2015 compatible iterator for coll.\"],\"~$Delay\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^8J\",\"^43\",\"^5Z\"]],\"^1;\",\"^??\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^45\",true,\"^26\",10,\"^29\",10545,\"^46\",false,\"^2:\",10545,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^8J\",\"^43\",\"^5Z\"]]],\"~$munge-str\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11478,\"^26\",8,\"^2:\",11478,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/munge-str\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^:\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11478,\"^2H\",\"^2S\",\"^2:\",11478,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\"]]]]]],\"~$pr-str-with-opts\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10198,\"^26\",7,\"^2:\",10198,\"^25\",23,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]],\"^2B\",\"Prints a sequence of objects to a string, observing all the\\n  options given in opts\"],\"^1;\",\"~$cljs.core/pr-str-with-opts\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^79\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10198,\"^2H\",\"^3J\",\"^2:\",10198,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]],\"^2B\",\"Prints a sequence of objects to a string, observing all the\\n  options given in opts\"],\"~$->RecordIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",6514,\"^2:\",6514,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$i\",\"~$record\",\"~$base-count\",\"~$fields\",\"~$ext-map-iter\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/RecordIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->RecordIter\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$i\",\"^H[\",\"^I0\",\"^I1\",\"^I2\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6514,\"^2H\",\"^@V\",\"^2:\",6514,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$i\",\"^H[\",\"^I0\",\"^I1\",\"^I2\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/RecordIter.\"],\"~$m3-C2\",[\"^ \",\"^1;\",\"~$cljs.core/m3-C2\",\"^24\",\"cljs/core.cljs\",\"^29\",912,\"^26\",1,\"^2:\",912,\"^25\",11,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",912,\"^26\",6,\"^2:\",912,\"^25\",11],\"^2R\",\"^<\"],\"~$->Symbol\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^<X\",\"^1[\",\"^5Z\",\"^22\"]],\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",10,\"^27\",\"^28\",\"^29\",1060,\"^2:\",1060,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\",\"^:\",\"~$str\",\"~$_hash\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^<X\",\"^1[\",\"^5Z\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/Symbol.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^<X\",\"^1[\",\"^5Z\",\"^22\"]],\"^1;\",\"~$cljs.core/->Symbol\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^4@\",\"^:\",\"^I7\",\"^I8\",\"^GB\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",1060,\"^2H\",\"^<G\",\"^2:\",1060,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\",\"^:\",\"^I7\",\"^I8\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^<X\",\"^1[\",\"^5Z\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/Symbol.\"],\"~$*print-newline*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",106,\"^26\",3,\"^2:\",106,\"^25\",18,\"^6R\",true,\"^2B\",\"When set to logical false will drop newlines from printing calls.\\n  This is to work around the implicit newlines emitted by standard JavaScript\\n  console objects.\"],\"^1;\",\"~$cljs.core/*print-newline*\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^6R\",true,\"^29\",101,\"^2:\",106,\"^2R\",\"^3D\",\"^2B\",\"When set to logical false will drop newlines from printing calls.\\n  This is to work around the implicit newlines emitted by standard JavaScript\\n  console objects.\"],\"~$unchecked-multiply-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",37,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",15,\"^29\",2759,\"^2:\",2759,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the product of nums. (*) returns 1.\"],\"^1;\",\"~$cljs.core/unchecked-multiply-int\",\"^24\",\"cljs/core.cljs\",\"^25\",37,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2759,\"^2H\",\"^<\",\"^2:\",2759,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the product of nums. (*) returns 1.\"],\"~$tapset\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11525,\"^26\",3,\"^2:\",11525,\"^25\",9,\"^38\",[\"@type {*}\"],\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/tapset\",\"^24\",\"cljs/core.cljs\",\"^25\",9,\"^26\",1,\"^29\",11524,\"^2:\",11525,\"^2R\",\"^4C\",\"^38\",[\"@type {*}\"]],\"~$chunk-rest\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3631,\"^26\",7,\"^2:\",3631,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"^1;\",\"~$cljs.core/chunk-rest\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3631,\"^2H\",\"^2S\",\"^2:\",3631,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"~$remove-all-methods\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11210,\"^26\",7,\"^2:\",11210,\"^25\",25,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Removes all of the methods of multimethod.\"],\"^1;\",\"~$cljs.core/remove-all-methods\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^8C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11210,\"^2H\",\"^2S\",\"^2:\",11210,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Removes all of the methods of multimethod.\"],\"~$trampoline\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10794,\"^26\",7,\"^2:\",10794,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^AP\"]]]]],\"^2B\",\"trampoline can be used to convert algorithms requiring mutual\\n  recursion without stack consumption. Calls f with supplied args, if\\n  any. If f returns a fn, calls that fn with no arguments, and\\n  continues to repeat, until the return value is not a fn, then\\n  returns that non-fn value. Note that if you want to return a fn as a\\n  final value, you must wrap it in some data structure and unpack it\\n  after trampoline returns.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/trampoline\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",10794,\"^2:\",10794,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$&\",\"^AP\"]]],\"^2B\",\"trampoline can be used to convert algorithms requiring mutual\\n  recursion without stack consumption. Calls f with supplied args, if\\n  any. If f returns a fn, calls that fn with no arguments, and\\n  continues to repeat, until the return value is not a fn, then\\n  returns that non-fn value. Note that if you want to return a fn as a\\n  final value, you must wrap it in some data structure and unpack it\\n  after trampoline returns.\"],\"~$double?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2325,\"^26\",7,\"^2:\",2325,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true for JavaScript numbers, false otherwise.\"],\"^1;\",\"~$cljs.core/double?\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2325,\"^2H\",\"^3D\",\"^2:\",2325,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true for JavaScript numbers, false otherwise.\"],\"~$pr-opts\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",176,\"^26\",8,\"^2:\",176,\"^25\",15,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pr-opts\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",176,\"^2H\",\"^<W\",\"^2:\",176,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]]],\"~$*1\",[\"^ \",\"^1;\",\"~$cljs.core/*1\",\"^24\",\"cljs/core.cljs\",\"^29\",199,\"^26\",1,\"^2:\",201,\"^25\",5,\"^2B\",\"bound in a repl thread to the most recent value printed\",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",201,\"^26\",3,\"^2:\",201,\"^25\",5,\"^2B\",\"bound in a repl thread to the most recent value printed\"]],\"~$vec\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5700,\"^26\",7,\"^2:\",5700,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"],\"^1;\",\"~$cljs.core/vec\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5700,\"^2H\",[\"^1:\",[\"^2T\",\"^94\",\"^2S\",\"^5A\",\"^4C\"]],\"^2:\",5700,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Creates a new vector containing the contents of coll. JavaScript arrays\\n  will be aliased and should not be modified.\"],\"~$->Cycle\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",10,\"^27\",\"^28\",\"^29\",4831,\"^2:\",4831,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$all\",\"~$prev\",\"~$current\",\"^;A\"]]]]],\"^2A\",[\"^1:\",[\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Cycle.\"],\"^1P\",[\"^1:\",[\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->Cycle\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2>\",\"^IO\",\"^IP\",\"^IQ\",\"^;A\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4831,\"^2H\",\"^?C\",\"^2:\",4831,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^IO\",\"^IP\",\"^IQ\",\"^;A\"]]]]],\"^2A\",[\"^1:\",[\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Cycle.\"],\"~$*print-meta*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",122,\"^26\",3,\"^2:\",122,\"^25\",15,\"^6R\",true,\"^2B\",\"If set to logical true, when printing an object, its metadata will also\\n  be printed in a form that can be read back by the reader.\\n\\n  Defaults to false.\"],\"^1;\",\"~$cljs.core/*print-meta*\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",1,\"^6R\",true,\"^29\",116,\"^2:\",122,\"^2R\",\"^3D\",\"^2B\",\"If set to logical true, when printing an object, its metadata will also\\n  be printed in a form that can be read back by the reader.\\n\\n  Defaults to false.\"],\"~$-notify-watches\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",773,\"^26\",4,\"^2:\",773,\"^25\",19,\"^69\",\"^D7\",\"^2B\",\"Calls all watchers with this, oldval and newval.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^D8\",\"^EW\",\"^;7\"]]]]]],\"^69\",\"^D7\",\"^1;\",\"~$cljs.core/-notify-watches\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^D8\",\"^EW\",\"^;7\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",771,\"^2H\",\"^2S\",\"^2:\",773,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^D8\",\"^EW\",\"^;7\"]]]]],\"^2B\",\"Calls all watchers with this, oldval and newval.\"],\"~$MultiFn\",[\"^ \",\"^41\",8,\"^1P\",[\"^1:\",[\"^1R\",\"^1S\",\"^81\",\"^<X\"]],\"^1;\",\"^EL\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",11025,\"^46\",false,\"^2:\",11025,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1R\",\"^1S\",\"^81\",\"^<X\"]]],\"~$NONE\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4075,\"^26\",16,\"^2:\",4075,\"^25\",20,\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/NONE\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",4075,\"^2:\",4075,\"^2R\",\"^4>\"],\"~$int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2796,\"^26\",7,\"^2:\",2796,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to int by stripping decimal places.\"],\"^1;\",\"~$cljs.core/int\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2796,\"^2H\",\"^<\",\"^2:\",2796,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to int by stripping decimal places.\"],\"~$->ValSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",10,\"^27\",\"^28\",\"^29\",9012,\"^2:\",9012,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^GA\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ValSeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->ValSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^GA\",\"^GB\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9012,\"^2H\",\"^?B\",\"^2:\",9012,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^GA\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ValSeq.\"],\"~$map-entry?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6726,\"^26\",7,\"^2:\",6726,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x satisfies IMapEntry\"],\"^1;\",\"~$cljs.core/map-entry?\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6726,\"^2H\",\"^3D\",\"^2:\",6726,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x satisfies IMapEntry\"],\"~$rand\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10810,\"^26\",7,\"^2:\",10810,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$n\"]]]]],\"^2B\",\"Returns a random floating point number between 0 (inclusive) and\\n  n (default 1) (exclusive).\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"~$n\"]]],\"^2;\",[\"^2<\",[[],[\"~$n\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/rand\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"~$n\"]]],\"^2;\",[\"^2<\",[[],[\"~$n\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[],[\"~$n\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^<\"]],\"^29\",10810,\"^2:\",10810,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$n\"]]],\"^2B\",\"Returns a random floating point number between 0 (inclusive) and\\n  n (default 1) (exclusive).\"],\"~$second\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1743,\"^26\",7,\"^2:\",1743,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (first (next x))\"],\"^1;\",\"~$cljs.core/second\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1743,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",1743,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (first (next x))\"],\"~$find-ns-obj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11598,\"^26\",7,\"^2:\",11598,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\"]]]]],\"^2B\",\"Bootstrap only.\"],\"^1;\",\"~$cljs.core/find-ns-obj\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^4@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11598,\"^2:\",11598,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\"]]]]],\"^2B\",\"Bootstrap only.\"],\"~$IEditableCollection\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^26\",14,\"^29\",781,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^>R\",[[\"^2X\"]]]],\"^2:\",781,\"^2B\",\"Protocol for collections which can transformed to transients.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1U\",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^26\",1,\"^29\",781,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^>R\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",781,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^59\",\"^5<\",\"^2I\"]],\"^2B\",\"Protocol for collections which can transformed to transients.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$hash-combine\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1023,\"^26\",7,\"^2:\",1023,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$seed\",\"^BH\"]]]]]],\"^1;\",\"~$cljs.core/hash-combine\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^J<\",\"^BH\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1023,\"^2H\",\"^<\",\"^2:\",1023,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^J<\",\"^BH\"]]]]]],\"~$>\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",2653,\"^2:\",2653,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"],\"^1;\",\"~$cljs.core/>\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",2653,\"^2H\",\"^3D\",\"^2:\",2653,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns non-nil if nums are in monotonically decreasing order,\\n  otherwise false.\"],\"~$-name\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^<X\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",12,\"^29\",841,\"^2:\",841,\"^2R\",\"^3J\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the name String of x.\"],\"^69\",\"^<X\",\"^1;\",\"~$cljs.core/-name\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",839,\"^2H\",\"^3J\",\"^2:\",841,\"^2J\",1,\"^2R\",\"^3J\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the name String of x.\"],\"~$replace\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9448,\"^26\",7,\"^2:\",9448,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$smap\"],[\"^JB\",\"^2X\"]]]]],\"^2B\",\"Given a map of replacement pairs and a vector/collection, returns a\\n  vector/seq with any elements = a key in smap replaced with the\\n  corresponding val in smap.  Returns a transducer when no collection\\n  is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^JB\"],[\"^JB\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^JB\"],[\"^JB\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/replace\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^JB\"],[\"^JB\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^JB\"],[\"^JB\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^JB\"],[\"^JB\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\",\"^3U\"]]]],\"^29\",9448,\"^2:\",9448,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^JB\"],[\"^JB\",\"^2X\"]]],\"^2B\",\"Given a map of replacement pairs and a vector/collection, returns a\\n  vector/seq with any elements = a key in smap replaced with the\\n  corresponding val in smap.  Returns a transducer when no collection\\n  is provided.\"],\"~$int?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2267,\"^26\",7,\"^2:\",2267,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"],\"^1;\",\"~$cljs.core/int?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2267,\"^2H\",\"^3D\",\"^2:\",2267,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies integer? or is an instance of goog.math.Integer\\n   or goog.math.Long.\"],\"~$->Subvec\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",10,\"^27\",\"^28\",\"^29\",5823,\"^2:\",5823,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$v\",\"^51\",\"^52\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Subvec.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->Subvec\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^2>\",\"~$v\",\"^51\",\"^52\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",5823,\"^2H\",\"^5;\",\"^2:\",5823,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$v\",\"^51\",\"^52\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Subvec.\"],\"~$associative?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2131,\"^26\",7,\"^2:\",2131,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements IAssociative\"],\"^1;\",\"~$cljs.core/associative?\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2131,\"^2H\",\"^3D\",\"^2:\",2131,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements IAssociative\"],\"~$unchecked-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2801,\"^26\",7,\"^2:\",2801,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to int by stripping decimal places.\"],\"^1;\",\"~$cljs.core/unchecked-int\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2801,\"^2H\",\"^<\",\"^2:\",2801,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Coerce to int by stripping decimal places.\"],\"~$js-keys\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2182,\"^26\",7,\"^2:\",2182,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\"]]]]],\"^2B\",\"Return the JavaScript keys for an object.\"],\"^1;\",\"~$cljs.core/js-keys\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^3B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2182,\"^2H\",\"^2S\",\"^2:\",2182,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\"]]]]],\"^2B\",\"Return the JavaScript keys for an object.\"],\"~$inst-ms*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1381,\"^26\",4,\"^2:\",1381,\"^25\",12,\"^69\",\"~$cljs.core/Inst\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7<\"]]]]]],\"^69\",\"^JO\",\"^1;\",\"~$cljs.core/inst-ms*\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^7<\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1380,\"^2H\",\"^2S\",\"^2:\",1381,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7<\"]]]]],\"^2B\",null],\"~$ES6EntriesIterator\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^C0\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^45\",true,\"^26\",10,\"^29\",6527,\"^46\",false,\"^2:\",6527,\"^2R\",\"^47\",\"^2A\",null],\"~$keyword?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3330,\"^26\",7,\"^2:\",3330,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a Keyword\"],\"^1;\",\"~$cljs.core/keyword?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3330,\"^2H\",\"^3D\",\"^2:\",3330,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a Keyword\"],\"~$array-iter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4027,\"^26\",7,\"^2:\",4027,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/array-iter\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4027,\"^2H\",\"~$cljs.core/ArrayIter\",\"^2:\",4027,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$force\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10567,\"^26\",7,\"^2:\",10567,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"If x is a Delay, returns the (possibly cached) value of its expression, else returns x\"],\"^1;\",\"~$cljs.core/force\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10567,\"^2H\",[\"^1:\",[null,\"^2S\"]],\"^2:\",10567,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"If x is a Delay, returns the (possibly cached) value of its expression, else returns x\"],\"~$group-by\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10827,\"^26\",7,\"^2:\",10827,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^2X\"]]]]],\"^2B\",\"Returns a map of the elements of coll keyed by the result of\\n  f on each element. The value at each key will be a vector of the\\n  corresponding elements, in the order they appeared in coll.\"],\"^1;\",\"~$cljs.core/group-by\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10827,\"^2H\",\"^2T\",\"^2:\",10827,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^2X\"]]]]],\"^2B\",\"Returns a map of the elements of coll keyed by the result of\\n  f on each element. The value at each key will be a vector of the\\n  corresponding elements, in the order they appeared in coll.\"],\"^DW\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^5O\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",9,\"^29\",730,\"^2:\",730,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq of the items in coll in reversed order.\"],\"^69\",\"^5O\",\"^1;\",\"~$cljs.core/-rseq\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",728,\"^2H\",\"^2T\",\"^2:\",730,\"^2J\",1,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq of the items in coll in reversed order.\"],\"~$prn\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10271,\"^26\",7,\"^2:\",10271,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^79\"]]]]],\"^2B\",\"Same as pr followed by (newline).\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/prn\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^4C\"]],\"^29\",10271,\"^2H\",\"^2S\",\"^2:\",10271,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2B\",\"Same as pr followed by (newline).\"],\"~$tv-pop-tail\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6010,\"^26\",8,\"^2:\",6010,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8N\",\"^:B\",\"^8@\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tv-pop-tail\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^8N\",\"^:B\",\"^8@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6010,\"^2H\",[\"^1:\",[null,\"^8T\",\"^4C\"]],\"^2:\",6010,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8N\",\"^:B\",\"^8@\"]]]]]],\"^BQ\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11239,\"^26\",7,\"^2:\",11239,\"^25\",27,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, return it's default-dispatch-val.\"],\"^1;\",\"~$cljs.core/default-dispatch-val\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^8C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11239,\"^2H\",\"^2S\",\"^2:\",11239,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, return it's default-dispatch-val.\"],\"~$RangeChunk\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^5N\",\"^1Y\",\"^4J\",\"^:S\"]],\"^1;\",\"^:T\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^45\",true,\"^26\",10,\"^29\",9635,\"^46\",false,\"^2:\",9635,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^1Y\",\"^4J\"]]],\"~$->Atom\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^D7\",\"~$cljs.core/IAtom\",\"^1Q\",\"^1R\",\"^1V\",\"^1[\",\"^43\"]],\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",10,\"^27\",\"^28\",\"^29\",4414,\"^2:\",4414,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$state\",\"^2>\",\"^8Z\",\"~$watches\"]]]]],\"^2A\",[\"^1:\",[\"^D7\",\"^K7\",\"^1Q\",\"^1R\",\"^1[\",\"^43\"]],\"^2B\",\"Positional factory function for cljs.core/Atom.\"],\"^1P\",[\"^1:\",[\"^D7\",\"^K7\",\"^1Q\",\"^1R\",\"^1V\",\"^1[\",\"^43\"]],\"^1;\",\"~$cljs.core/->Atom\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^K8\",\"^2>\",\"^8Z\",\"^K9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4414,\"^2H\",\"^90\",\"^2:\",4414,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^K8\",\"^2>\",\"^8Z\",\"^K9\"]]]]],\"^2A\",[\"^1:\",[\"^D7\",\"^K7\",\"^1Q\",\"^1R\",\"^1[\",\"^43\"]],\"^2B\",\"Positional factory function for cljs.core/Atom.\"],\"~$PersistentHashMap\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1977,\"^26\",10,\"^2:\",1977,\"^25\",27,\"^5M\",true],\"^41\",6,\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^1;\",\"^57\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^45\",true,\"^26\",10,\"^29\",7854,\"^46\",false,\"^5M\",true,\"^2:\",7854,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\"]]],\"~$unchecked-multiply\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",15,\"^29\",2752,\"^2:\",2752,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the product of nums. (*) returns 1.\"],\"^1;\",\"~$cljs.core/unchecked-multiply\",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2752,\"^2H\",\"^<\",\"^2:\",2752,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the product of nums. (*) returns 1.\"],\"~$ArrayNodeSeq\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?A\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^45\",true,\"^26\",10,\"^29\",7772,\"^46\",false,\"^2:\",7772,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$even?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4245,\"^26\",7,\"^2:\",4245,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns true if n is even, throws an exception if n is not an integer\"],\"^1;\",\"~$cljs.core/even?\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4245,\"^2H\",\"^3D\",\"^2:\",4245,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns true if n is even, throws an exception if n is not an integer\"],\"~$es6-iterator-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1306,\"^26\",7,\"^2:\",1306,\"^25\",23,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4L\"]]]]],\"^2B\",\"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"],\"^1;\",\"~$cljs.core/es6-iterator-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^4L\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1306,\"^2H\",\"^2T\",\"^2:\",1306,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4L\"]]]]],\"^2B\",\"EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.\"],\"~$unchecked-dec\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2729,\"^26\",7,\"^2:\",2729,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one less than x, an int.\"],\"^1;\",\"~$cljs.core/unchecked-dec\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2729,\"^2H\",\"^<\",\"^2:\",2729,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one less than x, an int.\"],\"~$Inst\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1380,\"^26\",14,\"^2:\",1380,\"^25\",18,\"^32\",true,\"^38\",[\"^2<\",[\"@interface\"]],\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^JN\",[[\"^7<\"]]]]],\"^32\",true,\"^1;\",\"^JO\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^29\",1380,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^JN\",[[\"^7<\"]]]],\"^3:\",null,\"^2:\",1380,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^GG\"]],\"^38\",[\"^2<\",[\"@interface\"]]],\"~$hash-collision-node-find-index\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7562,\"^26\",8,\"^2:\",7562,\"^25\",38,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"^6C\",\"^36\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/hash-collision-node-find-index\",\"^24\",\"cljs/core.cljs\",\"^25\",38,\"^2D\",[\"^2<\",[[\"^6B\",\"^6C\",\"^36\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7562,\"^2H\",\"^<\",\"^2:\",7562,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"^6C\",\"^36\"]]]]]],\"~$persistent-array-map-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6796,\"^26\",7,\"^2:\",6796,\"^25\",31,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^GB\"]]]]]],\"^1;\",\"~$cljs.core/persistent-array-map-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"^GB\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6796,\"^2H\",[\"^1:\",[\"^<<\",\"^4C\"]],\"^2:\",6796,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^GB\"]]]]]],\"~$RangeIterator\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/RangeIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^45\",true,\"^26\",10,\"^29\",9656,\"^46\",false,\"^2:\",9656,\"^2R\",\"^47\",\"^2A\",null],\"~$tagged-literal?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11421,\"^26\",7,\"^2:\",11421,\"^25\",22,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\"]]]]],\"^2B\",\"Return true if the value is the data representation of a tagged literal\"],\"^1;\",\"~$cljs.core/tagged-literal?\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^4K\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11421,\"^2H\",\"^3D\",\"^2:\",11421,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\"]]]]],\"^2B\",\"Return true if the value is the data representation of a tagged literal\"],\"~$double-array\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3706,\"^26\",7,\"^2:\",3706,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]]]],\"^2B\",\"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/double-array\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^7F\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^7F\"]],\"^29\",3706,\"^2:\",3706,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2B\",\"Creates an array of doubles. Does not coerce array, provided for compatibility\\n  with Clojure.\"],\"~$create-ns\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11634,\"^26\",7,\"^2:\",11634,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]]]],\"^2B\",\"Create a new namespace named by the symbol. Bootstrap only.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]],\"^2;\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/create-ns\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]],\"^2;\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^4B\"]],\"^29\",11634,\"^2:\",11634,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^H9\"],[\"^H9\",\"^@6\"]]],\"^2B\",\"Create a new namespace named by the symbol. Bootstrap only.\"],\"~$->EmptyList\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",10,\"^27\",\"^28\",\"^29\",3113,\"^2:\",3113,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\"]]]]],\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/EmptyList.\"],\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->EmptyList\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^2>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3113,\"^2H\",\"^?>\",\"^2:\",3113,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\"]]]]],\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/EmptyList.\"],\"~$seq-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2458,\"^26\",8,\"^2:\",2458,\"^25\",18,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/seq-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2458,\"^2:\",2458,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^37\",\"^2X\"]]]],\"~$spread\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3762,\"^26\",7,\"^2:\",3762,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$arglist\"]]]]]],\"^1;\",\"~$cljs.core/spread\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^KW\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3762,\"^2H\",[\"^1:\",[\"^2[\",\"^2T\",\"^4C\"]],\"^2:\",3762,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^KW\"]]]]]],\"~$balance-left\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8232,\"^26\",8,\"^2:\",8232,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"~$ins\",\"~$right\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/balance-left\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^36\",\"^37\",\"^KZ\",\"^K[\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8232,\"^2H\",\"^2T\",\"^2:\",8232,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^KZ\",\"^K[\"]]]]]],\"~$rseq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3189,\"^26\",12,\"^2:\",3189,\"^25\",16,\"^2R\",\"^2[\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$rev\"]]]]],\"^2B\",\"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"],\"^1;\",\"~$cljs.core/rseq\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^L2\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3189,\"^2H\",\"^2[\",\"^2:\",3189,\"^2J\",1,\"^2R\",\"^2[\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^L2\"]]]]],\"^2B\",\"Returns, in constant time, a seq of the items in rev (which\\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"],\"~$ex-cause\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11359,\"^26\",7,\"^2:\",11359,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<9\"]]]]],\"^2B\",\"Returns exception cause (an Error / ExceptionInfo) if ex is an\\n  ExceptionInfo.\\n  Otherwise returns nil.\"],\"^1;\",\"~$cljs.core/ex-cause\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^<9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11359,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",11359,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<9\"]]]]],\"^2B\",\"Returns exception cause (an Error / ExceptionInfo) if ex is an\\n  ExceptionInfo.\\n  Otherwise returns nil.\"],\"~$IReset\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",14,\"^29\",849,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-reset!\",[[\"~$o\",\"^D2\"]]]],\"^2:\",849,\"^2B\",\"Protocol for adding resetting functionality.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/IReset\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",849,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^L7\",[[\"~$o\",\"^D2\"]]]],\"^3:\",null,\"^2:\",849,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[]],\"^2B\",\"Protocol for adding resetting functionality.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$IEmptyableCollection\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^26\",14,\"^29\",575,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^7J\",[[\"^2X\"]]]],\"^2:\",575,\"^2B\",\"Protocol for creating an empty collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1X\",\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^26\",1,\"^29\",575,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^7J\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",575,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^?<\",\"^59\",\"^:<\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^2I\",\"^5=\",\"^?G\",\"^?H\",\"^7R\",\"^?I\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for creating an empty collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$array-map-index-of\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6612,\"^26\",8,\"^2:\",6612,\"^25\",26,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-map-index-of\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"~$m\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6612,\"^2H\",\"^<\",\"^2:\",6612,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\"]]]]]],\"~$ex-message\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11352,\"^26\",7,\"^2:\",11352,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<9\"]]]]],\"^2B\",\"Returns the message attached to the given Error / ExceptionInfo object.\\n  For non-Errors returns nil.\"],\"^1;\",\"~$cljs.core/ex-message\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^<9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11352,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",11352,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<9\"]]]]],\"^2B\",\"Returns the message attached to the given Error / ExceptionInfo object.\\n  For non-Errors returns nil.\"],\"~$->NodeIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",11,\"^27\",\"^28\",\"^29\",7188,\"^2:\",7188,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$next-entry\",\"~$next-iter\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/NodeIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->NodeIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"^L?\",\"^L@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",2,\"^2G\",false,\"^27\",\"^28\",\"^29\",7188,\"^2H\",\"~$cljs.core/NodeIterator\",\"^2:\",7188,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^L?\",\"^L@\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/NodeIterator.\"],\"~$*print-fn-bodies*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",169,\"^26\",3,\"^2:\",169,\"^25\",20,\"^6R\",true,\"^2B\",\"*print-fns-bodies* controls whether functions print their source or\\n    only their names.\"],\"^1;\",\"~$cljs.core/*print-fn-bodies*\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^6R\",true,\"^29\",165,\"^2:\",169,\"^2R\",\"^3D\",\"^2B\",\"*print-fns-bodies* controls whether functions print their source or\\n    only their names.\"],\"~$string-print\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10053,\"^26\",7,\"^2:\",10053,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/string-print\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10053,\"^2H\",\"^4C\",\"^2:\",10053,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$float\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2706,\"^26\",15,\"^2:\",2706,\"^25\",20,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/float\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2706,\"^2H\",\"^<\",\"^2:\",2706,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$IRecord\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",14,\"^29\",725,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",725,\"^2B\",\"Marker interface indicating a record object\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"~$cljs.core/IRecord\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",1,\"^29\",725,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",725,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[]],\"^2B\",\"Marker interface indicating a record object\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$pr-str\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10229,\"^26\",7,\"^2:\",10229,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^79\"]]]]],\"^2B\",\"pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/pr-str\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^3J\"]],\"^29\",10229,\"^2H\",\"^2S\",\"^2:\",10229,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2B\",\"pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.\"],\"~$first-array-for-longvec\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5392,\"^26\",8,\"^2:\",5392,\"^25\",31,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/first-array-for-longvec\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"^6J\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5392,\"^2H\",\"^2S\",\"^2:\",5392,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\"]]]]]],\"~$es6-set-entries-iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6549,\"^26\",7,\"^2:\",6549,\"^25\",31,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^1;\",\"~$cljs.core/es6-set-entries-iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6549,\"^2H\",\"^67\",\"^2:\",6549,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"~$concat\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3771,\"^26\",7,\"^2:\",3771,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"~$zs\"]]]]],\"^2B\",\"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^LR\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/concat\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^LR\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3U\"]],\"^29\",3771,\"^2:\",3771,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^LR\"]]],\"^2B\",\"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"],\"~$-methods\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11017,\"^26\",4,\"^2:\",11017,\"^25\",12,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-methods\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^82\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11017,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]],\"^2B\",null],\"~$js-reserved\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11453,\"^26\",3,\"^2:\",11453,\"^25\",14,\"^38\",[\"@type {null|Object}\"]],\"^1;\",\"~$cljs.core/js-reserved\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",1,\"^29\",11451,\"^2:\",11453,\"^2R\",\"^4C\",\"^38\",[\"@type {null|Object}\"]],\"~$IDerefWithTimeout\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",676,\"^26\",14,\"^2:\",676,\"^25\",31,\"^32\",true,\"^38\",[\"^2<\",[\"@interface\"]],\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^E2\",[[\"~$o\",\"^E4\",\"^E5\"]]]]],\"^32\",true,\"^1;\",\"^E3\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^26\",1,\"^29\",676,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^E2\",[[\"~$o\",\"^E4\",\"^E5\"]]]],\"^3:\",null,\"^2:\",676,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[]],\"^38\",[\"^2<\",[\"@interface\"]]],\"~$symbol\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1099,\"^26\",7,\"^2:\",1099,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]]]],\"^2B\",\"Returns a Symbol with the given namespace and name. Arity-1 works\\n  on strings, keywords, and vars.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2;\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/symbol\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2;\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^<G\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<G\"]],\"^29\",1099,\"^2:\",1099,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2B\",\"Returns a Symbol with the given namespace and name. Arity-1 works\\n  on strings, keywords, and vars.\"],\"~$to-array-2d\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3651,\"^26\",7,\"^2:\",3651,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"],\"^1;\",\"~$cljs.core/to-array-2d\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3651,\"^2H\",\"^7F\",\"^2:\",3651,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a (potentially-ragged) 2-dimensional array\\n  containing the contents of coll.\"],\"~$Subvec\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"^5;\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",5823,\"^46\",false,\"^2:\",5823,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]]],\"~$ExceptionInfo\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11310,\"^26\",3,\"^2:\",11310,\"^25\",16,\"^38\",[\"@constructor\"],\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$message\",\"~$data\",\"~$cause\"]]]]]],\"^1;\",\"^?@\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^M3\",\"^M4\",\"^M5\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11309,\"^2H\",\"^2S\",\"^2:\",11310,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^M3\",\"^M4\",\"^M5\"]]]]],\"^38\",[\"@constructor\"]],\"~$mod\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2830,\"^26\",7,\"^2:\",2830,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"Modulus of num and div. Truncates toward negative infinity.\"],\"^1;\",\"~$cljs.core/mod\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$n\",\"~$d\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2830,\"^2H\",\"^<\",\"^2:\",2830,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"Modulus of num and div. Truncates toward negative infinity.\"],\"~$ISet\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",14,\"^29\",651,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-disjoin\",[[\"^2X\",\"~$v\"]]]],\"^2:\",651,\"^2B\",\"Protocol for adding set functionality to a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1W\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^29\",651,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^M9\",[[\"^2X\",\"~$v\"]]]],\"^3:\",null,\"^2:\",651,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^2I\",\"^7R\"]],\"^2B\",\"Protocol for adding set functionality to a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$pop\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2089,\"^26\",7,\"^2:\",2089,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"],\"^1;\",\"~$cljs.core/pop\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2089,\"^2H\",[\"^1:\",[\"^2T\",\"^4C\"]],\"^2:\",2089,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"For a list or queue, returns a new list/queue without the first\\n  item, for a vector, returns a new vector without the last item.\\n  Note - not the same as next/butlast.\"],\"~$IPending\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",14,\"^29\",765,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^DZ\",[[\"~$x\"]]]],\"^2:\",765,\"^2B\",\"Protocol for types which can have a deferred realization. Currently only\\n  implemented by Delay and LazySeq.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^8J\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",1,\"^29\",765,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^DZ\",[[\"~$x\"]]]],\"^3:\",null,\"^2:\",765,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^??\",\"^3U\",\"^?C\",\"^?E\",\"^7D\"]],\"^2B\",\"Protocol for types which can have a deferred realization. Currently only\\n  implemented by Delay and LazySeq.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$-entry-key\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",745,\"^26\",4,\"^2:\",745,\"^25\",14,\"^69\",\"^75\",\"^2B\",\"Returns the key for entry.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$entry\"]]]]]],\"^69\",\"^75\",\"^1;\",\"~$cljs.core/-entry-key\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2X\",\"^M>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",733,\"^2H\",\"^2S\",\"^2:\",745,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"^M>\"]]]]],\"^2B\",\"Returns the key for entry.\"],\"~$CHAR_MAP\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",336,\"^26\",3,\"^2:\",336,\"^25\",11,\"^38\",[\"@enum {string}\"]],\"^1;\",\"~$cljs.core/CHAR_MAP\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^26\",1,\"^29\",335,\"^2:\",336,\"^2R\",\"^4>\",\"^38\",[\"@enum {string}\"]],\"~$pop-tail\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5426,\"^26\",8,\"^2:\",5426,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"^:B\",\"^8@\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pop-tail\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^6J\",\"^:B\",\"^8@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5426,\"^2H\",[\"^1:\",[\"^8T\",\"^4C\"]],\"^2:\",5426,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"^:B\",\"^8@\"]]]]]],\"~$dissoc!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3846,\"^26\",7,\"^2:\",3846,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\",\"^36\"],[\"^35\",\"^36\",\"~$&\",\"^8V\"]]]]],\"^2B\",\"Returns a transient map that doesn't contain a mapping for key(s).\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^35\",\"^36\"]]],\"^2;\",[\"^2<\",[[\"^35\",\"^36\"],[\"^35\",\"^36\",\"~$&\",\"^8V\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/dissoc!\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^35\",\"^36\"]]],\"^2;\",[\"^2<\",[[\"^35\",\"^36\"],[\"^35\",\"^36\",\"~$&\",\"^8V\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^35\",\"^36\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^2T\"]],\"^29\",3846,\"^2:\",3846,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^35\",\"^36\"],[\"^35\",\"^36\",\"~$&\",\"^8V\"]]],\"^2B\",\"Returns a transient map that doesn't contain a mapping for key(s).\"],\"~$reductions\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9883,\"^26\",7,\"^2:\",9883,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy seq of the intermediate values of the reduction (as\\n  per reduce) of coll by f, starting with init.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/reductions\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2T\"]],\"^29\",9883,\"^2:\",9883,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^9?\",\"^2X\"]]],\"^2B\",\"Returns a lazy seq of the intermediate values of the reduction (as\\n  per reduce) of coll by f, starting with init.\"],\"~$indexed?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1524,\"^26\",7,\"^2:\",1524,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements nth in constant time\"],\"^1;\",\"~$cljs.core/indexed?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1524,\"^2H\",\"^3D\",\"^2:\",1524,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements nth in constant time\"],\"~$-\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",15,\"^29\",2606,\"^2:\",2606,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"],\"^1;\",\"~$cljs.core/-\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2606,\"^2H\",\"^<\",\"^2:\",2606,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"],\"~$Cycle\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?C\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^45\",true,\"^26\",10,\"^29\",4831,\"^46\",false,\"^2:\",4831,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"^GE\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^1Q\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",13,\"^29\",706,\"^2:\",706,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^GF\"]]]]],\"^2B\",\"Returns true if o and other are equal, false otherwise.\"],\"^69\",\"^1Q\",\"^1;\",\"~$cljs.core/-equiv\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$o\",\"^GF\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",704,\"^2H\",\"^3D\",\"^2:\",706,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^GF\"]]]]],\"^2B\",\"Returns true if o and other are equal, false otherwise.\"],\"~$->RangeIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",10,\"^27\",\"^28\",\"^29\",9656,\"^2:\",9656,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$i\",\"^52\",\"^=S\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/RangeIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->RangeIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$i\",\"^52\",\"^=S\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9656,\"^2H\",\"^KK\",\"^2:\",9656,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$i\",\"^52\",\"^=S\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/RangeIterator.\"],\"~$->ArrayNode\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",10,\"^27\",\"^28\",\"^29\",7461,\"^2:\",7461,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^6C\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^21\"]],\"^2B\",\"Positional factory function for cljs.core/ArrayNode.\"],\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^1;\",\"~$cljs.core/->ArrayNode\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^>2\",\"^6C\",\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7461,\"^2H\",\"^?O\",\"^2:\",7461,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^6C\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^21\"]],\"^2B\",\"Positional factory function for cljs.core/ArrayNode.\"],\"~$assoc!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3834,\"^26\",7,\"^2:\",3834,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"],[\"^35\",\"^36\",\"^37\",\"~$&\",\"~$kvs\"]]]]],\"^2B\",\"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"],[\"^35\",\"^36\",\"^37\",\"~$&\",\"^MR\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/assoc!\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"],[\"^35\",\"^36\",\"^37\",\"~$&\",\"^MR\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^2T\"]],\"^29\",3834,\"^2:\",3834,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^35\",\"^36\",\"^37\"],[\"^35\",\"^36\",\"^37\",\"~$&\",\"^MR\"]]],\"^2B\",\"When applied to a transient map, adds mapping of key(s) to\\n  val(s). When applied to a transient vector, sets the val at index.\\n  Note - index must be <= (count vector). Returns coll.\"],\"~$hash-set\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9430,\"^26\",7,\"^2:\",9430,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$&\",\"^C[\"]]]]],\"^2B\",\"Returns a new hash set with supplied keys.  Any equal keys are\\n  handled as if by repeated uses of conj.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[\"^2<\",[[]]],\"^2;\",[\"^2<\",[[],[\"~$&\",\"^C[\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/hash-set\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[\"^2<\",[[]]],\"^2;\",[\"^2<\",[[],[\"~$&\",\"^C[\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^1W\"],[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\",\"^1W\",\"^5A\",\"^4C\"]]]],\"^29\",9430,\"^2:\",9430,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$&\",\"^C[\"]]],\"^2B\",\"Returns a new hash set with supplied keys.  Any equal keys are\\n  handled as if by repeated uses of conj.\"],\"~$reduce-kv\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2553,\"^26\",7,\"^2:\",2553,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^9?\",\"^2X\"]]]]],\"^2B\",\"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"],\"^1;\",\"~$cljs.core/reduce-kv\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$f\",\"^9?\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2553,\"^2H\",[\"^1:\",[null,\"^2S\"]],\"^2:\",2553,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^9?\",\"^2X\"]]]]],\"^2B\",\"Reduces an associative collection. f should be a function of 3\\n  arguments. Returns the result of applying f to init, the first key\\n  and the first value in coll, then applying f to that result and the\\n  2nd key and value, etc. If coll contains no entries, returns init\\n  and f is not called. Note that reduce-kv is supported on vectors,\\n  where the keys will be the ordinals.\"],\"~$reset!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4462,\"^26\",7,\"^2:\",4462,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"^D2\"]]]]],\"^2B\",\"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"],\"^1;\",\"~$cljs.core/reset!\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$a\",\"^D2\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4462,\"^2H\",[\"^1:\",[null,\"^2S\"]],\"^2:\",4462,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"^D2\"]]]]],\"^2B\",\"Sets the value of atom to newval without regard for the\\n  current value. Returns new-value.\"],\"^:\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9499,\"^26\",7,\"^2:\",9499,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the name String of a string, symbol or keyword.\"],\"^1;\",\"~$cljs.core/name\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9499,\"^2H\",\"^3J\",\"^2:\",9499,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the name String of a string, symbol or keyword.\"],\"~$->RedNode\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",8455,\"^2:\",8455,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"~$left\",\"^K[\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/RedNode.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->RedNode\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^K[\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",8455,\"^2H\",\"^5>\",\"^2:\",8455,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^K[\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/RedNode.\"],\"~$unchecked-array-for\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5400,\"^26\",8,\"^2:\",5400,\"^25\",27,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"~$i\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/unchecked-array-for\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^6J\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5400,\"^2H\",\"^2S\",\"^2:\",5400,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"~$i\"]]]]]],\"~$Fn\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",14,\"^29\",534,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",534,\"^2B\",\"Marker protocol\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^4Q\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",1,\"^29\",534,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",534,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^4R\",\"^47\",\"^5A\"]],\"^2B\",\"Marker protocol\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$ffirst\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1748,\"^26\",7,\"^2:\",1748,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (first (first x))\"],\"^1;\",\"~$cljs.core/ffirst\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1748,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",1748,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (first (first x))\"],\"~$->ArrayNodeIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",7441,\"^2:\",7441,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^L@\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ArrayNodeIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->ArrayNodeIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"^L@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7441,\"^2H\",\"~$cljs.core/ArrayNodeIterator\",\"^2:\",7441,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"^L@\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ArrayNodeIterator.\"],\"~$sorted-set\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9436,\"^26\",7,\"^2:\",9436,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^C[\"]]]]],\"^2B\",\"Returns a new sorted set with supplied keys.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^C[\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^C[\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/sorted-set\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^C[\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^C[\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^C[\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",9436,\"^2H\",\"^2S\",\"^2:\",9436,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^C[\"]]],\"^2B\",\"Returns a new sorted set with supplied keys.\"],\"~$pr-with-opts\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10215,\"^26\",8,\"^2:\",10215,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]],\"^2B\",\"Prints a sequence of objects using string-print, observing all\\n  the options given in opts\"],\"^5E\",true,\"^1;\",\"~$cljs.core/pr-with-opts\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^79\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10215,\"^2H\",\"^4C\",\"^2:\",10215,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]],\"^2B\",\"Prints a sequence of objects using string-print, observing all\\n  the options given in opts\"],\"~$PersistentTreeMap\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^1;\",\"^5=\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^45\",true,\"^26\",10,\"^29\",8726,\"^46\",false,\"^2:\",8726,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^87\",\"^<W\",\"^23\"]]],\"~$strip-ns\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10278,\"^26\",8,\"^2:\",10278,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$named\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/strip-ns\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^N@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10278,\"^2H\",\"^2T\",\"^2:\",10278,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^N@\"]]]]]],\"~$->PersistentTreeMap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",8726,\"^2:\",8726,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2Y\",\"^62\",\"^6C\",\"^2>\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentTreeMap.\"],\"^1P\",[\"^1:\",[\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^1;\",\"~$cljs.core/->PersistentTreeMap\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^2Y\",\"^62\",\"^6C\",\"^2>\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",8726,\"^2H\",\"^5=\",\"^2:\",8726,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2Y\",\"^62\",\"^6C\",\"^2>\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentTreeMap.\"],\"~$array-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1487,\"^26\",8,\"^2:\",1487,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",1487,\"^2:\",1487,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^6B\",\"~$f\"],[\"^6B\",\"~$f\",\"^37\"],[\"^6B\",\"~$f\",\"^37\",\"^7G\"]]]],\"~$counted?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1520,\"^26\",7,\"^2:\",1520,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements count in constant time\"],\"^1;\",\"~$cljs.core/counted?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1520,\"^2H\",\"^3D\",\"^2:\",1520,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements count in constant time\"],\"~$tagged-literal\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11426,\"^26\",7,\"^2:\",11426,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H1\",\"^?V\"]]]]],\"^2B\",\"Construct a data representation of a tagged literal from a\\n  tag symbol and a form.\"],\"^1;\",\"~$cljs.core/tagged-literal\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^H1\",\"^?V\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11426,\"^2H\",\"^7P\",\"^2:\",11426,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H1\",\"^?V\"]]]]],\"^2B\",\"Construct a data representation of a tagged literal from a\\n  tag symbol and a form.\"],\"^C\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10259,\"^26\",7,\"^2:\",10259,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^79\"]]]]],\"^2B\",\"Same as print followed by (newline)\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/println\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^79\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^4C\"]],\"^29\",10259,\"^2H\",\"^2S\",\"^2:\",10259,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^79\"]]],\"^2B\",\"Same as print followed by (newline)\"],\"~$assoc-in\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5289,\"^26\",7,\"^2:\",5289,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$v\"]]]]],\"^2B\",\"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"],\"^1;\",\"~$cljs.core/assoc-in\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$m\",\"~$p__1996\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5289,\"^2H\",[\"^1:\",[\"^2T\",\"^2S\"]],\"^2:\",5289,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$v\"]]]]],\"^2B\",\"Associates a value in a nested associative structure, where ks is a\\n  sequence of keys and v is the new value and returns a new nested structure.\\n  If any levels do not exist, hash-maps will be created.\"],\"~$PersistentHashSet\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^1W\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^23\"]],\"^1;\",\"^2I\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^45\",true,\"^26\",10,\"^29\",9143,\"^46\",false,\"^2:\",9143,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1W\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^23\"]]],\"~$bit-test\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2890,\"^26\",16,\"^2:\",2890,\"^25\",24,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Test bit at index n\"],\"^1;\",\"~$cljs.core/bit-test\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2890,\"^2H\",\"^3D\",\"^2:\",2890,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Test bit at index n\"],\"~$->Namespace\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",10,\"^27\",\"^28\",\"^29\",11566,\"^2:\",11566,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^:\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\"]],\"^2B\",\"Positional factory function for cljs.core/Namespace.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1V\"]],\"^1;\",\"~$cljs.core/->Namespace\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^3B\",\"^:\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",11566,\"^2H\",\"^4B\",\"^2:\",11566,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^:\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\"]],\"^2B\",\"Positional factory function for cljs.core/Namespace.\"],\"~$TransientHashMap\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7114,\"^26\",10,\"^2:\",7114,\"^25\",26,\"^5M\",true],\"^41\",5,\"^1P\",[\"^1:\",[\"^1S\",\"^:@\",\"^1V\",\"^1Y\",\"^@;\",\"^39\",\"^23\"]],\"^1;\",\"^3=\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^45\",true,\"^26\",10,\"^29\",8032,\"^46\",false,\"^5M\",true,\"^2:\",8032,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1S\",\"^:@\",\"^1Y\",\"^@;\",\"^39\",\"^23\"]]],\"~$->PersistentHashMap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",7854,\"^2:\",7854,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6C\",\"^3S\",\"~$has-nil?\",\"~$nil-val\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentHashMap.\"],\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^1;\",\"~$cljs.core/->PersistentHashMap\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^2>\",\"^6C\",\"^3S\",\"^NU\",\"^NV\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7854,\"^2H\",\"^57\",\"^2:\",7854,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6C\",\"^3S\",\"^NU\",\"^NV\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentHashMap.\"],\"~$array-extend-kv\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6615,\"^26\",8,\"^2:\",6615,\"^25\",23,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\",\"~$v\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-extend-kv\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^6B\",\"~$k\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6615,\"^2H\",\"^7F\",\"^2:\",6615,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\",\"~$v\"]]]]]],\"~$ISwap\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",854,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^E?\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]]],\"^2:\",854,\"^2B\",\"Protocol for adding swapping functionality.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^E@\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",854,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^E?\",[[\"~$o\",\"~$f\"],[\"~$o\",\"~$f\",\"~$a\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\"],[\"~$o\",\"~$f\",\"~$a\",\"~$b\",\"^5F\"]]]],\"^3:\",null,\"^2:\",854,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[]],\"^2B\",\"Protocol for adding swapping functionality.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$ChunkedCons\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2167,\"^26\",10,\"^2:\",2167,\"^25\",21,\"^5M\",true],\"^41\",4,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\"]],\"^1;\",\"^?I\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^45\",true,\"^26\",10,\"^29\",3544,\"^46\",false,\"^5M\",true,\"^2:\",3544,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\"]]],\"~$memoize\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10779,\"^26\",7,\"^2:\",10779,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Returns a memoized version of a referentially transparent function. The\\n  memoized version of the function keeps a cache of the mapping from arguments\\n  to results and, when calls with the same arguments are repeated often, has\\n  higher performance at the expense of higher memory use.\"],\"^1;\",\"~$cljs.core/memoize\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10779,\"^2H\",\"^47\",\"^2:\",10779,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Returns a memoized version of a referentially transparent function. The\\n  memoized version of the function keeps a cache of the mapping from arguments\\n  to results and, when calls with the same arguments are repeated often, has\\n  higher performance at the expense of higher memory use.\"],\"~$alter-meta!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10484,\"^26\",7,\"^2:\",10484,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"~$f\",\"~$&\",\"^AP\"]]]]],\"^2B\",\"Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\\n\\n  (apply f its-current-meta args)\\n\\n  f must be free of side-effects\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[[\"^2<\",[\"^G>\",\"~$f\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"^G>\",\"~$f\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/alter-meta!\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[[\"^2<\",[\"^G>\",\"~$f\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"^G>\",\"~$f\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^G>\",\"~$f\",\"^AP\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",true]],\"^29\",10484,\"^2H\",\"^2S\",\"^2:\",10484,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^G>\",\"~$f\",\"~$&\",\"^AP\"]]],\"^2B\",\"Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\\n\\n  (apply f its-current-meta args)\\n\\n  f must be free of side-effects\"],\"~$->StringBufferWriter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^9H\"]],\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",10,\"^27\",\"^28\",\"^29\",872,\"^2:\",872,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$sb\"]]]]],\"^2A\",[\"^1:\",[\"^9H\"]],\"^2B\",\"Positional factory function for cljs.core/StringBufferWriter.\"],\"^1P\",[\"^1:\",[\"^9H\"]],\"^1;\",\"~$cljs.core/->StringBufferWriter\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2D\",[\"^2<\",[[\"^O5\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",872,\"^2H\",\"^FP\",\"^2:\",872,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^O5\"]]]]],\"^2A\",[\"^1:\",[\"^9H\"]],\"^2B\",\"Positional factory function for cljs.core/StringBufferWriter.\"],\"~$zero?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2935,\"^26\",16,\"^2:\",2935,\"^25\",21,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if num is zero, else false\"],\"^1;\",\"~$cljs.core/zero?\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2935,\"^2H\",\"^3D\",\"^2:\",2935,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if num is zero, else false\"],\"~$tv-ensure-editable\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5985,\"^26\",8,\"^2:\",5985,\"^25\",26,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^8@\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tv-ensure-editable\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"^>2\",\"^8@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5985,\"^2H\",[\"^1:\",[null,\"^8T\"]],\"^2:\",5985,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^8@\"]]]]]],\"~$simple-keyword?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3380,\"^26\",7,\"^2:\",3380,\"^25\",22,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a keyword without a namespace\"],\"^1;\",\"~$cljs.core/simple-keyword?\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3380,\"^2H\",\"^3D\",\"^2:\",3380,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a keyword without a namespace\"],\"~$-indexOf\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1528,\"^26\",8,\"^2:\",1528,\"^25\",16,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/-indexOf\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^<\"]]]],\"^29\",1528,\"^2:\",1528,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\",\"~$x\"],[\"^2X\",\"~$x\",\"^51\"]]]],\"~$*main-cli-fn*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",298,\"^26\",3,\"^2:\",298,\"^25\",16,\"^2B\",\"When compiled for a command-line target, whatever function\\n  *main-cli-fn* is set to will be called with the command-line\\n  argv as arguments\"],\"^1;\",\"~$cljs.core/*main-cli-fn*\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",1,\"^29\",294,\"^2:\",298,\"^2R\",\"^4C\",\"^2B\",\"When compiled for a command-line target, whatever function\\n  *main-cli-fn* is set to will be called with the command-line\\n  argv as arguments\"],\"^?M\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^94\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",9,\"^29\",668,\"^2:\",668,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\",\"^37\"]]]]],\"^2B\",\"Returns a new vector with value val added at position n.\"],\"^69\",\"^94\",\"^1;\",\"~$cljs.core/-assoc-n\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\",\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",666,\"^2H\",\"^2T\",\"^2:\",668,\"^2J\",3,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\",\"^37\"]]]]],\"^2B\",\"Returns a new vector with value val added at position n.\"],\"~$unchecked-dec-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2734,\"^26\",7,\"^2:\",2734,\"^25\",24,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one less than x, an int.\"],\"^1;\",\"~$cljs.core/unchecked-dec-int\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2734,\"^2H\",\"^<\",\"^2:\",2734,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one less than x, an int.\"],\"~$hash-imap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3003,\"^26\",8,\"^2:\",3003,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/hash-imap\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$m\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3003,\"^2H\",\"^<\",\"^2:\",3003,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\"]]]]]],\"~$dominates\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10979,\"^26\",8,\"^2:\",10979,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\",\"^BP\",\"^6?\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/dominates\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\",\"^BP\",\"^6?\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10979,\"^2H\",\"^3D\",\"^2:\",10979,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\",\"^BP\",\"^6?\"]]]]]],\"~$persistent!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3814,\"^26\",7,\"^2:\",3814,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"],\"^1;\",\"~$cljs.core/persistent!\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^35\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3814,\"^2H\",\"^2T\",\"^2:\",3814,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Returns a new, persistent version of the transient collection, in\\n  constant time. The transient collection cannot be used after this\\n  call, any such use will throw an exception.\"],\"~$set-print-fn!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",86,\"^26\",7,\"^2:\",86,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Set *print-fn* to f.\"],\"^1;\",\"~$cljs.core/set-print-fn!\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",86,\"^2:\",86,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Set *print-fn* to f.\"],\"~$nnext\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1763,\"^26\",7,\"^2:\",1763,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (next (next x))\"],\"^1;\",\"~$cljs.core/nnext\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1763,\"^2H\",\"^2[\",\"^2:\",1763,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Same as (next (next x))\"],\"~$Box\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[]],\"^1;\",\"~$cljs.core/Box\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^45\",true,\"^26\",10,\"^29\",7125,\"^46\",false,\"^2:\",7125,\"^2R\",\"^47\",\"^2A\",null],\"~$balance-right\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8257,\"^26\",8,\"^2:\",8257,\"^25\",21,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^KZ\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/balance-right\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^KZ\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8257,\"^2H\",\"^2T\",\"^2:\",8257,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^KZ\"]]]]]],\"~$throw-no-method-error\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11022,\"^26\",8,\"^2:\",11022,\"^25\",29,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\",\"^83\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/throw-no-method-error\",\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^2D\",[\"^2<\",[[\"^:\",\"^83\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11022,\"^2H\",\"^;[\",\"^2:\",11022,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\",\"^83\"]]]]]],\"~$demunge-str\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11500,\"^26\",8,\"^2:\",11500,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$munged-name\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/demunge-str\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^OU\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11500,\"^2H\",\"^3J\",\"^2:\",11500,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^OU\"]]]]]],\"~$add-watch\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10498,\"^26\",7,\"^2:\",10498,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"^36\",\"~$f\"]]]]],\"^2B\",\"Adds a watch function to an atom reference. The watch fn must be a\\n  fn of 4 args: a key, the reference, its old-state, its\\n  new-state. Whenever the reference's state might have been changed,\\n  any registered watches will have their functions called. The watch\\n  fn will be called synchronously. Note that an atom's state\\n  may have changed again prior to the fn call, so use old/new-state\\n  rather than derefing the reference. Keys must be unique per\\n  reference, and can be used to remove the watch with remove-watch,\\n  but are otherwise considered opaque by the watch mechanism.  Bear in\\n  mind that regardless of the result or action of the watch fns the\\n  atom's value will change.  Example:\\n\\n      (def a (atom 0))\\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\\n      (swap! a inc)\\n      ;; Assertion Error\\n      (deref a)\\n      ;=> 1\"],\"^1;\",\"~$cljs.core/add-watch\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^G>\",\"^36\",\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10498,\"^2:\",10498,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"^36\",\"~$f\"]]]]],\"^2B\",\"Adds a watch function to an atom reference. The watch fn must be a\\n  fn of 4 args: a key, the reference, its old-state, its\\n  new-state. Whenever the reference's state might have been changed,\\n  any registered watches will have their functions called. The watch\\n  fn will be called synchronously. Note that an atom's state\\n  may have changed again prior to the fn call, so use old/new-state\\n  rather than derefing the reference. Keys must be unique per\\n  reference, and can be used to remove the watch with remove-watch,\\n  but are otherwise considered opaque by the watch mechanism.  Bear in\\n  mind that regardless of the result or action of the watch fns the\\n  atom's value will change.  Example:\\n\\n      (def a (atom 0))\\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\\n      (swap! a inc)\\n      ;; Assertion Error\\n      (deref a)\\n      ;=> 1\"],\"~$not-every?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4226,\"^26\",7,\"^2:\",4226,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"],\"^1;\",\"~$cljs.core/not-every?\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4226,\"^2H\",\"^3D\",\"^2:\",4226,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns false if (pred x) is logical true for every x in\\n  coll, else true.\"],\"~$rem\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2841,\"^26\",7,\"^2:\",2841,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"remainder of dividing numerator by denominator.\"],\"^1;\",\"~$cljs.core/rem\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$n\",\"~$d\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2841,\"^2H\",\"^<\",\"^2:\",2841,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"remainder of dividing numerator by denominator.\"],\"~$ifind?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2135,\"^26\",7,\"^2:\",2135,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements IFind\"],\"^1;\",\"~$cljs.core/ifind?\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2135,\"^2H\",\"^3D\",\"^2:\",2135,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll implements IFind\"],\"~$pr-sb-with-opts\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10191,\"^26\",8,\"^2:\",10191,\"^25\",23,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pr-sb-with-opts\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^79\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10191,\"^2:\",10191,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]]],\"~$->HashMapIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",10,\"^27\",\"^28\",\"^29\",7842,\"^2:\",7842,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^NV\",\"~$root-iter\",\"~$seen\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/HashMapIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->HashMapIter\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^NV\",\"^P6\",\"^P7\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7842,\"^2H\",\"~$cljs.core/HashMapIter\",\"^2:\",7842,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^NV\",\"^P6\",\"^P7\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/HashMapIter.\"],\"~$BitmapIndexedNode\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^1;\",\"^?P\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^45\",true,\"^26\",10,\"^29\",7226,\"^46\",false,\"^2:\",7226,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^21\"]]],\"~$->NodeSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",7691,\"^2:\",7691,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$nodes\",\"~$i\",\"~$s\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/NodeSeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->NodeSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2>\",\"^P<\",\"~$i\",\"~$s\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7691,\"^2H\",\"^:<\",\"^2:\",7691,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^P<\",\"~$i\",\"~$s\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/NodeSeq.\"],\"~$some\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4231,\"^26\",7,\"^2:\",4231,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"],\"^1;\",\"~$cljs.core/some\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4231,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",4231,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns the first logical true value of (pred x) for any x in coll,\\n  else nil.  One common idiom is to use a set as pred, for example\\n  this will return :fred if :fred is in the sequence, otherwise nil:\\n  (some #{:fred} coll)\"],\"~$INamed\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",14,\"^29\",839,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^J?\",[[\"~$x\"]],\"~$-namespace\",[[\"~$x\"]]]],\"^2:\",839,\"^2B\",\"Protocol for adding a name.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^<X\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",1,\"^29\",839,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^J?\",[[\"~$x\"]],\"^PA\",[[\"~$x\"]]]],\"^3:\",null,\"^2:\",839,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^EL\",\"^<5\",\"^<G\"]],\"^2B\",\"Protocol for adding a name.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->Box\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[]],\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^26\",10,\"^27\",\"^28\",\"^29\",7125,\"^2:\",7125,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Box.\"],\"^1P\",[\"^1:\",[]],\"^1;\",\"~$cljs.core/->Box\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7125,\"^2H\",\"^OO\",\"^2:\",7125,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Box.\"],\"~$IReduce\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",14,\"^29\",689,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^=2\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]]],\"^2:\",689,\"^2B\",\"Protocol for seq types that can reduce themselves.\\n  Called by cljs.core/reduce.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^5Q\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",1,\"^29\",689,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^=2\",[[\"^2X\",\"~$f\"],[\"^2X\",\"~$f\",\"^51\"]]]],\"^3:\",null,\"^2:\",689,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^?<\",\"^3O\",\"^59\",\"^:<\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^?G\",\"^?H\",\"^:U\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for seq types that can reduce themselves.\\n  Called by cljs.core/reduce.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$neg-int?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2291,\"^26\",16,\"^2:\",2291,\"^25\",24,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies int? and is negative.\"],\"^1;\",\"~$cljs.core/neg-int?\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2291,\"^2H\",\"^3D\",\"^2:\",2291,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies int? and is negative.\"],\"~$drop\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4767,\"^26\",7,\"^2:\",4767,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/drop\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",4767,\"^2:\",4767,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of all but the first n items in coll.\\n  Returns a stateful transducer when no collection is provided.\"],\"~$NodeIterator\",[\"^ \",\"^41\",4,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^LB\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^45\",true,\"^26\",11,\"^29\",7188,\"^46\",false,\"^2:\",7188,\"^2R\",\"^47\",\"^2A\",null],\"~$js-obj\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2174,\"^26\",7,\"^2:\",2174,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$&\",\"^:5\"]]]]],\"^2B\",\"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[\"^2<\",[[]]],\"^2;\",[\"^2<\",[[],[\"~$&\",\"^:5\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/js-obj\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[\"^2<\",[[]]],\"^2;\",[\"^2<\",[[],[\"~$&\",\"^:5\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^4>\"],[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",2174,\"^2:\",2174,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$&\",\"^:5\"]]],\"^2B\",\"Create JavaSript object from an even number arguments representing\\n  interleaved keys and values.\"],\"~$ITransientCollection\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^26\",14,\"^29\",786,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-conj!\",[[\"^35\",\"^37\"]],\"^DK\",[[\"^35\"]]]],\"^2:\",786,\"^2B\",\"Protocol for adding basic functionality to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^@;\",\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^26\",1,\"^29\",786,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^PM\",[[\"^35\",\"^37\"]],\"^DK\",[[\"^35\"]]]],\"^3:\",null,\"^2:\",786,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^3<\",\"^3=\",\"^3>\",\"^7Q\"]],\"^2B\",\"Protocol for adding basic functionality to transient collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$Atom\",[\"^ \",\"^41\",4,\"^1P\",[\"^1:\",[\"^D7\",\"^K7\",\"^1Q\",\"^1R\",\"^1V\",\"^1[\",\"^43\"]],\"^1;\",\"^90\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^45\",true,\"^26\",10,\"^29\",4414,\"^46\",false,\"^2:\",4414,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^D7\",\"^K7\",\"^1Q\",\"^1R\",\"^1[\",\"^43\"]]],\"~$nth\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1855,\"^26\",7,\"^2:\",1855,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]]]],\"^2B\",\"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/nth\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^4C\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\",\"^4C\"]]]],\"^29\",1855,\"^2:\",1855,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^2X\",\"~$n\"],[\"^2X\",\"~$n\",\"^7?\"]]],\"^2B\",\"Returns the value at the index. get returns nil if index out of\\n  bounds, nth throws an exception unless not-found is supplied.  nth\\n  also works for strings, arrays, regex Matchers and Lists, and,\\n  in O(n) time, for sequences.\"],\"~$sorted?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2143,\"^26\",7,\"^2:\",2143,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll satisfies ISorted\"],\"^1;\",\"~$cljs.core/sorted?\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2143,\"^2H\",\"^3D\",\"^2:\",2143,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll satisfies ISorted\"],\"~$nil?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",229,\"^26\",16,\"^2:\",229,\"^25\",20,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is nil, false otherwise.\"],\"^1;\",\"~$cljs.core/nil?\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",229,\"^2H\",\"^3D\",\"^2:\",229,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is nil, false otherwise.\"],\"~$split-at\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4898,\"^26\",7,\"^2:\",4898,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a vector of [(take n coll) (drop n coll)]\"],\"^1;\",\"~$cljs.core/split-at\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4898,\"^2H\",\"^94\",\"^2:\",4898,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"]]]]],\"^2B\",\"Returns a vector of [(take n coll) (drop n coll)]\"],\"~$TransientHashSet\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9131,\"^26\",10,\"^2:\",9131,\"^25\",26,\"^5M\",true],\"^41\",1,\"^1P\",[\"^1:\",[\"~$cljs.core/ITransientSet\",\"^1S\",\"^1Y\",\"^@;\",\"^23\"]],\"^1;\",\"^7Q\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^45\",true,\"^26\",10,\"^29\",9267,\"^46\",false,\"^5M\",true,\"^2:\",9267,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^PX\",\"^1S\",\"^1Y\",\"^@;\",\"^23\"]]],\"~$*e\",[\"^ \",\"^1;\",\"~$cljs.core/*e\",\"^24\",\"cljs/core.cljs\",\"^29\",211,\"^26\",1,\"^2:\",213,\"^25\",5,\"^2B\",\"bound in a repl thread to the most recent exception caught by the repl\",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",213,\"^26\",3,\"^2:\",213,\"^25\",5,\"^2B\",\"bound in a repl thread to the most recent exception caught by the repl\"]],\"~$array-map-extend-kv\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6626,\"^26\",8,\"^2:\",6626,\"^25\",27,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$v\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-map-extend-kv\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$v\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6626,\"^2H\",\"^7F\",\"^2:\",6626,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$v\"]]]]]],\"~$prn-str-with-opts\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10206,\"^26\",7,\"^2:\",10206,\"^25\",24,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]],\"^2B\",\"Same as pr-str-with-opts followed by (newline)\"],\"^1;\",\"~$cljs.core/prn-str-with-opts\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^79\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10206,\"^2H\",\"^3J\",\"^2:\",10206,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^2M\"]]]]],\"^2B\",\"Same as pr-str-with-opts followed by (newline)\"],\"~$not-native\",[\"^ \",\"^1;\",\"~$cljs.core/not-native\",\"^24\",\"cljs/core.cljs\",\"^29\",220,\"^26\",1,\"^2:\",220,\"^25\",16,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",220,\"^26\",6,\"^2:\",220,\"^25\",16],\"^2R\",\"^4C\"],\"~$random-sample\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10641,\"^26\",7,\"^2:\",10641,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$prob\"],[\"^Q6\",\"^2X\"]]]]],\"^2B\",\"Returns items from coll with random probability of prob (0.0 -\\n  1.0).  Returns a transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^Q6\"],[\"^Q6\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^Q6\"],[\"^Q6\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/random-sample\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^Q6\"],[\"^Q6\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^Q6\"],[\"^Q6\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^Q6\"],[\"^Q6\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",10641,\"^2:\",10641,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^Q6\"],[\"^Q6\",\"^2X\"]]],\"^2B\",\"Returns items from coll with random probability of prob (0.0 -\\n  1.0).  Returns a transducer when no collection is provided.\"],\"~$select-keys\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9115,\"^26\",7,\"^2:\",9115,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;J\",\"~$keyseq\"]]]]],\"^2B\",\"Returns a map containing only those entries in map whose key is in keys\"],\"^1;\",\"~$cljs.core/select-keys\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^;J\",\"^Q9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9115,\"^2H\",\"^2T\",\"^2:\",9115,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;J\",\"^Q9\"]]]]],\"^2B\",\"Returns a map containing only those entries in map whose key is in keys\"],\"~$bit-and\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2853,\"^26\",7,\"^2:\",2853,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Bitwise and\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/bit-and\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2853,\"^2:\",2853,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Bitwise and\"],\"~$bounded-count\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3750,\"^26\",7,\"^2:\",3750,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"]]]]],\"^2B\",\"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\",\"^7B\",\"1.9\"],\"^7B\",\"1.9\",\"^1;\",\"~$cljs.core/bounded-count\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$n\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3750,\"^2H\",\"^<\",\"^2:\",3750,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"]]]]],\"^2B\",\"If coll is counted? returns its count, else will count at most the first n\\n   elements of coll using its seq\"],\"~$update\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5325,\"^26\",7,\"^2:\",5325,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2;\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/update\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2;\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"]]],\"^2E\",null,\"^2O\",6,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",6,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",6,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]]],\"^29\",5325,\"^2:\",5325,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$m\",\"~$k\",\"~$f\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\"],[\"~$m\",\"~$k\",\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"~$&\",\"^6M\"]]],\"^2B\",\"'Updates' a value in an associative structure, where k is a\\n  key and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  structure.  If the key does not exist, nil is passed as the old value.\"],\"~$gensym_counter\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10531,\"^26\",3,\"^2:\",10531,\"^25\",17,\"^38\",[\"@type {*}\"]],\"^1;\",\"~$cljs.core/gensym_counter\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",1,\"^29\",10529,\"^2:\",10531,\"^2R\",\"^4C\",\"^38\",[\"@type {*}\"]],\"~$find-macros-ns\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11656,\"^26\",7,\"^2:\",11656,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\"]]]]],\"^2B\",\"Returns the macros namespace named by the symbol or nil if it doesn't exist.\\n  Bootstrap only.\"],\"^1;\",\"~$cljs.core/find-macros-ns\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^4@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11656,\"^2H\",[\"^1:\",[\"^4B\",\"^2S\",\"^4C\"]],\"^2:\",11656,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\"]]]]],\"^2B\",\"Returns the macros namespace named by the symbol or nil if it doesn't exist.\\n  Bootstrap only.\"],\"~$list*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3796,\"^26\",7,\"^2:\",3796,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/list*\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2[\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",4,\"^2G\",true,\"^2R\",\"^2T\"]],\"^29\",3796,\"^2:\",3796,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^AP\"],[\"~$a\",\"^AP\"],[\"~$a\",\"~$b\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"^AP\"],[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^6M\"]]],\"^2B\",\"Creates a new list containing the items prepended to the rest, the\\n  last of which will be treated as a sequence.\"],\"~$array-index-of-keyword?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6562,\"^26\",8,\"^2:\",6562,\"^25\",31,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-index-of-keyword?\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"^6B\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6562,\"^2H\",\"^<\",\"^2:\",6562,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$k\"]]]]]],\"~$->Keyword\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^<X\",\"^5Z\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",3302,\"^2:\",3302,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\",\"^:\",\"~$fqn\",\"^I8\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^<X\",\"^5Z\"]],\"^2B\",\"Positional factory function for cljs.core/Keyword.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^<X\",\"^5Z\"]],\"^1;\",\"~$cljs.core/->Keyword\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^4@\",\"^:\",\"^QJ\",\"^I8\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3302,\"^2H\",\"^<5\",\"^2:\",3302,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4@\",\"^:\",\"^QJ\",\"^I8\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^<X\",\"^5Z\"]],\"^2B\",\"Positional factory function for cljs.core/Keyword.\"],\"~$update-in\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5298,\"^26\",7,\"^2:\",5298,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$&\",\"^AP\"]]]]],\"^2B\",\"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"]]],\"^2;\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/update-in\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"]]],\"^2;\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"]]],\"^2E\",null,\"^2O\",6,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",6,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",6,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^2S\"]]]],\"^29\",5298,\"^2:\",5298,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\"],[\"~$m\",[\"~$k\",\"~$&\",\"^8V\"],\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$&\",\"^AP\"]]],\"^2B\",\"'Updates' a value in a nested associative structure, where ks is a\\n  sequence of keys and f is a function that will take the old value\\n  and any supplied args and return the new value, and returns a new\\n  nested structure.  If any levels do not exist, hash-maps will be\\n  created.\"],\"~$prefer-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11220,\"^26\",7,\"^2:\",11220,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\",\"~$dispatch-val-x\",\"^84\"]]]]],\"^2B\",\"Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\\n   when there is a conflict\"],\"^1;\",\"~$cljs.core/prefer-method\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^8C\",\"^QO\",\"^84\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11220,\"^2H\",\"^2S\",\"^2:\",11220,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\",\"^QO\",\"^84\"]]]]],\"^2B\",\"Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\\n   when there is a conflict\"],\"~$hash-symbol\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1041,\"^26\",8,\"^2:\",1041,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H9\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/hash-symbol\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^H9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1041,\"^2H\",\"^<\",\"^2:\",1041,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H9\"]]]]]],\"~$ensure-reduced\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1434,\"^26\",7,\"^2:\",1434,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"If x is already reduced?, returns it, else returns (reduced x)\"],\"^1;\",\"~$cljs.core/ensure-reduced\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1434,\"^2H\",\"^:8\",\"^2:\",1434,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"If x is already reduced?, returns it, else returns (reduced x)\"],\"~$t_cljs$core1506\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^1;\",\"^B4\",\"^24\",\"cljs/core.cljs\",\"^45\",true,\"^9K\",true,\"^26\",3,\"^29\",4000,\"^46\",false,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]]],\"~$edit-and-set\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7159,\"^26\",8,\"^2:\",7159,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$inode\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"^QW\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2;\",[\"^2<\",[[\"^QW\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/edit-and-set\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"^QW\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2;\",[\"^2<\",[[\"^QW\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^QW\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2E\",null,\"^2O\",6,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",6,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",7159,\"^2:\",7159,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^QW\",\"^>2\",\"~$i\",\"~$a\"],[\"^QW\",\"^>2\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]]],\"~$->PersistentArrayMap\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",10,\"^27\",\"^28\",\"^29\",6811,\"^2:\",6811,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6C\",\"^6B\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentArrayMap.\"],\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->PersistentArrayMap\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2D\",[\"^2<\",[[\"^2>\",\"^6C\",\"^6B\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6811,\"^2H\",\"^59\",\"^2:\",6811,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6C\",\"^6B\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentArrayMap.\"],\"~$instance?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1030,\"^26\",16,\"^2:\",1030,\"^25\",25,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$c\",\"~$x\"]]]]],\"^2B\",\"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"],\"^1;\",\"~$cljs.core/instance?\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"~$c\",\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1030,\"^2H\",\"^3D\",\"^2:\",1030,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$c\",\"~$x\"]]]]],\"^2B\",\"Evaluates x and tests if it is an instance of the type\\n  c. Returns true or false\"],\"~$mix-collection-hash\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1316,\"^26\",15,\"^2:\",1316,\"^25\",34,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$hash-basis\",\"^AS\"]]]]],\"^2B\",\"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"],\"^1;\",\"~$cljs.core/mix-collection-hash\",\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^2D\",[\"^2<\",[[\"^R2\",\"^AS\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1316,\"^2H\",\"^<\",\"^2:\",1316,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^R2\",\"^AS\"]]]]],\"^2B\",\"Mix final collection hash for ordered or unordered collections.\\n   hash-basis is the combined collection hash, count is the number\\n   of elements included in the basis. Note this is the hash code\\n   consistent with =, different from .hashCode.\\n   See http://clojure.org/data_structures#hash for full algorithms.\"],\"~$re-find\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9981,\"^26\",7,\"^2:\",9981,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]],\"^2B\",\"Returns the first regex match, if any, of s to re, using\\n  re.exec(s). Returns a vector, containing first the matching\\n  substring, then any capturing groups if the regular expression contains\\n  capturing groups.\"],\"^1;\",\"~$cljs.core/re-find\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^<Q\",\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9981,\"^2H\",[\"^1:\",[\"^2T\",\"^94\",\"^2S\",\"^5A\",\"^4C\"]],\"^2:\",9981,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]],\"^2B\",\"Returns the first regex match, if any, of s to re, using\\n  re.exec(s). Returns a vector, containing first the matching\\n  substring, then any capturing groups if the regular expression contains\\n  capturing groups.\"],\"~$run!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10688,\"^26\",7,\"^2:\",10688,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$proc\",\"^2X\"]]]]],\"^2B\",\"Runs the supplied procedure (via reduce), for purposes of side\\n  effects, on successive items in the collection. Returns nil\"],\"^1;\",\"~$cljs.core/run!\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^R7\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10688,\"^2H\",\"^4C\",\"^2:\",10688,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^R7\",\"^2X\"]]]]],\"^2B\",\"Runs the supplied procedure (via reduce), for purposes of side\\n  effects, on successive items in the collection. Returns nil\"],\"~$char-escapes\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10062,\"^26\",16,\"^2:\",10062,\"^25\",28,\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/char-escapes\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",1,\"^29\",10062,\"^2:\",10062,\"^2R\",\"^4>\"],\"~$ES6Iterator\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^8R\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^45\",true,\"^26\",10,\"^29\",1280,\"^46\",false,\"^2:\",1280,\"^2R\",\"^47\",\"^2A\",null],\"^37\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9086,\"^26\",7,\"^2:\",9086,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^HG\"]]]]],\"^2B\",\"Returns the value in the map entry.\"],\"^1;\",\"~$cljs.core/val\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^HG\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9086,\"^2H\",\"^2S\",\"^2:\",9086,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^HG\"]]]]],\"^2B\",\"Returns the value in the map entry.\"],\"~$unchecked-add\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",15,\"^29\",2715,\"^2:\",2715,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the sum of nums. (+) returns 0.\"],\"^1;\",\"~$cljs.core/unchecked-add\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2715,\"^2H\",\"^<\",\"^2:\",2715,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the sum of nums. (+) returns 0.\"],\"~$transformer-iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4175,\"^26\",7,\"^2:\",4175,\"^25\",27,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5[\",\"^;D\",\"^;E\"]]]]]],\"^1;\",\"~$cljs.core/transformer-iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^5[\",\"^;D\",\"^;E\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4175,\"^2H\",\"^;G\",\"^2:\",4175,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5[\",\"^;D\",\"^;E\"]]]]]],\"~$not\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",246,\"^26\",7,\"^2:\",246,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is logical false, false otherwise.\"],\"^1;\",\"~$cljs.core/not\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",246,\"^2H\",\"^3D\",\"^2:\",246,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is logical false, false otherwise.\"],\"^D;\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",861,\"^26\",4,\"^2:\",861,\"^25\",12,\"^69\",\"^42\",\"^2B\",\"Sets the value of volatile o to new-value without regard for the\\n     current value. Returns new-value.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^D2\"]]]]]],\"^69\",\"^42\",\"^1;\",\"~$cljs.core/-vreset!\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$o\",\"^D2\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",859,\"^2H\",\"^2S\",\"^2:\",861,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^D2\"]]]]],\"^2B\",\"Sets the value of volatile o to new-value without regard for the\\n     current value. Returns new-value.\"],\"~$fn->comparator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2417,\"^26\",17,\"^2:\",2417,\"^25\",31,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Given a fn that might be boolean valued or a comparator,\\n   return a fn that is a comparator.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/fn->comparator\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2417,\"^2H\",[\"^1:\",[\"^<\",\"^47\"]],\"^2:\",2417,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Given a fn that might be boolean valued or a comparator,\\n   return a fn that is a comparator.\"],\"~$with-meta\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2066,\"^26\",7,\"^2:\",2066,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^2>\"]]]]],\"^2B\",\"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"],\"^1;\",\"~$cljs.core/with-meta\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$o\",\"^2>\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2066,\"^2H\",[\"^1:\",[\"^2T\",\"^5A\",\"^4C\"]],\"^2:\",2066,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\",\"^2>\"]]]]],\"^2B\",\"Returns an object of the same type and value as obj, with\\n  map m as its metadata.\"],\"~$unreduced\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1439,\"^26\",7,\"^2:\",1439,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"If x is reduced?, returns (deref x), else returns x\"],\"^1;\",\"~$cljs.core/unreduced\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1439,\"^2H\",[\"^1:\",[null,\"^2S\"]],\"^2:\",1439,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"If x is reduced?, returns (deref x), else returns x\"],\"~$record?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2158,\"^26\",7,\"^2:\",2158,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies IRecord\"],\"^1;\",\"~$cljs.core/record?\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2158,\"^2H\",\"^3D\",\"^2:\",2158,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies IRecord\"],\"^16\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",305,\"^26\",7,\"^2:\",305,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return x's constructor.\"],\"^1;\",\"~$cljs.core/type\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",305,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",305,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return x's constructor.\"],\"~$identical?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",224,\"^26\",16,\"^2:\",224,\"^25\",26,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Tests if 2 arguments are the same object\"],\"^1;\",\"~$cljs.core/identical?\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",224,\"^2H\",\"^3D\",\"^2:\",224,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Tests if 2 arguments are the same object\"],\"^PA\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^<X\",\"^24\",\"cljs/core.cljs\",\"^25\",40,\"^26\",30,\"^29\",843,\"^2:\",843,\"^2R\",[\"^1:\",[\"^3J\",\"^4C\"]],\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the namespace String of x.\"],\"^69\",\"^<X\",\"^1;\",\"~$cljs.core/-namespace\",\"^24\",\"cljs/core.cljs\",\"^25\",40,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",839,\"^2H\",[\"^1:\",[\"^3J\",\"^4C\"]],\"^2:\",843,\"^2J\",1,\"^2R\",[\"^1:\",[\"^3J\",\"^4C\"]],\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns the namespace String of x.\"],\"~$unchecked-divide-int\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",35,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",15,\"^29\",2739,\"^2:\",2739,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"],\"^1;\",\"~$cljs.core/unchecked-divide-int\",\"^24\",\"cljs/core.cljs\",\"^25\",35,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2739,\"^2H\",\"^<\",\"^2:\",2739,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"],\"~$ns-name\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11675,\"^26\",7,\"^2:\",11675,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@6\"]]]]],\"^2B\",\"Returns the name of the namespace, a Namespace object.\\n  Bootstrap only.\"],\"^1;\",\"~$cljs.core/ns-name\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^@6\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11675,\"^2H\",\"^2S\",\"^2:\",11675,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@6\"]]]]],\"^2B\",\"Returns the name of the namespace, a Namespace object.\\n  Bootstrap only.\"],\"~$swap-global-hierarchy!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10853,\"^26\",8,\"^2:\",10853,\"^25\",30,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"~$&\",\"^AP\"]]]]],\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"~$f\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/swap-global-hierarchy!\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"~$f\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"~$f\",\"^AP\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",10853,\"^2H\",\"^2S\",\"^2:\",10853,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"~$&\",\"^AP\"]]]],\"~$max-key\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9520,\"^26\",7,\"^2:\",9520,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the x for which (k x), a number, is greatest.\\n  \\n  If there are multiple such xs, the last one is returned.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/max-key\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false],[\"^ \",\"^2O\",3,\"^2G\",false],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",9520,\"^2:\",9520,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the x for which (k x), a number, is greatest.\\n  \\n  If there are multiple such xs, the last one is returned.\"],\"~$->PersistentTreeSet\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^1W\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^23\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",9304,\"^2:\",9304,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$tree-map\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1W\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentTreeSet.\"],\"^1P\",[\"^1:\",[\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^1W\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^23\"]],\"^1;\",\"~$cljs.core/->PersistentTreeSet\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^2>\",\"^RY\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9304,\"^2H\",\"^7R\",\"^2:\",9304,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^RY\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1W\",\"^1X\",\"^1Y\",\"^75\",\"^1Z\",\"^1[\",\"^20\",\"^22\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentTreeSet.\"],\"~$*out*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",59,\"^26\",3,\"^2:\",59,\"^25\",8,\"^6R\",true,\"^38\",[\"@type {*}\"]],\"^1;\",\"~$cljs.core/*out*\",\"^24\",\"cljs/core.cljs\",\"^25\",8,\"^26\",1,\"^6R\",true,\"^29\",56,\"^2:\",59,\"^2R\",\"^4C\",\"^38\",[\"@type {*}\"]],\"~$->ChunkBuffer\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\",\"^1Y\"]],\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",10,\"^27\",\"^28\",\"^29\",3495,\"^2:\",3495,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$buf\",\"^52\"]]]]],\"^2A\",[\"^1:\",[\"^1Y\"]],\"^2B\",\"Positional factory function for cljs.core/ChunkBuffer.\"],\"^1P\",[\"^1:\",[\"^1V\",\"^1Y\"]],\"^1;\",\"~$cljs.core/->ChunkBuffer\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^S2\",\"^52\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3495,\"^2H\",\"^CH\",\"^2:\",3495,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^S2\",\"^52\"]]]]],\"^2A\",[\"^1:\",[\"^1Y\"]],\"^2B\",\"Positional factory function for cljs.core/ChunkBuffer.\"],\"~$hash-string\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",976,\"^26\",7,\"^2:\",976,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\"]]]]]],\"^1;\",\"~$cljs.core/hash-string\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",976,\"^2H\",\"^<\",\"^2:\",976,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\"]]]]]],\"~$ValSeq\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?B\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",9012,\"^46\",false,\"^2:\",9012,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$-prefers\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11018,\"^26\",4,\"^2:\",11018,\"^25\",12,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-prefers\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^82\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11018,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]],\"^2B\",null],\"~$set-validator!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4539,\"^26\",7,\"^2:\",4539,\"^25\",21,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"^37\"]]]]],\"^2B\",\"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"],\"^1;\",\"~$cljs.core/set-validator!\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^G>\",\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4539,\"^2:\",4539,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"^37\"]]]]],\"^2B\",\"Sets the validator-fn for an atom. validator-fn must be nil or a\\n  side-effect-free fn of one argument, which will be passed the intended\\n  new state on any state change. If the new state is unacceptable, the\\n  validator-fn should return false or throw an Error. If the current state\\n  is not acceptable to the new validator, an Error will be thrown and the\\n  validator will not be changed.\"],\"~$ident?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3360,\"^26\",7,\"^2:\",3360,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a symbol or keyword\"],\"^1;\",\"~$cljs.core/ident?\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3360,\"^2H\",\"^3D\",\"^2:\",3360,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a symbol or keyword\"],\"^B3\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^1[\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",16,\"^29\",681,\"^2:\",681,\"^2R\",\"^FR\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the metadata of object o.\"],\"^69\",\"^1[\",\"^1;\",\"~$cljs.core/-meta\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$o\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",679,\"^2H\",\"^FR\",\"^2:\",681,\"^2J\",1,\"^2R\",\"^FR\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$o\"]]]]],\"^2B\",\"Returns the metadata of object o.\"],\"~$RedNode\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8230,\"^26\",10,\"^2:\",8230,\"^25\",17,\"^5M\",true],\"^41\",5,\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"^5>\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",8455,\"^46\",false,\"^5M\",true,\"^2:\",8455,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]]],\"~$-dispatch-fn\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11020,\"^26\",4,\"^2:\",11020,\"^25\",16,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-dispatch-fn\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^82\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11020,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]],\"^2B\",null],\"~$->IndexedSeqIterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^26\",10,\"^27\",\"^28\",\"^29\",1562,\"^2:\",1562,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/IndexedSeqIterator.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->IndexedSeqIterator\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",1562,\"^2H\",\"~$cljs.core/IndexedSeqIterator\",\"^2:\",1562,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/IndexedSeqIterator.\"],\"~$-add-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11013,\"^26\",4,\"^2:\",11013,\"^25\",15,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\",\"~$method\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-add-method\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^82\",\"^83\",\"^SE\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11013,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\",\"^SE\"]]]]],\"^2B\",null],\"~$balance-left-del\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8279,\"^26\",8,\"^2:\",8279,\"^25\",24,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"~$del\",\"^K[\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/balance-left-del\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"^36\",\"^37\",\"^SH\",\"^K[\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8279,\"^2H\",\"^2T\",\"^2:\",8279,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^SH\",\"^K[\"]]]]]],\"~$swap!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4493,\"^26\",7,\"^2:\",4493,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/swap!\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",4493,\"^2:\",4493,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$a\",\"~$f\"],[\"~$a\",\"~$f\",\"~$x\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\"],[\"~$a\",\"~$f\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Atomically swaps the value of atom to be:\\n  (apply f current-value-of-atom args). Note that f may be called\\n  multiple times, and thus should be free of side effects.  Returns\\n  the value that was swapped in.\"],\"^B;\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9080,\"^26\",7,\"^2:\",9080,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;J\"]]]]],\"^2B\",\"Returns a sequence of the map's values, in the same order as (seq map).\"],\"^1;\",\"~$cljs.core/vals\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^;J\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9080,\"^2H\",[\"^1:\",[\"^?B\",\"^4C\"]],\"^2:\",9080,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;J\"]]]]],\"^2B\",\"Returns a sequence of the map's values, in the same order as (seq map).\"],\"~$Repeat\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?E\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",4903,\"^46\",false,\"^2:\",4903,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$-chunked-next\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",836,\"^26\",4,\"^2:\",836,\"^25\",17,\"^69\",\"^A8\",\"^2B\",\"Returns a new collection of coll without the first chunk.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^A8\",\"^1;\",\"~$cljs.core/-chunked-next\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",834,\"^2H\",\"^2S\",\"^2:\",836,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new collection of coll without the first chunk.\"],\"~$Single\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/Single\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",4077,\"^46\",false,\"^2:\",4077,\"^2R\",\"^47\",\"^2A\",null],\"~$unchecked-subtract\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",15,\"^29\",2777,\"^2:\",2777,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"],\"^1;\",\"~$cljs.core/unchecked-subtract\",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2777,\"^2H\",\"^<\",\"^2:\",2777,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"If no ys are supplied, returns the negation of x, else subtracts\\n  the ys from x and returns the result.\"],\"~$tap>\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11546,\"^26\",16,\"^2:\",11546,\"^25\",20,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.\"],\"^1;\",\"~$cljs.core/tap>\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11546,\"^2H\",\"^3D\",\"^2:\",11546,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.\"],\"~$remove-pair\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7147,\"^26\",8,\"^2:\",7147,\"^25\",19,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/remove-pair\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7147,\"^2H\",\"^7F\",\"^2:\",7147,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\"]]]]]],\"~$IMap\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",14,\"^29\",638,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-dissoc\",[[\"^2X\",\"~$k\"]]]],\"^2:\",638,\"^2B\",\"Protocol for adding mapping functionality to collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^<W\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^29\",638,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^SY\",[[\"^2X\",\"~$k\"]]]],\"^3:\",null,\"^2:\",638,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^59\",\"^5=\"]],\"^2B\",\"Protocol for adding mapping functionality to collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->SeqIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",4033,\"^2:\",4033,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$_seq\",\"^;A\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/SeqIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->SeqIter\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^S[\",\"^;A\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4033,\"^2H\",\"~$cljs.core/SeqIter\",\"^2:\",4033,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^S[\",\"^;A\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/SeqIter.\"],\"~$sorted-set-by\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9441,\"^26\",7,\"^2:\",9441,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$comparator\",\"~$&\",\"^C[\"]]]]],\"^2B\",\"Returns a new sorted set with supplied keys, using the supplied comparator.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"^T3\",\"^C[\"]]],\"^2;\",[\"^2<\",[[\"^T3\",\"~$&\",\"^C[\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/sorted-set-by\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[[\"^2<\",[\"^T3\",\"^C[\"]]],\"^2;\",[\"^2<\",[[\"^T3\",\"~$&\",\"^C[\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^T3\",\"^C[\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",9441,\"^2H\",\"^2S\",\"^2:\",9441,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^T3\",\"~$&\",\"^C[\"]]],\"^2B\",\"Returns a new sorted set with supplied keys, using the supplied comparator.\"],\"~$PersistentVector\",[\"^ \",\"^41\",6,\"^1P\",[\"^1:\",[\"^;I\",\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"^5<\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^45\",true,\"^26\",10,\"^29\",5481,\"^46\",false,\"^2:\",5481,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]]],\"~$cloneable?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1200,\"^26\",7,\"^2:\",1200,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\"]]]]],\"^2B\",\"Return true if x implements ICloneable protocol.\"],\"^1;\",\"~$cljs.core/cloneable?\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^4K\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1200,\"^2H\",\"^3D\",\"^2:\",1200,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4K\"]]]]],\"^2B\",\"Return true if x implements ICloneable protocol.\"],\"~$qualified-ident?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3368,\"^26\",7,\"^2:\",3368,\"^25\",23,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a symbol or keyword with a namespace\"],\"^1;\",\"~$cljs.core/qualified-ident?\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3368,\"^2H\",\"^3D\",\"^2:\",3368,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is a symbol or keyword with a namespace\"],\"~$hash-string*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",959,\"^26\",7,\"^2:\",959,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"^1;\",\"~$cljs.core/hash-string*\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",959,\"^2H\",\"^<\",\"^2:\",959,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"~$key-test\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7129,\"^26\",7,\"^2:\",7129,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^GF\"]]]]]],\"^1;\",\"~$cljs.core/key-test\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^36\",\"^GF\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7129,\"^2H\",\"^3D\",\"^2:\",7129,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^GF\"]]]]]],\"~$-reset\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11012,\"^26\",4,\"^2:\",11012,\"^25\",10,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-reset\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"^82\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11012,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\"]]]]],\"^2B\",null],\"~$true?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2217,\"^26\",16,\"^2:\",2217,\"^25\",21,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is the value true, false otherwise.\"],\"^1;\",\"~$cljs.core/true?\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2217,\"^2H\",\"^3D\",\"^2:\",2217,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x is the value true, false otherwise.\"],\"~$find-ns-obj*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11590,\"^26\",8,\"^2:\",11590,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$ctxt\",\"^5F\"]]]]],\"^2B\",\"Bootstrap only.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/find-ns-obj*\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^TC\",\"^5F\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11590,\"^2H\",[\"^1:\",[null,\"^4C\"]],\"^2:\",11590,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^TC\",\"^5F\"]]]]],\"^2B\",\"Bootstrap only.\"],\"^7F\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",435,\"^26\",14,\"^2:\",435,\"^25\",19,\"^2R\",\"^7F\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$var-args\"]]]]],\"^2B\",\"Creates a new javascript array.\\n@param {...*} var_args\"],\"^1;\",\"~$cljs.core/array\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^TE\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",435,\"^2H\",\"^7F\",\"^2:\",435,\"^2J\",1,\"^2R\",\"^7F\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^TE\"]]]]],\"^2B\",\"Creates a new javascript array.\\n@param {...*} var_args\"],\"~$print\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10250,\"^26\",3,\"^2:\",10250,\"^25\",8,\"^2B\",\"Prints the object(s) using string-print.\\n  print and println produce output for human consumption.\"],\"^1;\",\"~$cljs.core/print\",\"^24\",\"cljs/core.cljs\",\"^25\",8,\"^2D\",[\"^2<\",[[\"^79\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[]],\"^26\",1,\"^2G\",true,\"^29\",10247,\"^2H\",\"^4C\",\"^2:\",10250,\"^2J\",0,\"^2K\",true,\"^2;\",null,\"^2B\",\"Prints the object(s) using string-print.\\n  print and println produce output for human consumption.\"],\"^D5\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",660,\"^26\",4,\"^2:\",660,\"^25\",9,\"^69\",\"^95\",\"^2B\",\"Returns the item from the top of the stack. Is used by cljs.core/peek.\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^69\",\"^95\",\"^1;\",\"~$cljs.core/-peek\",\"^24\",\"cljs/core.cljs\",\"^25\",9,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",656,\"^2H\",\"^2S\",\"^2:\",660,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns the item from the top of the stack. Is used by cljs.core/peek.\"],\"~$ISeq\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",14,\"^29\",601,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^99\",[[\"^2X\"]],\"~$-rest\",[[\"^2X\"]]]],\"^2:\",601,\"^2B\",\"Protocol for collections to provide access to their items as sequences.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^4J\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^29\",601,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^99\",[[\"^2X\"]],\"^TK\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",601,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^:T\",\"^?<\",\"^:<\",\"^?=\",\"^5R\",\"^?>\",\"^3U\",\"^4[\",\"^?A\",\"^?B\",\"^?C\",\"^4O\",\"^<<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^?G\",\"^?H\",\"^?I\",\"^?5\",\"^9F\"]],\"^2B\",\"Protocol for collections to provide access to their items as sequences.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$empty\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1795,\"^26\",7,\"^2:\",1795,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns an empty collection of the same category as coll, or nil\"],\"^1;\",\"~$cljs.core/empty\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1795,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",1795,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns an empty collection of the same category as coll, or nil\"],\"~$remove-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11215,\"^26\",7,\"^2:\",11215,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\",\"^83\"]]]]],\"^2B\",\"Removes the method of multimethod associated with dispatch-value.\"],\"^1;\",\"~$cljs.core/remove-method\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^8C\",\"^83\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11215,\"^2H\",\"^2S\",\"^2:\",11215,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\",\"^83\"]]]]],\"^2B\",\"Removes the method of multimethod associated with dispatch-value.\"],\"~$PersistentQueueSeq\",[\"^ \",\"^41\",4,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\"]],\"^1;\",\"^4[\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^45\",true,\"^26\",10,\"^29\",6188,\"^46\",false,\"^2:\",6188,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\"]]],\"~$balance-right-del\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8298,\"^26\",8,\"^2:\",8298,\"^25\",25,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^SH\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/balance-right-del\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^SH\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8298,\"^2H\",\"^2T\",\"^2:\",8298,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^N0\",\"^SH\"]]]]]],\"~$volatile!\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4565,\"^26\",7,\"^2:\",4565,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\"]]]]],\"^2B\",\"Creates and returns a Volatile with an initial value of val.\"],\"^1;\",\"~$cljs.core/volatile!\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4565,\"^2H\",\"^44\",\"^2:\",4565,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\"]]]]],\"^2B\",\"Creates and returns a Volatile with an initial value of val.\"],\"~$/\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^24\",\"cljs/core.cljs\"],\"^1;\",\"~$cljs.core//\",\"^24\",\"cljs/core.cljs\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2622,\"^2H\",\"^<\",\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"If no denominators are supplied, returns 1/numerator,\\n  else returns numerator divided by all of the denominators.\"],\"~$bitpos\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7156,\"^26\",8,\"^2:\",7156,\"^25\",14,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BH\",\"^=X\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/bitpos\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^BH\",\"^=X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7156,\"^2H\",\"^<\",\"^2:\",7156,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BH\",\"^=X\"]]]]]],\"~$Many\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/Many\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^45\",true,\"^26\",10,\"^29\",4063,\"^46\",false,\"^2:\",4063,\"^2R\",\"^47\",\"^2A\",null],\"~$bit-or\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2859,\"^26\",7,\"^2:\",2859,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Bitwise or\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/bit-or\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2859,\"^2:\",2859,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Bitwise or\"],\"~$m3-fmix\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",920,\"^26\",15,\"^2:\",920,\"^25\",22,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@R\",\"^5H\"]]]]]],\"^1;\",\"~$cljs.core/m3-fmix\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^@R\",\"^5H\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",920,\"^2H\",\"^<\",\"^2:\",920,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^@R\",\"^5H\"]]]]]],\"~$vector\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5720,\"^26\",7,\"^2:\",5720,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^AP\"]]]]],\"^2B\",\"Creates a new vector containing the args.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^AP\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/vector\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^AP\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^AP\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^AP\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^94\",\"^2S\",\"^5A\",\"^4C\"]]]],\"^29\",5720,\"^2H\",\"^2S\",\"^2:\",5720,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^AP\"]]],\"^2B\",\"Creates a new vector containing the args.\"],\"~$hash-coll\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2993,\"^26\",8,\"^2:\",2993,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/hash-coll\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2993,\"^2H\",[\"^1:\",[null,\"^<\"]],\"^2:\",2993,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"~$clone-and-set\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7138,\"^26\",8,\"^2:\",7138,\"^25\",21,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2;\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/clone-and-set\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2;\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]],\"^2E\",null,\"^2O\",5,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^7F\"],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",\"^7F\"]],\"^29\",7138,\"^2:\",7138,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^6B\",\"~$i\",\"~$a\"],[\"^6B\",\"~$i\",\"~$a\",\"~$j\",\"~$b\"]]]],\"~$array->transient-hash-map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7116,\"^26\",8,\"^2:\",7116,\"^25\",33,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5H\",\"^6B\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array->transient-hash-map\",\"^24\",\"cljs/core.cljs\",\"^25\",33,\"^2D\",[\"^2<\",[[\"^5H\",\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",7116,\"^2H\",\"^2T\",\"^2:\",7116,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^5H\",\"^6B\"]]]]]],\"~$>=\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",2665,\"^2:\",2665,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"],\"^1;\",\"~$cljs.core/>=\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",2665,\"^2H\",\"^3D\",\"^2:\",2665,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns non-nil if nums are in monotonically non-increasing order,\\n  otherwise false.\"],\"~$->TransientHashSet\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^PX\",\"^1S\",\"^1Y\",\"^@;\",\"^23\"]],\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^26\",10,\"^27\",\"^28\",\"^29\",9267,\"^2:\",9267,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$transient-map\"]]]]],\"^2A\",[\"^1:\",[\"^PX\",\"^1S\",\"^1Y\",\"^@;\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/TransientHashSet.\"],\"^1P\",[\"^1:\",[\"^PX\",\"^1S\",\"^1Y\",\"^@;\",\"^23\"]],\"^1;\",\"~$cljs.core/->TransientHashSet\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^2D\",[\"^2<\",[[\"^U=\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9267,\"^2H\",\"^7Q\",\"^2:\",9267,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^U=\"]]]]],\"^2A\",[\"^1:\",[\"^PX\",\"^1S\",\"^1Y\",\"^@;\",\"^23\"]],\"^2B\",\"Positional factory function for cljs.core/TransientHashSet.\"],\"~$drop-last\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4792,\"^26\",7,\"^2:\",4792,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]]]],\"^2B\",\"Return a lazy sequence of all but the last n (default 1) items in coll\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]],\"^2;\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/drop-last\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]],\"^2;\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",4792,\"^2:\",4792,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$s\"],[\"~$n\",\"~$s\"]]],\"^2B\",\"Return a lazy sequence of all but the last n (default 1) items in coll\"],\"~$->ArrayIter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",10,\"^27\",\"^28\",\"^29\",4018,\"^2:\",4018,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ArrayIter.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->ArrayIter\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^6B\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4018,\"^2H\",\"^JV\",\"^2:\",4018,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"~$i\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/ArrayIter.\"],\"~$object?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",258,\"^26\",7,\"^2:\",258,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x's constructor is Object\"],\"^1;\",\"~$cljs.core/object?\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",258,\"^2H\",\"^3D\",\"^2:\",258,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x's constructor is Object\"],\"~$->ArrayNodeSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",10,\"^27\",\"^28\",\"^29\",7772,\"^2:\",7772,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^P<\",\"~$i\",\"~$s\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ArrayNodeSeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->ArrayNodeSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^2>\",\"^P<\",\"~$i\",\"~$s\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7772,\"^2H\",\"^?A\",\"^2:\",7772,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^P<\",\"~$i\",\"~$s\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ArrayNodeSeq.\"],\"~$lift-ns\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10284,\"^26\",8,\"^2:\",10284,\"^25\",15,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\"]]]]],\"^2B\",\"Returns [lifted-ns lifted-map] or nil if m can't be lifted.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/lift-ns\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$m\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10284,\"^2H\",[\"^1:\",[\"^94\",\"^4C\"]],\"^2:\",10284,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$m\"]]]]],\"^2B\",\"Returns [lifted-ns lifted-map] or nil if m can't be lifted.\"],\"~$tree-map-append\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8638,\"^26\",8,\"^2:\",8638,\"^25\",23,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^N0\",\"^K[\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/tree-map-append\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^N0\",\"^K[\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8638,\"^2H\",[\"^1:\",[null,\"^2T\"]],\"^2:\",8638,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^N0\",\"^K[\"]]]]]],\"~$not-empty\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3995,\"^26\",7,\"^2:\",3995,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"If coll is empty, returns nil, else coll\"],\"^1;\",\"~$cljs.core/not-empty\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3995,\"^2H\",[\"^1:\",[null,\"^4C\"]],\"^2:\",3995,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"If coll is empty, returns nil, else coll\"],\"~$distinct\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9465,\"^26\",7,\"^2:\",9465,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of the elements of coll with duplicates removed.\\n  Returns a stateful transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^2X\"]]],\"^2;\",[\"^2<\",[[],[\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/distinct\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^2X\"]]],\"^2;\",[\"^2<\",[[],[\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[],[\"^2X\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",9465,\"^2:\",9465,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of the elements of coll with duplicates removed.\\n  Returns a stateful transducer when no collection is provided.\"],\"~$partition\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5248,\"^26\",7,\"^2:\",5248,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"~$pad\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"^UP\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"^UP\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/partition\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"^UP\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"^UP\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"^UP\",\"^2X\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^3U\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",5248,\"^2:\",5248,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"],[\"~$n\",\"^=S\",\"^UP\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of lists of n items each, at offsets step\\n  apart. If step is not supplied, defaults to n, i.e. the partitions\\n  do not overlap. If a pad collection is supplied, use its elements as\\n  necessary to complete last partition up to n items. In case there are\\n  not enough padding elements, return a partition with less than n items.\"],\"~$IMultiFn\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11011,\"^26\",14,\"^2:\",11011,\"^25\",22,\"^32\",true,\"^38\",[\"^2<\",[\"@interface\"]],\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^80\",[[\"^82\",\"^83\",\"^84\"]],\"^9V\",[[\"^82\"]],\"^AJ\",[[\"^82\",\"^83\"]],\"^LT\",[[\"^82\"]],\"^S7\",[[\"^82\"]],\"^S?\",[[\"^82\"]],\"^SD\",[[\"^82\",\"^83\",\"^SE\"]],\"^T>\",[[\"^82\"]],\"~$-get-method\",[[\"^82\",\"^83\"]]]]],\"^32\",true,\"^1;\",\"^81\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",1,\"^29\",11011,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^80\",[[\"^82\",\"^83\",\"^84\"]],\"^9V\",[[\"^82\"]],\"^AJ\",[[\"^82\",\"^83\"]],\"^LT\",[[\"^82\"]],\"^S7\",[[\"^82\"]],\"^S?\",[[\"^82\"]],\"^SD\",[[\"^82\",\"^83\",\"^SE\"]],\"^T>\",[[\"^82\"]],\"^US\",[[\"^82\",\"^83\"]]]],\"^3:\",null,\"^2:\",11011,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^EL\"]],\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->Many\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",10,\"^27\",\"^28\",\"^29\",4063,\"^2:\",4063,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^B;\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Many.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->Many\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^B;\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4063,\"^2H\",\"^TY\",\"^2:\",4063,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^B;\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Many.\"],\"~$DEMUNGE_PATTERN\",[\"^ \",\"^1;\",\"~$cljs.core/DEMUNGE_PATTERN\",\"^24\",\"cljs/core.cljs\",\"^29\",389,\"^26\",1,\"^2:\",389,\"^25\",21,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",389,\"^26\",6,\"^2:\",389,\"^25\",21],\"^2R\",\"^4C\"],\"~$fix\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2791,\"^26\",16,\"^2:\",2791,\"^25\",19,\"^2R\",\"^<\",\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$q\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/fix\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$q\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2791,\"^2H\",\"^<\",\"^2:\",2791,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$q\"]]]]]],\"~$EmptyList\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?>\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^45\",true,\"^26\",10,\"^29\",3113,\"^46\",false,\"^2:\",3113,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$HashMapIter\",[\"^ \",\"^41\",3,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^P9\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^45\",true,\"^26\",10,\"^29\",7842,\"^46\",false,\"^2:\",7842,\"^2R\",\"^47\",\"^2A\",null],\"~$IAssociative\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^26\",14,\"^29\",625,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-contains-key?\",[[\"^2X\",\"~$k\"]],\"^86\",[[\"^2X\",\"~$k\",\"~$v\"]]]],\"^2:\",625,\"^2B\",\"Protocol for adding associativity to collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^87\",\"^24\",\"cljs/core.cljs\",\"^25\",26,\"^26\",1,\"^29\",625,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^V1\",[[\"^2X\",\"~$k\"]],\"^86\",[[\"^2X\",\"~$k\",\"~$v\"]]]],\"^3:\",null,\"^2:\",625,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^59\",\"^5:\",\"^2U\",\"^5;\",\"^5<\",\"^5=\",\"^5>\"]],\"^2B\",\"Protocol for adding associativity to collections.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->Single\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",10,\"^27\",\"^28\",\"^29\",4077,\"^2:\",4077,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Single.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->Single\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4077,\"^2H\",\"^SQ\",\"^2:\",4077,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Single.\"],\"~$bit-flip\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2876,\"^26\",7,\"^2:\",2876,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Flip bit at index n\"],\"^1;\",\"~$cljs.core/bit-flip\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2876,\"^2H\",\"^<\",\"^2:\",2876,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Flip bit at index n\"],\"~$long-array\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3684,\"^26\",7,\"^2:\",3684,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]]]],\"^2B\",\"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/long-array\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^7F\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^7F\"]],\"^29\",3684,\"^2:\",3684,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2B\",\"Creates an array of longs. Does not coerce array, provided for compatibility\\n  with Clojure.\"],\"~$descendants\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10892,\"^26\",7,\"^2:\",10892,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]]]],\"^2B\",\"Returns the immediate and indirect children of tag, through a\\n  relationship established via derive. h must be a hierarchy obtained\\n  from make-hierarchy, if not supplied defaults to the global\\n  hierarchy. Note: does not work on JavaScript type inheritance\\n  relationships.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2;\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/descendants\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2;\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^4C\"]]]],\"^29\",10892,\"^2:\",10892,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2B\",\"Returns the immediate and indirect children of tag, through a\\n  relationship established via derive. h must be a hierarchy obtained\\n  from make-hierarchy, if not supplied defaults to the global\\n  hierarchy. Note: does not work on JavaScript type inheritance\\n  relationships.\"],\"~$imul\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",899,\"^26\",17,\"^2:\",899,\"^25\",21,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$b\"]]]]]],\"^1;\",\"~$cljs.core/imul\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"~$a\",\"~$b\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",3,\"^2G\",false,\"^29\",899,\"^2H\",\"^<\",\"^2:\",899,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$b\"]]]]]],\"~$->Delay\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^8J\",\"^43\",\"^5Z\"]],\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",10,\"^27\",\"^28\",\"^29\",10545,\"^2:\",10545,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^4K\"]]]]],\"^2A\",[\"^1:\",[\"^8J\",\"^43\",\"^5Z\"]],\"^2B\",\"Positional factory function for cljs.core/Delay.\"],\"^1P\",[\"^1:\",[\"^8J\",\"^43\",\"^5Z\"]],\"^1;\",\"~$cljs.core/->Delay\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$f\",\"^4K\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",10545,\"^2H\",\"^??\",\"^2:\",10545,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^4K\"]]]]],\"^2A\",[\"^1:\",[\"^8J\",\"^43\",\"^5Z\"]],\"^2B\",\"Positional factory function for cljs.core/Delay.\"],\"~$array-for\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5411,\"^26\",8,\"^2:\",5411,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"~$i\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/array-for\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^6J\",\"~$i\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5411,\"^2H\",\"^2S\",\"^2:\",5411,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6J\",\"~$i\"]]]]]],\"~$merge\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9091,\"^26\",7,\"^2:\",9091,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^@B\"]]]]],\"^2B\",\"Returns a map that consists of the rest of the maps conj-ed onto\\n  the first.  If a key occurs in more than one map, the mapping from\\n  the latter (left-to-right) will be the mapping in the result.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^@B\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^@B\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/merge\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^@B\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^@B\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^@B\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\",\"^4C\"]]]],\"^29\",9091,\"^2H\",\"^2S\",\"^2:\",9091,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^@B\"]]],\"^2B\",\"Returns a map that consists of the rest of the maps conj-ed onto\\n  the first.  If a key occurs in more than one map, the mapping from\\n  the latter (left-to-right) will be the mapping in the result.\"],\"~$ISeqable\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",14,\"^29\",714,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-seq\",[[\"~$o\"]]]],\"^2:\",714,\"^2B\",\"Protocol for adding the ability to a type to be transformed into a sequence.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1Z\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^26\",1,\"^29\",714,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^VC\",[[\"~$o\"]]]],\"^3:\",null,\"^2:\",714,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^?<\",\"^3O\",\"^59\",\"^:<\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^?A\",\"^?B\",\"^?C\",\"^4O\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^2I\",\"^5=\",\"^?G\",\"^?H\",\"^7R\",\"^?I\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for adding the ability to a type to be transformed into a sequence.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$Empty\",[\"^ \",\"^41\",0,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/Empty\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^45\",true,\"^26\",10,\"^29\",4096,\"^46\",false,\"^2:\",4096,\"^2R\",\"^47\",\"^2A\",null],\"~$js-mod\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2825,\"^26\",7,\"^2:\",2825,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"],\"^1;\",\"~$cljs.core/js-mod\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$n\",\"~$d\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2825,\"^2H\",\"^<\",\"^2:\",2825,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$d\"]]]]],\"^2B\",\"Modulus of num and div with original javascript behavior. i.e. bug for negative numbers\"],\"~$->RangeChunk\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^1Y\",\"^4J\",\"^:S\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",9635,\"^2:\",9635,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^51\",\"^=S\",\"^AS\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^1Y\",\"^4J\"]],\"^2B\",\"Positional factory function for cljs.core/RangeChunk.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^1Y\",\"^4J\",\"^:S\"]],\"^1;\",\"~$cljs.core/->RangeChunk\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^51\",\"^=S\",\"^AS\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9635,\"^2H\",\"^:T\",\"^2:\",9635,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^51\",\"^=S\",\"^AS\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^1Y\",\"^4J\"]],\"^2B\",\"Positional factory function for cljs.core/RangeChunk.\"],\"~$integer?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2259,\"^26\",7,\"^2:\",2259,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns true if n is a JavaScript number with no decimal part.\"],\"^1;\",\"~$cljs.core/integer?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2259,\"^2H\",\"^3D\",\"^2:\",2259,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns true if n is a JavaScript number with no decimal part.\"],\"~$MetaFn\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1S\",\"^1[\",\"^4Q\",\"^22\"]],\"^1;\",\"^5A\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^45\",true,\"^26\",10,\"^29\",2013,\"^46\",false,\"^2:\",2013,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1S\",\"^1[\",\"^22\"]]],\"~$NS_CACHE\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11588,\"^26\",3,\"^2:\",11588,\"^25\",11,\"^2B\",\"Bootstrap only.\",\"^38\",[\"@type {*}\"]],\"^1;\",\"~$cljs.core/NS_CACHE\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^26\",1,\"^29\",11586,\"^2:\",11588,\"^2R\",\"^4C\",\"^2B\",\"Bootstrap only.\",\"^38\",[\"@type {*}\"]],\"~$mapv\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5223,\"^26\",7,\"^2:\",5223,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]]]],\"^2B\",\"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/mapv\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2T\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2T\",\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2T\",\"^2S\"]]]],\"^29\",5223,\"^2:\",5223,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"^2X\"],[\"~$f\",\"^;K\",\"^;L\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\"],[\"~$f\",\"^;K\",\"^;L\",\"^;M\",\"~$&\",\"^;N\"]]],\"^2B\",\"Returns a vector consisting of the result of applying f to the\\n  set of first items of each coll, followed by applying f to the set\\n  of second items in each coll, until any one of the colls is\\n  exhausted.  Any remaining items in other colls are ignored. Function\\n  f should accept number-of-colls arguments.\"],\"~$infinite?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2330,\"^26\",7,\"^2:\",2330,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true for Infinity and -Infinity values.\"],\"^1;\",\"~$cljs.core/infinite?\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2330,\"^2H\",\"^3D\",\"^2:\",2330,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true for Infinity and -Infinity values.\"],\"~$partition-all\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9549,\"^26\",7,\"^2:\",9549,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of lists like partition, but may include\\n  partitions with fewer than n items at the end.  Returns a stateful\\n  transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/partition-all\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",9549,\"^2:\",9549,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$n\"],[\"~$n\",\"^2X\"],[\"~$n\",\"^=S\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of lists like partition, but may include\\n  partitions with fewer than n items at the end.  Returns a stateful\\n  transducer when no collection is provided.\"],\"~$partition-by\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9833,\"^26\",7,\"^2:\",9833,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]]]],\"^2B\",\"Applies f to each value in coll, splitting it each time f returns a\\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\\n   transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/partition-by\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",9833,\"^2:\",9833,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^2X\"]]],\"^2B\",\"Applies f to each value in coll, splitting it each time f returns a\\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\\n   transducer when no collection is provided.\"],\"~$ISequential\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",14,\"^29\",719,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",719,\"^2B\",\"Marker interface indicating a persistent collection of sequential items\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^4W\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",1,\"^29\",719,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",719,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^?<\",\"^3O\",\"^:<\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^?G\",\"^?H\",\"^?I\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Marker interface indicating a persistent collection of sequential items\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->LazySeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",3412,\"^2:\",3412,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$fn\",\"~$s\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/LazySeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->LazySeq\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2>\",\"^VY\",\"~$s\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3412,\"^2H\",\"^3U\",\"^2:\",3412,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^VY\",\"~$s\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/LazySeq.\"],\"~$equiv-map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6328,\"^26\",7,\"^2:\",6328,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Test map equivalence. Returns true if x equals y, otherwise returns false.\"],\"^1;\",\"~$cljs.core/equiv-map\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6328,\"^2H\",\"^3D\",\"^2:\",6328,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$y\"]]]]],\"^2B\",\"Test map equivalence. Returns true if x equals y, otherwise returns false.\"],\"~$->Volatile\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^42\",\"^43\"]],\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",10,\"^27\",\"^28\",\"^29\",4557,\"^2:\",4557,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^K8\"]]]]],\"^2A\",[\"^1:\",[\"^43\"]],\"^2B\",\"Positional factory function for cljs.core/Volatile.\"],\"^1P\",[\"^1:\",[\"^42\",\"^43\"]],\"^1;\",\"~$cljs.core/->Volatile\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^K8\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4557,\"^2H\",\"^44\",\"^2:\",4557,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^K8\"]]]]],\"^2A\",[\"^1:\",[\"^43\"]],\"^2B\",\"Positional factory function for cljs.core/Volatile.\"],\"~$object-array\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3728,\"^26\",7,\"^2:\",3728,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]]]],\"^2B\",\"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/object-array\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^7F\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^7F\"]],\"^29\",3728,\"^2:\",3728,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^BK\"],[\"^BL\",\"^BM\"]]],\"^2B\",\"Creates an array of objects. Does not coerce array, provided for compatibility\\n  with Clojure.\"],\"~$Keyword\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",222,\"^26\",20,\"^2:\",222,\"^25\",27,\"^5M\",true],\"^41\",4,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^<X\",\"^5Z\"]],\"^1;\",\"^<5\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",3302,\"^46\",false,\"^5M\",true,\"^2:\",3302,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^<X\",\"^5Z\"]]],\"~$derive\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10901,\"^26\",7,\"^2:\",10901,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]]]],\"^2B\",\"Establishes a parent/child relationship between parent and\\n  tag. Parent must be a namespace-qualified symbol or keyword and\\n  child can be either a namespace-qualified symbol or keyword or a\\n  class. h must be a hierarchy obtained from make-hierarchy, if not\\n  supplied defaults to, and modifies, the global hierarchy.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]],\"^2;\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/derive\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]],\"^2;\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^4C\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^<W\"]]]],\"^29\",10901,\"^2:\",10901,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^H1\",\"^:C\"],[\"~$h\",\"^H1\",\"^:C\"]]],\"^2B\",\"Establishes a parent/child relationship between parent and\\n  tag. Parent must be a namespace-qualified symbol or keyword and\\n  child can be either a namespace-qualified symbol or keyword or a\\n  class. h must be a hierarchy obtained from make-hierarchy, if not\\n  supplied defaults to, and modifies, the global hierarchy.\"],\"~$->t_cljs$core1506\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^9K\",true,\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]],\"^27\",\"^28\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$meta1507\"]]]]],\"^2B\",\"Positional factory function for cljs.core/t_cljs$core1506.\",\"^24\",\"cljs/core.cljs\"],\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^1;\",\"~$cljs.core/->t_cljs$core1506\",\"^24\",\"cljs/core.cljs\",\"^2D\",[\"^2<\",[[\"^W9\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^9K\",true,\"^26\",3,\"^2G\",false,\"^27\",\"^28\",\"^29\",4000,\"^2H\",\"^B4\",\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^W9\"]]]]],\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/t_cljs$core1506.\"],\"~$seq-iter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4051,\"^26\",7,\"^2:\",4051,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^1;\",\"~$cljs.core/seq-iter\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4051,\"^2H\",\"^T1\",\"^2:\",4051,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"~$->Empty\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\"]],\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",10,\"^27\",\"^28\",\"^29\",4096,\"^2:\",4096,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Empty.\"],\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"~$cljs.core/->Empty\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",4096,\"^2H\",\"^VE\",\"^2:\",4096,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/Empty.\"],\"~$IChunkedSeq\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",14,\"^29\",827,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^GV\",[[\"^2X\"]],\"^7S\",[[\"^2X\"]]]],\"^2:\",827,\"^2B\",\"Protocol for accessing a collection as sequential chunks.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^7T\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",1,\"^29\",827,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^GV\",[[\"^2X\"]],\"^7S\",[[\"^2X\"]]]],\"^3:\",null,\"^2:\",827,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^?H\",\"^?I\",\"^?5\"]],\"^2B\",\"Protocol for accessing a collection as sequential chunks.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$special-symbol?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11373,\"^26\",16,\"^2:\",11373,\"^25\",31,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x names a special form\"],\"^1;\",\"~$cljs.core/special-symbol?\",\"^24\",\"cljs/core.cljs\",\"^25\",31,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11373,\"^2H\",\"^3D\",\"^2:\",11373,\"^2J\",1,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if x names a special form\"],\"~$compare-keywords\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3290,\"^26\",8,\"^2:\",3290,\"^25\",24,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$b\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/compare-keywords\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2D\",[\"^2<\",[[\"~$a\",\"~$b\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3290,\"^2H\",[\"^1:\",[\"^2S\",\"^<\"]],\"^2:\",3290,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$a\",\"~$b\"]]]]]],\"~$ancestors\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10884,\"^26\",7,\"^2:\",10884,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]]]],\"^2B\",\"Returns the immediate and indirect parents of tag, either via a JavaScript type\\n  inheritance relationship or a relationship established via derive. h\\n  must be a hierarchy obtained from make-hierarchy, if not supplied\\n  defaults to the global hierarchy\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2;\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/ancestors\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2;\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^4C\"]]]],\"^29\",10884,\"^2:\",10884,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^H1\"],[\"~$h\",\"^H1\"]]],\"^2B\",\"Returns the immediate and indirect parents of tag, either via a JavaScript type\\n  inheritance relationship or a relationship established via derive. h\\n  must be a hierarchy obtained from make-hierarchy, if not supplied\\n  defaults to the global hierarchy\"],\"~$subseq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9605,\"^26\",7,\"^2:\",9605,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"~$start-test\",\"~$start-key\",\"~$end-test\",\"~$end-key\"]]]]],\"^2B\",\"sc must be a sorted collection, test(s) one of <, <=, > or\\n  >=. Returns a seq of those entries with keys ek for\\n  which (test (.. sc comparator (compare ek key)) 0) is true\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2;\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/subseq\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2;\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2E\",null,\"^2O\",5,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2[\",\"^2T\",\"^3U\",\"^4C\"]]],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",[\"^1:\",[\"^3U\",\"^4C\"]]]],\"^29\",9605,\"^2:\",9605,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2B\",\"sc must be a sorted collection, test(s) one of <, <=, > or\\n  >=. Returns a seq of those entries with keys ek for\\n  which (test (.. sc comparator (compare ek key)) 0) is true\"],\"~$gensym\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10533,\"^26\",7,\"^2:\",10533,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$prefix-string\"]]]]],\"^2B\",\"Returns a new symbol with a unique name. If a prefix string is\\n  supplied, the name is prefix# where # is some unique number. If\\n  prefix is not supplied, the prefix is 'G__'.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^WM\"]]],\"^2;\",[\"^2<\",[[],[\"^WM\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/gensym\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"^WM\"]]],\"^2;\",[\"^2<\",[[],[\"^WM\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[],[\"^WM\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^<G\"]]]],\"^29\",10533,\"^2:\",10533,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"^WM\"]]],\"^2B\",\"Returns a new symbol with a unique name. If a prefix string is\\n  supplied, the name is prefix# where # is some unique number. If\\n  prefix is not supplied, the prefix is 'G__'.\"],\"^CB\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^4V\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^26\",16,\"^29\",613,\"^2:\",613,\"^2R\",\"^FR\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new collection of coll without the first item. In contrast to\\n     rest, it should return nil if there are no more items, e.g.\\n     (next []) => nil\\n     (next nil) => nil\"],\"^69\",\"^4V\",\"^1;\",\"~$cljs.core/-next\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",611,\"^2H\",\"^FR\",\"^2:\",613,\"^2J\",1,\"^2R\",\"^FR\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a new collection of coll without the first item. In contrast to\\n     rest, it should return nil if there are no more items, e.g.\\n     (next []) => nil\\n     (next nil) => nil\"],\"~$->HashCollisionNode\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",10,\"^27\",\"^28\",\"^29\",7571,\"^2:\",7571,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"~$collision-hash\",\"^6C\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^21\"]],\"^2B\",\"Positional factory function for cljs.core/HashCollisionNode.\"],\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^1;\",\"~$cljs.core/->HashCollisionNode\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^>2\",\"^WQ\",\"^6C\",\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",7571,\"^2H\",\"^>4\",\"^2:\",7571,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^WQ\",\"^6C\",\"^6B\"]]]]],\"^2A\",[\"^1:\",[\"^21\"]],\"^2B\",\"Positional factory function for cljs.core/HashCollisionNode.\"],\"~$delay?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10563,\"^26\",7,\"^2:\",10563,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"returns true if x is a Delay created with delay\"],\"^1;\",\"~$cljs.core/delay?\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10563,\"^2H\",\"^3D\",\"^2:\",10563,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"returns true if x is a Delay created with delay\"],\"~$create-inode-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7755,\"^26\",8,\"^2:\",7755,\"^25\",24,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2;\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/create-inode-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2;\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^:<\",\"^4C\"]]]],\"^29\",7755,\"^2:\",7755,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]]],\"~$flatten\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5199,\"^26\",7,\"^2:\",5199,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"],\"^1;\",\"~$cljs.core/flatten\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5199,\"^2H\",\"^3U\",\"^2:\",5199,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Takes any nested combination of sequential things (lists, vectors,\\n  etc.) and returns their contents as a single, flat sequence.\\n  (flatten nil) returns nil.\"],\"^SY\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^<W\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^26\",9,\"^29\",641,\"^2:\",641,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns a new collection of coll without the mapping for key k.\"],\"^69\",\"^<W\",\"^1;\",\"~$cljs.core/-dissoc\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^2X\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",638,\"^2H\",\"^2T\",\"^2:\",641,\"^2J\",2,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns a new collection of coll without the mapping for key k.\"],\"~$doubles\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2822,\"^26\",7,\"^2:\",2822,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/doubles\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2822,\"^2:\",2822,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$halt-when\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^7B\",\"1.9\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"~$retf\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^X1\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^26\",7,\"^29\",10598,\"^2:\",10598,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^X1\"]]]]],\"^2B\",\"Returns a transducer that ends transduction when pred returns true\\n  for an input. When retf is supplied it must be a fn of 2 arguments -\\n  it will be passed the (completed) result so far and the input that\\n  triggered the predicate, and its return value (if it does not throw\\n  an exception) will be the return value of the transducer. If retf\\n  is not supplied, the input that triggered the predicate will be\\n  returned. If the predicate never returns true the transduction is\\n  unaffected.\"],\"^7B\",\"1.9\",\"^1;\",\"~$cljs.core/halt-when\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^X1\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^X1\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^X1\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^47\"]],\"^29\",10598,\"^2:\",10598,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^X1\"]]],\"^2B\",\"Returns a transducer that ends transduction when pred returns true\\n  for an input. When retf is supplied it must be a fn of 2 arguments -\\n  it will be passed the (completed) result so far and the input that\\n  triggered the predicate, and its return value (if it does not throw\\n  an exception) will be the return value of the transducer. If retf\\n  is not supplied, the input that triggered the predicate will be\\n  returned. If the predicate never returns true the transduction is\\n  unaffected.\"],\"^V1\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^87\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",13,\"^29\",627,\"^2:\",627,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns true if k is a key in coll.\"],\"^69\",\"^87\",\"^1;\",\"~$cljs.core/-contains-key?\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^2X\",\"~$k\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",625,\"^2H\",\"^3D\",\"^2:\",627,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\",\"~$k\"]]]]],\"^2B\",\"Returns true if k is a key in coll.\"],\"~$remove-watch\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10521,\"^26\",7,\"^2:\",10521,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"^36\"]]]]],\"^2B\",\"Removes a watch (set by add-watch) from a reference\"],\"^1;\",\"~$cljs.core/remove-watch\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"^G>\",\"^36\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10521,\"^2:\",10521,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^G>\",\"^36\"]]]]],\"^2B\",\"Removes a watch (set by add-watch) from a reference\"],\"~$ex-info\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11338,\"^26\",7,\"^2:\",11338,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$msg\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]]]],\"^2B\",\"Create an instance of ExceptionInfo, an Error type that carries a\\n  map of additional data.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^X7\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]],\"^2;\",[\"^2<\",[[\"^X7\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/ex-info\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^X7\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]],\"^2;\",[\"^2<\",[[\"^X7\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^X7\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^?@\"]],\"^29\",11338,\"^2:\",11338,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^X7\",\"^M4\"],[\"^X7\",\"^M4\",\"^M5\"]]],\"^2B\",\"Create an instance of ExceptionInfo, an Error type that carries a\\n  map of additional data.\"],\"~$ifn?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2254,\"^26\",7,\"^2:\",2254,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Returns true if f returns true for fn? or satisfies IFn.\"],\"^1;\",\"~$cljs.core/ifn?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$f\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2254,\"^2H\",\"^3D\",\"^2:\",2254,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"]]]]],\"^2B\",\"Returns true if f returns true for fn? or satisfies IFn.\"],\"~$IAtom\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",14,\"^29\",846,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",846,\"^2B\",\"Marker protocol indicating an atom.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^K7\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^26\",1,\"^29\",846,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",846,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^90\"]],\"^2B\",\"Marker protocol indicating an atom.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$->PersistentQueue\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\"]],\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",10,\"^27\",\"^28\",\"^29\",6246,\"^2:\",6246,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^AS\",\"^4X\",\"^4Y\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentQueue.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\"]],\"^1;\",\"~$cljs.core/->PersistentQueue\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2D\",[\"^2<\",[[\"^2>\",\"^AS\",\"^4X\",\"^4Y\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6246,\"^2H\",\"^?=\",\"^2:\",6246,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^AS\",\"^4X\",\"^4Y\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentQueue.\"],\"~$nat-int?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2305,\"^26\",7,\"^2:\",2305,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies int? and is a natural integer value.\"],\"^1;\",\"~$cljs.core/nat-int?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2305,\"^2H\",\"^3D\",\"^2:\",2305,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies int? and is a natural integer value.\"],\"~$t_cljs$core9576\",[\"^ \",\"^41\",1,\"^1P\",[\"^1:\",[\"^1V\",\"^1[\",\"^22\"]],\"^1;\",\"^9N\",\"^24\",\"cljs/core.cljs\",\"^45\",true,\"^9K\",true,\"^26\",3,\"^29\",4000,\"^46\",false,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1[\",\"^22\"]]],\"~$IWatchable\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^26\",14,\"^29\",771,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^IU\",[[\"^D8\",\"^EW\",\"^;7\"]],\"^E0\",[[\"^D8\",\"^36\",\"~$f\"]],\"^D6\",[[\"^D8\",\"^36\"]]]],\"^2:\",771,\"^2B\",\"Protocol for types that can be watched. Currently only implemented by Atom.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^D7\",\"^24\",\"cljs/core.cljs\",\"^25\",24,\"^26\",1,\"^29\",771,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^IU\",[[\"^D8\",\"^EW\",\"^;7\"]],\"^E0\",[[\"^D8\",\"^36\",\"~$f\"]],\"^D6\",[[\"^D8\",\"^36\"]]]],\"^3:\",null,\"^2:\",771,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^90\"]],\"^2B\",\"Protocol for types that can be watched. Currently only implemented by Atom.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$pv-fresh-node\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5345,\"^26\",8,\"^2:\",5345,\"^25\",21,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pv-fresh-node\",\"^24\",\"cljs/core.cljs\",\"^25\",21,\"^2D\",[\"^2<\",[[\"^>2\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5345,\"^2H\",\"^8T\",\"^2:\",5345,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\"]]]]]],\"~$subvec\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5973,\"^26\",7,\"^2:\",5973,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]]]],\"^2B\",\"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/subvec\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]],\"^2;\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^5;\"]],\"^29\",5973,\"^2:\",5973,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$v\",\"^51\"],[\"~$v\",\"^51\",\"^52\"]]],\"^2B\",\"Returns a persistent vector of the items in vector from\\n  start (inclusive) to end (exclusive).  If end is not supplied,\\n  defaults to (count vector). This operation is O(1) and very fast, as\\n  the resulting vector shares structure with the original and no\\n  trimming is done.\"],\"^HF\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^@<\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",9,\"^29\",808,\"^2:\",808,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Returns tcoll with the last item removed from it.\"],\"^69\",\"^@<\",\"^1;\",\"~$cljs.core/-pop!\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^35\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",804,\"^2H\",\"^2T\",\"^2:\",808,\"^2J\",1,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\"]]]]],\"^2B\",\"Returns tcoll with the last item removed from it.\"],\"~$partial\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4298,\"^26\",7,\"^2:\",4298,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"~$arg1\"],[\"~$f\",\"^XH\",\"~$arg2\"],[\"~$f\",\"^XH\",\"^XI\",\"~$arg3\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^XH\"],[\"~$f\",\"^XH\",\"^XI\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^XH\"],[\"~$f\",\"^XH\",\"^XI\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]]],\"^1;\",\"~$cljs.core/partial\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^XH\"],[\"~$f\",\"^XH\",\"^XI\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\"]]],\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^XH\"],[\"~$f\",\"^XH\",\"^XI\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^XH\"],[\"~$f\",\"^XH\",\"^XI\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",4,\"^2G\",true,\"^2R\",\"^47\"]],\"^29\",4298,\"^2:\",4298,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\"],[\"~$f\",\"^XH\"],[\"~$f\",\"^XH\",\"^XI\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\"],[\"~$f\",\"^XH\",\"^XI\",\"^XJ\",\"~$&\",\"^6M\"]]],\"^2B\",\"Takes a function f and fewer than the normal arguments to f, and\\n  returns a fn that takes a variable number of additional args. When\\n  called, the returned function calls f with args + additional args.\"],\"~$chunked-seq?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2169,\"^26\",7,\"^2:\",2169,\"^25\",19,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is satisfies IChunkedSeq.\"],\"^1;\",\"~$cljs.core/chunked-seq?\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2169,\"^2H\",\"^3D\",\"^2:\",2169,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x is satisfies IChunkedSeq.\"],\"~$replicate\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5007,\"^26\",7,\"^2:\",5007,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$x\"]]]]],\"^2B\",\"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"],\"^1;\",\"~$cljs.core/replicate\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$n\",\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5007,\"^2H\",\"^3U\",\"^2:\",5007,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\",\"~$x\"]]]]],\"^2B\",\"DEPRECATED: Use 'repeat' instead.\\n  Returns a lazy seq of n xs.\"],\"~$PersistentQueue\",[\"^ \",\"^41\",5,\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\"]],\"^1;\",\"^?=\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^45\",true,\"^26\",10,\"^29\",6246,\"^46\",false,\"^2:\",6246,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^1Z\",\"^1[\",\"^20\",\"^95\",\"^21\",\"^4W\",\"^22\"]]],\"~$min-key\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9529,\"^26\",7,\"^2:\",9529,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the x for which (k x), a number, is least.\\n\\n  If there are multiple such xs, the last one is returned.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/min-key\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false],[\"^ \",\"^2O\",3,\"^2G\",false],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",9529,\"^2:\",9529,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$k\",\"~$x\"],[\"~$k\",\"~$x\",\"~$y\"],[\"~$k\",\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the x for which (k x), a number, is least.\\n\\n  If there are multiple such xs, the last one is returned.\"],\"~$hash-iset\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3013,\"^26\",8,\"^2:\",3013,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/hash-iset\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3013,\"^2H\",\"^<\",\"^2:\",3013,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$s\"]]]]]],\"~$reduced\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1424,\"^26\",7,\"^2:\",1424,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Wraps x in a way such that a reduce will terminate with the value x\"],\"^1;\",\"~$cljs.core/reduced\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1424,\"^2H\",\"^:8\",\"^2:\",1424,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Wraps x in a way such that a reduce will terminate with the value x\"],\"~$re-matches\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9969,\"^26\",7,\"^2:\",9969,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]],\"^2B\",\"Returns the result of (re-find re s) if re fully matches s.\"],\"^1;\",\"~$cljs.core/re-matches\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^<Q\",\"~$s\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9969,\"^2H\",[\"^1:\",[\"^2T\",\"^94\",\"^2S\",\"^5A\",\"^4C\"]],\"^2:\",9969,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^<Q\",\"~$s\"]]]]],\"^2B\",\"Returns the result of (re-find re s) if re fully matches s.\"],\"~$pr-writer-impl\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10086,\"^26\",8,\"^2:\",10086,\"^25\",22,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^7W\",\"^2M\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/pr-writer-impl\",\"^24\",\"cljs/core.cljs\",\"^25\",22,\"^2D\",[\"^2<\",[[\"^3B\",\"^7W\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10086,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",10086,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^7W\",\"^2M\"]]]]]],\"~$array-map\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8892,\"^26\",7,\"^2:\",8892,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^:5\"]]]]],\"^2B\",\"keyval => key val\\n  Returns a new array map with supplied mappings.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^:5\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^:5\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/array-map\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^:5\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^:5\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^:5\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",8892,\"^2H\",\"^2S\",\"^2:\",8892,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^:5\"]]],\"^2B\",\"keyval => key val\\n  Returns a new array map with supplied mappings.\"],\"~$ITransientSet\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",14,\"^29\",811,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-disjoin!\",[[\"^35\",\"~$v\"]]]],\"^2:\",811,\"^2B\",\"Protocol for adding set functionality to a transient collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^PX\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",1,\"^29\",811,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^Y2\",[[\"^35\",\"~$v\"]]]],\"^3:\",null,\"^2:\",811,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^7Q\"]],\"^2B\",\"Protocol for adding set functionality to a transient collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$ITER_SYMBOL\",[\"^ \",\"^1;\",\"~$cljs.core/ITER_SYMBOL\",\"^24\",\"cljs/core.cljs\",\"^29\",333,\"^26\",3,\"^2:\",333,\"^25\",19,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",333,\"^26\",8,\"^2:\",333,\"^25\",19],\"^2R\",\"^3J\"],\"~$unchecked-byte\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2709,\"^26\",15,\"^2:\",2709,\"^25\",29,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-byte\",\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2709,\"^2H\",\"^<\",\"^2:\",2709,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$checked-aset\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",466,\"^26\",8,\"^2:\",466,\"^25\",20,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]]]],\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/checked-aset\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",466,\"^2:\",466,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]]],\"~$ArrayNode\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7186,\"^26\",10,\"^2:\",7186,\"^25\",19,\"^5M\",true],\"^41\",3,\"^1P\",[\"^1:\",[\"^1V\",\"^21\"]],\"^1;\",\"^?O\",\"^24\",\"cljs/core.cljs\",\"^25\",19,\"^45\",true,\"^26\",10,\"^29\",7461,\"^46\",false,\"^5M\",true,\"^2:\",7461,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^21\"]]],\"~$->ChunkedSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",5729,\"^2:\",5729,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^IL\",\"^8@\",\"~$i\",\"^>J\",\"^2>\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ChunkedSeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->ChunkedSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^IL\",\"^8@\",\"~$i\",\"^>J\",\"^2>\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",5729,\"^2H\",\"^?H\",\"^2:\",5729,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^IL\",\"^8@\",\"~$i\",\"^>J\",\"^2>\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^A8\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ChunkedSeq.\"],\"~$every-pred\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4615,\"^26\",7,\"^2:\",4615,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$p\"],[\"~$p1\",\"~$p2\"],[\"^Y=\",\"^Y>\",\"~$p3\"],[\"^Y=\",\"^Y>\",\"^Y?\",\"~$&\",\"~$ps\"]]]]],\"^2B\",\"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$p\"],[\"^Y=\",\"^Y>\"],[\"^Y=\",\"^Y>\",\"^Y?\"]]],\"^2;\",[\"^2<\",[[\"~$p\"],[\"^Y=\",\"^Y>\"],[\"^Y=\",\"^Y>\",\"^Y?\"],[\"^Y=\",\"^Y>\",\"^Y?\",\"~$&\",\"^Y@\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]]],\"^1;\",\"~$cljs.core/every-pred\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"~$p\"],[\"^Y=\",\"^Y>\"],[\"^Y=\",\"^Y>\",\"^Y?\"]]],\"^2;\",[\"^2<\",[[\"~$p\"],[\"^Y=\",\"^Y>\"],[\"^Y=\",\"^Y>\",\"^Y?\"],[\"^Y=\",\"^Y>\",\"^Y?\",\"~$&\",\"^Y@\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$p\"],[\"^Y=\",\"^Y>\"],[\"^Y=\",\"^Y>\",\"^Y?\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^47\"]],\"^29\",4615,\"^2:\",4615,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$p\"],[\"^Y=\",\"^Y>\"],[\"^Y=\",\"^Y>\",\"^Y?\"],[\"^Y=\",\"^Y>\",\"^Y?\",\"~$&\",\"^Y@\"]]],\"^2B\",\"Takes a set of predicates and returns a function f that returns true if all of its\\n  composing predicates return a logical true value against all of its arguments, else it returns\\n  false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical false result against the original predicates.\"],\"^C[\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9001,\"^26\",7,\"^2:\",9001,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;J\"]]]]],\"^2B\",\"Returns a sequence of the map's keys, in the same order as (seq map).\"],\"^1;\",\"~$cljs.core/keys\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"^;J\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9001,\"^2H\",[\"^1:\",[\"^?G\",\"^4C\"]],\"^2:\",9001,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^;J\"]]]]],\"^2B\",\"Returns a sequence of the map's keys, in the same order as (seq map).\"],\"~$missing-protocol\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",311,\"^26\",7,\"^2:\",311,\"^25\",23,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$proto\",\"^3B\"]]]]]],\"^1;\",\"~$cljs.core/missing-protocol\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2D\",[\"^2<\",[[\"^YD\",\"^3B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",311,\"^2H\",\"~$js/Error\",\"^2:\",311,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^YD\",\"^3B\"]]]]]],\"~$load-file\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",326,\"^26\",7,\"^2:\",326,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$file\"]]]]]],\"^1;\",\"~$cljs.core/load-file\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^YH\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",326,\"^2H\",[\"^1:\",[\"^2S\",\"^4C\"]],\"^2:\",326,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^YH\"]]]]]],\"~$PersistentArrayMap\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1977,\"^26\",28,\"^2:\",1977,\"^25\",46,\"^5M\",true],\"^41\",4,\"^1P\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\",\"^5Q\"]],\"^1;\",\"^59\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^45\",true,\"^26\",10,\"^29\",6811,\"^46\",false,\"^5M\",true,\"^2:\",6811,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^9@\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1U\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^22\",\"^87\",\"^<W\",\"^23\",\"^5Q\"]]],\"~$distinct?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",16,\"^29\",2357,\"^2:\",2357,\"^2R\",\"^3D\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns true if no two of the arguments are =\"],\"^1;\",\"~$cljs.core/distinct?\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3D\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",\"^3D\"]],\"^29\",2357,\"^2H\",\"^3D\",\"^2:\",2357,\"^2J\",2,\"^2R\",\"^3D\",\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns true if no two of the arguments are =\"],\"~$pos-int?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2275,\"^26\",7,\"^2:\",2275,\"^25\",15,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies int? and is positive.\"],\"^1;\",\"~$cljs.core/pos-int?\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2275,\"^2H\",\"^3D\",\"^2:\",2275,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Return true if x satisfies int? and is positive.\"],\"~$never-equiv\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6326,\"^26\",16,\"^2:\",6326,\"^25\",27,\"^5E\",true],\"^5E\",true,\"^1;\",\"~$cljs.core/never-equiv\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^26\",1,\"^29\",6326,\"^2:\",6326,\"^2R\",\"^<O\"],\"~$unchecked-short\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2711,\"^26\",15,\"^2:\",2711,\"^25\",30,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/unchecked-short\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2711,\"^2H\",\"^<\",\"^2:\",2711,\"^2J\",1,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$->Range\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^1Q\",\"^1R\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^26\",10,\"^27\",\"^28\",\"^29\",9667,\"^2:\",9667,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^51\",\"^52\",\"^=S\",\"^;9\",\"~$chunk-next\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^1Q\",\"^1R\",\"^1T\",\"^A8\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Range.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^1Q\",\"^1R\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->Range\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^2>\",\"^51\",\"^52\",\"^=S\",\"^;9\",\"^YT\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",9667,\"^2H\",\"^?5\",\"^2:\",9667,\"^2J\",7,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^51\",\"^52\",\"^=S\",\"^;9\",\"^YT\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^1Q\",\"^1R\",\"^1T\",\"^A8\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Range.\"],\"~$->MapEntry\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",10,\"^27\",\"^28\",\"^29\",6631,\"^2:\",6631,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/MapEntry.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1V\",\"^56\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->MapEntry\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^36\",\"^37\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",6631,\"^2H\",\"^2U\",\"^2:\",6631,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^36\",\"^37\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^94\",\"^5O\",\"^1Q\",\"^1R\",\"^1S\",\"^1T\",\"^1X\",\"^1Y\",\"^1Z\",\"^1[\",\"^95\",\"^96\",\"^4W\",\"^22\",\"^87\",\"^23\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/MapEntry.\"],\"~$apply-to-simple\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^5E\",true,\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"~$a0\",\"^AP\"],[\"~$f\",\"^YY\",\"~$a1\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"~$a2\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"~$a3\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"^YY\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^Z0\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^26\",8,\"^29\",3888,\"^2:\",3888,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"^YY\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^Z0\",\"^AP\"]]]]],\"^2B\",\"Internal. DO NOT USE!\\n  Assumes args was already called with seq beforehand!\"],\"^5E\",true,\"^1;\",\"~$cljs.core/apply-to-simple\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",6,\"^2J\",6,\"^2D\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"^YY\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^Z0\",\"^AP\"]]],\"^2;\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"^YY\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^Z0\",\"^AP\"]]],\"^2F\",[\"^2<\",[null,null,null,null,null]]],\"^2D\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"^YY\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^Z0\",\"^AP\"]]],\"^2E\",null,\"^2O\",6,\"^2F\",[\"^2<\",[null,null,null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",6,\"^2G\",false,\"^2R\",\"^2S\"]],\"^29\",3888,\"^2:\",3888,\"^2J\",6,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$f\",\"^AP\"],[\"~$f\",\"^YY\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^AP\"],[\"~$f\",\"^YY\",\"^YZ\",\"^Y[\",\"^Z0\",\"^AP\"]]],\"^2B\",\"Internal. DO NOT USE!\\n  Assumes args was already called with seq beforehand!\"],\"~$methods\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11226,\"^26\",7,\"^2:\",11226,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, returns a map of dispatch values -> dispatch fns\"],\"^1;\",\"~$cljs.core/methods\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^8C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11226,\"^2H\",\"^2S\",\"^2:\",11226,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\"]]]]],\"^2B\",\"Given a multimethod, returns a map of dispatch values -> dispatch fns\"],\"~$odd?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",4251,\"^26\",7,\"^2:\",4251,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns true if n is odd, throws an exception if n is not an integer\"],\"^1;\",\"~$cljs.core/odd?\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2D\",[\"^2<\",[[\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",4251,\"^2H\",\"^3D\",\"^2:\",4251,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$n\"]]]]],\"^2B\",\"Returns true if n is odd, throws an exception if n is not an integer\"],\"~$->ArrayChunk\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^5N\",\"^1Y\",\"^:S\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",3512,\"^2:\",3512,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"^>J\",\"^52\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^1Y\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ArrayChunk.\"],\"^1P\",[\"^1:\",[\"^5N\",\"^1Y\",\"^:S\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->ArrayChunk\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^6B\",\"^>J\",\"^52\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3512,\"^2H\",\"^:U\",\"^2:\",3512,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^6B\",\"^>J\",\"^52\"]]]]],\"^2A\",[\"^1:\",[\"^5N\",\"^1Y\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/ArrayChunk.\"],\"~$ci-reduce\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^5E\",true,\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"~$cicoll\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^Z9\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^26\",8,\"^29\",1454,\"^2:\",1454,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^Z9\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]]]],\"^2B\",\"Accepts any collection which satisfies the ICount and IIndexed protocols and\\nreduces them without incurring seq initialization\"],\"^5E\",true,\"^1;\",\"~$cljs.core/ci-reduce\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",4,\"^2J\",4,\"^2D\",[\"^2<\",[[\"^Z9\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]],\"^2;\",[\"^2<\",[[\"^Z9\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[\"^Z9\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]],\"^2E\",null,\"^2O\",4,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]],[\"^ \",\"^2O\",4,\"^2G\",false,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",1454,\"^2:\",1454,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^Z9\",\"~$f\"],[\"^Z9\",\"~$f\",\"^37\"],[\"^Z9\",\"~$f\",\"^37\",\"^7G\"]]],\"^2B\",\"Accepts any collection which satisfies the ICount and IIndexed protocols and\\nreduces them without incurring seq initialization\"],\"~$*3\",[\"^ \",\"^1;\",\"~$cljs.core/*3\",\"^24\",\"cljs/core.cljs\",\"^29\",207,\"^26\",1,\"^2:\",209,\"^25\",5,\"^2B\",\"bound in a repl thread to the third most recent value printed\",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",209,\"^26\",3,\"^2:\",209,\"^25\",5,\"^2B\",\"bound in a repl thread to the third most recent value printed\"]],\"^US\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11016,\"^26\",4,\"^2:\",11016,\"^25\",15,\"^69\",\"^81\",\"^2B\",null,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\"]]]]]],\"^69\",\"^81\",\"^1;\",\"~$cljs.core/-get-method\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^2D\",[\"^2<\",[[\"^82\",\"^83\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11011,\"^2H\",\"^2S\",\"^2:\",11016,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^82\",\"^83\"]]]]],\"^2B\",null],\"~$->Var\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^1[\",\"^4Q\",\"^43\",\"^22\"]],\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^26\",10,\"^27\",\"^28\",\"^29\",1118,\"^2:\",1118,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\",\"^H9\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1[\",\"^43\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/Var.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1V\",\"^1[\",\"^4Q\",\"^43\",\"^22\"]],\"^1;\",\"~$cljs.core/->Var\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2D\",[\"^2<\",[[\"^37\",\"^H9\",\"^GB\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",1118,\"^2H\",\"^4R\",\"^2:\",1118,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^37\",\"^H9\",\"^GB\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1S\",\"^1[\",\"^43\",\"^22\"]],\"^2B\",\"Positional factory function for cljs.core/Var.\"],\"~$frequencies\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9874,\"^26\",7,\"^2:\",9874,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a map from distinct items in coll to the number of times\\n  they appear.\"],\"^1;\",\"~$cljs.core/frequencies\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9874,\"^2H\",\"^2T\",\"^2:\",9874,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a map from distinct items in coll to the number of times\\n  they appear.\"],\"~$reduceable?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2147,\"^26\",7,\"^2:\",2147,\"^25\",18,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll satisfies IReduce\"],\"^1;\",\"~$cljs.core/reduceable?\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2147,\"^2H\",\"^3D\",\"^2:\",2147,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns true if coll satisfies IReduce\"],\"~$string-hash-cache\",[\"^ \",\"^1;\",\"~$cljs.core/string-hash-cache\",\"^24\",\"cljs/core.cljs\",\"^29\",955,\"^26\",1,\"^2:\",955,\"^25\",23,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",955,\"^26\",6,\"^2:\",955,\"^25\",23],\"^2R\",\"^4>\"],\"~$->Iterate\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",10,\"^27\",\"^28\",\"^29\",5021,\"^2:\",5021,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$f\",\"~$prev-seed\",\"^J<\",\"~$next\"]]]]],\"^2A\",[\"^1:\",[\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Iterate.\"],\"^1P\",[\"^1:\",[\"^1T\",\"^1V\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->Iterate\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^2>\",\"~$f\",\"^ZG\",\"^J<\",\"^ZH\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",5021,\"^2H\",\"^7D\",\"^2:\",5021,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"~$f\",\"^ZG\",\"^J<\",\"^ZH\"]]]]],\"^2A\",[\"^1:\",[\"^1T\",\"^8J\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Iterate.\"],\"~$rsubseq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9620,\"^26\",7,\"^2:\",9620,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]]]],\"^2B\",\"sc must be a sorted collection, test(s) one of <, <=, > or\\n  >=. Returns a reverse seq of those entries with keys ek for\\n  which (test (.. sc comparator (compare ek key)) 0) is true\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2;\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/rsubseq\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",5,\"^2J\",5,\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2;\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2E\",null,\"^2O\",5,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2[\",\"^2T\",\"^3U\",\"^4C\"]]],[\"^ \",\"^2O\",5,\"^2G\",false,\"^2R\",[\"^1:\",[\"^3U\",\"^4C\"]]]],\"^29\",9620,\"^2:\",9620,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^9Q\",\"^9R\",\"^36\"],[\"^9Q\",\"^WG\",\"^WH\",\"^WI\",\"^WJ\"]]],\"^2B\",\"sc must be a sorted collection, test(s) one of <, <=, > or\\n  >=. Returns a reverse seq of those entries with keys ek for\\n  which (test (.. sc comparator (compare ek key)) 0) is true\"],\"~$inc\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1414,\"^26\",7,\"^2:\",1414,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one greater than num.\"],\"^1;\",\"~$cljs.core/inc\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1414,\"^2H\",\"^<\",\"^2:\",1414,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]],\"^2B\",\"Returns a number one greater than num.\"],\"~$type->str\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",320,\"^26\",7,\"^2:\",320,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$ty\"]]]]]],\"^1;\",\"~$cljs.core/type->str\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^ZO\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",320,\"^2H\",[\"^1:\",[\"^2S\",\"^3J\"]],\"^2:\",320,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^ZO\"]]]]]],\"~$obj-clone\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6384,\"^26\",8,\"^2:\",6384,\"^25\",17,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^8V\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/obj-clone\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^3B\",\"^8V\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6384,\"^2H\",\"^4>\",\"^2:\",6384,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^3B\",\"^8V\"]]]]]],\"~$get-method\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11230,\"^26\",7,\"^2:\",11230,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\",\"^83\"]]]]],\"^2B\",\"Given a multimethod and a dispatch value, returns the dispatch fn\\n  that would apply to that value, or nil if none apply and no default\"],\"^1;\",\"~$cljs.core/get-method\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^8C\",\"^83\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11230,\"^2H\",\"^2S\",\"^2:\",11230,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^8C\",\"^83\"]]]]],\"^2B\",\"Given a multimethod and a dispatch value, returns the dispatch fn\\n  that would apply to that value, or nil if none apply and no default\"],\"~$uuid?\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",11293,\"^26\",7,\"^2:\",11293,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/uuid?\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",11293,\"^2H\",\"^3D\",\"^2:\",11293,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"~$vector-index-out-of-bounds\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5389,\"^26\",8,\"^2:\",5389,\"^25\",34,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$i\",\"^6C\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/vector-index-out-of-bounds\",\"^24\",\"cljs/core.cljs\",\"^25\",34,\"^2D\",[\"^2<\",[[\"~$i\",\"^6C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",5389,\"^2H\",\"^;[\",\"^2:\",5389,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$i\",\"^6C\"]]]]]],\"~$es6-entries-iterator\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",6536,\"^26\",7,\"^2:\",6536,\"^25\",27,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"^1;\",\"~$cljs.core/es6-entries-iterator\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",6536,\"^2H\",\"^C0\",\"^2:\",6536,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]]],\"~$bit-clear\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2871,\"^26\",7,\"^2:\",2871,\"^25\",16,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Clear bit at index n\"],\"^1;\",\"~$cljs.core/bit-clear\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2871,\"^2H\",\"^<\",\"^2:\",2871,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]],\"^2B\",\"Clear bit at index n\"],\"~$Range\",[\"^ \",\"^41\",7,\"^1P\",[\"^1:\",[\"^5N\",\"^1Q\",\"^1R\",\"^1T\",\"^A8\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"^?5\",\"^24\",\"cljs/core.cljs\",\"^25\",15,\"^45\",true,\"^26\",10,\"^29\",9667,\"^46\",false,\"^2:\",9667,\"^2R\",\"^47\",\"^2A\",[\"^1:\",[\"^5N\",\"^1Q\",\"^1R\",\"^1T\",\"^A8\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^21\",\"^7T\",\"^4W\",\"^22\",\"^5Q\"]]],\"~$filter\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",5147,\"^26\",7,\"^2:\",5147,\"^25\",13,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns logical true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/filter\",\"^24\",\"cljs/core.cljs\",\"^25\",13,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^47\"],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^3U\"]],\"^29\",5147,\"^2:\",5147,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^4G\"],[\"^4G\",\"^2X\"]]],\"^2B\",\"Returns a lazy sequence of the items in coll for which\\n  (pred item) returns logical true. pred must be free of side-effects.\\n  Returns a transducer when no collection is provided.\"],\"~$->PersistentTreeMapSeq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^26\",10,\"^27\",\"^28\",\"^29\",8156,\"^2:\",8156,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^@\",\"^76\",\"^6C\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentTreeMapSeq.\"],\"^1P\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1V\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->PersistentTreeMapSeq\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2D\",[\"^2<\",[[\"^2>\",\"^@\",\"^76\",\"^6C\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",8156,\"^2H\",\"^9F\",\"^2:\",8156,\"^2J\",5,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^@\",\"^76\",\"^6C\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^1Q\",\"^1R\",\"^1T\",\"^1X\",\"^1Y\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/PersistentTreeMapSeq.\"],\"~$create-array-node-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",7828,\"^26\",8,\"^2:\",7828,\"^25\",29,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]]]],\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2;\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/create-array-node-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",29,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2;\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",[\"^1:\",[\"^?A\",\"^4C\"]]]],\"^29\",7828,\"^2:\",7828,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^P<\"],[\"^P<\",\"~$i\",\"~$s\"]]]],\"^HE\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^69\",\"^@<\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",9,\"^29\",806,\"^2:\",806,\"^2R\",\"^2T\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\",\"~$n\",\"^37\"]]]]],\"^2B\",\"Returns tcoll with value val added at position n.\"],\"^69\",\"^@<\",\"^1;\",\"~$cljs.core/-assoc-n!\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^35\",\"~$n\",\"^37\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",804,\"^2H\",\"^2T\",\"^2:\",806,\"^2J\",3,\"^2R\",\"^2T\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^35\",\"~$n\",\"^37\"]]]]],\"^2B\",\"Returns tcoll with value val added at position n.\"],\"~$IWithMeta\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",14,\"^29\",684,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^68\",[[\"~$o\",\"^2>\"]]]],\"^2:\",684,\"^2B\",\"Protocol for adding metadata to an object.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^22\",\"^24\",\"cljs/core.cljs\",\"^25\",23,\"^26\",1,\"^29\",684,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^68\",[[\"~$o\",\"^2>\"]]]],\"^3:\",null,\"^2:\",684,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^?<\",\"^59\",\"^:<\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^4R\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^2I\",\"^5=\",\"^?G\",\"^?H\",\"^7R\",\"^?I\",\"^<G\",\"^5A\",\"^B4\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for adding metadata to an object.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$next*\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^5E\",true,\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",13,\"^29\",3881,\"^2:\",3881,\"^2R\",\"^2[\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Internal. DO NOT USE! Next without the nil? check.\"],\"^5E\",true,\"^1;\",\"~$cljs.core/next*\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",3881,\"^2H\",\"^2[\",\"^2:\",3881,\"^2J\",1,\"^2R\",\"^2[\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Internal. DO NOT USE! Next without the nil? check.\"],\"~$list\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3202,\"^26\",7,\"^2:\",3202,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$&\",\"^5F\"]]]]],\"^2B\",\"Creates a new list containing the items.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^5F\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^5F\"]]],\"^2F\",[\"^2<\",[null]]]],\"^1;\",\"~$cljs.core/list\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",0,\"^2J\",0,\"^2D\",[[\"^2<\",[\"^5F\"]]],\"^2;\",[\"^2<\",[[\"~$&\",\"^5F\"]]],\"^2F\",[\"^2<\",[null]]],\"^2D\",[[\"^2<\",[\"^5F\"]]],\"^2E\",null,\"^2O\",0,\"^2F\",[\"^2<\",[null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",true,\"^2R\",[\"^1:\",[\"^2T\",\"^30\"]]]],\"^29\",3202,\"^2H\",\"^2S\",\"^2:\",3202,\"^2J\",0,\"^2K\",true,\"^2;\",[\"^2<\",[[\"~$&\",\"^5F\"]]],\"^2B\",\"Creates a new list containing the items.\"],\"~$+\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^26\",15,\"^29\",2598,\"^2:\",2598,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]]]],\"^2B\",\"Returns the sum of nums. (+) returns 0.\"],\"^1;\",\"~$cljs.core/+\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2F\",[\"^2<\",[null,null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",1,\"^2G\",false],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<\"],[\"^ \",\"^2O\",2,\"^2G\",true,\"^2R\",[\"^1:\",[null,\"^2S\"]]]],\"^29\",2598,\"^2H\",\"^<\",\"^2:\",2598,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^6M\"]]],\"^2B\",\"Returns the sum of nums. (+) returns 0.\"],\"~$IndexedSeqIterator\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^SC\",\"^24\",\"cljs/core.cljs\",\"^25\",28,\"^45\",true,\"^26\",10,\"^29\",1562,\"^46\",false,\"^2:\",1562,\"^2R\",\"^47\",\"^2A\",null],\"~$split-with\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",9828,\"^26\",7,\"^2:\",9828,\"^25\",17,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a vector of [(take-while pred coll) (drop-while pred coll)]\"],\"^1;\",\"~$cljs.core/split-with\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^2D\",[\"^2<\",[[\"^4G\",\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",9828,\"^2H\",\"^94\",\"^2:\",9828,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^4G\",\"^2X\"]]]]],\"^2B\",\"Returns a vector of [(take-while pred coll) (drop-while pred coll)]\"],\"~$->VectorNode\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[]],\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^26\",10,\"^27\",\"^28\",\"^29\",5343,\"^2:\",5343,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^6B\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/VectorNode.\"],\"^1P\",[\"^1:\",[]],\"^1;\",\"~$cljs.core/->VectorNode\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^>2\",\"^6B\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",5343,\"^2H\",\"^8T\",\"^2:\",5343,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^>2\",\"^6B\"]]]]],\"^2A\",null,\"^2B\",\"Positional factory function for cljs.core/VectorNode.\"],\"~$aset\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",503,\"^26\",7,\"^2:\",503,\"^25\",11,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]]]],\"^2B\",\"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/aset\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",3,\"^2J\",3,\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"]]],\"^2E\",null,\"^2O\",3,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",3,\"^2G\",false,\"^2R\",\"^2S\"],[\"^ \",\"^2O\",3,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",503,\"^2:\",503,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^7F\",\"^7G\",\"^37\"],[\"^7F\",\"^7G\",\"^@N\",\"~$&\",\"^@O\"]]],\"^2B\",\"Sets the value at the index/indices. Works on JavaScript arrays.\\n  Returns val.\"],\"~$int-rotate-left\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",890,\"^26\",15,\"^2:\",890,\"^25\",30,\"^2R\",\"^<\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]]],\"^1;\",\"~$cljs.core/int-rotate-left\",\"^24\",\"cljs/core.cljs\",\"^25\",30,\"^2D\",[\"^2<\",[[\"~$x\",\"~$n\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",890,\"^2H\",\"^<\",\"^2:\",890,\"^2J\",2,\"^2R\",\"^<\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\",\"~$n\"]]]]]],\"~$keyword\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",3388,\"^26\",7,\"^2:\",3388,\"^25\",14,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]]]],\"^2B\",\"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\",\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2;\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2F\",[\"^2<\",[null,null]]]],\"^1;\",\"~$cljs.core/keyword\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2N\",[\"^ \",\"^2G\",false,\"^2O\",2,\"^2J\",2,\"^2D\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2;\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2F\",[\"^2<\",[null,null]]],\"^2D\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2E\",null,\"^2O\",2,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^2Q\",[[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^<5\",\"^4C\"]]],[\"^ \",\"^2O\",2,\"^2G\",false,\"^2R\",\"^<5\"]],\"^29\",3388,\"^2:\",3388,\"^2J\",2,\"^2K\",true,\"^2;\",[\"^2<\",[[\"^:\"],[\"^4@\",\"^:\"]]],\"^2B\",\"Returns a Keyword with the given namespace and name.  Do not use :\\n  in the keyword strings, it will be added automatically.\"],\"~$->Cons\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]],\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^26\",10,\"^27\",\"^28\",\"^29\",3219,\"^2:\",3219,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6V\",\"^<6\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Cons.\"],\"^1P\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1V\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]],\"^1;\",\"~$cljs.core/->Cons\",\"^24\",\"cljs/core.cljs\",\"^25\",14,\"^2D\",[\"^2<\",[[\"^2>\",\"^6V\",\"^<6\",\"^2@\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^27\",\"^28\",\"^29\",3219,\"^2H\",\"^?<\",\"^2:\",3219,\"^2J\",4,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2>\",\"^6V\",\"^<6\",\"^2@\"]]]]],\"^2A\",[\"^1:\",[\"^30\",\"^1Q\",\"^1R\",\"^5P\",\"^1T\",\"^1X\",\"^4J\",\"^4V\",\"^1Z\",\"^1[\",\"^20\",\"^4W\",\"^22\",\"^5Q\"]],\"^2B\",\"Positional factory function for cljs.core/Cons.\"],\"~$*ns*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",54,\"^26\",3,\"^2:\",54,\"^25\",7,\"^6R\",true,\"^2B\",\"Var bound to the current namespace. Only used for bootstrapping.\",\"^38\",[\"@type {*}\"]],\"^1;\",\"~$cljs.core/*ns*\",\"^24\",\"cljs/core.cljs\",\"^25\",7,\"^26\",1,\"^6R\",true,\"^29\",50,\"^2:\",54,\"^2R\",\"^4C\",\"^2B\",\"Var bound to the current namespace. Only used for bootstrapping.\",\"^38\",[\"@type {*}\"]],\"~$*assert*\",[\"^ \",\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",63,\"^26\",3,\"^2:\",63,\"^25\",11,\"^6R\",true],\"^1;\",\"~$cljs.core/*assert*\",\"^24\",\"cljs/core.cljs\",\"^25\",11,\"^26\",1,\"^6R\",true,\"^29\",61,\"^2:\",63,\"^2R\",\"^3D\"],\"~$create-tree-map-seq\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",8227,\"^26\",8,\"^2:\",8227,\"^25\",27,\"^5E\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^62\",\"^76\",\"^6C\"]]]]]],\"^5E\",true,\"^1;\",\"~$cljs.core/create-tree-map-seq\",\"^24\",\"cljs/core.cljs\",\"^25\",27,\"^2D\",[\"^2<\",[[\"^62\",\"^76\",\"^6C\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",8227,\"^2H\",\"^9F\",\"^2:\",8227,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^62\",\"^76\",\"^6C\"]]]]]],\"~$ICollection\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",14,\"^29\",581,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^:9\",[[\"^2X\",\"~$o\"]]]],\"^2:\",581,\"^2B\",\"Protocol for adding to a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^1T\",\"^24\",\"cljs/core.cljs\",\"^25\",25,\"^26\",1,\"^29\",581,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"^:9\",[[\"^2X\",\"~$o\"]]]],\"^3:\",null,\"^2:\",581,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^57\",\"^58\",\"^?<\",\"^59\",\"^:<\",\"^?=\",\"^5R\",\"^5:\",\"^2U\",\"^?>\",\"^3U\",\"^5;\",\"^4[\",\"^?A\",\"^?B\",\"^?C\",\"^<<\",\"^5<\",\"^?D\",\"^?E\",\"^?F\",\"^7D\",\"^2I\",\"^5=\",\"^?G\",\"^?H\",\"^7R\",\"^?I\",\"^?5\",\"^9F\",\"^5>\"]],\"^2B\",\"Protocol for adding to a collection.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$chars\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2818,\"^26\",7,\"^2:\",2818,\"^25\",12,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^1;\",\"~$cljs.core/chars\",\"^24\",\"cljs/core.cljs\",\"^25\",12,\"^2D\",[\"^2<\",[[\"~$x\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",2818,\"^2:\",2818,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"~$x\"]]]]]],\"^I7\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",2956,\"^26\",7,\"^2:\",2956,\"^25\",10,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$&\",\"^5G\"]]]]],\"^2B\",\"With no args, returns the empty string. With one arg x, returns\\n  x.toString().  (str nil) returns the empty string. With more than\\n  one arg, returns the concatenation of the str values of the args.\",\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"~$x\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$&\",\"^5G\"]]],\"^2F\",[\"^2<\",[null,null,null]]]],\"^1;\",\"~$cljs.core/str\",\"^24\",\"cljs/core.cljs\",\"^25\",10,\"^2N\",[\"^ \",\"^2G\",true,\"^2O\",1,\"^2J\",1,\"^2D\",[\"^2<\",[[],[\"~$x\"]]],\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$&\",\"^5G\"]]],\"^2F\",[\"^2<\",[null,null,null]]],\"^2D\",[\"^2<\",[[],[\"~$x\"]]],\"^2E\",null,\"^2O\",1,\"^2F\",[\"^2<\",[null,null,null]],\"^26\",1,\"^2G\",true,\"^2Q\",[[\"^ \",\"^2O\",0,\"^2G\",false,\"^2R\",\"^3J\"],[\"^ \",\"^2O\",1,\"^2G\",false,\"^2R\",[\"^1:\",[\"^2S\",\"^3J\"]]],[\"^ \",\"^2O\",1,\"^2G\",true,\"^2R\",\"^2S\"]],\"^29\",2956,\"^2:\",2956,\"^2J\",1,\"^2K\",true,\"^2;\",[\"^2<\",[[],[\"~$x\"],[\"~$x\",\"~$&\",\"^5G\"]]],\"^2B\",\"With no args, returns the empty string. With one arg x, returns\\n  x.toString().  (str nil) returns the empty string. With more than\\n  one arg, returns the concatenation of the str values of the args.\"],\"^ZH\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",1252,\"^26\",12,\"^2:\",1252,\"^25\",16,\"^2R\",\"^2[\",\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"],\"^1;\",\"~$cljs.core/next\",\"^24\",\"cljs/core.cljs\",\"^25\",16,\"^2D\",[\"^2<\",[[\"^2X\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",1252,\"^2H\",\"^2[\",\"^2:\",1252,\"^2J\",1,\"^2R\",\"^2[\",\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^2X\"]]]]],\"^2B\",\"Returns a seq of the items after the first. Calls seq on its\\n  argument.  If there are no more items, returns nil\"],\"~$ASeq\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",14,\"^29\",598,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^2:\",598,\"^2B\",\"Marker protocol indicating an array sequence.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"^32\",true,\"^1;\",\"^5P\",\"^24\",\"cljs/core.cljs\",\"^25\",18,\"^26\",1,\"^29\",598,\"^33\",[\"^ \",\"^2Q\",[\"^ \"]],\"^3:\",null,\"^2:\",598,\"^2R\",\"^2S\",\"^3;\",[\"^1:\",[\"^?<\",\"^5R\",\"^?D\",\"^?H\",\"^?I\"]],\"^2B\",\"Marker protocol indicating an array sequence.\",\"^38\",[\"^2<\",[\"@interface\"]]],\"~$pr-seq-writer\",[\"^ \",\"^1N\",null,\"^1O\",[\"^ \",\"^24\",\"cljs/core.cljs\",\"^29\",10185,\"^26\",7,\"^2:\",10185,\"^25\",20,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^7W\",\"^2M\"]]]]]],\"^1;\",\"~$cljs.core/pr-seq-writer\",\"^24\",\"cljs/core.cljs\",\"^25\",20,\"^2D\",[\"^2<\",[[\"^79\",\"^7W\",\"^2M\"]]],\"^2E\",null,\"^2F\",[\"^2<\",[null,null]],\"^26\",1,\"^2G\",false,\"^29\",10185,\"^2H\",\"^4C\",\"^2:\",10185,\"^2J\",3,\"^2K\",true,\"^2;\",[\"^2<\",[\"^2=\",[\"^2<\",[[\"^79\",\"^7W\",\"^2M\"]]]]]],\"~$SeqIter\",[\"^ \",\"^41\",2,\"^1P\",[\"^1:\",[\"^1V\"]],\"^1;\",\"^T1\",\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^45\",true,\"^26\",10,\"^29\",4033,\"^46\",false,\"^2:\",4033,\"^2R\",\"^47\",\"^2A\",null],\"~$IFn\",[\"^ \",\"^1O\",[\"^ \",\"^32\",true,\"^24\",\"cljs/core.cljs\",\"^25\",17,\"^26\",14,\"^29\",537,\"^33\",[\"^ \",\"^2Q\",[\"^ \",\"~$-invoke\",[[\"~$this\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"~$rest\"]]]],\"~:end-line\",537,\"~:doc\",\"Protocol for adding the ability to invoke an object as a function.\\n  For example, a vector can also be used to look up a value:\\n  ([1 2 3 4] 1) => 2\",\"~:jsdoc\",[\"~#list\",[\"@interface\"]]],\"~:protocol-symbol\",true,\"~:name\",\"~$cljs.core/IFn\",\"~:file\",\"cljs/core.cljs\",\"~:end-column\",17,\"~:column\",1,\"~:line\",537,\"~:protocol-info\",[\"^ \",\"~:methods\",[\"^ \",\"^0\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]]],\"~:info\",null,\"^3\",537,\"~:tag\",\"~$any\",\"~:impls\",[\"~#set\",[\"~$cljs.core/PersistentHashMap\",\"~$cljs.core/MultiFn\",\"~$cljs.core/ObjMap\",\"~$cljs.core/TransientVector\",\"~$cljs.core/PersistentArrayMap\",\"~$cljs.core/Keyword\",\"~$cljs.core/BlackNode\",\"~$cljs.core/MapEntry\",\"~$cljs.core/Subvec\",\"~$cljs.core/Var\",\"~$cljs.core/TransientHashMap\",\"~$cljs.core/PersistentVector\",\"~$cljs.core/TransientArrayMap\",\"~$cljs.core/TransientHashSet\",\"~$cljs.core/PersistentHashSet\",\"~$cljs.core/PersistentTreeMap\",\"~$cljs.core/PersistentTreeSet\",\"~$cljs.core/Symbol\",\"~$cljs.core/MetaFn\",\"~$cljs.core/RedNode\"]],\"^4\",\"Protocol for adding the ability to invoke an object as a function.\\n  For example, a vector can also be used to look up a value:\\n  ([1 2 3 4] 1) => 2\",\"^5\",[\"^6\",[\"@interface\"]]],\"~$regexp?\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",9964,\"^<\",7,\"^3\",9964,\"^;\",14,\"~:arglists\",[\"^6\",[\"~$quote\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is a JavaScript RegExp instance.\"],\"^8\",\"~$cljs.core/regexp?\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"~:method-params\",[\"^6\",[[\"~$x\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^6\",[null,null]],\"^<\",1,\"~:variadic?\",false,\"^=\",9964,\"~:ret-tag\",\"~$boolean\",\"^3\",9964,\"~:max-fixed-arity\",1,\"~:fn-var\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is a JavaScript RegExp instance.\"],\"~$hash-map\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",8883,\"^<\",7,\"^3\",8883,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$&\",\"~$keyvals\"]]]]],\"^4\",\"keyval => key val\\n  Returns a new hash map with supplied mappings.\",\"~:top-fn\",[\"^ \",\"^16\",true,\"~:fixed-arity\",0,\"^19\",0,\"^13\",[[\"^6\",[\"^1<\"]]],\"^10\",[\"^6\",[[\"~$&\",\"^1<\"]]],\"^15\",[\"^6\",[null]]]],\"^8\",\"~$cljs.core/hash-map\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",0,\"^19\",0,\"^13\",[[\"^6\",[\"^1<\"]]],\"^10\",[\"^6\",[[\"~$&\",\"^1<\"]]],\"^15\",[\"^6\",[null]]],\"^13\",[[\"^6\",[\"^1<\"]]],\"^14\",null,\"^1>\",0,\"^15\",[\"^6\",[null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",0,\"^16\",true,\"^A\",\"~$clj\"]],\"^=\",8883,\"^17\",\"^B\",\"^3\",8883,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[[\"~$&\",\"^1<\"]]],\"^4\",\"keyval => key val\\n  Returns a new hash map with supplied mappings.\"],\"~$*exec-tap-fn*\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",73,\"^<\",3,\"^3\",73,\"^;\",16,\"^4\",\"Arranges to have tap functions executed via the supplied f, a\\n  function of no arguments. Returns true if successful, false otherwise.\",\"~:dynamic\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$f\"]]]]]],\"^8\",\"~$cljs.core/*exec-tap-fn*\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^13\",[\"^6\",[[\"~$f\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^1B\",true,\"^=\",71,\"^17\",[\"^D\",[\"^18\",\"~$js\"]],\"^3\",73,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$f\"]]]]],\"^4\",\"Arranges to have tap functions executed via the supplied f, a\\n  function of no arguments. Returns true if successful, false otherwise.\"],\"~$underive\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10935,\"^<\",7,\"^3\",10935,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$tag\",\"~$parent\"],[\"~$h\",\"^1F\",\"^1G\"]]]]],\"^4\",\"Removes a parent/child relationship between parent and\\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\\n  supplied defaults to, and modifies, the global hierarchy.\",\"^1=\",[\"^ \",\"^16\",false,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"^1F\",\"^1G\"],[\"~$h\",\"^1F\",\"^1G\"]]],\"^10\",[\"^6\",[[\"^1F\",\"^1G\"],[\"~$h\",\"^1F\",\"^1G\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/underive\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"^1F\",\"^1G\"],[\"~$h\",\"^1F\",\"^1G\"]]],\"^10\",[\"^6\",[[\"^1F\",\"^1G\"],[\"~$h\",\"^1F\",\"^1G\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^1F\",\"^1G\"],[\"~$h\",\"^1F\",\"^1G\"]]],\"^14\",null,\"^1>\",3,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"~$clj-nil\"],[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",[\"^D\",[null,\"^B\"]]]],\"^=\",10935,\"^3\",10935,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[[\"^1F\",\"^1G\"],[\"~$h\",\"^1F\",\"^1G\"]]],\"^4\",\"Removes a parent/child relationship between parent and\\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\\n  supplied defaults to, and modifies, the global hierarchy.\"],\"~$array-copy\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2193,\"^<\",8,\"^3\",2193,\"^;\",18,\"~:private\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$from\",\"~$i\",\"~$to\",\"~$j\",\"~$len\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/array-copy\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^13\",[\"^6\",[[\"^1L\",\"~$i\",\"^1M\",\"~$j\",\"^1N\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2193,\"^3\",2193,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1L\",\"~$i\",\"^1M\",\"~$j\",\"^1N\"]]]]]],\"~$obj-map-compare-keys\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",6362,\"^<\",8,\"^3\",6362,\"^;\",28,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$a\",\"~$b\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/obj-map-compare-keys\",\"^:\",\"cljs/core.cljs\",\"^;\",28,\"^13\",[\"^6\",[[\"~$a\",\"~$b\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",6362,\"^17\",\"~$number\",\"^3\",6362,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$a\",\"~$b\"]]]]]],\"~$-reset!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",851,\"^<\",4,\"^3\",851,\"^;\",11,\"~:protocol\",\"~$cljs.core/IReset\",\"^4\",\"Sets the value of o to new-value.\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\",\"~$new-value\"]]]]]],\"^1T\",\"^1U\",\"^8\",\"~$cljs.core/-reset!\",\"^:\",\"cljs/core.cljs\",\"^;\",11,\"^13\",[\"^6\",[[\"~$o\",\"^1V\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",849,\"^17\",\"^B\",\"^3\",851,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\",\"^1V\"]]]]],\"^4\",\"Sets the value of o to new-value.\"],\"~$-rest\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"~$cljs.core/ISeq\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^<\",9,\"^=\",605,\"^3\",605,\"^A\",\"^1@\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$coll\"]]]]],\"^4\",\"Returns a new collection of coll without the first item. It should\\n     always return a seq, e.g.\\n     (rest []) => ()\\n     (rest nil) => ()\"],\"^1T\",\"^1Y\",\"^8\",\"~$cljs.core/-rest\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",601,\"^17\",\"^1@\",\"^3\",605,\"^19\",1,\"^A\",\"^1@\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns a new collection of coll without the first item. It should\\n     always return a seq, e.g.\\n     (rest []) => ()\\n     (rest nil) => ()\"],\"~$nil-iter\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3999,\"^<\",7,\"^3\",3999,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"^8\",\"~$cljs.core/nil-iter\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^13\",[\"^6\",[[]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3999,\"^17\",\"~$cljs.core/t_cljs$core1506\",\"^3\",3999,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"~$pr-writer\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10176,\"^<\",8,\"^3\",10176,\"^;\",17,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$obj\",\"~$writer\",\"~$opts\"]]]]],\"^4\",\"Prefer this to pr-seq, because it makes the printing function\\n   configurable, allowing efficient implementations such as appending\\n   to a StringBuffer.\"],\"^1K\",true,\"^8\",\"~$cljs.core/pr-writer\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"^24\",\"^25\",\"^26\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10176,\"^17\",[\"^D\",[\"^B\",\"^1I\"]],\"^3\",10176,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^24\",\"^25\",\"^26\"]]]]],\"^4\",\"Prefer this to pr-seq, because it makes the printing function\\n   configurable, allowing efficient implementations such as appending\\n   to a StringBuffer.\"],\"~$false?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2213,\"^<\",16,\"^3\",2213,\"^;\",22,\"^A\",\"^18\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is the value false, false otherwise.\"],\"^8\",\"~$cljs.core/false?\",\"^:\",\"cljs/core.cljs\",\"^;\",22,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2213,\"^17\",\"^18\",\"^3\",2213,\"^19\",1,\"^A\",\"^18\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is the value false, false otherwise.\"],\"~$RangedIterator\",[\"^ \",\"~:num-fields\",6,\"~:protocols\",[\"^D\",[\"~$cljs.core/Object\"]],\"^8\",\"~$cljs.core/RangedIterator\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"~:type\",true,\"^<\",10,\"^=\",5440,\"~:record\",false,\"^3\",5440,\"^A\",\"~$function\",\"~:skip-protocol-flag\",null],\"~$*print-readably*\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",114,\"^<\",3,\"^3\",114,\"^;\",19,\"^1B\",true,\"^4\",\"When set to logical false, strings and characters will be printed with\\n  non-alphanumeric characters converted to the appropriate escape sequences.\\n\\n  Defaults to true\"],\"^8\",\"~$cljs.core/*print-readably*\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^<\",1,\"^1B\",true,\"^=\",108,\"^3\",114,\"^A\",\"^18\",\"^4\",\"When set to logical false, strings and characters will be printed with\\n  non-alphanumeric characters converted to the appropriate escape sequences.\\n\\n  Defaults to true\"],\"~$ints\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2820,\"^<\",7,\"^3\",2820,\"^;\",11,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/ints\",\"^:\",\"cljs/core.cljs\",\"^;\",11,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2820,\"^3\",2820,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$some-fn\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4654,\"^<\",7,\"^3\",4654,\"^;\",14,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$p\"],[\"~$p1\",\"~$p2\"],[\"^2H\",\"^2I\",\"~$p3\"],[\"^2H\",\"^2I\",\"^2J\",\"~$&\",\"~$ps\"]]]]],\"^4\",\"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"~$p\"],[\"^2H\",\"^2I\"],[\"^2H\",\"^2I\",\"^2J\"]]],\"^10\",[\"^6\",[[\"~$p\"],[\"^2H\",\"^2I\"],[\"^2H\",\"^2I\",\"^2J\"],[\"^2H\",\"^2I\",\"^2J\",\"~$&\",\"^2K\"]]],\"^15\",[\"^6\",[null,null,null,null]]]],\"^8\",\"~$cljs.core/some-fn\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"~$p\"],[\"^2H\",\"^2I\"],[\"^2H\",\"^2I\",\"^2J\"]]],\"^10\",[\"^6\",[[\"~$p\"],[\"^2H\",\"^2I\"],[\"^2H\",\"^2I\",\"^2J\"],[\"^2H\",\"^2I\",\"^2J\",\"~$&\",\"^2K\"]]],\"^15\",[\"^6\",[null,null,null,null]]],\"^13\",[\"^6\",[[\"~$p\"],[\"^2H\",\"^2I\"],[\"^2H\",\"^2I\",\"^2J\"]]],\"^14\",null,\"^1>\",3,\"^15\",[\"^6\",[null,null,null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^2A\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^2A\"],[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",\"^2A\"],[\"^ \",\"^1>\",3,\"^16\",true,\"^A\",\"^2A\"]],\"^=\",4654,\"^3\",4654,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[[\"~$p\"],[\"^2H\",\"^2I\"],[\"^2H\",\"^2I\",\"^2J\"],[\"^2H\",\"^2I\",\"^2J\",\"~$&\",\"^2K\"]]],\"^4\",\"Takes a set of predicates and returns a function f that returns the first logical true value\\n  returned by one of its composing predicates against any of its arguments, else it returns\\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\\n  argument that triggers a logical true result against the original predicates.\"],\"~$demunge-pattern\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",11462,\"^<\",8,\"^3\",11462,\"^;\",23,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/demunge-pattern\",\"^:\",\"cljs/core.cljs\",\"^;\",23,\"^13\",[\"^6\",[[]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",11462,\"^17\",\"^1I\",\"^3\",11462,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"~$maybe-enable-print!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",11687,\"^<\",8,\"^3\",11687,\"^;\",27,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/maybe-enable-print!\",\"^:\",\"cljs/core.cljs\",\"^;\",27,\"^13\",[\"^6\",[[]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",11687,\"^17\",[\"^D\",[\"^B\",\"^1I\"]],\"^3\",11687,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"~$*flush-on-newline*\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",99,\"^<\",3,\"^3\",99,\"^;\",21,\"^1B\",true,\"^4\",\"When set to true, output will be flushed whenever a newline is printed.\\n\\n  Defaults to true.\"],\"^8\",\"~$cljs.core/*flush-on-newline*\",\"^:\",\"cljs/core.cljs\",\"^;\",21,\"^<\",1,\"^1B\",true,\"^=\",94,\"^3\",99,\"^A\",\"^18\",\"^4\",\"When set to true, output will be flushed whenever a newline is printed.\\n\\n  Defaults to true.\"],\"~$to-array\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3641,\"^<\",7,\"^3\",3641,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns an array containing the contents of coll.\"],\"^8\",\"~$cljs.core/to-array\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3641,\"^17\",\"~$array\",\"^3\",3641,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns an array containing the contents of coll.\"],\"~$build-subvec\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",5959,\"^<\",8,\"^3\",5959,\"^;\",20,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$meta\",\"~$v\",\"~$start\",\"~$end\",\"~$__hash\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/build-subvec\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^13\",[\"^6\",[[\"^2W\",\"~$v\",\"^2X\",\"^2Y\",\"^2Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",5959,\"^17\",\"^M\",\"^3\",5959,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"~$v\",\"^2X\",\"^2Y\",\"^2Z\"]]]]]],\"~$maybe-warn\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",447,\"^<\",8,\"^3\",447,\"^;\",18,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$e\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/maybe-warn\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^13\",[\"^6\",[[\"~$e\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",447,\"^17\",[\"^D\",[\"^B\",\"^1I\"]],\"^3\",447,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$e\"]]]]]],\"~$Namespace\",[\"^ \",\"^2;\",2,\"^2<\",[\"^D\",[\"~$cljs.core/IEquiv\",\"~$cljs.core/IHash\",\"^2=\"]],\"^8\",\"~$cljs.core/Namespace\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^2?\",true,\"^<\",10,\"^=\",11566,\"^2@\",false,\"^3\",11566,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^33\",\"^34\"]]],\"~$list?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3106,\"^<\",7,\"^3\",3106,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x implements IList\"],\"^8\",\"~$cljs.core/list?\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3106,\"^17\",\"^18\",\"^3\",3106,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x implements IList\"],\"~$tree-map-remove\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",8695,\"^<\",8,\"^3\",8695,\"^;\",23,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$comp\",\"~$tree\",\"~$k\",\"~$found\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/tree-map-remove\",\"^:\",\"cljs/core.cljs\",\"^;\",23,\"^13\",[\"^6\",[[\"^39\",\"^3:\",\"~$k\",\"^3;\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",8695,\"^17\",[\"^D\",[null,\"^1@\",\"^1I\"]],\"^3\",8695,\"^19\",4,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^39\",\"^3:\",\"~$k\",\"^3;\"]]]]]],\"~$PersistentQueueIter\",[\"^ \",\"^2;\",2,\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"~$cljs.core/PersistentQueueIter\",\"^:\",\"cljs/core.cljs\",\"^;\",29,\"^2?\",true,\"^<\",10,\"^=\",6173,\"^2@\",false,\"^3\",6173,\"^A\",\"^2A\",\"^2B\",null],\"~$HashCollisionNode\",[\"^ \",\"^2;\",4,\"^2<\",[\"^D\",[\"^2=\",\"~$cljs.core/IIterable\"]],\"^8\",\"~$cljs.core/HashCollisionNode\",\"^:\",\"cljs/core.cljs\",\"^;\",27,\"^2?\",true,\"^<\",10,\"^=\",7571,\"^2@\",false,\"^3\",7571,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^3@\"]]],\"~$array?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",234,\"^<\",16,\"^3\",234,\"^;\",22,\"^A\",\"^18\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is a JavaScript array.\"],\"^8\",\"~$cljs.core/array?\",\"^:\",\"cljs/core.cljs\",\"^;\",22,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",234,\"^17\",\"^18\",\"^3\",234,\"^19\",1,\"^A\",\"^18\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is a JavaScript array.\"],\"~$prefers*\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10961,\"^<\",8,\"^3\",10961,\"^;\",16,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$y\",\"~$prefer-table\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/prefers*\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^13\",[\"^6\",[[\"~$x\",\"~$y\",\"^3E\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10961,\"^17\",[\"^D\",[\"^18\",\"^1I\"]],\"^3\",10961,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$y\",\"^3E\"]]]]]],\"~$simple-ident?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3364,\"^<\",7,\"^3\",3364,\"^;\",20,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Return true if x is a symbol or keyword without a namespace\"],\"^8\",\"~$cljs.core/simple-ident?\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3364,\"^17\",\"^18\",\"^3\",3364,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Return true if x is a symbol or keyword without a namespace\"],\"~$clone\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1195,\"^<\",7,\"^3\",1195,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$value\"]]]]],\"^4\",\"Clone the supplied value which must implement ICloneable.\"],\"^8\",\"~$cljs.core/clone\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"^3J\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1195,\"^17\",\"^1@\",\"^3\",1195,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^3J\"]]]]],\"^4\",\"Clone the supplied value which must implement ICloneable.\"],\"~$scan-array\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",6348,\"^<\",8,\"^3\",6348,\"^;\",18,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$incr\",\"~$k\",\"^2U\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/scan-array\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^13\",[\"^6\",[[\"^3M\",\"~$k\",\"^2U\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",6348,\"^17\",[\"^D\",[\"^1R\",\"^1I\"]],\"^3\",6348,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^3M\",\"~$k\",\"^2U\"]]]]]],\"~$demunge\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",11517,\"^<\",7,\"^3\",11517,\"^;\",14,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$name\"]]]]]],\"^8\",\"~$cljs.core/demunge\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^13\",[\"^6\",[[\"^3P\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",11517,\"^17\",\"^B\",\"^3\",11517,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^3P\"]]]]]],\"~$bit-not\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2881,\"^<\",7,\"^3\",2881,\"^;\",14,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Bitwise complement\"],\"^8\",\"~$cljs.core/bit-not\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2881,\"^17\",\"^1R\",\"^3\",2881,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Bitwise complement\"],\"~$quote-string\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10072,\"^<\",17,\"^3\",10072,\"^;\",29,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$s\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/quote-string\",\"^:\",\"cljs/core.cljs\",\"^;\",29,\"^13\",[\"^6\",[[\"~$s\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10072,\"^17\",\"~$string\",\"^3\",10072,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$s\"]]]]]],\"~$byte\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2695,\"^<\",15,\"^3\",2695,\"^;\",19,\"^A\",\"^1R\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/byte\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2695,\"^17\",\"^1R\",\"^3\",2695,\"^19\",1,\"^A\",\"^1R\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$max\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^10\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"~$more\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^<\",15,\"^=\",2681,\"^3\",2681,\"^A\",\"^1R\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]]]],\"^4\",\"Returns the greatest of the nums.\"],\"^8\",\"~$cljs.core/max\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^10\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^13\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",2,\"^16\",true,\"^A\",[\"^D\",[null,\"^B\"]]]],\"^=\",2681,\"^17\",\"^1R\",\"^3\",2681,\"^19\",2,\"^A\",\"^1R\",\"^1:\",true,\"^10\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]],\"^4\",\"Returns the greatest of the nums.\"],\"~$->Repeat\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^33\",\"^34\",\"~$cljs.core/ICollection\",\"^2=\",\"~$cljs.core/IPending\",\"~$cljs.core/IEmptyableCollection\",\"^1Y\",\"~$cljs.core/INext\",\"~$cljs.core/ISeqable\",\"~$cljs.core/IMeta\",\"~$cljs.core/ISequential\",\"~$cljs.core/IWithMeta\",\"~$cljs.core/IReduce\"]],\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^<\",10,\"~:factory\",\"~:positional\",\"^=\",4903,\"^3\",4903,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"~$count\",\"~$val\",\"~$next\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^42\",\"^43\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/Repeat.\"],\"^2<\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^2=\",\"^42\",\"^43\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^8\",\"~$cljs.core/->Repeat\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^13\",[\"^6\",[[\"^2W\",\"^4<\",\"^4=\",\"^4>\",\"^2Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",4903,\"^17\",\"~$cljs.core/Repeat\",\"^3\",4903,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"^4<\",\"^4=\",\"^4>\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^42\",\"^43\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/Repeat.\"],\"~$IComparable\",[\"^ \",\"^[\",[\"^ \",\"^7\",true,\"^:\",\"cljs/core.cljs\",\"^;\",25,\"^<\",14,\"^=\",816,\"^>\",[\"^ \",\"^?\",[\"^ \",\"~$-compare\",[[\"~$x\",\"~$y\"]]]],\"^3\",816,\"^4\",\"Protocol for values that can be compared.\",\"^5\",[\"^6\",[\"@interface\"]]],\"^7\",true,\"^8\",\"~$cljs.core/IComparable\",\"^:\",\"cljs/core.cljs\",\"^;\",25,\"^<\",1,\"^=\",816,\"^>\",[\"^ \",\"^?\",[\"^ \",\"^4B\",[[\"~$x\",\"~$y\"]]]],\"^@\",null,\"^3\",816,\"^A\",\"^B\",\"^C\",[\"^D\",[\"~$js/Date\",\"^J\",\"^K\",\"^L\",\"^M\",\"^P\",\"^V\",\"~$cljs.core/UUID\",\"^X\"]],\"^4\",\"Protocol for values that can be compared.\",\"^5\",[\"^6\",[\"@interface\"]]],\"~$==\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^10\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^<\",16,\"^=\",2918,\"^3\",2918,\"^A\",\"^18\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]]]],\"^4\",\"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"],\"^8\",\"~$cljs.core/==\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^10\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^13\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^18\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^18\"],[\"^ \",\"^1>\",2,\"^16\",true,\"^A\",\"^18\"]],\"^=\",2918,\"^17\",\"^18\",\"^3\",2918,\"^19\",2,\"^A\",\"^18\",\"^1:\",true,\"^10\",[\"^6\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$&\",\"^3Z\"]]],\"^4\",\"Returns non-nil if nums all have the equivalent\\n  value, otherwise false. Behavior on non nums is\\n  undefined.\"],\"~$parents\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10876,\"^<\",7,\"^3\",10876,\"^;\",14,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]]]],\"^4\",\"Returns the immediate parents of tag, either via a JavaScript type\\n  inheritance relationship or a relationship established via derive. h\\n  must be a hierarchy obtained from make-hierarchy, if not supplied\\n  defaults to the global hierarchy\",\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]],\"^10\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/parents\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]],\"^10\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",[\"^D\",[null,\"^1I\"]]]],\"^=\",10876,\"^3\",10876,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"^1F\"],[\"~$h\",\"^1F\"]]],\"^4\",\"Returns the immediate parents of tag, either via a JavaScript type\\n  inheritance relationship or a relationship established via derive. h\\n  must be a hierarchy obtained from make-hierarchy, if not supplied\\n  defaults to the global hierarchy\"],\"^4<\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1814,\"^<\",7,\"^3\",1814,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"],\"^8\",\"~$cljs.core/count\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1814,\"^17\",\"^1R\",\"^3\",1814,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns the number of items in the collection. (count nil) returns\\n  0.  Also works on strings, arrays, and Maps\"],\"~$-disjoin!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"~$cljs.core/ITransientSet\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^<\",9,\"^=\",813,\"^3\",813,\"^A\",\"^1@\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$tcoll\",\"~$v\"]]]]],\"^4\",\"Returns tcoll without v.\"],\"^1T\",\"^4L\",\"^8\",\"~$cljs.core/-disjoin!\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^13\",[\"^6\",[[\"^4M\",\"~$v\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",811,\"^17\",\"^1@\",\"^3\",813,\"^19\",2,\"^A\",\"^1@\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"~$v\"]]]]],\"^4\",\"Returns tcoll without v.\"],\"~$*loaded-libs*\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",174,\"^<\",3,\"^3\",174,\"^;\",16,\"^1B\",true,\"^5\",[\"@type {*}\"]],\"^8\",\"~$cljs.core/*loaded-libs*\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^<\",1,\"^1B\",true,\"^=\",171,\"^3\",174,\"^A\",\"^1I\",\"^5\",[\"@type {*}\"]],\"~$EMPTY\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4107,\"^<\",16,\"^3\",4107,\"^;\",21,\"^1K\",true],\"^1K\",true,\"^8\",\"~$cljs.core/EMPTY\",\"^:\",\"cljs/core.cljs\",\"^;\",21,\"^<\",1,\"^=\",4107,\"^3\",4107,\"^A\",\"~$cljs.core/Empty\"],\"~$->TransientHashMap\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^9\",\"~$cljs.core/ITransientMap\",\"^2=\",\"~$cljs.core/ICounted\",\"~$cljs.core/ITransientCollection\",\"~$cljs.core/ITransientAssociative\",\"~$cljs.core/ILookup\"]],\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^<\",10,\"^4:\",\"^4;\",\"^=\",8032,\"^3\",8032,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$edit\",\"~$root\",\"^4<\",\"~$has-nil?\",\"~$nil-val\"]]]]],\"^2B\",[\"^D\",[\"^9\",\"^4U\",\"^4V\",\"^4W\",\"^4X\",\"^4Y\"]],\"^4\",\"Positional factory function for cljs.core/TransientHashMap.\"],\"^2<\",[\"^D\",[\"^9\",\"^4U\",\"^2=\",\"^4V\",\"^4W\",\"^4X\",\"^4Y\"]],\"^8\",\"~$cljs.core/->TransientHashMap\",\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^13\",[\"^6\",[[\"^4Z\",\"^4[\",\"^4<\",\"^50\",\"^51\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",8032,\"^17\",\"^O\",\"^3\",8032,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4Z\",\"^4[\",\"^4<\",\"^50\",\"^51\"]]]]],\"^2B\",[\"^D\",[\"^9\",\"^4U\",\"^4V\",\"^4W\",\"^4X\",\"^4Y\"]],\"^4\",\"Positional factory function for cljs.core/TransientHashMap.\"],\"~$array-index-of-symbol?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",6572,\"^<\",8,\"^3\",6572,\"^;\",30,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$arr\",\"~$k\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/array-index-of-symbol?\",\"^:\",\"cljs/core.cljs\",\"^;\",30,\"^13\",[\"^6\",[[\"^54\",\"~$k\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",6572,\"^17\",\"^1R\",\"^3\",6572,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^54\",\"~$k\"]]]]]],\"~$ArrayChunk\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3493,\"^<\",10,\"^3\",3493,\"^;\",20,\"~:declared\",true],\"^2;\",3,\"^2<\",[\"^D\",[\"~$cljs.core/IIndexed\",\"^4V\",\"~$cljs.core/IChunk\",\"^49\"]],\"^8\",\"~$cljs.core/ArrayChunk\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^2?\",true,\"^<\",10,\"^=\",3512,\"^2@\",false,\"^57\",true,\"^3\",3512,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^58\",\"^4V\",\"^49\"]]],\"~$sorted-map-by\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",8923,\"^<\",7,\"^3\",8923,\"^;\",20,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$comparator\",\"~$&\",\"^1<\"]]]]],\"^4\",\"keyval => key val\\n  Returns a new sorted map with supplied mappings, using the supplied comparator.\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",1,\"^19\",1,\"^13\",[[\"^6\",[\"^5<\",\"^1<\"]]],\"^10\",[\"^6\",[[\"^5<\",\"~$&\",\"^1<\"]]],\"^15\",[\"^6\",[null]]]],\"^8\",\"~$cljs.core/sorted-map-by\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",1,\"^19\",1,\"^13\",[[\"^6\",[\"^5<\",\"^1<\"]]],\"^10\",[\"^6\",[[\"^5<\",\"~$&\",\"^1<\"]]],\"^15\",[\"^6\",[null]]],\"^13\",[[\"^6\",[\"^5<\",\"^1<\"]]],\"^14\",null,\"^1>\",1,\"^15\",[\"^6\",[null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",true,\"^A\",\"^B\"]],\"^=\",8923,\"^17\",\"^B\",\"^3\",8923,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[[\"^5<\",\"~$&\",\"^1<\"]]],\"^4\",\"keyval => key val\\n  Returns a new sorted map with supplied mappings, using the supplied comparator.\"],\"~$apply\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3922,\"^<\",7,\"^3\",3922,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$f\",\"~$args\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"],[\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^5?\"]]]]],\"^4\",\"Applies fn f to the argument list formed by prepending intervening arguments to args.\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",5,\"^19\",5,\"^13\",[\"^6\",[[\"~$f\",\"^5?\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"]]],\"^10\",[\"^6\",[[\"~$f\",\"^5?\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"],[\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^5?\"]]],\"^15\",[\"^6\",[null,null,null,null,null]]]],\"^8\",\"~$cljs.core/apply\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",5,\"^19\",5,\"^13\",[\"^6\",[[\"~$f\",\"^5?\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"]]],\"^10\",[\"^6\",[[\"~$f\",\"^5?\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"],[\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^5?\"]]],\"^15\",[\"^6\",[null,null,null,null,null]]],\"^13\",[\"^6\",[[\"~$f\",\"^5?\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"]]],\"^14\",null,\"^1>\",5,\"^15\",[\"^6\",[null,null,null,null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",4,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",5,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",5,\"^16\",true,\"^A\",\"^B\"]],\"^=\",3922,\"^3\",3922,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[[\"~$f\",\"^5?\"],[\"~$f\",\"~$x\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"^5?\"],[\"~$f\",\"~$x\",\"~$y\",\"~$z\",\"^5?\"],[\"~$f\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$&\",\"^5?\"]]],\"^4\",\"Applies fn f to the argument list formed by prepending intervening arguments to args.\"],\"~$get-global-hierarchy\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10848,\"^<\",8,\"^3\",10848,\"^;\",28,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/get-global-hierarchy\",\"^:\",\"cljs/core.cljs\",\"^;\",28,\"^13\",[\"^6\",[[]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10848,\"^17\",\"^1I\",\"^3\",10848,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]]],\"~$add-to-string-hash-cache\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",970,\"^<\",7,\"^3\",970,\"^;\",31,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$k\"]]]]]],\"^8\",\"~$cljs.core/add-to-string-hash-cache\",\"^:\",\"cljs/core.cljs\",\"^;\",31,\"^13\",[\"^6\",[[\"~$k\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",970,\"^17\",\"^1R\",\"^3\",970,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$k\"]]]]]],\"~$clj->js\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10713,\"^<\",7,\"^3\",10713,\"^;\",14,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$&\",[\"^ \",\"~:keys\",[\"~$keyword-fn\"],\"~:or\",[\"^ \",\"^5G\",\"^3P\"],\"~:as\",\"~$options\"]]]]]],\"^4\",\"Recursively transforms ClojureScript values to JavaScript.\\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\\n  Options is a key-value pair, where the only valid key is\\n  :keyword-fn, which should point to a single-argument function to be\\n  called on keyword keys. Default to `name`.\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",1,\"^19\",1,\"^13\",[[\"^6\",[\"~$x\",[\"^ \",\"^5F\",[\"^5G\"],\"^5H\",[\"^ \",\"^5G\",\"^3P\"],\"^5I\",\"^5J\"]]]],\"^10\",[\"^6\",[[\"~$x\",\"~$&\",[\"^ \",\"^5F\",[\"^5G\"],\"^5H\",[\"^ \",\"^5G\",\"^3P\"],\"^5I\",\"^5J\"]]]],\"^15\",[\"^6\",[null]]]],\"^8\",\"~$cljs.core/clj->js\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",1,\"^19\",1,\"^13\",[[\"^6\",[\"~$x\",[\"^ \",\"^5F\",[\"^5G\"],\"^5H\",[\"^ \",\"^5G\",\"^3P\"],\"^5I\",\"^5J\"]]]],\"^10\",[\"^6\",[[\"~$x\",\"~$&\",[\"^ \",\"^5F\",[\"^5G\"],\"^5H\",[\"^ \",\"^5G\",\"^3P\"],\"^5I\",\"^5J\"]]]],\"^15\",[\"^6\",[null]]],\"^13\",[[\"^6\",[\"~$x\",[\"^ \",\"^5F\",[\"^5G\"],\"^5H\",[\"^ \",\"^5G\",\"^3P\"],\"^5I\",\"^5J\"]]]],\"^14\",null,\"^1>\",1,\"^15\",[\"^6\",[null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",true]],\"^=\",10713,\"^17\",\"^B\",\"^3\",10713,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[[\"~$x\",\"~$&\",[\"^ \",\"^5F\",[\"^5G\"],\"^5H\",[\"^ \",\"^5G\",\"^3P\"],\"^5I\",\"^5J\"]]]],\"^4\",\"Recursively transforms ClojureScript values to JavaScript.\\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\\n  Options is a key-value pair, where the only valid key is\\n  :keyword-fn, which should point to a single-argument function to be\\n  called on keyword keys. Default to `name`.\"],\"~$TransientArrayMap\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",6629,\"^<\",10,\"^3\",6629,\"^;\",27,\"^57\",true],\"^2;\",3,\"^2<\",[\"^D\",[\"^9\",\"^4U\",\"^4V\",\"^4W\",\"^4X\",\"^4Y\"]],\"^8\",\"^Q\",\"^:\",\"cljs/core.cljs\",\"^;\",27,\"^2?\",true,\"^<\",10,\"^=\",7034,\"^2@\",false,\"^57\",true,\"^3\",7034,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^9\",\"^4U\",\"^4V\",\"^4W\",\"^4X\",\"^4Y\"]]],\"~$->TransientVector\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^58\",\"^9\",\"^4V\",\"^4W\",\"~$cljs.core/ITransientVector\",\"^4X\",\"^4Y\"]],\"^:\",\"cljs/core.cljs\",\"^;\",25,\"^<\",10,\"^4:\",\"^4;\",\"^=\",6040,\"^3\",6040,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$cnt\",\"~$shift\",\"^4[\",\"~$tail\"]]]]],\"^2B\",[\"^D\",[\"^58\",\"^9\",\"^4V\",\"^4W\",\"^5N\",\"^4X\",\"^4Y\"]],\"^4\",\"Positional factory function for cljs.core/TransientVector.\"],\"^2<\",[\"^D\",[\"^58\",\"^9\",\"^4V\",\"^4W\",\"^5N\",\"^4X\",\"^4Y\"]],\"^8\",\"~$cljs.core/->TransientVector\",\"^:\",\"cljs/core.cljs\",\"^;\",25,\"^13\",[\"^6\",[[\"^5O\",\"^5P\",\"^4[\",\"^5Q\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",6040,\"^17\",\"^H\",\"^3\",6040,\"^19\",4,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^5O\",\"^5P\",\"^4[\",\"^5Q\"]]]]],\"^2B\",[\"^D\",[\"^58\",\"^9\",\"^4V\",\"^4W\",\"^5N\",\"^4X\",\"^4Y\"]],\"^4\",\"Positional factory function for cljs.core/TransientVector.\"],\"~$IChunkedNext\",[\"^ \",\"^[\",[\"^ \",\"^7\",true,\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^<\",14,\"^=\",834,\"^>\",[\"^ \",\"^?\",[\"^ \",\"~$-chunked-next\",[[\"^1Z\"]]]],\"^3\",834,\"^4\",\"Protocol for accessing the chunks of a collection.\",\"^5\",[\"^6\",[\"@interface\"]]],\"^7\",true,\"^8\",\"~$cljs.core/IChunkedNext\",\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^<\",1,\"^=\",834,\"^>\",[\"^ \",\"^?\",[\"^ \",\"^5T\",[[\"^1Z\"]]]],\"^@\",null,\"^3\",834,\"^A\",\"^B\",\"^C\",[\"^D\",[\"~$cljs.core/ChunkedSeq\",\"~$cljs.core/ChunkedCons\",\"~$cljs.core/Range\"]],\"^4\",\"Protocol for accessing the chunks of a collection.\",\"^5\",[\"^6\",[\"@interface\"]]],\"~$interpose\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",5101,\"^<\",7,\"^3\",5101,\"^;\",16,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$sep\"],[\"^5Z\",\"^1Z\"]]]]],\"^4\",\"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\",\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^5Z\"],[\"^5Z\",\"^1Z\"]]],\"^10\",[\"^6\",[[\"^5Z\"],[\"^5Z\",\"^1Z\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/interpose\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^5Z\"],[\"^5Z\",\"^1Z\"]]],\"^10\",[\"^6\",[[\"^5Z\"],[\"^5Z\",\"^1Z\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^5Z\"],[\"^5Z\",\"^1Z\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^2A\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"~$cljs.core/LazySeq\"]],\"^=\",5101,\"^3\",5101,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"^5Z\"],[\"^5Z\",\"^1Z\"]]],\"^4\",\"Returns a lazy seq of the elements of coll separated by sep.\\n  Returns a stateful transducer when no collection is provided.\"],\"~$TransformerIterator\",[\"^ \",\"^2;\",6,\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"~$cljs.core/TransformerIterator\",\"^:\",\"cljs/core.cljs\",\"^;\",29,\"^2?\",true,\"^<\",10,\"^=\",4136,\"^2@\",false,\"^3\",4136,\"^A\",\"^2A\",\"^2B\",null],\"~$->BlackNode\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^58\",\"~$cljs.core/IVector\",\"~$cljs.core/IReversible\",\"^33\",\"^34\",\"^9\",\"^41\",\"^2=\",\"~$cljs.core/IFind\",\"^43\",\"^4V\",\"^45\",\"^46\",\"~$cljs.core/IStack\",\"~$cljs.core/IMapEntry\",\"^47\",\"^48\",\"~$cljs.core/IAssociative\",\"^4Y\",\"^49\"]],\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^<\",10,\"^4:\",\"^4;\",\"^=\",8330,\"^3\",8330,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$key\",\"^4=\",\"~$left\",\"~$right\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^58\",\"^64\",\"^65\",\"^33\",\"^34\",\"^9\",\"^41\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^67\",\"^68\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/BlackNode.\"],\"^2<\",[\"^D\",[\"^58\",\"^64\",\"^65\",\"^33\",\"^34\",\"^9\",\"^41\",\"^2=\",\"^66\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^67\",\"^68\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^8\",\"~$cljs.core/->BlackNode\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^13\",[\"^6\",[[\"^6:\",\"^4=\",\"^6;\",\"^6<\",\"^2Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",8330,\"^17\",\"^K\",\"^3\",8330,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6:\",\"^4=\",\"^6;\",\"^6<\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^58\",\"^64\",\"^65\",\"^33\",\"^34\",\"^9\",\"^41\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^67\",\"^68\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/BlackNode.\"],\"~$deref\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1446,\"^<\",7,\"^3\",1446,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\"]]]]],\"^4\",\"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"],\"^8\",\"~$cljs.core/deref\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"~$o\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1446,\"^17\",\"^B\",\"^3\",1446,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\"]]]]],\"^4\",\"Also reader macro: @var/@atom/@delay. Returns the\\n   most-recently-committed value of ref. When applied to a var\\n   or atom, returns its current state. When applied to a delay, forces\\n   it if not already forced. See also - realized?.\"],\"~$pv-aget\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",5348,\"^<\",8,\"^3\",5348,\"^;\",15,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$node\",\"~$idx\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/pv-aget\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^13\",[\"^6\",[[\"^6A\",\"^6B\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",5348,\"^17\",\"^B\",\"^3\",5348,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6A\",\"^6B\"]]]]]],\"~$assoc\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1979,\"^<\",7,\"^3\",1979,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"],[\"^1Z\",\"~$k\",\"~$v\",\"~$&\",\"~$kvs\"]]]]],\"^4\",\"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"]]],\"^10\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"],[\"^1Z\",\"~$k\",\"~$v\",\"~$&\",\"^6E\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/assoc\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"]]],\"^10\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"],[\"^1Z\",\"~$k\",\"~$v\",\"~$&\",\"^6E\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"]]],\"^14\",null,\"^1>\",3,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",[\"^D\",[\"^1@\",\"^B\"]]],[\"^ \",\"^1>\",3,\"^16\",true,\"^A\",[\"^D\",[\"^1@\",\"^B\"]]]],\"^=\",1979,\"^3\",1979,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[[\"^1Z\",\"~$k\",\"~$v\"],[\"^1Z\",\"~$k\",\"~$v\",\"~$&\",\"^6E\"]]],\"^4\",\"assoc[iate]. When applied to a map, returns a new map of the\\n   same (hashed/sorted) type, that contains the mapping of key(s) to\\n   val(s). When applied to a vector, returns a new vector that\\n   contains val at index.\"],\"~$transient\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3809,\"^<\",7,\"^3\",3809,\"^;\",16,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns a new, transient version of the collection, in constant time.\"],\"^8\",\"~$cljs.core/transient\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3809,\"^17\",\"^1@\",\"^3\",3809,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns a new, transient version of the collection, in constant time.\"],\"~$-disjoin\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"~$cljs.core/ISet\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^<\",9,\"^=\",653,\"^3\",653,\"^A\",\"^1@\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\",\"~$v\"]]]]],\"^4\",\"Returns a new collection of coll that does not contain v.\"],\"^1T\",\"^6J\",\"^8\",\"~$cljs.core/-disjoin\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"^1Z\",\"~$v\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",651,\"^17\",\"^1@\",\"^3\",653,\"^19\",2,\"^A\",\"^1@\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\",\"~$v\"]]]]],\"^4\",\"Returns a new collection of coll that does not contain v.\"],\"~$chunk-cons\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3617,\"^<\",7,\"^3\",3617,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$chunk\",\"^2\"]]]]]],\"^8\",\"~$cljs.core/chunk-cons\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"^6M\",\"^2\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3617,\"^17\",[\"^D\",[null,\"^5W\"]],\"^3\",3617,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6M\",\"^2\"]]]]]],\"~$ArrayIter\",[\"^ \",\"^2;\",2,\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"~$cljs.core/ArrayIter\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^2?\",true,\"^<\",10,\"^=\",4018,\"^2@\",false,\"^3\",4018,\"^A\",\"^2A\",\"^2B\",null],\"^5<\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",11367,\"^<\",7,\"^3\",11367,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$pred\"]]]]],\"^4\",\"Returns an JavaScript compatible comparator based upon pred.\"],\"^8\",\"~$cljs.core/comparator\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"^6Q\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",11367,\"^17\",\"^2A\",\"^3\",11367,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6Q\"]]]]],\"^4\",\"Returns an JavaScript compatible comparator based upon pred.\"],\"~$print-prefix-map\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10300,\"^<\",7,\"^3\",10300,\"^;\",23,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$prefix\",\"~$m\",\"~$print-one\",\"^25\",\"^26\"]]]]]],\"^8\",\"~$cljs.core/print-prefix-map\",\"^:\",\"cljs/core.cljs\",\"^;\",23,\"^13\",[\"^6\",[[\"^6T\",\"~$m\",\"^6U\",\"^25\",\"^26\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10300,\"^17\",\"^B\",\"^3\",10300,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6T\",\"~$m\",\"^6U\",\"^25\",\"^26\"]]]]]],\"~$sorted-map\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",8914,\"^<\",7,\"^3\",8914,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$&\",\"^1<\"]]]]],\"^4\",\"keyval => key val\\n  Returns a new sorted map with supplied mappings.\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",0,\"^19\",0,\"^13\",[[\"^6\",[\"^1<\"]]],\"^10\",[\"^6\",[[\"~$&\",\"^1<\"]]],\"^15\",[\"^6\",[null]]]],\"^8\",\"~$cljs.core/sorted-map\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",0,\"^19\",0,\"^13\",[[\"^6\",[\"^1<\"]]],\"^10\",[\"^6\",[[\"~$&\",\"^1<\"]]],\"^15\",[\"^6\",[null]]],\"^13\",[[\"^6\",[\"^1<\"]]],\"^14\",null,\"^1>\",0,\"^15\",[\"^6\",[null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",0,\"^16\",true,\"^A\",\"^B\"]],\"^=\",8914,\"^17\",\"^B\",\"^3\",8914,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[[\"~$&\",\"^1<\"]]],\"^4\",\"keyval => key val\\n  Returns a new sorted map with supplied mappings.\"],\"~$drop-while\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4806,\"^<\",7,\"^3\",4806,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]]]],\"^4\",\"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\",\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]],\"^10\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/drop-while\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]],\"^10\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^2A\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^60\"]],\"^=\",4806,\"^3\",4806,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"^6Q\"],[\"^6Q\",\"^1Z\"]]],\"^4\",\"Returns a lazy sequence of the items in coll starting from the\\n  first item for which (pred item) returns logical false.  Returns a\\n  stateful transducer when no collection is provided.\"],\"~$IWriter\",[\"^ \",\"^[\",[\"^ \",\"^7\",true,\"^:\",\"cljs/core.cljs\",\"^;\",21,\"^<\",14,\"^=\",750,\"^>\",[\"^ \",\"^?\",[\"^ \",\"~$-write\",[[\"^25\",\"~$s\"]],\"~$-flush\",[[\"^25\"]]]],\"^3\",750,\"^4\",\"Protocol for writing. Currently only implemented by StringBufferWriter.\",\"^5\",[\"^6\",[\"@interface\"]]],\"^7\",true,\"^8\",\"~$cljs.core/IWriter\",\"^:\",\"cljs/core.cljs\",\"^;\",21,\"^<\",1,\"^=\",750,\"^>\",[\"^ \",\"^?\",[\"^ \",\"^70\",[[\"^25\",\"~$s\"]],\"^71\",[[\"^25\"]]]],\"^@\",null,\"^3\",750,\"^A\",\"^B\",\"^C\",[\"^D\",[\"~$cljs.core/StringBufferWriter\"]],\"^4\",\"Protocol for writing. Currently only implemented by StringBufferWriter.\",\"^5\",[\"^6\",[\"@interface\"]]],\"~$KeySeq\",[\"^ \",\"^2;\",2,\"^2<\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^2=\",\"^43\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^8\",\"~$cljs.core/KeySeq\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^2?\",true,\"^<\",10,\"^=\",8933,\"^2@\",false,\"^3\",8933,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^43\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]]],\"~$realized?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10574,\"^<\",16,\"^3\",10574,\"^;\",25,\"^A\",\"^18\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if a value has been produced for a delay or lazy sequence.\"],\"^8\",\"~$cljs.core/realized?\",\"^:\",\"cljs/core.cljs\",\"^;\",25,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10574,\"^17\",\"^18\",\"^3\",10574,\"^19\",1,\"^A\",\"^18\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if a value has been produced for a delay or lazy sequence.\"],\"~$*print-fn*\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",69,\"^<\",3,\"^3\",69,\"^;\",13,\"^4\",\"Each runtime environment provides a different way to print output.\\n  Whatever function *print-fn* is bound to will be passed any\\n  Strings which should be printed.\",\"^1B\",true],\"^8\",\"~$cljs.core/*print-fn*\",\"^:\",\"cljs/core.cljs\",\"^;\",13,\"^<\",1,\"^1B\",true,\"^=\",65,\"^3\",69,\"^A\",\"^1I\",\"^4\",\"Each runtime environment provides a different way to print output.\\n  Whatever function *print-fn* is bound to will be passed any\\n  Strings which should be printed.\"],\"~$compare\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2375,\"^<\",15,\"^3\",2375,\"^;\",22,\"^A\",\"^1R\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$y\"]]]]],\"^4\",\"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"],\"^8\",\"~$cljs.core/compare\",\"^:\",\"cljs/core.cljs\",\"^;\",22,\"^13\",[\"^6\",[[\"~$x\",\"~$y\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2375,\"^17\",\"^1R\",\"^3\",2375,\"^19\",2,\"^A\",\"^1R\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$y\"]]]]],\"^4\",\"Comparator. Returns a negative number, zero, or a positive number\\n  when x is logically 'less than', 'equal to', or 'greater than'\\n  y. Uses IComparable if available and google.array.defaultCompare for objects\\n of the same type and special-cases nil to be less than any other object.\"],\"~$complement\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4255,\"^<\",7,\"^3\",4255,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$f\"]]]]],\"^4\",\"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"],\"^8\",\"~$cljs.core/complement\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"~$f\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",4255,\"^17\",\"^2A\",\"^3\",4255,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$f\"]]]]],\"^4\",\"Takes a fn f and returns a fn that takes the same arguments as f,\\n  has the same effects, if any, and returns the opposite truth value.\"],\"~$lookup-sentinel\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2211,\"^<\",16,\"^3\",2211,\"^;\",31,\"^1K\",true],\"^1K\",true,\"^8\",\"~$cljs.core/lookup-sentinel\",\"^:\",\"cljs/core.cljs\",\"^;\",31,\"^<\",1,\"^=\",2211,\"^3\",2211,\"^A\",\"~$object\"],\"~$-assoc!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"^4X\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^<\",9,\"^=\",795,\"^3\",795,\"^A\",\"^1@\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"^6:\",\"^4=\"]]]]],\"^4\",\"Returns a new transient collection of tcoll with a mapping from key to\\n     val added to it.\"],\"^1T\",\"^4X\",\"^8\",\"~$cljs.core/-assoc!\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^13\",[\"^6\",[[\"^4M\",\"^6:\",\"^4=\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",793,\"^17\",\"^1@\",\"^3\",795,\"^19\",3,\"^A\",\"^1@\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"^6:\",\"^4=\"]]]]],\"^4\",\"Returns a new transient collection of tcoll with a mapping from key to\\n     val added to it.\"],\"~$*print-dup*\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",130,\"^<\",3,\"^3\",130,\"^;\",14,\"^1B\",true,\"^4\",\"When set to logical true, objects will be printed in a way that preserves\\n  their type when read in later.\\n\\n  Defaults to false.\"],\"^8\",\"~$cljs.core/*print-dup*\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^<\",1,\"^1B\",true,\"^=\",124,\"^3\",130,\"^A\",\"^18\",\"^4\",\"When set to logical true, objects will be printed in a way that preserves\\n  their type when read in later.\\n\\n  Defaults to false.\"],\"~$string-iter\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4015,\"^<\",7,\"^3\",4015,\"^;\",18,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/string-iter\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",4015,\"^17\",\"~$cljs.core/StringIter\",\"^3\",4015,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$-key->js\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10697,\"^<\",4,\"^3\",10697,\"^;\",12,\"^1T\",\"~$cljs.core/IEncodeJS\",\"^4\",\"Transforms map keys to valid JavaScript keys. Arbitrary keys are\\n  encoded to their string representation via (pr-str x)\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^1T\",\"^7I\",\"^8\",\"~$cljs.core/-key->js\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10695,\"^17\",\"^B\",\"^3\",10697,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Transforms map keys to valid JavaScript keys. Arbitrary keys are\\n  encoded to their string representation via (pr-str x)\"],\"~$IDeref\",[\"^ \",\"^[\",[\"^ \",\"^7\",true,\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^<\",14,\"^=\",671,\"^>\",[\"^ \",\"^?\",[\"^ \",\"~$-deref\",[[\"~$o\"]]]],\"^3\",671,\"^4\",\"Protocol for adding dereference functionality to a reference.\",\"^5\",[\"^6\",[\"@interface\"]]],\"^7\",true,\"^8\",\"~$cljs.core/IDeref\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^<\",1,\"^=\",671,\"^>\",[\"^ \",\"^?\",[\"^ \",\"^7L\",[[\"~$o\"]]]],\"^@\",null,\"^3\",671,\"^A\",\"^B\",\"^C\",[\"^D\",[\"~$cljs.core/Reduced\",\"~$cljs.core/Volatile\",\"~$cljs.core/Delay\",\"^N\",\"~$cljs.core/Atom\"]],\"^4\",\"Protocol for adding dereference functionality to a reference.\",\"^5\",[\"^6\",[\"@interface\"]]],\"~$sequence\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4195,\"^<\",7,\"^3\",4195,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"],[\"~$xform\",\"^1Z\"],[\"^7S\",\"^1Z\",\"~$&\",\"~$colls\"]]]]],\"^4\",\"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^1Z\"],[\"^7S\",\"^1Z\"]]],\"^10\",[\"^6\",[[\"^1Z\"],[\"^7S\",\"^1Z\"],[\"^7S\",\"^1Z\",\"~$&\",\"^7T\"]]],\"^15\",[\"^6\",[null,null,null]]]],\"^8\",\"~$cljs.core/sequence\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^1Z\"],[\"^7S\",\"^1Z\"]]],\"^10\",[\"^6\",[[\"^1Z\"],[\"^7S\",\"^1Z\"],[\"^7S\",\"^1Z\",\"~$&\",\"^7T\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^13\",[\"^6\",[[\"^1Z\"],[\"^7S\",\"^1Z\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",[\"^D\",[\"~$seq\",\"~$cljs.core/IList\"]]],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^1@\"],[\"^ \",\"^1>\",2,\"^16\",true,\"^A\",\"^1@\"]],\"^=\",4195,\"^3\",4195,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"^1Z\"],[\"^7S\",\"^1Z\"],[\"^7S\",\"^1Z\",\"~$&\",\"^7T\"]]],\"^4\",\"Coerces coll to a (possibly empty) sequence, if it is not already\\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\\n  transducer is supplied, returns a lazy sequence of applications of\\n  the transform to the items in coll(s), i.e. to the set of first\\n  items of each coll, followed by the set of second\\n  items in each coll, until any one of the colls is exhausted.  Any\\n  remaining items in other colls are ignored. The transform should accept\\n  number-of-colls arguments\"],\"~$constantly\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4265,\"^<\",7,\"^3\",4265,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns a function that takes any number of arguments and returns x.\"],\"^8\",\"~$cljs.core/constantly\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",4265,\"^17\",\"^2A\",\"^3\",4265,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns a function that takes any number of arguments and returns x.\"],\"~$->RangedIterator\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^2=\"]],\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^<\",10,\"^4:\",\"^4;\",\"^=\",5440,\"^3\",5440,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$i\",\"~$base\",\"^54\",\"~$v\",\"^2X\",\"^2Y\"]]]]],\"^2B\",null,\"^4\",\"Positional factory function for cljs.core/RangedIterator.\"],\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"~$cljs.core/->RangedIterator\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^13\",[\"^6\",[[\"~$i\",\"^7[\",\"^54\",\"~$v\",\"^2X\",\"^2Y\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",5440,\"^17\",\"^2>\",\"^3\",5440,\"^19\",6,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$i\",\"^7[\",\"^54\",\"~$v\",\"^2X\",\"^2Y\"]]]]],\"^2B\",null,\"^4\",\"Positional factory function for cljs.core/RangedIterator.\"],\"~$chunked-seq\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",5815,\"^<\",7,\"^3\",5815,\"^;\",18,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$vec\",\"~$i\",\"~$off\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]]]],\"^1=\",[\"^ \",\"^16\",false,\"^1>\",5,\"^19\",5,\"^13\",[\"^6\",[[\"^82\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]],\"^10\",[\"^6\",[[\"^82\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]],\"^15\",[\"^6\",[null,null,null]]]],\"^8\",\"~$cljs.core/chunked-seq\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",5,\"^19\",5,\"^13\",[\"^6\",[[\"^82\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]],\"^10\",[\"^6\",[[\"^82\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^13\",[\"^6\",[[\"^82\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]],\"^14\",null,\"^1>\",5,\"^15\",[\"^6\",[null,null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",\"^5V\"],[\"^ \",\"^1>\",4,\"^16\",false,\"^A\",\"^5V\"],[\"^ \",\"^1>\",5,\"^16\",false,\"^A\",\"^5V\"]],\"^=\",5815,\"^3\",5815,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[[\"^82\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\"],[\"^82\",\"^6A\",\"~$i\",\"^83\",\"^2W\"]]]],\"~$ISorted\",[\"^ \",\"^[\",[\"^ \",\"^7\",true,\"^:\",\"cljs/core.cljs\",\"^;\",21,\"^<\",14,\"^=\",733,\"^>\",[\"^ \",\"^?\",[\"^ \",\"~$-sorted-seq\",[[\"^1Z\",\"~$ascending?\"]],\"~$-sorted-seq-from\",[[\"^1Z\",\"~$k\",\"^87\"]],\"~$-entry-key\",[[\"^1Z\",\"~$entry\"]],\"~$-comparator\",[[\"^1Z\"]]]],\"^3\",733,\"^4\",\"Protocol for a collection which can represent their items\\n  in a sorted manner. \",\"^5\",[\"^6\",[\"@interface\"]]],\"^7\",true,\"^8\",\"~$cljs.core/ISorted\",\"^:\",\"cljs/core.cljs\",\"^;\",21,\"^<\",1,\"^=\",733,\"^>\",[\"^ \",\"^?\",[\"^ \",\"^86\",[[\"^1Z\",\"^87\"]],\"^88\",[[\"^1Z\",\"~$k\",\"^87\"]],\"^89\",[[\"^1Z\",\"^8:\"]],\"^8;\",[[\"^1Z\"]]]],\"^@\",null,\"^3\",733,\"^A\",\"^B\",\"^C\",[\"^D\",[\"^T\",\"^U\"]],\"^4\",\"Protocol for a collection which can represent their items\\n  in a sorted manner. \",\"^5\",[\"^6\",[\"@interface\"]]],\"~$make-array\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$size\"],[\"~$type\",\"^8>\"]]],\"^10\",[\"^6\",[[\"^8>\"],[\"^8?\",\"^8>\"],[\"^8?\",\"^8>\",\"~$&\",\"~$more-sizes\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^<\",14,\"^=\",410,\"^3\",410,\"^A\",\"^2U\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^8>\"],[\"^8?\",\"^8>\"],[\"^8?\",\"^8>\",\"~$&\",\"^8@\"]]]]],\"^4\",\"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"],\"^8\",\"~$cljs.core/make-array\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^8>\"],[\"^8?\",\"^8>\"]]],\"^10\",[\"^6\",[[\"^8>\"],[\"^8?\",\"^8>\"],[\"^8?\",\"^8>\",\"~$&\",\"^8@\"]]],\"^15\",[\"^6\",[null,null,null]]],\"^13\",[\"^6\",[[\"^8>\"],[\"^8?\",\"^8>\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^2U\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^2U\"],[\"^ \",\"^1>\",2,\"^16\",true,\"^A\",\"^2U\"]],\"^=\",410,\"^17\",\"^2U\",\"^3\",410,\"^19\",2,\"^A\",\"^2U\",\"^1:\",true,\"^10\",[\"^6\",[[\"^8>\"],[\"^8?\",\"^8>\"],[\"^8?\",\"^8>\",\"~$&\",\"^8@\"]]],\"^4\",\"Construct a JavaScript array of the specified dimensions. Accepts ignored\\n  type argument for compatibility with Clojure. Note that there is no efficient\\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\\n  will run in polynomial time when called with 3 or more arguments.\"],\"~$checked-aget\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",452,\"^<\",8,\"^3\",452,\"^;\",20,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2U\",\"^6B\"],[\"^2U\",\"^6B\",\"~$&\",\"~$idxs\"]]]]],\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^2U\",\"^6B\"]]],\"^10\",[\"^6\",[[\"^2U\",\"^6B\"],[\"^2U\",\"^6B\",\"~$&\",\"^8C\"]]],\"^15\",[\"^6\",[null,null]]]],\"^1K\",true,\"^8\",\"~$cljs.core/checked-aget\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^2U\",\"^6B\"]]],\"^10\",[\"^6\",[[\"^2U\",\"^6B\"],[\"^2U\",\"^6B\",\"~$&\",\"^8C\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^2U\",\"^6B\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",2,\"^16\",true,\"^A\",\"^B\"]],\"^=\",452,\"^3\",452,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"^2U\",\"^6B\"],[\"^2U\",\"^6B\",\"~$&\",\"^8C\"]]]],\"~$shorts\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2819,\"^<\",7,\"^3\",2819,\"^;\",13,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/shorts\",\"^:\",\"cljs/core.cljs\",\"^;\",13,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2819,\"^3\",2819,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$*unchecked-if*\",[\"^ \",\"^8\",\"~$cljs.core/*unchecked-if*\",\"^:\",\"cljs/core.cljs\",\"^=\",26,\"^<\",1,\"^3\",26,\"^;\",20,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",26,\"^<\",6,\"^3\",26,\"^;\",20],\"^A\",\"^18\"],\"~$->RSeq\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^2=\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"~$cljs.core/ICloneable\",\"^47\",\"^48\",\"^49\"]],\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^<\",10,\"^4:\",\"^4;\",\"^=\",1678,\"^3\",1678,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$ci\",\"~$i\",\"^2W\"]]]]],\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^8J\",\"^47\",\"^48\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/RSeq.\"],\"^2<\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^2=\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^8J\",\"^47\",\"^48\",\"^49\"]],\"^8\",\"~$cljs.core/->RSeq\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^13\",[\"^6\",[[\"^8K\",\"~$i\",\"^2W\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",1678,\"^17\",\"~$cljs.core/RSeq\",\"^3\",1678,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^8K\",\"~$i\",\"^2W\"]]]]],\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^8J\",\"^47\",\"^48\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/RSeq.\"],\"~$enable-console-print!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",185,\"^<\",7,\"^3\",185,\"^;\",28,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]],\"^4\",\"Set *print-fn* to console.log\"],\"^8\",\"~$cljs.core/enable-console-print!\",\"^:\",\"cljs/core.cljs\",\"^;\",28,\"^13\",[\"^6\",[[]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",185,\"^17\",\"^1I\",\"^3\",185,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]],\"^4\",\"Set *print-fn* to console.log\"],\"^71\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",754,\"^<\",4,\"^3\",754,\"^;\",10,\"^1T\",\"^72\",\"^4\",\"Flush writer.\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^25\"]]]]]],\"^1T\",\"^72\",\"^8\",\"~$cljs.core/-flush\",\"^:\",\"cljs/core.cljs\",\"^;\",10,\"^13\",[\"^6\",[[\"^25\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",750,\"^17\",\"^B\",\"^3\",754,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^25\"]]]]],\"^4\",\"Flush writer.\"],\"~$-lastIndexOf\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1545,\"^<\",8,\"^3\",1545,\"^;\",20,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]]]],\"^1=\",[\"^ \",\"^16\",false,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]],\"^10\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]],\"^15\",[\"^6\",[null,null]]]],\"^1K\",true,\"^8\",\"~$cljs.core/-lastIndexOf\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]],\"^10\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]],\"^14\",null,\"^1>\",3,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",[\"^D\",[\"^B\",\"^1R\"]]]],\"^=\",1545,\"^3\",1545,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[[\"^1Z\",\"~$x\"],[\"^1Z\",\"~$x\",\"^2X\"]]]],\"~$completing\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2569,\"^<\",7,\"^3\",2569,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$f\"],[\"~$f\",\"~$cf\"]]]]],\"^4\",\"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\",\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$f\"],[\"~$f\",\"^8T\"]]],\"^10\",[\"^6\",[[\"~$f\"],[\"~$f\",\"^8T\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/completing\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$f\"],[\"~$f\",\"^8T\"]]],\"^10\",[\"^6\",[[\"~$f\"],[\"~$f\",\"^8T\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"~$f\"],[\"~$f\",\"^8T\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^2A\"]],\"^=\",2569,\"^3\",2569,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"~$f\"],[\"~$f\",\"^8T\"]]],\"^4\",\"Takes a reducing function f of 2 args and returns a fn suitable for\\n  transduce by adding an arity-1 signature that calls cf (default -\\n  identity) on the result argument.\"],\"~$unchecked-negate-int\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2769,\"^<\",7,\"^3\",2769,\"^;\",27,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/unchecked-negate-int\",\"^:\",\"cljs/core.cljs\",\"^;\",27,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2769,\"^17\",\"^1R\",\"^3\",2769,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$->PersistentVector\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"~$cljs.core/APersistentVector\",\"^58\",\"^64\",\"^65\",\"~$cljs.core/IKVReduce\",\"^33\",\"^34\",\"^9\",\"^41\",\"~$cljs.core/IEditableCollection\",\"^2=\",\"^66\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^8J\",\"^67\",\"^3@\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^<\",10,\"^4:\",\"^4;\",\"^=\",5481,\"^3\",5481,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"^5O\",\"^5P\",\"^4[\",\"^5Q\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^58\",\"^64\",\"^65\",\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^8J\",\"^67\",\"^3@\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/PersistentVector.\"],\"^2<\",[\"^D\",[\"^8Y\",\"^58\",\"^64\",\"^65\",\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^2=\",\"^66\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^8J\",\"^67\",\"^3@\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^8\",\"~$cljs.core/->PersistentVector\",\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^13\",[\"^6\",[[\"^2W\",\"^5O\",\"^5P\",\"^4[\",\"^5Q\",\"^2Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",5481,\"^17\",\"^P\",\"^3\",5481,\"^19\",6,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"^5O\",\"^5P\",\"^4[\",\"^5Q\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^58\",\"^64\",\"^65\",\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^8J\",\"^67\",\"^3@\",\"^47\",\"^48\",\"^69\",\"^4Y\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/PersistentVector.\"],\"~$equiv-sequential\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2978,\"^<\",8,\"^3\",2978,\"^;\",24,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$y\"]]]]],\"^4\",\"Assumes x is sequential. Returns true if x equals y, otherwise\\n  returns false.\"],\"^1K\",true,\"^8\",\"~$cljs.core/equiv-sequential\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^13\",[\"^6\",[[\"~$x\",\"~$y\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2978,\"^17\",\"^18\",\"^3\",2978,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\",\"~$y\"]]]]],\"^4\",\"Assumes x is sequential. Returns true if x equals y, otherwise\\n  returns false.\"],\"~$hash-unordered-coll\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1342,\"^<\",15,\"^3\",1342,\"^;\",34,\"^A\",\"^1R\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"],\"^8\",\"~$cljs.core/hash-unordered-coll\",\"^:\",\"cljs/core.cljs\",\"^;\",34,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1342,\"^17\",\"^1R\",\"^3\",1342,\"^19\",1,\"^A\",\"^1R\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns the hash code, consistent with =, for an external unordered\\n   collection implementing Iterable. For maps, the iterator should\\n   return map entries whose hash is computed as\\n     (hash-ordered-coll [k v]).\\n   See http://clojure.org/data_structures#hash for full algorithms.\"],\"~$repeat\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",5000,\"^<\",7,\"^3\",5000,\"^;\",13,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]]]],\"^4\",\"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\",\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]],\"^10\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]],\"^15\",[\"^6\",[null,null]]]],\"^8\",\"~$cljs.core/repeat\",\"^:\",\"cljs/core.cljs\",\"^;\",13,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]],\"^10\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^4@\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",[\"^D\",[\"^B\",\"^4@\"]]]],\"^=\",5000,\"^3\",5000,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[[\"~$x\"],[\"~$n\",\"~$x\"]]],\"^4\",\"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"],\"~$unchecked-inc\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2746,\"^<\",7,\"^3\",2746,\"^;\",20,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/unchecked-inc\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2746,\"^17\",\"^1R\",\"^3\",2746,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$nthnext\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2946,\"^<\",7,\"^3\",2946,\"^;\",14,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\",\"~$n\"]]]]],\"^4\",\"Returns the nth next of coll, (seq coll) when n is 0.\"],\"^8\",\"~$cljs.core/nthnext\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^13\",[\"^6\",[[\"^1Z\",\"~$n\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2946,\"^17\",\"^7V\",\"^3\",2946,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\",\"~$n\"]]]]],\"^4\",\"Returns the nth next of coll, (seq coll) when n is 0.\"],\"~$preserving-reduced\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10579,\"^<\",8,\"^3\",10579,\"^;\",26,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$rf\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/preserving-reduced\",\"^:\",\"cljs/core.cljs\",\"^;\",26,\"^13\",[\"^6\",[[\"^9<\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",10579,\"^17\",\"^2A\",\"^3\",10579,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^9<\"]]]]]],\"~$get-validator\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4552,\"^<\",7,\"^3\",4552,\"^;\",20,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$iref\"]]]]],\"^4\",\"Gets the validator-fn for a var/ref/agent/atom.\"],\"^8\",\"~$cljs.core/get-validator\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^13\",[\"^6\",[[\"^9?\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",4552,\"^17\",\"^B\",\"^3\",4552,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^9?\"]]]]],\"^4\",\"Gets the validator-fn for a var/ref/agent/atom.\"],\"~$StringIter\",[\"^ \",\"^2;\",2,\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"^7G\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^2?\",true,\"^<\",10,\"^=\",4006,\"^2@\",false,\"^3\",4006,\"^A\",\"^2A\",\"^2B\",null],\"~$number?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",241,\"^<\",16,\"^3\",241,\"^;\",23,\"^A\",\"^18\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is a JavaScript number.\"],\"^8\",\"~$cljs.core/number?\",\"^:\",\"cljs/core.cljs\",\"^;\",23,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",241,\"^17\",\"^18\",\"^3\",241,\"^19\",1,\"^A\",\"^18\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x is a JavaScript number.\"],\"~$-conj!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"^4W\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^<\",9,\"^=\",788,\"^3\",788,\"^A\",\"^1@\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"^4=\"]]]]],\"^4\",\"Adds value val to tcoll and returns tcoll.\"],\"^1T\",\"^4W\",\"^8\",\"~$cljs.core/-conj!\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^13\",[\"^6\",[[\"^4M\",\"^4=\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",786,\"^17\",\"^1@\",\"^3\",788,\"^19\",2,\"^A\",\"^1@\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"^4=\"]]]]],\"^4\",\"Adds value val to tcoll and returns tcoll.\"],\"~$->PersistentArrayMapSeq\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^2=\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^:\",\"cljs/core.cljs\",\"^;\",31,\"^<\",10,\"^4:\",\"^4;\",\"^=\",6731,\"^3\",6731,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^54\",\"~$i\",\"~$_meta\"]]]]],\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/PersistentArrayMapSeq.\"],\"^2<\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^2=\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^8\",\"~$cljs.core/->PersistentArrayMapSeq\",\"^:\",\"cljs/core.cljs\",\"^;\",31,\"^13\",[\"^6\",[[\"^54\",\"~$i\",\"^9G\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",6731,\"^17\",\"~$cljs.core/PersistentArrayMapSeq\",\"^3\",6731,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^54\",\"~$i\",\"^9G\"]]]]],\"^2B\",[\"^D\",[\"^33\",\"^34\",\"^41\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^47\",\"^48\",\"^49\"]],\"^4\",\"Positional factory function for cljs.core/PersistentArrayMapSeq.\"],\"~$chunk-next\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3634,\"^<\",7,\"^3\",3634,\"^;\",17,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$s\"]]]]]],\"^8\",\"~$cljs.core/chunk-next\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"~$s\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3634,\"^17\",[\"^D\",[\"^7V\",\"^B\"]],\"^3\",3634,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$s\"]]]]]],\"~$ArrayList\",[\"^ \",\"^2;\",1,\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"~$cljs.core/ArrayList\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^2?\",true,\"^<\",10,\"^=\",9538,\"^2@\",false,\"^3\",9538,\"^A\",\"^2A\",\"^2B\",null],\"~$print-str\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",10254,\"^<\",7,\"^3\",10254,\"^;\",16,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$&\",\"~$objs\"]]]]],\"^4\",\"print to a string, returning it\",\"^1=\",[\"^ \",\"^16\",true,\"^1>\",0,\"^19\",0,\"^13\",[[\"^6\",[\"^9O\"]]],\"^10\",[\"^6\",[[\"~$&\",\"^9O\"]]],\"^15\",[\"^6\",[null]]]],\"^8\",\"~$cljs.core/print-str\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^1=\",[\"^ \",\"^16\",true,\"^1>\",0,\"^19\",0,\"^13\",[[\"^6\",[\"^9O\"]]],\"^10\",[\"^6\",[[\"~$&\",\"^9O\"]]],\"^15\",[\"^6\",[null]]],\"^13\",[[\"^6\",[\"^9O\"]]],\"^14\",null,\"^1>\",0,\"^15\",[\"^6\",[null]],\"^<\",1,\"^16\",true,\"^?\",[[\"^ \",\"^1>\",0,\"^16\",true,\"^A\",\"^3V\"]],\"^=\",10254,\"^17\",\"^B\",\"^3\",10254,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[[\"~$&\",\"^9O\"]]],\"^4\",\"print to a string, returning it\"],\"~$not-any?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4240,\"^<\",7,\"^3\",4240,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6Q\",\"^1Z\"]]]]],\"^4\",\"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"],\"^8\",\"~$cljs.core/not-any?\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^13\",[\"^6\",[[\"^6Q\",\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",4240,\"^17\",\"^18\",\"^3\",4240,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^6Q\",\"^1Z\"]]]]],\"^4\",\"Returns false if (pred x) is logical true for any x in coll,\\n  else true.\"],\"~$into-array\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"~$aseq\"],[\"^8?\",\"^9T\"]]],\"^10\",[\"^6\",[[\"^9T\"],[\"^8?\",\"^9T\"]]],\"^15\",[\"^6\",[null,null]]],\"^<\",14,\"^=\",518,\"^3\",518,\"^A\",\"^2U\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^9T\"],[\"^8?\",\"^9T\"]]]]],\"^4\",\"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"],\"^8\",\"~$cljs.core/into-array\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",2,\"^19\",2,\"^13\",[\"^6\",[[\"^9T\"],[\"^8?\",\"^9T\"]]],\"^10\",[\"^6\",[[\"^9T\"],[\"^8?\",\"^9T\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"^9T\"],[\"^8?\",\"^9T\"]]],\"^14\",null,\"^1>\",2,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^2U\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",[\"^D\",[null,\"^B\"]]]],\"^=\",518,\"^17\",\"^2U\",\"^3\",518,\"^19\",2,\"^A\",\"^2U\",\"^1:\",true,\"^10\",[\"^6\",[[\"^9T\"],[\"^8?\",\"^9T\"]]],\"^4\",\"Returns an array with components set to the values in aseq. Optional type\\n  argument accepted for compatibility with Clojure.\"],\"~$-hash\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",711,\"^<\",4,\"^3\",711,\"^;\",9,\"^1T\",\"^34\",\"^4\",\"Returns the hash code of o.\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\"]]]]]],\"^1T\",\"^34\",\"^8\",\"~$cljs.core/-hash\",\"^:\",\"cljs/core.cljs\",\"^;\",9,\"^13\",[\"^6\",[[\"~$o\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",709,\"^17\",\"^B\",\"^3\",711,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\"]]]]],\"^4\",\"Returns the hash code of o.\"],\"~$qualified-symbol?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3376,\"^<\",7,\"^3\",3376,\"^;\",24,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Return true if x is a symbol with a namespace\"],\"^8\",\"~$cljs.core/qualified-symbol?\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3376,\"^17\",\"^18\",\"^3\",3376,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Return true if x is a symbol with a namespace\"],\"~$-dissoc!\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"^4U\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^<\",9,\"^=\",801,\"^3\",801,\"^A\",\"^1@\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"^6:\"]]]]],\"^4\",\"Returns a new transient collection of tcoll without the mapping for key.\"],\"^1T\",\"^4U\",\"^8\",\"~$cljs.core/-dissoc!\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"^4M\",\"^6:\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",799,\"^17\",\"^1@\",\"^3\",801,\"^19\",2,\"^A\",\"^1@\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4M\",\"^6:\"]]]]],\"^4\",\"Returns a new transient collection of tcoll without the mapping for key.\"],\"~$->Reduced\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^7M\"]],\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^<\",10,\"^4:\",\"^4;\",\"^=\",1420,\"^3\",1420,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4=\"]]]]],\"^2B\",[\"^D\",[\"^7M\"]],\"^4\",\"Positional factory function for cljs.core/Reduced.\"],\"^2<\",[\"^D\",[\"^7M\"]],\"^8\",\"~$cljs.core/->Reduced\",\"^:\",\"cljs/core.cljs\",\"^;\",17,\"^13\",[\"^6\",[[\"^4=\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",1420,\"^17\",\"^7N\",\"^3\",1420,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^4=\"]]]]],\"^2B\",[\"^D\",[\"^7M\"]],\"^4\",\"Positional factory function for cljs.core/Reduced.\"],\"~$chunk-buffer\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",3509,\"^<\",7,\"^3\",3509,\"^;\",19,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$capacity\"]]]]]],\"^8\",\"~$cljs.core/chunk-buffer\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^13\",[\"^6\",[[\"^:3\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",3509,\"^17\",\"~$cljs.core/ChunkBuffer\",\"^3\",3509,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^:3\"]]]]]],\"~$seqable?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2237,\"^<\",7,\"^3\",2237,\"^;\",15,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$s\"]]]]],\"^4\",\"Return true if the seq function is supported for s\"],\"^8\",\"~$cljs.core/seqable?\",\"^:\",\"cljs/core.cljs\",\"^;\",15,\"^13\",[\"^6\",[[\"~$s\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2237,\"^17\",\"^18\",\"^3\",2237,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$s\"]]]]],\"^4\",\"Return true if the seq function is supported for s\"],\"~$symbol?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1036,\"^<\",16,\"^3\",1036,\"^;\",23,\"^A\",\"^18\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Return true if x is a Symbol\"],\"^8\",\"~$cljs.core/symbol?\",\"^:\",\"cljs/core.cljs\",\"^;\",23,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1036,\"^17\",\"^18\",\"^3\",1036,\"^19\",1,\"^A\",\"^18\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Return true if x is a Symbol\"],\"~$m3-hash-unencoded-chars\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",936,\"^<\",15,\"^3\",936,\"^;\",38,\"^A\",\"^1R\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$in\"]]]]]],\"^8\",\"~$cljs.core/m3-hash-unencoded-chars\",\"^:\",\"cljs/core.cljs\",\"^;\",38,\"^13\",[\"^6\",[[\"^:;\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",936,\"^17\",\"^1R\",\"^3\",936,\"^19\",1,\"^A\",\"^1R\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^:;\"]]]]]],\"~$unchecked-char\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2710,\"^<\",15,\"^3\",2710,\"^;\",29,\"^A\",\"^1R\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/unchecked-char\",\"^:\",\"cljs/core.cljs\",\"^;\",29,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2710,\"^17\",\"^1R\",\"^3\",2710,\"^19\",1,\"^A\",\"^1R\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$system-time\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",391,\"^<\",7,\"^3\",391,\"^;\",18,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]],\"^4\",\"Returns highest resolution time offered by host in milliseconds.\"],\"^8\",\"~$cljs.core/system-time\",\"^:\",\"cljs/core.cljs\",\"^;\",18,\"^13\",[\"^6\",[[]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",391,\"^17\",[\"^D\",[\"^1D\",\"^1R\"]],\"^3\",391,\"^19\",0,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[]]]]],\"^4\",\"Returns highest resolution time offered by host in milliseconds.\"],\"~$NeverEquiv\",[\"^ \",\"^2;\",0,\"^2<\",[\"^D\",[\"^33\",\"^2=\"]],\"^8\",\"~$cljs.core/NeverEquiv\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^2?\",true,\"^<\",10,\"^=\",6319,\"^2@\",false,\"^3\",6319,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^33\"]]],\"~$chunkIteratorSeq\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",4125,\"^<\",8,\"^3\",4125,\"^;\",24,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$iter\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/chunkIteratorSeq\",\"^:\",\"cljs/core.cljs\",\"^;\",24,\"^13\",[\"^6\",[[\"^:D\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",4125,\"^17\",\"^60\",\"^3\",4125,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^:D\"]]]]]],\"^0\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"^9\",\"^:\",\"cljs/core.cljs\",\"^;\",11,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",22,\"^19\",22,\"^13\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]],\"^10\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]],\"^15\",[\"^6\",[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]]],\"^<\",4,\"^=\",541,\"^3\",541,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]]]],\"^4\",null],\"^1T\",\"^9\",\"^8\",\"~$cljs.core/-invoke\",\"^:\",\"cljs/core.cljs\",\"^;\",11,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",22,\"^19\",22,\"^13\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]],\"^10\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]],\"^15\",[\"^6\",[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]]],\"^13\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]],\"^14\",null,\"^1>\",22,\"^15\",[\"^6\",[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",1,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",3,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",4,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",5,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",6,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",7,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",8,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",9,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",10,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",11,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",12,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",13,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",14,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",15,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",16,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",17,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",18,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",19,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",20,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",21,\"^16\",false,\"^A\",\"^B\"],[\"^ \",\"^1>\",22,\"^16\",false,\"^A\",\"^B\"]],\"^=\",537,\"^3\",541,\"^19\",22,\"^1:\",true,\"^10\",[\"^6\",[[\"^1\"],[\"^1\",\"~$a\"],[\"^1\",\"~$a\",\"~$b\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\"],[\"^1\",\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$e\",\"~$f\",\"~$g\",\"~$h\",\"~$i\",\"~$j\",\"~$k\",\"~$l\",\"~$m\",\"~$n\",\"~$o\",\"~$p\",\"~$q\",\"~$r\",\"~$s\",\"~$t\",\"^2\"]]],\"^4\",null],\"~$coll?\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2117,\"^<\",7,\"^3\",2117,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x satisfies ICollection\"],\"^8\",\"~$cljs.core/coll?\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2117,\"^17\",\"^18\",\"^3\",2117,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]],\"^4\",\"Returns true if x satisfies ICollection\"],\"~$get-in\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"~:added\",\"1.2\",\"^:\",\"cljs/core.cljs\",\"^;\",13,\"~:static\",true,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"~$m\",\"~$ks\"],[\"~$m\",\"^:L\",\"~$not-found\"]]],\"^10\",[\"^6\",[[\"~$m\",\"^:L\"],[\"~$m\",\"^:L\",\"^:M\"]]],\"^15\",[\"^6\",[null,null]]],\"^<\",7,\"^=\",5270,\"^3\",5270,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$m\",\"^:L\"],[\"~$m\",\"^:L\",\"^:M\"]]]]],\"^4\",\"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"],\"^:J\",\"1.2\",\"^8\",\"~$cljs.core/get-in\",\"^:\",\"cljs/core.cljs\",\"^;\",13,\"^:K\",true,\"^1=\",[\"^ \",\"^16\",false,\"^1>\",3,\"^19\",3,\"^13\",[\"^6\",[[\"~$m\",\"^:L\"],[\"~$m\",\"^:L\",\"^:M\"]]],\"^10\",[\"^6\",[[\"~$m\",\"^:L\"],[\"~$m\",\"^:L\",\"^:M\"]]],\"^15\",[\"^6\",[null,null]]],\"^13\",[\"^6\",[[\"~$m\",\"^:L\"],[\"~$m\",\"^:L\",\"^:M\"]]],\"^14\",null,\"^1>\",3,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^?\",[[\"^ \",\"^1>\",2,\"^16\",false,\"^A\",[\"^D\",[null,\"^B\"]]],[\"^ \",\"^1>\",3,\"^16\",false]],\"^=\",5270,\"^3\",5270,\"^19\",3,\"^1:\",true,\"^10\",[\"^6\",[[\"~$m\",\"^:L\"],[\"~$m\",\"^:L\",\"^:M\"]]],\"^4\",\"Returns the value in a nested associative structure,\\n  where ks is a sequence of keys. Returns nil if the key is not present,\\n  or the not-found value if supplied.\"],\"~$fnext\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1758,\"^<\",7,\"^3\",1758,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Same as (first (next x))\"],\"^8\",\"~$cljs.core/fnext\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1758,\"^17\",[\"^D\",[\"^B\",\"^1I\"]],\"^3\",1758,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Same as (first (next x))\"],\"~$IList\",[\"^ \",\"^[\",[\"^ \",\"^7\",true,\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^<\",14,\"^=\",722,\"^>\",[\"^ \",\"^?\",[\"^ \"]],\"^3\",722,\"^4\",\"Marker interface indicating a persistent list\",\"^5\",[\"^6\",[\"@interface\"]]],\"^7\",true,\"^8\",\"^7W\",\"^:\",\"cljs/core.cljs\",\"^;\",19,\"^<\",1,\"^=\",722,\"^>\",[\"^ \",\"^?\",[\"^ \"]],\"^@\",null,\"^3\",722,\"^A\",\"^B\",\"^C\",[\"^D\",[\"~$cljs.core/Cons\",\"~$cljs.core/EmptyList\",\"~$cljs.core/List\"]],\"^4\",\"Marker interface indicating a persistent list\",\"^5\",[\"^6\",[\"@interface\"]]],\"~$ArrayNodeIterator\",[\"^ \",\"^2;\",3,\"^2<\",[\"^D\",[\"^2=\"]],\"^8\",\"~$cljs.core/ArrayNodeIterator\",\"^:\",\"cljs/core.cljs\",\"^;\",27,\"^2?\",true,\"^<\",10,\"^=\",7441,\"^2@\",false,\"^3\",7441,\"^A\",\"^2A\",\"^2B\",null],\"~$List\",[\"^ \",\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1518,\"^<\",45,\"^3\",1518,\"^;\",49,\"^57\",true],\"^2;\",5,\"^2<\",[\"^D\",[\"^7W\",\"^33\",\"^34\",\"~$cljs.core/ASeq\",\"^41\",\"^2=\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^8J\",\"^67\",\"^47\",\"^48\",\"^49\"]],\"^8\",\"^:T\",\"^:\",\"cljs/core.cljs\",\"^;\",14,\"^2?\",true,\"^<\",10,\"^=\",3036,\"^2@\",false,\"^57\",true,\"^3\",3036,\"^A\",\"^2A\",\"^2B\",[\"^D\",[\"^7W\",\"^33\",\"^34\",\"^:X\",\"^41\",\"^43\",\"^4V\",\"^1Y\",\"^44\",\"^45\",\"^46\",\"^8J\",\"^67\",\"^47\",\"^48\",\"^49\"]]],\"~$-val\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",648,\"^<\",4,\"^3\",648,\"^;\",8,\"^1T\",\"^68\",\"^4\",\"Returns the value of the map entry.\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]]],\"^1T\",\"^68\",\"^8\",\"~$cljs.core/-val\",\"^:\",\"cljs/core.cljs\",\"^;\",8,\"^13\",[\"^6\",[[\"^1Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",644,\"^17\",\"^B\",\"^3\",648,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^1Z\"]]]]],\"^4\",\"Returns the value of the map entry.\"],\"~$bytes\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",2817,\"^<\",7,\"^3\",2817,\"^;\",12,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"^8\",\"~$cljs.core/bytes\",\"^:\",\"cljs/core.cljs\",\"^;\",12,\"^13\",[\"^6\",[[\"~$x\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",2817,\"^3\",2817,\"^19\",1,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$x\"]]]]]],\"~$->ObjMap\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^2<\",[\"^D\",[\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^2=\",\"^66\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^48\",\"^69\",\"~$cljs.core/IMap\",\"^4Y\"]],\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^<\",10,\"^4:\",\"^4;\",\"^=\",6394,\"^3\",6394,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"~$keys\",\"~$strobj\",\"~$update-count\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^48\",\"^69\",\"^;2\",\"^4Y\"]],\"^4\",\"Positional factory function for cljs.core/ObjMap.\"],\"^2<\",[\"^D\",[\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^2=\",\"^66\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^48\",\"^69\",\"^;2\",\"^4Y\"]],\"^8\",\"~$cljs.core/->ObjMap\",\"^:\",\"cljs/core.cljs\",\"^;\",16,\"^13\",[\"^6\",[[\"^2W\",\"^;3\",\"^;4\",\"^;5\",\"^2Z\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^4:\",\"^4;\",\"^=\",6394,\"^17\",\"^G\",\"^3\",6394,\"^19\",5,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"^2W\",\"^;3\",\"^;4\",\"^;5\",\"^2Z\"]]]]],\"^2B\",[\"^D\",[\"^8Z\",\"^33\",\"^34\",\"^9\",\"^41\",\"^8[\",\"^43\",\"^4V\",\"^45\",\"^46\",\"^48\",\"^69\",\"^;2\",\"^4Y\"]],\"^4\",\"Positional factory function for cljs.core/ObjMap.\"],\"~$compare-symbols\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^:\",\"cljs/core.cljs\",\"^=\",1046,\"^<\",8,\"^3\",1046,\"^;\",23,\"^1K\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$a\",\"~$b\"]]]]]],\"^1K\",true,\"^8\",\"~$cljs.core/compare-symbols\",\"^:\",\"cljs/core.cljs\",\"^;\",23,\"^13\",[\"^6\",[[\"~$a\",\"~$b\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",1046,\"^17\",[\"^D\",[\"^B\",\"^1R\"]],\"^3\",1046,\"^19\",2,\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$a\",\"~$b\"]]]]]],\"~$-seq\",[\"^ \",\"^Z\",null,\"^[\",[\"^ \",\"^1T\",\"^45\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^<\",16,\"^=\",716,\"^3\",716,\"^A\",\"~$clj-or-nil\",\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\"]]]]],\"^4\",\"Returns a seq of o, or nil if o is empty.\"],\"^1T\",\"^45\",\"^8\",\"~$cljs.core/-seq\",\"^:\",\"cljs/core.cljs\",\"^;\",20,\"^13\",[\"^6\",[[\"~$o\"]]],\"^14\",null,\"^15\",[\"^6\",[null,null]],\"^<\",1,\"^16\",false,\"^=\",714,\"^17\",\"^;:\",\"^3\",716,\"^19\",1,\"^A\",\"^;:\",\"^1:\",true,\"^10\",[\"^6\",[\"^11\",[\"^6\",[[\"~$o\"]]]]],\"^4\",\"Returns a seq of o, or nil if o is empty.\"]],\"~:cljs.spec/registry-ref\",[],\"~:require-macros\",null,\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^D\",[\"~$form\",\"^1F\",\"~$&\",\"~$uuid\",\"~$case*\",\"^2Y\",\"~$defrecord*\",\"^7[\",\"^24\",\"~$fqn\",\"~$first\",\"~$try\",\"^50\",\"~$rear\",\"~$hierarchy\",\"^:D\",\"~$step\",\"^18\",\"^;5\",\"~$method-table\",\"~:ready\",\"^6M\",\"~$i\",\"^2\",\"^[\",\"~:dup\",\"^39\",\"~$dispatch-fn\",\"~$buffer\",\"~:else\",\"^6;\",\"~$ns*\",\"~:cljs.core/none\",\"^5P\",\"~$iters\",\"^7S\",\"~:validator\",\"~$finally\",\"~:default\",\"^3E\",\"~$loop*\",\"~$watches\",\"~:ns\",\"~:pending\",\"~$bitmap\",\"~$_seq\",\"^51\",\"~$v\",\"~$riter\",\"^2Z\",\"^2W\",\"^9G\",\"~$meta9577\",\"~$afn\",\"^3:\",\"~$fn\",\"~$front\",\"~$buf\",\"~$next-entry\",\"~:val\",\"^6:\",\"~$_next\",\"~$root-iter\",\"~$do\",\"^82\",\"~:fallback-impl\",\"~:keyword-fn\",\"~$meta11185\",\"~:flush-on-newline\",\"~$default-dispatch-val\",\"~:no-test\",\"~$validator\",\"~$letfn*\",\"~$if\",\"^54\",\"~$new\",\"~:descendants\",\"~$ns\",\"~$completed\",\"~:ancestors\",\"^3J\",\"^3P\",\"~:readably\",\"~:more-marker\",\"~$fields\",\"~$method-cache\",\"^4Z\",\"~$editable?\",\"~$base-count\",\"~$collision-hash\",\"~$deftype*\",\"~$let*\",\"^2X\",\"~$sourceIter\",\"^1Z\",\"~$not-native\",\"~$js*\",\"^;4\",\"~$_rest\",\"~$fn*\",\"^4=\",\"^87\",\"~$recur\",\"~$xf\",\"^8K\",\"~:status\",\"~:print-length\",\"~$state\",\"~:ok\",\"~$vals\",\"~$all\",\"~:cljs.core/halt\",\"~$cached-hierarchy\",\"~$s\",\"~:parents\",\"^5O\",\"^6A\",\"~$sym\",\"~$sb\",\"~$seed\",\"~$prev-seed\",\"~$meta1507\",\"~$_hash\",\"^;3\",\"~$set!\",\"^A\",\"~$tree-map\",\"~$.\",\"~$var\",\"~:mutable\",\"^11\",\"^4[\",\"~$multi\",\"~$str\",\"^4>\",\"~$nodes\",\"~$seen\",\"^1;\",\"~$catch\",\"~:alt-impl\",\"~$ext-map-iter\",\"^5Q\",\"~$record\",\"~$mseq\",\"^4<\",\"~:keywordize-keys\",\"~$current\",\"^83\",\"~$stack\",\"~$transient-map\",\"~$prev\",\"^1N\",\"^6<\",\"~$throw\",\"~$fseq\",\"^9J\",\"~:cljs.core/not-found\",\"^3Z\",\"~$def\",\"~$f\",\"~$next-iter\"]],\"~:order\",[\"^<>\",\"^<I\",\"^[\",\"^;L\",\"^<Z\",\"^;O\",\"^=7\",\"^;U\",\"^<F\",\"^3P\",\"^=A\",\"^=;\",\"^=?\",\"^9G\",\"^4=\",\"^=6\",\"~$s\",\"^3J\",\"^:D\",\"^<U\",\"^54\",\"~$i\",\"^2W\",\"^8K\",\"^<2\",\"^;E\",\"^2\",\"^4<\",\"^2Z\",\"^;D\",\"^<3\",\"^<5\",\"^2Y\",\"^83\",\"^6M\",\"^3Z\",\"^<1\",\"^;[\",\"^<8\",\"^=1\",\"^;R\",\"^;N\",\"^<G\",\"^<X\",\"^<R\",\"^=@\",\"^<[\",\"^<A\",\"^;W\",\"^;S\",\"^=2\",\"^=M\",\"^=J\",\"^4>\",\"~$f\",\"^=9\",\"^=8\",\"^4Z\",\"^7[\",\"~$v\",\"^2X\",\"^5O\",\"^5P\",\"^4[\",\"^5Q\",\"^82\",\"^6A\",\"^=O\",\"^<0\",\"^<4\",\"^;G\",\"^;3\",\"^;4\",\"^;5\",\"^=G\",\"^<N\",\"^<K\",\"^=F\",\"^6:\",\"^<M\",\"^1N\",\"^<6\",\"^=R\",\"^;Z\",\"^<O\",\"^=B\",\"^51\",\"^<9\",\"^=C\",\"^50\",\"^A\",\"^18\",\"^=K\",\"^87\",\"^6;\",\"^6<\",\"^39\",\"^3:\",\"^=H\",\"^<S\",\"^=P\",\"^1;\",\"^=L\",\"^==\",\"^;I\",\"^9J\",\"^;Q\",\"^<J\",\"^=E\",\"^<;\",\"^<7\",\"^<Y\",\"^;K\",\"^;Y\",\"^=3\",\"^7S\",\"^1Z\",\"^<<\",\"^=I\",\"^=5\",\"^<E\",\"^<H\",\"^;M\",\"^<?\",\"^;H\",\"^;J\",\"^3E\",\"^<L\",\"^=4\",\"^;A\",\"~$&\",\"^;B\",\"^;C\",\"^;F\",\"^;P\",\"^;T\",\"^;V\",\"^<:\",\"^<B\",\"^<C\",\"^<D\",\"^<P\",\"^<Q\",\"^<T\",\"^<V\",\"^<W\",\"^=<\",\"~$.\",\"^=>\",\"^11\",\"^=D\",\"^=N\",\"^=Q\",\"^=0\",\"^<@\",\"^1F\",\"^;@\",\"^;X\",\"^24\",\"^<=\",\"^=:\"]],\"^4\",null]"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/js.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.js",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.js\n  (:refer-clojure :exclude [require eval])\n  (:require-macros [cljs.js :refer [dump-core]]\n                   [cljs.env.macros :as env])\n  (:require [clojure.string :as string]\n            [clojure.walk :as walk]\n            [cljs.env :as env]\n            [cljs.spec.alpha]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.tools.reader :as r]\n            [cljs.tools.reader.reader-types :as rt]\n            [cljs.tagged-literals :as tags]\n            [goog.crypt.base64 :as base64]\n            [cljs.source-map :as sm])\n  (:import [goog.string StringBuffer]))\n\n(js/goog.require \"cljs.core$macros\")\n\n(defn- debug-prn\n  [& args]\n  (binding [*print-fn* *print-err-fn*]\n    (apply println args)))\n\n(defn ns->relpath\n  \"Given a namespace as a symbol return the relative path sans extension\"\n  [ns-sym]\n  (string/replace (ana/munge-path ns-sym) \\. \\/))\n\n(defn file->ns\n  [file]\n  (let [lib-name (subs (string/replace file \"/\" \".\")\n                   0 (- (count file) 5))]\n    (symbol (demunge lib-name))))\n\n(defn- drop-macros-suffix\n  [ns-name]\n  (when ns-name\n    (if (string/ends-with? ns-name \"$macros\")\n      (subs ns-name 0 (- (count ns-name) 7))\n      ns-name)))\n\n(defn- elide-macros-suffix\n  [sym]\n  (symbol (drop-macros-suffix (namespace sym)) (name sym)))\n\n(defn- resolve-symbol\n  [sym]\n  (if (string/starts-with? (str sym) \".\")\n    sym\n    (elide-macros-suffix (ana/resolve-symbol sym))))\n\n(defn- read [eof rdr]\n  (binding [*ns* (symbol (drop-macros-suffix (str *ns*)))]\n    (r/read {:eof eof :read-cond :allow :features #{:cljs}} rdr)))\n\n(defn- atom? [x]\n  (instance? Atom x))\n\n(defn- valid-name? [x]\n  (or (nil? x) (symbol? x) (string? x)))\n\n(defn- valid-opts? [x]\n  (or (nil? x) (map? x)))\n\n(defonce\n  ^{:doc \"Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil.\"\n    :dynamic true}\n  *load-fn*\n  (fn [m cb]\n    (throw (js/Error. \"No *load-fn* set\"))))\n\n(defonce\n  ^{:doc \"Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value.\"\n    :dynamic true}\n  *eval-fn*\n  (fn [m]\n    (throw (js/Error. \"No *eval-fn* set\"))))\n\n(defn js-eval\n  \"A default JavaScript evaluation function.\"\n  [{:keys [source] :as resource}]\n  (js/eval source))\n\n(defn- wrap-error [ex]\n  {:error ex})\n\n(defn empty-state\n  \"Construct an empty compiler state. Required to invoke analyze, compile,\n   eval and eval-str.\"\n  ([]\n   (doto (env/default-compiler-env)\n     (swap!\n       (fn [state]\n         (-> state\n           (assoc-in [::ana/namespaces 'cljs.core] (dump-core)))))))\n  ([init]\n   (doto (empty-state) (swap! init))))\n\n(defn load-analysis-cache! [state ns cache]\n  (swap! state assoc-in [::ana/namespaces ns] cache))\n\n(defn load-source-map! [state ns sm-json]\n  (let [sm (sm/decode (.parse js/JSON sm-json))]\n    (swap! state assoc-in [:source-maps ns] sm)))\n\n(defn- sm-data []\n  (atom\n    {:source-map (sorted-map)\n     :gen-col    0\n     :gen-line   0}))\n\n(defn- prefix [s pre]\n  (str pre s))\n\n(defn- append-source-map\n  [state name source sb sm-data {:keys [output-dir asset-path source-map-timestamp] :as opts}]\n   (let [t    (.valueOf (js/Date.))\n         mn   (if name\n                (munge (str name))\n                (str \"cljs-\" t))\n         smn  (cond-> mn\n                name (string/replace \".\" \"/\"))\n         ts   (.valueOf (js/Date.))\n         out  (or output-dir asset-path)\n         src  (cond-> (str smn \".cljs\")\n                (true? source-map-timestamp) (str \"?rel=\" ts)\n                out (prefix (str out \"/\")))\n         file (cond-> (str smn \".js\")\n                (true? source-map-timestamp) (str \"?rel=\" ts)\n                out (prefix (str out \"/\")))\n         json (sm/encode {src (:source-map sm-data)}\n                {:lines (+ (:gen-line sm-data) 3)\n                 :file  file :sources-content [source]})]\n     (when (:verbose opts) (debug-prn json))\n     (swap! state assoc-in\n       [:source-maps (symbol mn)] (sm/invert-reverse-map (:source-map sm-data)))\n     (.append sb\n       (str \"\\n//# sourceURL=\" file\n            \"\\n//# sourceMappingURL=data:application/json;base64,\"\n            (-> (js/encodeURIComponent json)\n                (string/replace #\"%([0-9A-F]{2})\" (fn [[_ match]]\n                                                    (.fromCharCode js/String (str \"0x\" match))))\n                (base64/encodeString))))))\n\n(defn- alias-map\n  [compiler cljs-ns]\n  (->> (merge (get-in compiler [::ana/namespaces cljs-ns :requires])\n         (get-in compiler [::ana/namespaces cljs-ns :require-macros]))\n    (remove (fn [[k v]] (symbol-identical? k v)))\n    (into {})))\n\n;; -----------------------------------------------------------------------------\n;; Analyze\n\n(declare ^{:arglists '([bound-vars source name opts cb])} eval-str*)\n\n(def *loaded* (atom #{}))\n\n(defn- run-async!\n  \"Like cljs.core/run!, but for an async procedure, and with the\n  ability to break prior to processing the entire collection.\n\n  Chains successive calls to the supplied procedure for items in\n  the collection. The procedure should accept an item from the\n  collection and a callback of one argument. If the break? predicate,\n  when applied to the procedure callback value, yields a truthy\n  result, terminates early calling the supplied cb with the callback\n  value. Otherwise, when complete, calls cb with nil.\"\n  [proc coll break? cb]\n  (if (seq coll)\n    (proc (first coll)\n      (fn [res]\n        (if (break? res)\n          (cb res)\n          (run-async! proc (rest coll) break? cb))))\n    (cb nil)))\n\n(declare ^{:arglists '([name cb]\n                       [name opts cb]\n                       [bound-vars name opts cb]\n                       [bound-vars name reload opts cb])} require)\n\n(defn- process-deps\n  [bound-vars names opts cb]\n  (run-async! (fn [name cb]\n                (require bound-vars name nil opts cb))\n    names\n    :error\n    cb))\n\n(defn- process-macros-deps\n  [bound-vars cache opts cb]\n  (process-deps bound-vars\n    (distinct (vals (:require-macros cache)))\n    (-> opts\n      (assoc :macros-ns true)\n      (dissoc :emit-constants :optimize-constants))\n    cb))\n\n(defn- process-libs-deps\n  [bound-vars cache opts cb]\n  (process-deps bound-vars\n    (distinct (concat (vals (:requires cache)) (vals (:imports cache))))\n    (dissoc opts :macros-ns)\n    cb))\n\n(defn- pre-file-side-effects\n  [st name file opts]\n  (when (:verbose opts)\n    (debug-prn \"Pre-file side-effects\" file))\n  ;; In case any constants are defined in the namespace, flush any analysis metadata\n  ;; so that the constants can be defined wihtout triggering re-defined errors.\n  (when (and (get-in @st [::ana/namespaces name :defs])\n             (not ('#{cljs.core cljs.core$macros} name)))\n    (swap! st update ::ana/namespaces dissoc name)))\n\n(defn- post-file-side-effects\n  [file opts]\n  (when (:verbose opts)\n    (debug-prn \"Post-file side-effects\" file))\n  ;; Note, we don't (set! *unchecked-arrays* false) here, as that would interpreted\n  ;; an intrinsic affecting the compilation of this file, emitting a no-op. We bypass this\n  ;; and emit our own runtime assignment code.\n  (js* \"cljs.core._STAR_unchecked_arrays_STAR_ = false;\"))\n\n(defn require\n  ([name cb]\n    (require name nil cb))\n  ([name opts cb]\n    (require nil name opts cb))\n  ([bound-vars name opts cb]\n   (require bound-vars name nil opts cb))\n  ([bound-vars name reload opts cb]\n   (let [bound-vars (merge\n                      {:*compiler*     (env/default-compiler-env)\n                       :*data-readers* tags/*cljs-data-readers*\n                       :*load-macros*  (:load-macros opts true)\n                       :*analyze-deps* (:analyze-deps opts true)\n                       :*load-fn*      (or (:load opts) *load-fn*)\n                       :*eval-fn*      (or (:eval opts) *eval-fn*)}\n                      bound-vars)\n         aname (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n     (when (= :reload reload)\n       (swap! *loaded* disj aname))\n     (when (= :reload-all reload)\n       (reset! *loaded* #{}))\n     (when (:verbose opts)\n       (debug-prn (str \"Loading \" name (when (:macros-ns opts) \" macros\") \" namespace\")))\n     (if-not (contains? @*loaded* aname)\n       (let [env (:*env* bound-vars)]\n         (try\n           ((:*load-fn* bound-vars)\n             {:name name\n              :macros (:macros-ns opts)\n              :path (ns->relpath name)}\n             (fn [resource]\n               (assert (or (map? resource) (nil? resource))\n                 \"*load-fn* may only return a map or nil\")\n               (if resource\n                 (let [{:keys [lang source cache source-map file]} resource]\n                   (condp keyword-identical? lang\n                     :clj (do\n                            (pre-file-side-effects (:*compiler* bound-vars) aname file opts)\n                            (eval-str* bound-vars source name (assoc opts :cljs-file file)\n                              (fn [res]\n                                (post-file-side-effects file opts)\n                                (if (:error res)\n                                  (cb res)\n                                  (do\n                                    (swap! *loaded* conj aname)\n                                    (cb {:value true}))))))\n                     :js (process-macros-deps bound-vars cache opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (process-libs-deps bound-vars cache opts\n                                 (fn [res]\n                                   (if (:error res)\n                                     (cb res)\n                                     (let [res (try\n                                                 ((:*eval-fn* bound-vars) resource)\n                                                 (when cache\n                                                   (load-analysis-cache!\n                                                     (:*compiler* bound-vars) aname cache)\n                                                   (ana/register-specs cache))\n                                                 (when source-map\n                                                   (load-source-map!\n                                                     (:*compiler* bound-vars) aname source-map))\n                                                 (catch :default cause\n                                                   (wrap-error\n                                                     (ana/error env\n                                                       (str \"Could not require \" name) cause))))]\n                                       (if (:error res)\n                                         (cb res)\n                                         (do\n                                           (swap! *loaded* conj aname)\n                                           (cb {:value true}))))))))))\n                     (cb (wrap-error\n                           (ana/error env\n                             (str \"Invalid :lang specified \" lang \", only :clj or :js allowed\"))))))\n                 (cb (wrap-error\n                       (ana/error env\n                         (ana/error-message (if (:macros-ns opts)\n                                              :undeclared-macros-ns\n                                              :undeclared-ns)\n                           {:ns-sym name :js-provide (cljs.core/name name)})))))))\n           (catch :default cause\n             (cb (wrap-error\n                   (ana/error env\n                     (str \"Could not require \" name) cause))))))\n       (cb {:value true})))))\n\n(defn- patch-alias-map\n  [compiler in from to]\n  (let [patch (fn [k add-if-present?]\n                (swap! compiler update-in [::ana/namespaces in k]\n                  (fn [m]\n                    (let [replaced (walk/postwalk-replace {from to} m)]\n                      (if (and add-if-present?\n                               (some #{to} (vals replaced)))\n                        (assoc replaced from to)\n                        replaced)))))\n        patch-renames (fn [k]\n                        (swap! compiler update-in [::ana/namespaces in k]\n                          (fn [m]\n                            (when m\n                              (reduce (fn [acc [renamed qualified-sym :as entry]]\n                                        (if (= (str from) (namespace qualified-sym))\n                                          (assoc acc renamed (symbol (str to) (name qualified-sym)))\n                                          (merge acc entry)))\n                                {} m)))))]\n    (patch :requires true)\n    (patch :require-macros true)\n    (patch :uses false)\n    (patch :use-macros false)\n    (patch-renames :renames)\n    (patch-renames :rename-macros)))\n\n(defn- self-require? [deps opts]\n  (and (true? (:def-emits-var opts)) (some #{ana/*cljs-ns*} deps)))\n\n(defn- load-deps\n  ([bound-vars ana-env lib deps cb]\n   (load-deps bound-vars ana-env lib deps nil nil cb))\n  ([bound-vars ana-env lib deps reload opts cb]\n   (when (:verbose opts)\n     (debug-prn \"Loading dependencies for\" lib))\n   (binding [ana/*cljs-dep-set* (let [lib (if (self-require? deps opts)\n                                            'cljs.user\n                                            lib)]\n                                  (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                    update-in [:dep-path] conj lib))]\n     (let [bound-vars (assoc bound-vars :*cljs-dep-set* ana/*cljs-dep-set*)]\n       (if-not (every? #(not (contains? ana/*cljs-dep-set* %)) deps)\n         (cb (wrap-error\n               (ana/error ana-env\n                 (str \"Circular dependency detected \"\n                   (apply str\n                     (interpose \" -> \"\n                       (conj (-> ana/*cljs-dep-set* meta :dep-path)\n                         (some ana/*cljs-dep-set* deps))))))))\n         (if (seq deps)\n           (let [dep (first deps)\n                 opts' (-> opts\n                         (dissoc :context)\n                         (dissoc :def-emits-var)\n                         (dissoc :ns))]\n             (require bound-vars dep reload opts'\n               (fn [res]\n                 (when (:verbose opts)\n                   (debug-prn \"Loading result:\" res))\n                 (if-not (:error res)\n                   (load-deps bound-vars ana-env lib (next deps) nil opts cb)\n                   (if-let [cljs-dep (let [cljs-ns (ana/clj-ns->cljs-ns dep)]\n                                       (get {dep nil} cljs-ns cljs-ns))]\n                     (require bound-vars cljs-dep opts'\n                       (fn [res]\n                         (if (:error res)\n                           (cb res)\n                           (do\n                             (patch-alias-map (:*compiler* bound-vars) lib dep cljs-dep)\n                             (load-deps bound-vars ana-env lib (next deps) nil opts\n                               (fn [res]\n                                 (if (:error res)\n                                   (cb res)\n                                   (cb (update res :aliased-loads assoc dep cljs-dep)))))))))\n                     (cb res))))))\n           (cb {:value nil})))))))\n\n(declare ^{:arglists '([bound-vars source name opts cb])} analyze-str*)\n\n(defn- analyze-deps\n  ([bound-vars ana-env lib deps cb]\n   (analyze-deps bound-vars ana-env lib deps nil cb))\n  ([bound-vars ana-env lib deps opts cb]\n   (binding [ana/*cljs-dep-set* (vary-meta (conj (:*cljs-dep-set* bound-vars) lib)\n                                  update-in [:dep-path] conj lib)]\n     (let [compiler @(:*compiler* bound-vars)\n           bound-vars (assoc bound-vars :*cljs-dep-set* ana/*cljs-dep-set*)]\n       (if-not (every? #(not (contains? ana/*cljs-dep-set* %)) deps)\n         (cb (wrap-error\n               (ana/error ana-env\n                 (str \"Circular dependency detected \"\n                   (apply str\n                     (interpose \" -> \"\n                       (conj (-> ana/*cljs-dep-set* meta :dep-path)\n                         (some ana/*cljs-dep-set* deps))))))))\n         (if (seq deps)\n           (let [dep (first deps)]\n             (try\n               ((:*load-fn* bound-vars) {:name dep :path (ns->relpath dep)}\n                (fn [resource]\n                  (assert (or (map? resource) (nil? resource))\n                    \"*load-fn* may only return a map or nil\")\n                  (if-not resource\n                    (if-let [cljs-dep (let [cljs-ns (ana/clj-ns->cljs-ns dep)]\n                                        (get {dep nil} cljs-ns cljs-ns))]\n                      (do\n                        (patch-alias-map (:*compiler* bound-vars) lib dep cljs-dep)\n                        (analyze-deps bound-vars ana-env lib (cons cljs-dep (next deps)) opts\n                          (fn [res]\n                            (if (:error res)\n                              (cb res)\n                              (cb (update res :aliased-loads assoc dep cljs-dep))))))\n                      (cb (wrap-error\n                            (ana/error ana-env\n                              (ana/error-message :undeclared-ns\n                                {:ns-sym dep :js-provide (name dep)})))))\n                    (let [{:keys [name lang source file]} resource]\n                      (condp keyword-identical? lang\n                        :clj (do\n                               (pre-file-side-effects (:*compiler* bound-vars) name file opts)\n                               (analyze-str* bound-vars source name (assoc opts :cljs-file file)\n                                 (fn [res]\n                                   (post-file-side-effects file opts)\n                                   (if-not (:error res)\n                                     (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                                     (cb res)))))\n                        :js (analyze-deps bound-vars ana-env lib (next deps) opts cb)\n                        (wrap-error\n                          (ana/error ana-env\n                            (str \"Invalid :lang specified \" lang \", only :clj or :js allowed\"))))))))\n               (catch :default cause\n                 (cb (wrap-error\n                       (ana/error ana-env\n                         (str \"Could not analyze dep \" dep) cause))))))\n           (cb {:value nil})))))))\n\n(defn- load-macros [bound-vars k macros lib reload reloads opts cb]\n  (if (seq macros)\n    (let [nsym (first (vals macros))\n          k    (or (reload k)\n                   (get-in reloads [k nsym])\n                   (and (= nsym name) (:*reload-macros* bound-vars) :reload)\n                   nil)\n          opts' (-> opts\n                  (assoc :macros-ns true)\n                  (dissoc :context)\n                  (dissoc :def-emits-var)\n                  (dissoc :ns)\n                  (dissoc :emit-constants :optimize-constants))]\n      (require bound-vars nsym k opts'\n        (fn [res]\n          (if-not (:error res)\n            (load-macros bound-vars k (next macros) lib reload reloads opts cb)\n            (if-let [cljs-dep (let [cljs-ns (ana/clj-ns->cljs-ns nsym)]\n                                (get {nsym nil} cljs-ns cljs-ns))]\n              (require bound-vars cljs-dep k opts'\n                (fn [res]\n                  (if (:error res)\n                    (cb res)\n                    (do\n                      (patch-alias-map (:*compiler* bound-vars) lib nsym cljs-dep)\n                      (load-macros bound-vars k (next macros) lib reload reloads opts\n                        (fn [res]\n                          (if (:error res)\n                            (cb res)\n                            (cb (update res :aliased-loads assoc nsym cljs-dep)))))))))\n              (cb res))))))\n    (cb {:value nil})))\n\n(defn- rewrite-ns-ast\n  ([ast smap]\n   (rewrite-ns-ast ast smap false))\n  ([ast smap macros?]\n   (let [[uk rk renk] (if macros?\n                        [:use-macros :require-macros :rename-macros]\n                        [:uses :requires :renames])\n         rewrite-renames (fn [m]\n                           (when m\n                             (reduce (fn [acc [renamed qualified-sym :as entry]]\n                                       (let [from (symbol (namespace qualified-sym))\n                                             to   (get smap from)]\n                                         (if (some? to)\n                                           (assoc acc renamed (symbol (str to) (name qualified-sym)))\n                                           (merge acc entry))))\n                               {} m)))\n         rewrite-deps (fn [deps]\n                        (into []\n                          (map (fn [dep]\n                                 (if-let [new-dep (get smap dep)]\n                                   new-dep\n                                   dep)))\n                          deps))]\n     (-> ast\n       (update uk #(walk/postwalk-replace smap %))\n       (update rk #(merge smap (walk/postwalk-replace smap %)))\n       (update renk rewrite-renames)\n       (update :deps rewrite-deps)))))\n\n(defn- check-macro-autoload-inferring-missing\n  [{:keys [requires name] :as ast} cenv]\n  (let [namespaces (-> @cenv ::ana/namespaces)\n        missing-require-macros (into {}\n                                 (filter (fn [[_ full-ns]]\n                                           (let [{:keys [use-macros require-macros]} (get namespaces full-ns)]\n                                             (or (some #{full-ns} (vals use-macros))\n                                                 (some #{full-ns} (vals require-macros))))))\n                                 requires)\n        ast' (update-in ast [:require-macros] merge missing-require-macros)]\n    (swap! cenv update-in [::ana/namespaces name :require-macros] merge missing-require-macros)\n    ast'))\n\n(defn- ns-side-effects\n  ([bound-vars ana-env ast opts cb]\n    (ns-side-effects false bound-vars ana-env ast opts cb))\n  ([load bound-vars ana-env {:keys [op] :as ast} opts cb]\n   (when (:verbose opts)\n     (debug-prn \"Namespace side effects for\" (:name ast)))\n   (if (#{:ns :ns*} op)\n     (letfn [(check-uses-and-load-macros [res rewritten-ast]\n               (let [env (:*compiler* bound-vars)\n                     {:keys [uses use-macros reload reloads name]} rewritten-ast]\n                 (if (:error res)\n                   (cb res)\n                   (if (:*load-macros* bound-vars)\n                     (do\n                       (when (:verbose opts) (debug-prn \"Processing :use-macros for\" name))\n                       (load-macros bound-vars :use-macros use-macros name reload reloads opts\n                         (fn [res]\n                           (if (:error res)\n                             (cb res)\n                             (let [{:keys [require-macros] :as rewritten-ast} (rewrite-ns-ast rewritten-ast (:aliased-loads res) true)]\n                               (when (:verbose opts) (debug-prn \"Processing :require-macros for\" (:name ast)))\n                               (load-macros bound-vars :require-macros require-macros name reload reloads opts\n                                 (fn [res']\n                                   (if (:error res')\n                                     (cb res')\n                                     (let [{:keys [use-macros] :as rewritten-ast} (rewrite-ns-ast rewritten-ast (:aliased-loads res) true)\n                                           res' (try\n                                                  (when (seq use-macros)\n                                                    (when (:verbose opts) (debug-prn \"Checking :use-macros for\" (:name ast)))\n                                                    (binding [ana/*analyze-deps* (:*analyze-deps* bound-vars)\n                                                              env/*compiler* (:*compiler* bound-vars)]\n                                                      (ana/check-use-macros use-macros env)))\n                                                  {:value nil}\n                                                  (catch :default cause\n                                                    (wrap-error\n                                                      (ana/error ana-env\n                                                        (str \"Could not parse ns form \" (:name ast)) cause))))]\n                                       (if (:error res')\n                                         (cb res')\n                                         (try\n                                           (binding [ana/*analyze-deps* (:*analyze-deps* bound-vars)\n                                                     env/*compiler* (:*compiler* bound-vars)]\n                                             (let [ast' (-> rewritten-ast\n                                                          (ana/check-use-macros-inferring-missing env)\n                                                          (ana/check-rename-macros-inferring-missing env)\n                                                          (check-macro-autoload-inferring-missing env))]\n                                               (cb {:value ast'})))\n                                           (catch :default cause\n                                             (cb (wrap-error\n                                                   (ana/error ana-env\n                                                     (str \"Could not parse ns form \" (:name ast)) cause)))))))))))))))\n                     (try\n                       (when (:verbose opts) (debug-prn \"Checking uses\"))\n                       (ana/check-uses\n                         (when (and (:*analyze-deps* bound-vars) (seq uses))\n                           (ana/missing-uses uses env))\n                         env)\n                       (cb {:value ast})\n                       (catch :default cause\n                         (cb (wrap-error\n                               (ana/error ana-env\n                                 (str \"Could not parse ns form \" (:name ast)) cause)))))))))]\n       (cond\n         (and load (seq (:deps ast)))\n         (let [{:keys [reload name deps]} ast]\n           (load-deps bound-vars ana-env name deps (or (:require reload) (:use reload)) (dissoc opts :macros-ns)\n             #(check-uses-and-load-macros % (rewrite-ns-ast ast (:aliased-loads %)))))\n\n         (and (not load) (:*analyze-deps* bound-vars) (seq (:deps ast)))\n         (analyze-deps bound-vars ana-env (:name ast) (:deps ast) (dissoc opts :macros-ns)\n           #(check-uses-and-load-macros % (rewrite-ns-ast ast (:aliased-loads %))))\n\n         :else\n         (check-uses-and-load-macros {:value nil} ast)))\n     (cb {:value ast}))))\n\n(defn- node-side-effects\n  [bound-vars sb deps ns-name emit-nil-result?]\n  (doseq [dep deps]\n    (.append sb\n      (with-out-str\n        (comp/emitln (munge ns-name) \".\"\n          (ana/munge-node-lib dep)\n          \" = require('\" dep \"');\"))))\n  (when (and (seq deps) emit-nil-result?)\n    (.append sb \"null;\")))\n\n(defn- global-exports-side-effects\n  [bound-vars sb deps ns-name emit-nil-result?]\n  (let [{:keys [js-dependency-index]} @(:*compiler* bound-vars)]\n    (doseq [dep deps]\n      (let [{:keys [global-exports]} (get js-dependency-index (name dep))]\n        (.append sb\n          (with-out-str\n            (comp/emit-global-export ns-name global-exports dep)))))\n    (when (and (seq deps) emit-nil-result?)\n      (.append sb \"null;\"))))\n\n(defn- trampoline-safe\n  \"Returns a new function that calls f but discards any return value,\n  returning nil instead, thus avoiding any inadvertent trampoline continuation\n  if a function happens to be returned.\"\n  [f]\n  (comp (constantly nil) f))\n\n(defn- analyze-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        cb         (trampoline-safe cb)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (trampoline\n     (fn analyze-loop [last-ast ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 ana/*cljs-ns*          ns\n                 ana/*checked-arrays*   (:checked-arrays opts)\n                 ana/*cljs-static-fns*  (:static-fns opts)\n                 ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n                 *ns*                   (create-ns ns)\n                 ana/*passes*           (:*passes* bound-vars)\n                 r/*alias-map*          (alias-map @(:*compiler* bound-vars) ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 r/resolve-symbol       resolve-symbol\n                 comp/*source-map-data* (:*sm-data* bound-vars)\n                 ana/*cljs-file*        (:cljs-file opts)]\n         (let [res (try\n                     {:value (read eof rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not analyze \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not analyze \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)]\n                       (if (#{:ns :ns*} (:op ast))\n                         ((trampoline-safe ns-side-effects) bound-vars aenv ast opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (trampoline analyze-loop ast (:name ast)))))\n                         #(analyze-loop ast ns)))))\n                 (cb {:value last-ast}))))))) nil the-ns)))\n\n(defn analyze-str\n  \"Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.\"\n  ([state source cb]\n   (analyze-str state source nil cb))\n  ([state source name cb]\n   (analyze-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (analyze-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*passes*       (or (:passes opts) ana/*passes*)\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))\n\n;; -----------------------------------------------------------------------------\n;; Eval\n\n(declare ^{:arglists '([])} clear-fns!)\n\n(defn- eval* [bound-vars form opts cb]\n  (let [the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (clear-fns!)\n    (binding [env/*compiler*         (:*compiler* bound-vars)\n              *eval-fn*              (:*eval-fn* bound-vars)\n              ana/*cljs-ns*          (:*cljs-ns* bound-vars)\n              ana/*checked-arrays*   (:checked-arrays opts)\n              ana/*cljs-static-fns*  (:static-fns opts)\n              ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n              *ns*                   (create-ns (:*cljs-ns* bound-vars))\n              r/*alias-map*          (alias-map @(:*compiler* bound-vars) (:*cljs-ns* bound-vars))\n              r/*data-readers*       (:*data-readers* bound-vars)\n              r/resolve-symbol       resolve-symbol\n              comp/*source-map-data* (:*sm-data* bound-vars)]\n      (let [aenv (ana/empty-env)\n            aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                   (:context opts) (assoc :context (:context opts))\n                   (:def-emits-var opts) (assoc :def-emits-var true))\n            res  (try\n                   {:value (ana/analyze aenv form nil opts)}\n                   (catch :default cause\n                     (wrap-error\n                       (ana/error aenv\n                         (str \"Could not eval \" form) cause))))]\n        (if (:error res)\n          (cb res)\n          (let [ast (:value res)\n                [node-deps ast] (if (keyword-identical? (:target opts) :nodejs)\n                                  (let [{node-libs true libs-to-load false} (group-by ana/node-module-dep? (:deps ast))]\n                                    [node-libs (assoc ast :deps libs-to-load)])\n                                  [nil ast])]\n            (if (#{:ns :ns*} (:op ast))\n              (ns-side-effects true bound-vars aenv ast opts\n                (fn [res]\n                  (if (:error res)\n                    (cb res)\n                    (let [ns-name (:name ast)\n                          sb (StringBuffer.)]\n                      (.append sb\n                        (with-out-str (comp/emitln (str \"goog.provide(\\\"\" (comp/munge ns-name) \"\\\");\"))))\n                      (when-not (nil? node-deps)\n                        (node-side-effects bound-vars sb node-deps ns-name (:def-emits-var opts)))\n                      (global-exports-side-effects bound-vars sb\n                        (filter ana/dep-has-global-exports? (:deps ast))\n                        ns-name\n                        (:def-emits-var opts))\n                      (cb {:value (*eval-fn* {:source (.toString sb)})})))))\n              (let [src (with-out-str (comp/emit ast))]\n                (cb {:value (*eval-fn* {:source src})})))))))))\n\n(defn eval\n  \"Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.\"\n  ([state form cb]\n   (eval state form nil cb))\n  ([state form opts cb]\n   (eval*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     form opts cb)))\n\n;; -----------------------------------------------------------------------------\n;; Compile\n\n(defn- compile-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        cb         (trampoline-safe cb)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))]\n    (trampoline\n     (fn compile-loop [ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          ns\n                 ana/*checked-arrays*   (:checked-arrays opts)\n                 ana/*cljs-static-fns*  (:static-fns opts)\n                 ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n                 *ns*                   (create-ns ns)\n                 r/*alias-map*          (alias-map @(:*compiler* bound-vars) ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 r/resolve-symbol       resolve-symbol\n                 comp/*source-map-data* (:*sm-data* bound-vars)]\n         (let [res (try\n                     {:value (read eof rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not compile \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ana/*cljs-ns*))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not compile \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)\n                           [node-deps ast] (if (keyword-identical? (:target opts) :nodejs)\n                                             (let [{node-libs true libs-to-load false} (group-by ana/node-module-dep? (:deps ast))]\n                                               [node-libs (assoc ast :deps libs-to-load)])\n                                             [nil ast])]\n                       (if (#{:ns :ns*} (:op ast))\n                         ((trampoline-safe ns-side-effects) bound-vars aenv ast opts\n                           (fn [res]\n                             (if (:error res)\n                               (cb res)\n                               (let [ns-name (:name ast)]\n                                 (.append sb (with-out-str (comp/emit (:value res))))\n                                 (when-not (nil? node-deps)\n                                   (node-side-effects bound-vars sb node-deps ns-name (:def-emits-var opts)))\n                                 (trampoline compile-loop (:name ast))))))\n                         (do\n                           (.append sb (with-out-str (comp/emit ast)))\n                           #(compile-loop ns))))))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       name source sb @comp/*source-map-data* opts))\n                   (cb {:value (.toString sb)})))))))) the-ns)))\n\n(defn compile-str\n  \"Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source - used as key in :source-maps\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:expr`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.\"\n  ([state source cb]\n   (compile-str state source nil cb))\n  ([state source name cb]\n   (compile-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (compile-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)\n      :*sm-data*      (when (:source-map opts) (sm-data))}\n     source name opts cb)))\n\n;; -----------------------------------------------------------------------------\n;; Evaluate String\n\n(defn- eval-str* [bound-vars source name opts cb]\n  (let [rdr        (rt/indexing-push-back-reader source 1 name)\n        cb         (trampoline-safe cb)\n        eof        (js-obj)\n        aenv       (ana/empty-env)\n        sb         (StringBuffer.)\n        the-ns     (or (:ns opts) 'cljs.user)\n        bound-vars (cond-> (merge bound-vars {:*cljs-ns* the-ns})\n                     (:source-map opts) (assoc :*sm-data* (sm-data)))\n        aname      (cond-> name (:macros-ns opts) ana/macro-ns-name)]\n    (when (:verbose opts) (debug-prn \"Evaluating\" name))\n    (clear-fns!)\n    (trampoline\n     (fn compile-loop [ns]\n       (binding [env/*compiler*         (:*compiler* bound-vars)\n                 *eval-fn*              (:*eval-fn* bound-vars)\n                 ana/*cljs-ns*          ns\n                 ana/*checked-arrays*   (:checked-arrays opts)\n                 ana/*cljs-static-fns*  (:static-fns opts)\n                 ana/*fn-invoke-direct* (and (:static-fns opts) (:fn-invoke-direct opts))\n                 *ns*                   (create-ns ns)\n                 r/*alias-map*          (alias-map @(:*compiler* bound-vars) ns)\n                 r/*data-readers*       (:*data-readers* bound-vars)\n                 r/resolve-symbol       resolve-symbol\n                 comp/*source-map-data* (:*sm-data* bound-vars)\n                 ana/*cljs-file*        (:cljs-file opts)]\n         (let [res (try\n                     {:value (read eof rdr)}\n                     (catch :default cause\n                       (wrap-error\n                         (ana/error aenv\n                           (str \"Could not eval \" name) cause))))]\n           (if (:error res)\n             (cb res)\n             (let [form (:value res)]\n               (if-not (identical? eof form)\n                 (let [aenv (cond-> (assoc aenv :ns (ana/get-namespace ns))\n                              (:context opts) (assoc :context (:context opts))\n                              (:def-emits-var opts) (assoc :def-emits-var true))\n                       res  (try\n                              {:value (ana/analyze aenv form nil opts)}\n                              (catch :default cause\n                                (wrap-error\n                                  (ana/error aenv\n                                    (str \"Could not eval \" name) cause))))]\n                   (if (:error res)\n                     (cb res)\n                     (let [ast (:value res)\n                           ns' ana/*cljs-ns*\n                           [node-deps ast] (if (keyword-identical? (:target opts) :nodejs)\n                                             (let [{node-libs true libs-to-load false} (group-by ana/node-module-dep? (:deps ast))]\n                                               [node-libs (assoc ast :deps libs-to-load)])\n                                             [nil ast])]\n                      (if (#{:ns :ns*} (:op ast))\n                        (do\n                          (.append sb\n                            (with-out-str (comp/emitln (str \"goog.provide(\\\"\" (comp/munge (:name ast)) \"\\\");\"))))\n                          ((trampoline-safe ns-side-effects) true bound-vars aenv ast opts\n                            (fn [res]\n                              (if (:error res)\n                                (cb res)\n                                (let [ns-name (:name ast)]\n                                  (when-not (nil? node-deps)\n                                    (node-side-effects bound-vars sb node-deps ns-name (:def-emits-var opts)))\n                                  (global-exports-side-effects bound-vars sb\n                                    (filter ana/dep-has-global-exports? (:deps ast))\n                                    ns-name\n                                    (:def-emits-var opts))\n                                  (trampoline compile-loop ns'))))))\n                        (do\n                          (env/with-compiler-env (assoc @(:*compiler* bound-vars) :options opts)\n                            (.append sb (with-out-str (comp/emit ast))))\n                          #(compile-loop ns'))))))\n                 (do\n                   (when (:source-map opts)\n                     (append-source-map env/*compiler*\n                       aname source sb @comp/*source-map-data* opts))\n                   (when (symbol? aname)\n                     (ana/dump-specs aname))\n                   (let [js-source (.toString sb)\n                         evalm     {:lang   :clj\n                                    :name   name\n                                    :path   (ns->relpath name)\n                                    :source js-source\n                                    :cache  (get-in @env/*compiler* [::ana/namespaces aname])}\n                         complete  (fn [res]\n                                     (if (:error res)\n                                       (cb res)\n                                       (do\n                                         (when (:verbose opts)\n                                           (debug-prn js-source))\n                                         (let [res (try\n                                                     {:ns ns :value (*eval-fn* evalm)}\n                                                     (catch :default cause\n                                                       (wrap-error (ana/error aenv \"ERROR\" cause))))]\n                                           (cb res)))))]\n                     (if-let [f (:cache-source opts)]\n                       ((trampoline-safe f) evalm complete)\n                       (complete {:value nil}))))))))))\n      (:*cljs-ns* bound-vars))))\n\n(defn eval-str\n  \"Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source - used as key in :source-maps\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:expr`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.\"\n  ([state source cb]\n   (eval-str state source nil cb))\n  ([state source name cb]\n   (eval-str state source name nil cb))\n  ([state source name opts cb]\n   {:pre [(atom? state) (string? source)\n          (valid-name? name) (valid-opts? opts) (fn? cb)]}\n   (eval-str*\n     {:*compiler*     state\n      :*data-readers* tags/*cljs-data-readers*\n      :*analyze-deps* (:analyze-deps opts true)\n      :*cljs-dep-set* ana/*cljs-dep-set*\n      :*load-macros*  (:load-macros opts true)\n      :*load-fn*      (or (:load opts) *load-fn*)\n      :*eval-fn*      (or (:eval opts) *eval-fn*)}\n     source name opts cb)))\n\n;;; Support for cljs.core/eval\n\n;; The following volatiles and fns set up a scheme to\n;; emit function values into JavaScript as numeric\n;; references that are looked up. Needed to implement eval.\n\n(defonce ^:private fn-index (volatile! 0))\n(defonce ^:private fn-refs (volatile! {}))\n\n(defn- clear-fns!\n  \"Clears saved functions.\"\n  []\n  (vreset! fn-refs {}))\n\n(defn- put-fn\n  \"Saves a function, returning a numeric representation.\"\n  [f]\n  (let [n (vswap! fn-index inc)]\n    (vswap! fn-refs assoc n f)\n    n))\n\n(defn- get-fn\n  \"Gets a function, given its numeric representation.\"\n  [n]\n  (get @fn-refs n))\n\n(defn- emit-fn [f]\n  (print \"cljs.js.get_fn(\" (put-fn f) \")\"))\n\n(defmethod comp/emit-constant* js/Function\n  [f]\n  (emit-fn f))\n\n(defmethod comp/emit-constant* cljs.core/Var\n  [f]\n  (emit-fn f))\n\n(defn- eval-impl\n  ([form]\n   (eval-impl form (.-name *ns*)))\n  ([form ns]\n   (let [result (atom nil)]\n     (let [st env/*compiler*]\n       (eval st form\n         {:ns            ns\n          :context       :expr\n          :def-emits-var true}\n         (fn [{:keys [value error]}]\n           (if error\n             (throw error)\n             (reset! result value)))))\n     @result)))\n\n(set! *eval* eval-impl)\n\n(comment\n  (require '[cljs.js :as cljs]\n           '[cljs.analyzer :as ana])\n\n  (def vm (js/require \"vm\"))\n  (def fs (js/require \"fs\"))\n  (def st (cljs/empty-state))\n\n  (set! *target* \"nodejs\")\n\n  (defn node-eval [{:keys [name source]}]\n    (.runInThisContext vm source (str (munge name) \".js\")))\n\n  (def libs\n    {'bootstrap-test.core :cljs\n     'bootstrap-test.macros :clj\n     'bootstrap-test.helper :clj})\n\n  (defn node-load [{:keys [name macros]} cb]\n    (if (contains? libs name)\n      (let [path (str \"src/test/cljs/\" (cljs/ns->relpath name)\n                      \".\" (cljs.core/name (get libs name)))]\n        (.readFile fs path \"utf-8\"\n          (fn [err src]\n            (cb (if-not err\n                  {:lang :clj :source src}\n                  (.error js/console err))))))\n      (cb nil)))\n\n  (defn elide-env [env ast opts]\n    (dissoc ast :env))\n\n  (cljs/analyze-str st \"(+ 1 1)\" nil\n    {:passes [ana/infer-type elide-env]\n     :eval node-eval}\n    (fn [{:keys [value]}]\n      (println value)))\n\n  (cljs/eval st '(defn foo [a b] (+ a b))\n    {:eval node-eval}\n    (fn [res]\n      (println res)))\n\n  (cljs/compile-str st \"(defprotocol IFoo (foo [this]))\"\n    (fn [{:keys [value]}]\n      (println \"Source:\")\n      (println value)))\n\n  (cljs/eval-str st\n    \"(defn foo [a b] (+ a b))\n     (defn bar [c d] (+ c d))\"\n    nil\n    {:eval node-eval}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval-str st \"1\"\n    nil\n    {:eval node-eval\n     :context :expr}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval-str st \"(def x 1)\"\n    nil\n    {:eval node-eval\n     :context :expr\n     :def-emits-var true}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval st '(ns foo.bar)\n    {:eval node-eval}\n    (fn [res]\n      (println res)))\n\n  (cljs/eval st '(def x 1)\n    {:eval node-eval\n     :context :expr\n     :def-emits-var true\n     :ns 'foo.bar}\n    (fn [res]\n      (println res)))\n\n  (cljs/compile-str st \"(defn foo\\n[a b]\\n(+ a b))\" 'cljs.foo\n    {:verbose true :source-map true}\n    (fn [js-source]\n      (println \"Source:\")\n      (println js-source)))\n\n  (cljs/eval-str st\n    \"(ns foo.bar (:require [bootstrap-test.core]))\\n(bootstrap-test.core/foo 3 4)\"\n    'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [ret]\n      (println ret)))\n\n  (cljs/eval-str st\n    \"(ns foo.bar (:require-macros [bootstrap-test.macros :refer [foo]]))\\n(foo 4 4)\"\n    'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println \"Error:\" error)\n          (println (.. error -cause -stack)))\n        (println \"Result:\" res))))\n\n  (cljs/compile-str st\n    \"(ns foo.bar (:require-macros [bootstrap-test.macros :refer [foo]]))\\n(foo 4 4)\"\n    'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println \"Error:\" error)\n          (println (.. error -cause -stack)))\n        (println \"Result:\" res))))\n\n  (cljs/eval-str st\n    \"(ns foo.bar)\\n(first [1 2 3])\"\n    'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println error)\n          (println (.. error -cause -stack)))\n        (println res))))\n\n  (cljs/eval-str st\n    \"(ns foo.bar)\\n(map inc [1 2 3])\"\n    'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println error)\n          (println (.. error -cause -stack)))\n        (println res))))\n\n  ;; *NOT* source mapped under Node.js\n  ;; source-map-support does not yet work, users will need to map\n  ;; themselves\n  (cljs/eval-str st\n    \"(ns foo.bar)\\n(ffirst [1 2 3])\"\n    'foo.bar\n    {:verbose true\n     :source-map true\n     :eval node-eval\n     :load node-load}\n    (fn [{:keys [error] :as res}]\n      (if error\n        (do\n          (println error)\n          (println (.. error -cause -stack)))\n        (println res))))\n  )\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/set.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.set",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)\n\n(defn- bubble-max-key\n  \"Move a maximal element of coll according to fn k (which returns a\n  number) to the front of coll.\"\n  [k coll]\n  (let [max (apply max-key k coll)]\n    (cons max (remove #(identical? max %) coll))))\n\n(defn union\n  \"Return a set that is the union of the input sets\"\n  {:added \"1.0\"}\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn intersection\n  \"Return a set that is the intersection of the input sets\"\n  {:added \"1.0\"}\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn difference\n  \"Return a set that is the first set without elements of the remaining sets\"\n  {:added \"1.0\"}\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))\n\n\n(defn select\n  \"Returns a set of the elements for which pred is true\"\n  {:added \"1.0\"}\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))\n\n(defn project\n  \"Returns a rel of the elements of xrel with only the keys in ks\"\n  {:added \"1.0\"}\n  [xrel ks]\n  (with-meta (set (map #(select-keys % ks) xrel)) (meta xrel)))\n\n(defn rename-keys\n  \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n  {:added \"1.0\"}\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m)) \n     (apply dissoc map (keys kmap)) kmap))\n\n(defn rename\n  \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n  {:added \"1.0\"}\n  [xrel kmap]\n  (with-meta (set (map #(rename-keys % kmap) xrel)) (meta xrel)))\n\n(defn index\n  \"Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.\"\n  {:added \"1.0\"}\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))\n   \n(defn map-invert\n  \"Returns the map with the vals mapped to the keys.\"\n  {:added \"1.0\"}\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))\n\n(defn join\n  \"When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.\"\n  {:added \"1.0\"}\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))\n\n(defn subset? \n  \"Is set1 a subset of set2?\"\n  {:added \"1.2\",\n   :tag Boolean}\n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))\n\n(defn superset? \n  \"Is set1 a superset of set2?\"\n  {:added \"1.2\",\n   :tag Boolean}\n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))\n\n(comment\n(refer 'set)\n(def xs #{{:a 11 :b 1 :c 1 :d 4}\n         {:a 2 :b 12 :c 2 :d 6}\n         {:a 3 :b 3 :c 3 :d 8 :f 42}})\n\n(def ys #{{:a 11 :b 11 :c 11 :e 5}\n         {:a 12 :b 11 :c 12 :e 3}\n         {:a 3 :b 3 :c 3 :e 7 }})\n\n(join xs ys)\n(join xs (rename ys {:b :yb :c :yc}) {:a :a})\n\n(union #{:a :b :c} #{:c :d :e })\n(difference #{:a :b :c} #{:c :d :e})\n(intersection #{:a :b :c} #{:c :d :e})\n\n(index ys [:b])\n)\n\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/walk.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.walk",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;;; walk.cljs - generic tree walker with replacement\n\n;; by Stuart Sierra\n;; Jul5 17, 2011\n\n;; CHANGE LOG:\n;;\n;; * July 17, 2011: Port to ClojureScript\n;; \n;; * December 15, 2008: replaced 'walk' with 'prewalk' & 'postwalk'\n;;\n;; * December 9, 2008: first version\n\n\n(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)\n\n(defn walk\n  \"Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n\n  {:added \"1.1\"}\n  [inner outer form]\n  (cond\n    (list? form)      (outer (apply list (map inner form)))\n    (map-entry? form)\n    (outer (MapEntry. (inner (key form)) (inner (val form)) nil))\n    (seq? form)       (outer (doall (map inner form)))\n    (record? form)    (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)      (outer (into (empty form) (map inner form)))\n    :else             (outer form)))\n\n(defn postwalk\n  \"Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial postwalk f) f form))\n\n(defn prewalk\n  \"Like postwalk, but does pre-order traversal.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))\n\n(defn keywordize-keys\n  \"Recursively transforms all map keys from strings to keywords.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn stringify-keys\n  \"Recursively transforms all map keys from keywords to strings.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn prewalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn postwalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/tools/reader.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.tools.reader",new cljs.core.Keyword(null,"source","source",-433931539),";;   Copyright (c) Nicola Mometto, Rich Hickey & contributors.\n;;   The use and distribution terms for this software are covered by the\n;;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;;   which can be found in the file epl-v10.html at the root of this distribution.\n;;   By using this software in any fashion, you are agreeing to be bound by\n;;   the terms of this license.\n;;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"A clojure reader in clojure\"\n      :author \"Bronsa\"}\n  cljs.tools.reader\n  (:refer-clojure :exclude [read read-line read-string char read+string\n                            default-data-readers *default-data-reader-fn*\n                            *data-readers* *suppress-read*])\n  (:require-macros [cljs.tools.reader.reader-types :refer [log-source]])\n  (:require [cljs.tools.reader.reader-types :refer\n             [read-char unread peek-char indexing-reader?\n              get-line-number get-column-number get-file-name\n              string-push-back-reader]]\n            [cljs.tools.reader.impl.utils :refer\n             [char ex-info? whitespace? numeric? desugar-meta next-id namespace-keys second'\n              ReaderConditional reader-conditional reader-conditional? char-code]]\n            [cljs.tools.reader.impl.commons :refer\n             [number-literal? read-past match-number parse-symbol read-comment throwing-reader]]\n            [cljs.tools.reader.impl.errors :as err]\n            [goog.array :as garray]\n            [goog.string :as gstring])\n  (:import goog.string.StringBuffer))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; helpers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(declare ^:private read*\n         macros dispatch-macros\n         ^:dynamic *data-readers*\n         ^:dynamic *default-data-reader-fn*\n         ^:dynamic *suppress-read*\n         default-data-readers)\n\n(defn- ^boolean macro-terminating? [ch]\n  (case ch\n    (\\\" \\; \\@ \\^ \\` \\~ \\( \\) \\[ \\] \\{ \\} \\\\) true\n    false))\n\n(def sb (StringBuffer.))\n\n(defn- read-token\n  \"Read in a single logical token from the reader\"\n  [^not-native rdr kind initch]\n  (if (nil? initch)\n    (err/throw-eof-at-start rdr kind)\n    (do\n      (.clear sb)\n      (loop [ch initch]\n        (if (or (whitespace? ch)\n                (macro-terminating? ch)\n                (nil? ch))\n          (do\n            (when-not (nil? ch)\n              (unread rdr ch))\n            (.toString sb))\n          (do\n            (.append sb ch)\n            (recur (read-char rdr))))))))\n\n(declare read-tagged)\n\n(defn- read-dispatch\n  [^not-native rdr _ opts pending-forms]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch opts pending-forms)\n      (read-tagged (doto rdr (unread ch)) ch opts pending-forms)) ;; ctor reader is implemented as a tagged literal\n    (err/throw-eof-at-dispatch rdr)))\n\n(defn- read-unmatched-delimiter\n  [rdr ch opts pending-forms]\n  (err/throw-unmatch-delimiter rdr ch))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; readers\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(defn read-regex\n  [^not-native rdr ch opts pending-forms]\n  (let [sb (StringBuffer.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\\" ch)\n        (re-pattern (str sb))\n        (if (nil? ch)\n          (err/throw-eof-reading rdr :regex sb)\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (err/throw-eof-reading rdr :regex sb))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))\n\n(defn- read-unicode-char\n  ([token offset length base]\n     (let [l (+ offset length)]\n       (when-not (== (count token) l)\n         (err/throw-invalid-unicode-literal nil token))\n       (loop [i offset uc 0]\n         (if (== i l)\n           (js/String.fromCharCode uc)\n           (let [d (char-code (nth token i) base)]\n             (if (== d -1)\n               (err/throw-invalid-unicode-digit-in-token nil (nth token i) token)\n               (recur (inc i) (+ d (* uc base)))))))))\n\n  ([^not-native rdr initch base length exact?]\n     (loop [i 1 uc (char-code initch base)]\n       (if (== uc -1)\n         (err/throw-invalid-unicode-digit rdr initch)\n         (if-not (== i length)\n           (let [ch (peek-char rdr)]\n             (if (or (whitespace? ch)\n                     (macros ch)\n                     (nil? ch))\n               (if exact?\n                 (err/throw-invalid-unicode-len rdr i length)\n                 (js/String.fromCharCode uc))\n               (let [d (char-code ch base)]\n                 (read-char rdr)\n                 (if (== d -1)\n                   (err/throw-invalid-unicode-digit rdr ch)\n                   (recur (inc i) (+ d (* uc base)))))))\n           (js/String.fromCharCode uc))))))\n\n(def ^:private ^:const upper-limit (.charCodeAt \\uD7ff 0))\n(def ^:private ^:const lower-limit (.charCodeAt \\uE000 0))\n\n(defn- valid-octal? [token base]\n  (<= (js/parseInt token base) 0377))\n\n(defn- read-char*\n  \"Read in a character literal\"\n  [^not-native rdr backslash opts pending-forms]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (if (or (macro-terminating? ch)\n                          (whitespace? ch))\n                    (str ch)\n                    (read-token rdr :character ch))\n            token-len (. token -length)]\n        (cond\n\n         (== 1 token-len)  (.charAt token 0) ;;; no char type - so can't ensure/cache char\n\n         (= token \"newline\") \\newline\n         (= token \"space\") \\space\n         (= token \"tab\") \\tab\n         (= token \"backspace\") \\backspace\n         (= token \"formfeed\") \\formfeed\n         (= token \"return\") \\return\n\n         (gstring/startsWith token \"u\")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (.charCodeAt c 0)]\n           (if (and (> ic upper-limit)\n                    (< ic lower-limit))\n             (err/throw-invalid-character-literal rdr (.toString ic 16))\n             c))\n\n         (gstring/startsWith token \"o\")\n         (let [len (dec token-len)]\n           (if (> len 3)\n             (err/throw-invalid-octal-len rdr token)\n             (let [offset 1\n                   base 8\n                   uc (read-unicode-char token offset len base)]\n               (if-not (valid-octal? (subs token offset) base)\n                 (err/throw-bad-octal-number rdr)\n                 uc))))\n\n         :else (err/throw-unsupported-character rdr token)))\n      (err/throw-eof-in-character rdr))))\n\n(defn- starting-line-col-info [^not-native rdr]\n  (when (indexing-reader? rdr)\n    [(get-line-number rdr) (int (dec (get-column-number rdr)))]))\n\n(defn- ending-line-col-info [^not-native rdr]\n  (when (indexing-reader? rdr)\n    [(get-line-number rdr) (get-column-number rdr)]))\n\n(defonce ^:private READ_EOF (js/Object.))\n(defonce ^:private READ_FINISHED (js/Object.))\n\n(def ^:dynamic *read-delim* false)\n\n(defn- read-delimited-internal [kind delim rdr opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        delim (char delim)]\n    (loop [a (transient [])]\n      (let [form (read* rdr false READ_EOF delim opts pending-forms)]\n        (if (identical? form READ_FINISHED)\n          (persistent! a)\n          (if (identical? form READ_EOF)\n            (err/throw-eof-delimited rdr kind start-line start-column (count a))\n            (recur (conj! a form))))))))\n\n(defn- read-delimited\n  \"Reads and returns a collection ended with delim\"\n  [kind delim rdr opts pending-forms]\n  (binding [*read-delim* true]\n    (read-delimited-internal kind delim rdr opts pending-forms)))\n\n(defn- read-list\n  \"Read in a list, including its location if the reader is an indexing reader\"\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-list (read-delimited :list \\) rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta (if (empty? the-list)\n                 '()\n                 (apply list the-list))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))\n\n(defn- read-vector\n  \"Read in a vector, including its location if the reader is an indexing reader\"\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-vector (read-delimited :vector \\] rdr opts pending-forms)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (with-meta the-vector\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))\n\n(defn- read-map\n  \"Read in a map, including its location if the reader is an indexing reader\"\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        the-map (read-delimited :map \\} rdr opts pending-forms)\n        map-count (count the-map)\n        ks (take-nth 2 the-map)\n        key-set (set ks)\n        [end-line end-column] (ending-line-col-info rdr)]\n    (when (odd? map-count)\n      (err/throw-odd-map rdr start-line start-column the-map))\n    (when-not (= (count key-set) (count ks))\n      (err/throw-dup-keys rdr :map ks))\n    (with-meta\n      (if (<= map-count (* 2 (.-HASHMAP-THRESHOLD cljs.core/PersistentArrayMap)))\n        (.fromArray cljs.core/PersistentArrayMap (to-array the-map) true true)\n        (.fromArray cljs.core/PersistentHashMap (to-array the-map) true))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))\n\n(defn- read-number\n  [^not-native rdr initch]\n  (loop [sb (doto (StringBuffer.) (.append initch))\n         ch (read-char rdr)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread rdr ch)\n        (or (match-number s)\n            (err/throw-invalid-number rdr s)))\n      (recur (doto sb (.append ch)) (read-char rdr)))))\n\n(defn- escape-char [sb ^not-native rdr]\n  (let [ch (read-char rdr)]\n    (case ch\n      \\t \"\\t\"\n      \\r \"\\r\"\n      \\n \"\\n\"\n      \\\\ \"\\\\\"\n      \\\" \"\\\"\"\n      \\b \"\\b\"\n      \\f \"\\f\"\n      \\u (let [ch (read-char rdr)]\n           (if (== -1 (js/parseInt (int ch) 16))\n             (err/throw-invalid-unicode-escape rdr ch)\n             (read-unicode-char rdr ch 16 4 true)))\n      (if (numeric? ch)\n        (let [ch (read-unicode-char rdr ch 8 3 false)]\n          (if (> (int ch) 0377)\n            (err/throw-bad-octal-number rdr)\n            ch))\n        (err/throw-bad-escape-char rdr ch)))))\n\n(defn- read-string*\n  [^not-native reader _ opts pending-forms]\n  (loop [sb (StringBuffer.)\n         ch (read-char reader)]\n    (if (nil? ch)\n      (err/throw-eof-reading reader :string \\\" sb)\n      (case ch\n        \\\\ (recur (doto sb (.append (escape-char sb reader)))\n             (read-char reader))\n        \\\" (str sb)\n        (recur (doto sb (.append ch)) (read-char reader))))))\n\n(defn- loc-info [rdr line column]\n  (when-not (nil? line)\n    (let [file (get-file-name rdr)\n          filem (when-not (nil? file) {:file file})\n          [end-line end-column] (ending-line-col-info rdr)\n          lcm {:line line\n               :column column\n               :end-line end-line\n               :end-column end-column}]\n      (merge filem lcm))))\n\n(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (starting-line-col-info rdr)\n        token (read-token rdr :symbol initch)]\n    (when-not (nil? token)\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n\n        (let [^not-native p (parse-symbol token)]\n          (if-not (nil? p)\n            (let [^not-native sym (symbol (-nth p 0) (-nth p 1))]\n              (-with-meta sym (loc-info rdr line column)))\n            (err/throw-invalid rdr :symbol token)))))))\n\n(def ^:dynamic *alias-map*\n  \"Map from ns alias to ns, if non-nil, it will be used to resolve read-time\n   ns aliases.\n\n   Defaults to nil\"\n  nil)\n\n(defn- resolve-alias [sym]\n  (get *alias-map* sym))\n\n(defn- resolve-ns [sym]\n  (or (resolve-alias sym)\n      (when-let [ns (find-ns sym)]\n        (symbol (ns-name ns)))))\n\n(defn- read-keyword\n  [^not-native reader initch opts pending-forms]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader :keyword ch)\n            ^not-native s (parse-symbol token)]\n        (if-not (nil? s)\n          (let [ns (-nth s 0)\n                name (-nth s 1)]\n            (if (identical? \\: (.charAt token 0))\n              (if-not (nil? ns)\n                (if-let [ns (resolve-alias (symbol (subs ns 1)))]\n                  (keyword (str ns) name)\n                  (err/throw-invalid reader :keyword (str \\: token)))\n                (if-let [ns *ns*]\n                  (keyword (str ns) (subs name 1))\n                  (err/reader-error reader \"Invalid token: :\" token)))\n              (keyword ns name)))\n          (err/throw-invalid reader :keyword (str \\: token))))\n      (err/throw-single-colon reader))))\n\n(defn- wrapping-reader\n  \"Returns a function which wraps a reader in a call to sym\"\n  [sym]\n  (fn [rdr _ opts pending-forms]\n    (list sym (read* rdr true nil opts pending-forms))))\n\n(defn- read-meta\n  \"Read metadata and return the following object with the metadata applied\"\n  [rdr _ opts pending-forms]\n  (log-source rdr\n    (let [[line column] (starting-line-col-info rdr)\n          m (desugar-meta (read* rdr true nil opts pending-forms))]\n      (when-not (map? m)\n        (err/throw-bad-metadata rdr m))\n      (let [o (read* rdr true nil opts pending-forms)]\n        (if (implements? IMeta o)\n          (let [m (if (and line (seq? o))\n                    (assoc m :line line :column column)\n                    m)]\n            (if (implements? IWithMeta o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (err/throw-bad-metadata-target rdr o))))))\n\n(defn- read-set\n  [rdr _ opts pending-forms]\n  (let [[start-line start-column] (starting-line-col-info rdr)\n        ;; subtract 1 from start-column so it includes the # in the leading #{\n        start-column (if start-column (int (dec start-column)))\n        coll (read-delimited :set \\} rdr opts pending-forms)\n        the-set (set coll)\n        [end-line end-column] (ending-line-col-info rdr)]\n      (when-not (= (count coll) (count the-set))\n        (err/reader-error rdr (err/throw-dup-keys rdr :set coll)))\n      (with-meta the-set\n        (when start-line\n          (merge\n           (when-let [file (get-file-name rdr)]\n             {:file file})\n           {:line start-line\n            :column start-column\n            :end-line end-line\n            :end-column end-column})))))\n\n(defn- read-discard\n  \"Read and discard the first object from rdr\"\n  [rdr _ opts pending-forms]\n  (doto rdr\n    (read* true nil opts pending-forms)))\n\n(defn- read-symbolic-value\n  [rdr _ opts pending-forms]\n  (let [sym (read* rdr true nil opts pending-forms)]\n    (case sym\n\n      NaN js/Number.NaN\n      -Inf js/Number.NEGATIVE_INFINITY\n      Inf js/Number.POSITIVE_INFINITY\n\n      (err/reader-error rdr (str \"Invalid token: ##\" sym)))))\n\n(def ^:private RESERVED_FEATURES #{:else :none})\n\n(defn- has-feature?\n  [rdr feature opts]\n  (if (keyword? feature)\n    (or (= :default feature) (contains? (get opts :features) feature))\n    (err/reader-error rdr \"Feature should be a keyword: \" feature)))\n\n(defn- check-eof-error\n  [form rdr first-line]\n  (when (identical? form READ_EOF)\n    (err/throw-eof-error rdr (and (< first-line 0) first-line))))\n\n(defn- check-reserved-features\n  [rdr form]\n  (when (get RESERVED_FEATURES form)\n    (err/reader-error rdr \"Feature name \" form \" is reserved\")))\n\n(defn- check-invalid-read-cond\n  [form rdr first-line]\n  (when (identical? form READ_FINISHED)\n    (if (< first-line 0)\n      (err/reader-error rdr \"read-cond requires an even number of forms\")\n      (err/reader-error rdr \"read-cond starting on line \" first-line \" requires an even number of forms\"))))\n\n(defn- read-suppress\n  \"Read next form and suppress. Return nil or READ_FINISHED.\"\n  [first-line rdr opts pending-forms]\n  (binding [*suppress-read* true]\n    (let [form (read* rdr false READ_EOF \\) opts pending-forms)]\n      (check-eof-error form rdr first-line)\n      (when (identical? form READ_FINISHED)\n        READ_FINISHED))))\n\n(defonce ^:private NO_MATCH (js/Object.))\n\n(defn- match-feature\n  \"Read next feature. If matched, read next form and return.\n   Otherwise, read and skip next form, returning READ_FINISHED or nil.\"\n  [first-line rdr opts pending-forms]\n  (let [feature (read* rdr false READ_EOF \\) opts pending-forms)]\n    (check-eof-error feature rdr first-line)\n    (if (= feature READ_FINISHED)\n      READ_FINISHED\n      (do\n        (check-reserved-features rdr feature)\n        (if (has-feature? rdr feature opts)\n          ;; feature matched, read selected form\n          (doto (read* rdr false READ_EOF \\) opts pending-forms)\n            (check-eof-error rdr first-line)\n            (check-invalid-read-cond rdr first-line))\n          ;; feature not matched, ignore next form\n          (or (read-suppress first-line rdr opts pending-forms)\n              NO_MATCH))))))\n\n(defn- read-cond-delimited\n  [rdr splicing opts pending-forms]\n  (let [first-line (if (indexing-reader? rdr) (get-line-number rdr) -1)\n        result (loop [matched NO_MATCH\n                      finished nil]\n                 (cond\n                  ;; still looking for match, read feature+form\n                  (identical? matched NO_MATCH)\n                  (let [match (match-feature first-line rdr opts pending-forms)]\n                    (if (identical? match READ_FINISHED)\n                      READ_FINISHED\n                      (recur match nil)))\n\n                  ;; found match, just read and ignore the rest\n                  (not (identical? finished READ_FINISHED))\n                  (recur matched (read-suppress first-line rdr opts pending-forms))\n\n                  :else\n                  matched))]\n    (if (identical? result READ_FINISHED)\n      rdr\n      (if splicing\n        (do\n          (if (implements? ISequential result)\n            (do\n              (garray/insertArrayAt pending-forms (to-array result) 0)\n              rdr)\n            (err/reader-error rdr \"Spliced form list in read-cond-splicing must implement ISequential\")))\n        result))))\n\n(defn- read-cond\n  [^not-native rdr _ opts pending-forms]\n  (when (not (and opts (#{:allow :preserve} (:read-cond opts))))\n    (throw (ex-info \"Conditional read not allowed\"\n                    {:type :runtime-exception})))\n  (if-let [ch (read-char rdr)]\n    (let [splicing (= ch \\@)\n          ch (if splicing (read-char rdr) ch)]\n      (when splicing\n        (when-not *read-delim*\n          (err/reader-error rdr \"cond-splice not in list\")))\n      (if-let [ch (if (whitespace? ch) (read-past whitespace? rdr) ch)]\n        (if (not= ch \\()\n          (throw (ex-info \"read-cond body must be a list\"\n                          {:type :runtime-exception}))\n          (binding [*suppress-read* (or *suppress-read* (= :preserve (:read-cond opts)))]\n            (if *suppress-read*\n              (reader-conditional (read-list rdr ch opts pending-forms) splicing)\n              (read-cond-delimited rdr splicing opts pending-forms))))\n        (err/throw-eof-in-character rdr)))\n    (err/throw-eof-in-character rdr)))\n\n(def ^:private ^:dynamic arg-env nil)\n\n(defn- garg\n  \"Get a symbol for an anonymous ?argument?\"\n  [n]\n  (symbol (str (if (== -1 n) \"rest\" (str \"p\" n))\n               \"__\" (next-id) \"#\")))\n\n(defn- read-fn\n  [rdr _ opts pending-forms]\n  (if arg-env\n    (throw (ex-info \"Nested #()s are not allowed\" {:type :illegal-state})))\n  (binding [arg-env (sorted-map)]\n    (let [form (read* (doto rdr (unread \\()) true nil opts pending-forms) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (key (first rargs))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (> i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args '& (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list 'fn* args form))))\n\n(defn- register-arg\n  \"Registers an argument to the arg-env\"\n  [n]\n  (if arg-env\n    (if-let [ret (arg-env n)]\n      ret\n      (let [g (garg n)]\n        (set! arg-env (assoc arg-env n g))\n        g))\n    (throw (ex-info \"Arg literal not in #()\"\n                    {:type :illegal-state})))) ;; should never hit this\n\n(declare read-symbol)\n\n(defn- read-arg\n  [^not-native rdr pct opts pending-forms]\n  (if (nil? arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (= ch \\&)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read* rdr true nil opts pending-forms)]\n         (if-not (integer? n)\n           (throw (ex-info \"Arg literal must be %, %& or %integer\"\n                           {:type :illegal-state}))\n           (register-arg n)))))))\n\n(def ^:private ^:dynamic gensym-env nil)\n\n(defn- read-unquote\n  [^not-native rdr comma opts pending-forms]\n  (if-let [ch (peek-char rdr)]\n    (if (= \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@ opts pending-forms)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~ opts pending-forms))))\n\n(declare syntax-quote*)\n\n(defn- unquote-splicing? [form]\n  (and (seq? form)\n       (= (first form) 'clojure.core/unquote-splicing)))\n\n(defn- unquote? [form]\n  (and (seq? form)\n       (= (first form) 'clojure.core/unquote)))\n\n(defn- expand-list\n  \"Expand a list by resolving its syntax quotes and unquotes\"\n  [s]\n  (loop [s (seq s) r (transient [])]\n    (if s\n      (let [item (first s)\n            ret (conj! r\n                       (cond\n                        (unquote? item)          (list 'clojure.core/list (second item))\n                        (unquote-splicing? item) (second item)\n                        :else                    (list 'clojure.core/list (syntax-quote* item))))]\n        (recur (next s) ret))\n      (seq (persistent! r)))))\n\n(defn- flatten-map\n  \"Flatten a map into a seq of alternate keys and values\"\n  [form]\n  (loop [s (seq form) key-vals (transient [])]\n    (if s\n      (let [e (first s)]\n        (recur (next s) (-> key-vals\n                          (conj! (key e))\n                          (conj! (val e)))))\n      (seq (persistent! key-vals)))))\n\n(defn- register-gensym [sym]\n  (if-not gensym-env\n    (throw (ex-info \"Gensym literal not in syntax-quote\"\n                    {:type :illegal-state})))\n  (or (get gensym-env sym)\n      (let [gs (symbol (str (subs (name sym)\n                                  0 (dec (count (name sym))))\n                            \"__\" (next-id) \"__auto__\"))]\n        (set! gensym-env (assoc gensym-env sym gs))\n        gs)))\n\n(defn- add-meta [form ret]\n  (if (and (implements? IWithMeta form)\n           (seq (dissoc (meta form) :line :column :end-line :end-column :file :source)))\n    (list 'cljs.core/with-meta ret (syntax-quote* (meta form)))\n    ret))\n\n(defn- syntax-quote-coll [type coll]\n  (let [res (list 'cljs.core/sequence\n                  (cons 'cljs.core/concat\n                        (expand-list coll)))]\n    (if type\n      (list 'cljs.core/apply type res)\n      res)))\n\n(defn map-func\n  \"Decide which map type to use, array-map if less than 16 elements\"\n  [coll]\n  (if (>= (count coll) 16)\n    'cljs.core/hash-map\n    'cljs.core/array-map))\n\n(defn bool? [x]\n  (or (instance? js/Boolean x)\n      (true? x)\n      (false? x)))\n\n(defn ^:dynamic resolve-symbol\n  \"Resolve a symbol s into its fully qualified namespace version\"\n  [s]\n  (throw (ex-info \"resolve-symbol is not implemented\" {:sym s})))\n\n(defn- syntax-quote* [form]\n  (->>\n   (cond\n    (special-symbol? form) (list 'quote form)\n\n    (symbol? form)\n    (list 'quote\n          (if (and (not (namespace form))\n                   (gstring/endsWith (name form) \"#\"))\n            (register-gensym form)\n            (let [sym (str form)]\n              (if (gstring/endsWith sym \".\")\n                (let [csym (symbol (subs sym 0 (dec (count sym))))]\n                  (symbol (str (resolve-symbol csym) \".\")))\n                (resolve-symbol form)))))\n\n    (unquote? form) (second form)\n    (unquote-splicing? form) (throw (ex-info \"unquote-splice not in list\"\n                                             {:type :illegal-state}))\n\n    (coll? form)\n    (cond\n\n     (implements? IRecord form) form\n     (map? form) (syntax-quote-coll (map-func form) (flatten-map form))\n     (vector? form) (list 'cljs.core/vec (syntax-quote-coll nil form))\n     (set? form) (syntax-quote-coll 'cljs.core/hash-set form)\n     (or (seq? form) (list? form))\n     (let [seq (seq form)]\n       (if seq\n         (syntax-quote-coll nil seq)\n         '(cljs.core/list)))\n\n     :else (throw (ex-info \"Unknown Collection type\"\n                           {:type :unsupported-operation})))\n\n    (or (keyword? form)\n        (number? form)\n        (string? form)\n        (nil? form)\n        (bool? form)\n        (instance? js/RegExp form))\n    form\n\n    :else (list 'quote form))\n   (add-meta form)))\n\n(defn- read-syntax-quote\n  [rdr backquote opts pending-forms]\n  (binding [gensym-env {}]\n    (-> (read* rdr true nil opts pending-forms)\n      syntax-quote*)))\n\n(defn- read-namespaced-map\n  [rdr _ opts pending-forms]\n  (let [token (read-token rdr :namespaced-map (read-char rdr))]\n    (if-let [ns (cond\n                  (= token \":\")\n                  (ns-name *ns*)\n\n                  (= \\: (first token))\n                  (some-> token (subs 1) parse-symbol second' symbol resolve-ns)\n\n                  :else\n                  (some-> token parse-symbol second'))]\n\n      (let [ch (read-past whitespace? rdr)]\n        (if (identical? ch \\{)\n          (let [items (read-delimited :namespaced-map \\} rdr opts pending-forms)]\n            (when (odd? (count items))\n              (err/throw-odd-map rdr nil nil items))\n            (let [keys (namespace-keys (str ns) (take-nth 2 items))\n                  vals (take-nth 2 (rest items))]\n              (when-not (= (count (set keys)) (count keys))\n                (err/throw-dup-keys rdr :namespaced-map keys))\n              (zipmap keys vals)))\n              (err/throw-ns-map-no-map rdr token)))\n          (err/throw-bad-ns rdr token))))\n\n(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))\n\n(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;; deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\= (throwing-reader \"read-eval not supported\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    \\? read-cond\n    \\: read-namespaced-map\n    \\# read-symbolic-value\n    nil))\n\n(defn- read-tagged [^not-native rdr initch opts pending-forms]\n  (let [tag (read* rdr true nil opts pending-forms)]\n    (if-not (symbol? tag)\n      (err/throw-bad-reader-tag rdr tag))\n    (if *suppress-read*\n      (tagged-literal tag (read* rdr true nil opts pending-forms))\n      (if-let [f (or (*data-readers* tag)\n                     (default-data-readers tag))]\n        (f (read* rdr true nil opts pending-forms))\n        (if-let [f *default-data-reader-fn*]\n          (f tag (read* rdr true nil opts pending-forms))\n          (err/throw-unknown-reader-tag rdr tag))))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Public API\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n(def ^:dynamic *data-readers*\n  \"Map from reader tag symbols to data reader Vars.\n  Reader tags without namespace qualifiers are reserved for Clojure.\n  This light version of tools.reader has no implementation for default\n  reader tags such as #inst and #uuid.\"\n  {})\n\n(def ^:dynamic *default-data-reader-fn*\n  \"When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments, the tag and the value.\n  If *default-data-reader-fn* is nil (the default value), an exception\n  will be thrown for the unknown tag.\"\n  nil)\n\n(def ^:dynamic *suppress-read* false)\n\n(def default-data-readers\n  \"Default map of data reader functions provided by Clojure.\n  May be overridden by binding *data-readers*\"\n  {})\n\n(defn- read*-internal\n  [^not-native reader ^boolean eof-error? sentinel return-on opts pending-forms]\n  (loop []\n    (log-source reader\n      (if-not ^boolean (garray/isEmpty pending-forms)\n        (let [form (aget pending-forms 0)]\n          (garray/removeAt pending-forms 0)\n          form)\n        (let [ch (read-char reader)]\n          (cond\n            (whitespace? ch) (recur)\n            (nil? ch) (if eof-error? (err/throw-eof-error reader nil) sentinel)\n            (identical? ch return-on) READ_FINISHED\n            (number-literal? reader ch) (read-number reader ch)\n            :else (let [f (macros ch)]\n                    (if-not (nil? f)\n                      (let [res (f reader ch opts pending-forms)]\n                        (if (identical? res reader)\n                          (recur)\n                          res))\n                      (read-symbol reader ch)))))))))\n\n(defn- read*\n  ([reader eof-error? sentinel opts pending-forms]\n     (read* reader eof-error? sentinel nil opts pending-forms))\n  ([^not-native reader eof-error? sentinel return-on opts pending-forms]\n     (try\n       (read*-internal reader eof-error? sentinel return-on opts pending-forms)\n       (catch js/Error e\n         (if (ex-info? e)\n           (let [d (ex-data e)]\n             (if (= :reader-exception (:type d))\n               (throw e)\n               (throw (ex-info (.-message e)\n                               (merge {:type :reader-exception}\n                                      d\n                                      (if (indexing-reader? reader)\n                                        {:line   (get-line-number reader)\n                                         :column (get-column-number reader)\n                                         :file   (get-file-name reader)}))\n                               e))))\n           (throw (ex-info (.-message e)\n                           (merge {:type :reader-exception}\n                                  (if (indexing-reader? reader)\n                                    {:line   (get-line-number reader)\n                                     :column (get-column-number reader)\n                                     :file   (get-file-name reader)}))\n                           e)))))))\n\n(defn read\n  \"Reads the first object from an IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is providen, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   To read data structures only, use clojure.tools.reader.edn/read\n\n   Note that the function signature of clojure.tools.reader/read and\n   clojure.tools.reader.edn/read is not the same for eof-handling\"\n  {:arglists '([reader] [opts reader] [reader eof-error? eof-value])}\n  ([reader] (read reader true nil))\n  ([{eof :eof :as opts :or {eof :eofthrow}} reader] (read* reader (= eof :eofthrow) eof nil opts (to-array [])))\n  ([reader eof-error? sentinel] (read* reader eof-error? sentinel nil {} (to-array []))))\n\n(defn read-string\n  \"Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   To read data structures only, use clojure.tools.reader.edn/read-string\n\n   Note that the function signature of clojure.tools.reader/read-string and\n   clojure.tools.reader.edn/read-string is not the same for eof-handling\"\n  ([s]\n     (read-string {} s))\n  ([opts s]\n     (when (and s (not (identical? s \"\")))\n       (read opts (string-push-back-reader s)))))\n\n(defn read+string\n  \"Like read, and taking the same args. reader must be a SourceLoggingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.\"\n  ([reader & args]\n   (let [buf (fn [reader] (str (:buffer @(.-frames reader))))\n         offset (count (buf reader))\n         o (log-source reader (if (= 1 (count args))\n                                (read (first args) reader)\n                                (apply read reader args)))\n         s (.trim (subs (buf reader) offset))]\n     [o s])))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"clojure/reflect.cljs",new cljs.core.Keyword(null,"ns","ns",441598760),"clojure.reflect",new cljs.core.Keyword(null,"source","source",-433931539),"(ns clojure.reflect\n  ^{:doc \"DEPRECATED. Do not use, superceded by REPL enhancements.\"}\n  (:refer-clojure :exclude [meta macroexpand])\n  (:require [clojure.browser.net :as net]\n            [clojure.browser.event :as event]))\n\n(defn- evaluate-javascript [block]\n  (let [result (try (js* \"eval(~{block})\")\n                    (catch :default e\n                      (.log js/console e)))]\n    result))\n\n(defn- query-reflection\n  \"Issues a GET to /reflect with a single query-parameter string.\n  Calls cb with the result.\"\n  [query-param cb]\n  (let [conn (net/xhr-connection)\n        url  (str \"/reflect?\" query-param)]\n    (event/listen conn :success (fn [e]\n                                  (let [resp (.getResponseText (.-currentTarget e) ())]\n                                    (cb resp))))\n    (event/listen conn :error #(println \"Reflection query failed.\"))\n    (net/transmit conn url)))\n\n(defn meta\n  \"Queries the reflection api with a fully qualified symbol, then calls\n  callback fn cb with the evaluated cljs map containing that symbol's\n  meta information.\"\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))\n\n(defn macroexpand\n  \"Queries the reflection api with a quoted macro form, then calls the\n  callback function with the macroexpanded form, as a string.\"\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))\n\n(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))\n\n(defn doc\n  \"Queries the reflection api with a fully qualified symbol, then prints\n  documentation information at the repl.\"\n  [sym]\n  (meta sym print-doc))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/reader.clj",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.reader",new cljs.core.Keyword(null,"source","source",-433931539),";; Copyright (c) Rich Hickey. All rights reserved.\n;; The use and distribution terms for this software are covered by the\n;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;; which can be found in the file epl-v10.html at the root of this distribution.\n;; By using this software in any fashion, you are agreeing to be bound by\n;; the terms of this license.\n;; You must not remove this notice, or any other, from this software.\n\n(ns cljs.reader\n  (:require [cljs.env :as env]))\n\n(defmacro add-data-readers [default-readers]\n  (let [data-readers\n        (->> (get @env/*compiler* :cljs.analyzer/data-readers)\n          (map (fn [[k v]]\n                 `['~k (fn [x#] (~(vary-meta v assoc :cljs.analyzer/no-resolve true) x#))]))\n          (into {}))]\n    `(do (merge ~default-readers ~data-readers))))\n"], null),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"relative-path","relative-path",1848635172),"cljs/spec/alpha.cljc",new cljs.core.Keyword(null,"ns","ns",441598760),"cljs.spec.alpha",new cljs.core.Keyword(null,"source","source",-433931539),";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.spec.alpha\n  (:refer-clojure :exclude [+ * and or cat def keys merge resolve assert])\n  (:require [cljs.core :as c]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.analyzer.api :refer [resolve]]\n            [clojure.walk :as walk]\n            [cljs.spec.gen.alpha :as gen]\n            [clojure.string :as str]))\n\n(defonce registry-ref (atom {}))\n\n(defn- ->sym\n  \"Returns a symbol from a symbol or var\"\n  [x]\n  (if (map? x)\n    (:name x)\n    x))\n\n(defn- unfn [expr]\n  (if (clojure.core/and (seq? expr)\n             (symbol? (first expr))\n             (= \"fn*\" (name (first expr))))\n    (let [[[s] & form] (rest expr)]\n      (conj (walk/postwalk-replace {s '%} form) '[%] 'cljs.core/fn))\n    expr))\n\n(defn- res [env form]\n  (cond\n    (keyword? form) form\n    (symbol? form) #?(:clj  (clojure.core/or (->> form (resolve env) ->sym) form)\n                      :cljs (let [resolved (clojure.core/or (->> form (resolve env) ->sym) form)\n                                  ns-name (namespace resolved)]\n                              (symbol\n                                (if (clojure.core/and ns-name (str/ends-with? ns-name \"$macros\"))\n                                  (subs ns-name 0 (- (count ns-name) 7))\n                                  ns-name)\n                                (name resolved))))\n    (sequential? form) (walk/postwalk #(if (symbol? %) (res env %) %) (unfn form))\n    :else form))\n\n(defmacro ^:private mres\n  \"a compile time res, for use in cljs/spec/alpha.cljs\"\n  [form]\n  (res &env form))\n\n(defn- ns-qualify\n  \"Qualify symbol s by resolving it or using the current *ns*.\"\n  [env s]\n  (if (namespace s)\n    (->sym (binding [ana/*private-var-access-nowarn* true]\n             (ana/resolve-var env s)))\n    (symbol (str ana/*cljs-ns*) (str s))))\n\n(defmacro def\n  \"Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.\"\n  [k spec-form]\n  (let [k    (if (symbol? k) (ns-qualify &env k) k)\n        form (res &env spec-form)]\n    (swap! registry-ref (fn [r]\n                          (if (nil? form)\n                            (dissoc r k)\n                            (assoc r k form))))\n    `(def-impl '~k '~form ~spec-form)))\n\n(defmacro spec\n  \"Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.\"\n  [form & {:keys [gen]}]\n  (when form\n    `(spec-impl '~(res &env form) ~form ~gen nil)))\n\n(defmacro multi-spec\n  \"Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n\"\n  [mm retag]\n  `(multi-spec-impl '~(res &env mm) (var ~mm) ~retag))\n\n(defmacro keys\n  \"Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\"\n  [& {:keys [req req-un opt opt-un gen]}]\n  (let [unk #(-> % name keyword)\n        req-keys (filterv keyword? (flatten req))\n        req-un-specs (filterv keyword? (flatten req-un))\n        _ (clojure.core/assert (every? #(clojure.core/and (keyword? %) (namespace %)) (concat req-keys req-un-specs opt opt-un))\n                  \"all keys must be namespace-qualified keywords\")\n        req-specs (into req-keys req-un-specs)\n        req-keys (into req-keys (map unk req-un-specs))\n        opt-keys (into (vec opt) (map unk opt-un))\n        opt-specs (into (vec opt) opt-un)\n        gx (gensym)\n        parse-req (fn [rk f]\n                    (map (fn [x]\n                           (if (keyword? x)\n                             `(contains? ~gx ~(f x))\n                             (walk/postwalk\n                               (fn [y] (if (keyword? y) `(contains? ~gx ~(f y)) y))\n                               x)))\n                         rk))\n        pred-exprs [`(map? ~gx)]\n        pred-exprs (into pred-exprs (parse-req req identity))\n        pred-exprs (into pred-exprs (parse-req req-un unk))\n        keys-pred `(fn* [~gx] (c/and ~@pred-exprs))\n        pred-exprs (mapv (fn [e] `(fn* [~gx] ~e)) pred-exprs)\n        pred-forms (walk/postwalk #(res &env %) pred-exprs)]\n    ;; `(map-spec-impl ~req-keys '~req ~opt '~pred-forms ~pred-exprs ~gen)\n    `(map-spec-impl {:req '~req :opt '~opt :req-un '~req-un :opt-un '~opt-un\n                     :req-keys '~req-keys :req-specs '~req-specs\n                     :opt-keys '~opt-keys :opt-specs '~opt-specs\n                     :pred-forms '~pred-forms\n                     :pred-exprs ~pred-exprs\n                     :keys-pred ~keys-pred\n                     :gfn ~gen})))\n\n(defmacro or\n  \"Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.\"\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"spec/or expects k1 p1 k2 p2..., where ks are keywords\")\n    `(or-spec-impl ~keys '~pf ~pred-forms nil)))\n\n(defmacro and\n  \"Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.\"\n  [& pred-forms]\n  `(and-spec-impl '~(mapv #(res &env %) pred-forms) ~(vec pred-forms) nil))\n\n(defn- res-kind\n  [env opts]\n  (let [{kind :kind :as mopts} opts]\n    (->>\n      (if kind\n        (assoc mopts :kind `~(res env kind))\n        mopts)\n      (mapcat identity))))\n\n(defmacro every\n  \"takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n\"\n  [pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]\n  (let [desc (::describe opts)\n        nopts (-> opts\n                (dissoc :gen ::describe)\n                (assoc ::kind-form `'~(res &env (:kind opts))\n                       ::describe (clojure.core/or desc `'(every ~(res &env pred) ~@(res-kind &env opts)))))\n        gx (gensym)\n        cpreds (cond-> [(list (clojure.core/or kind `coll?) gx)]\n                 count (conj `(= ~count (c/bounded-count ~count ~gx)))\n\n                 (clojure.core/or min-count max-count)\n                 (conj `(<= (c/or ~min-count 0)\n                          (c/bounded-count (if ~max-count (inc ~max-count) ~min-count) ~gx)\n                          (c/or ~max-count MAX_INT)))\n\n                 distinct\n                 (conj `(c/or (empty? ~gx) (apply distinct? ~gx))))]\n    `(every-impl '~pred ~pred ~(assoc nopts ::cpred `(fn* [~gx] (c/and ~@cpreds))) ~gen)))\n\n(defmacro every-kv\n  \"like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of\"\n\n  [kpred vpred & opts]\n  (let [desc `(every-kv ~(res &env kpred) ~(res &env vpred) ~@(res-kind &env opts))]\n    `(every (tuple ~kpred ~vpred) ::kfn (fn [i# v#] (nth v# 0)) :into {} ::describe '~desc ~@opts)))\n\n(defmacro coll-of\n  \"Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of\"\n  [pred & opts]\n  (let [desc `(coll-of ~(res &env pred) ~@(res-kind &env opts))]\n    `(every ~pred ::conform-all true ::describe '~desc ~@opts)))\n\n(defmacro map-of\n  \"Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv\"\n  [kpred vpred & opts]\n  (let [desc `(map-of ~(res &env kpred) ~(res &env vpred) ~@(res-kind &env opts))]\n    `(every-kv ~kpred ~vpred ::conform-all true :kind map? ::describe '~desc ~@opts)))\n\n(defmacro *\n  \"Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match\"\n  [pred-form]\n  `(rep-impl '~(res &env pred-form) ~pred-form))\n\n(defmacro +\n  \"Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches\"\n  [pred-form]\n  `(rep+impl '~(res &env pred-form) ~pred-form))\n\n(defmacro ?\n  \"Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.\"\n  [pred-form]\n  `(maybe-impl ~pred-form '~(res &env pred-form)))\n\n(defmacro alt\n  \"Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.\"\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"alt expects k1 p1 k2 p2..., where ks are keywords\")\n    `(alt-impl ~keys ~pred-forms '~pf)))\n\n(defmacro cat\n  \"Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.\"\n  [& key-pred-forms]\n  (let [pairs (partition 2 key-pred-forms)\n        keys (mapv first pairs)\n        pred-forms (mapv second pairs)\n        pf (mapv #(res &env %) pred-forms)]\n    ;;(prn key-pred-forms)\n    (clojure.core/assert (clojure.core/and (even? (count key-pred-forms)) (every? keyword? keys)) \"cat expects k1 p1 k2 p2..., where ks are keywords\")\n    `(cat-impl ~keys ~pred-forms '~pf)))\n\n(defmacro &\n  \"takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.\"\n  [re & preds]\n  (let [pv (vec preds)]\n    `(amp-impl ~re '~(res &env re) ~pv '~(mapv #(res &env %) pv))))\n\n(defmacro conformer\n  \"takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first\"\n  ([f] `(spec-impl '(conformer ~(res &env f)) ~f nil true))\n  ([f unf] `(spec-impl '(conformer ~(res &env f) ~(res &env unf)) ~f nil true ~unf)))\n\n(defmacro fspec\n  \"takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.\"\n  [& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]\n  (let [env &env]\n    `(fspec-impl (spec ~args) '~(res env args)\n                           (spec ~ret) '~(res env ret)\n                           (spec ~fn) '~(res env fn) ~gen)))\n\n(defmacro tuple\n  \"takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.\"\n  [& preds]\n  (clojure.core/assert (not (empty? preds)))\n  `(tuple-impl '~(mapv #(res &env %) preds) ~(vec preds)))\n\n(defonce ^:private _speced_vars (atom #{}))\n\n(defn speced-vars []\n  @_speced_vars)\n\n(defmacro fdef\n  \"Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)\"\n  [fn-sym & specs]\n  (swap! _speced_vars conj\n    (vary-meta (ns-qualify &env fn-sym)\n      assoc :fdef-ns (-> &env :ns :name)))\n  `(cljs.spec.alpha/def ~fn-sym (fspec ~@specs)))\n\n(defmacro keys*\n  \"takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}\"\n  [& kspecs]\n  `(let [mspec# (keys ~@kspecs)]\n     (with-gen (cljs.spec.alpha/& (* (cat ::k keyword? ::v cljs.core/any?)) ::kvs->map mspec#)\n       (fn [] (gen/fmap (fn [m#] (apply concat m#)) (gen mspec#))))))\n\n(defmacro nilable\n  \"returns a spec that accepts nil and values satisfiying pred\"\n  [pred]\n  (let [pf (res &env pred)]\n    `(nilable-impl '~pf ~pred nil)))\n\n(defmacro inst-in\n  \"Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).\"\n  [start end]\n  `(let [st# (cljs.core/inst-ms ~start)\n         et# (cljs.core/inst-ms ~end)\n         mkdate# (fn [d#] (js/Date. d#))]\n     (spec (and cljs.core/inst? #(inst-in-range? ~start ~end %))\n       :gen (fn []\n              (gen/fmap mkdate#\n                (gen/large-integer* {:min st# :max et#}))))))\n\n(defmacro int-in\n  \"Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).\"\n  [start end]\n  `(spec (and c/int? #(int-in-range? ~start ~end %))\n     :gen #(gen/large-integer* {:min ~start :max (dec ~end)})))\n\n(defmacro double-in\n  \"Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\"\n  [& {:keys [infinite? NaN? min max]\n      :or {infinite? true NaN? true}\n      :as m}]\n  `(spec (and c/double?\n           ~@(when-not infinite? '[#(not (infinite? %))])\n           ~@(when-not NaN? '[#(not (js/isNaN %))])\n           ~@(when max `[#(<= % ~max)])\n           ~@(when min `[#(<= ~min %)]))\n     :gen #(gen/double* ~m)))\n\n(defmacro merge\n  \"Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.\"\n  [& pred-forms]\n  `(merge-spec-impl '~(mapv #(res &env %) pred-forms) ~(vec pred-forms) nil))\n\n(defmacro exercise-fn\n  \"exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. \"\n  ([sym]\n   `(exercise-fn ~sym 10))\n  ([sym n]\n   `(exercise-fn ~sym ~n nil))\n  ([sym n fspec]\n   (let [sym (cond-> sym\n               (clojure.core/and (sequential? sym)\n                                 (= (first sym) 'quote))\n               second)]\n     `(let [fspec# ~(if-not fspec\n                      `(get-spec '~(:name (resolve &env sym)))\n                      fspec)\n            f#     ~sym]\n        (if-let [arg-spec# (c/and fspec# (:args fspec#))]\n          (for [args# (gen/sample (gen arg-spec#) ~n)]\n            [args# (apply f# args#)])\n          (throw (js/Error. \"No :args spec found, can't generate\")))))))\n\n(defmacro ^:private init-compile-asserts []\n  (let [compile-asserts (not (-> env/*compiler* deref :options :elide-asserts))]\n    compile-asserts))\n\n(defmacro assert\n  \"spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).\"\n  [spec x]\n  `(if *compile-asserts*\n     (if @#'*runtime-asserts*\n       (assert* ~spec ~x)\n       ~x)\n    ~x))\n"], null)]);
/**
 * A namespace loader that looks up the source against the
 * given relative path in the dependencies bundle.
 */
replete.io_impl.load = (function replete$io_impl$load(namespace_relative_path){
return new cljs.core.Keyword(null,"source","source",-433931539).cljs$core$IFn$_invoke$arity$1(cljs.core.get.call(null,replete.io_impl.dependencies,namespace_relative_path));
});
replete.io_impl.load_from_jar = (function replete$io_impl$load_from_jar(file_path,resource){
throw cljs.core.ex_info.call(null,"Unsupported",new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,"method","method",55703592),"REPLETE_LOAD_FROM_JAR",new cljs.core.Keyword(null,"file-path","file-path",-2005501162),file_path,new cljs.core.Keyword(null,"resource","resource",251898836),resource], null));
});
replete.io_impl.unsupported_request = (function replete$io_impl$unsupported_request(var_args){
var args__4736__auto__ = [];
var len__4730__auto___1294 = arguments.length;
var i__4731__auto___1295 = (0);
while(true){
if((i__4731__auto___1295 < len__4730__auto___1294)){
args__4736__auto__.push((arguments[i__4731__auto___1295]));

var G__1296 = (i__4731__auto___1295 + (1));
i__4731__auto___1295 = G__1296;
continue;
} else {
}
break;
}

var argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);
return replete.io_impl.unsupported_request.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);
});

replete.io_impl.unsupported_request.cljs$core$IFn$_invoke$arity$variadic = (function (args){
throw cljs.core.ex_info.call(null,"Unsupported",new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"method","method",55703592),"REPLETE_REQUEST",new cljs.core.Keyword(null,"args","args",1315556576),args], null));
});

replete.io_impl.unsupported_request.cljs$lang$maxFixedArity = (0);

/** @this {Function} */
replete.io_impl.unsupported_request.cljs$lang$applyTo = (function (seq1293){
var self__4718__auto__ = this;
return self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq1293));
});

goog.global.REPLETE_LOAD = replete.io_impl.load;
goog.global.REPLETE_SLEEP = replete.io_impl.sleep;
goog.global.REPLETE_LOAD_FROM_JAR = replete.io_impl.load_from_jar;
goog.global.REPLETE_REQUEST = replete.io_impl.unsupported_request;
